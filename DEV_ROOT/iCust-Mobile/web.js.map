{"version":3,"sources":["./node_modules/@capacitor/storage/dist/esm/web.js","./node_modules/@capacitor/camera/dist/esm/web.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAA4C;AACrC,yBAAyB,yDAAS;AACzC;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB,mBAAmB,MAAM;AAClE;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAAA;AAAgE;AACF;AACvD,wBAAwB,yDAAS;AACxC;AACA;AACA;AACA,0DAA0D,yDAAY;AACtE;AACA;AACA,wCAAwC,yDAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE,qBAAqB,sDAAsD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,yDAAY;AAC3C,+BAA+B,yDAAY;AAC3C;AACA;AACA,uCAAuC,4DAAe;AACtD;AACA;AACA,uCAAuC,4DAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkB;AAClB,+B","file":"web.js","sourcesContent":["import { WebPlugin } from '@capacitor/core';\nexport class StorageWeb extends WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.group = 'CapacitorStorage';\n    }\n    async configure({ group }) {\n        if (typeof group === 'string') {\n            this.group = group;\n        }\n    }\n    async get(options) {\n        const value = this.impl.getItem(this.applyPrefix(options.key));\n        return { value };\n    }\n    async set(options) {\n        this.impl.setItem(this.applyPrefix(options.key), options.value);\n    }\n    async remove(options) {\n        this.impl.removeItem(this.applyPrefix(options.key));\n    }\n    async keys() {\n        const keys = this.rawKeys().map(k => k.substring(this.prefix.length));\n        return { keys };\n    }\n    async clear() {\n        for (const key of this.rawKeys()) {\n            this.impl.removeItem(key);\n        }\n    }\n    async migrate() {\n        var _a;\n        const migrated = [];\n        const existing = [];\n        const oldprefix = '_cap_';\n        const keys = Object.keys(this.impl).filter(k => k.indexOf(oldprefix) === 0);\n        for (const oldkey of keys) {\n            const key = oldkey.substring(oldprefix.length);\n            const value = (_a = this.impl.getItem(oldkey)) !== null && _a !== void 0 ? _a : '';\n            const { value: currentValue } = await this.get({ key });\n            if (typeof currentValue === 'string') {\n                existing.push(key);\n            }\n            else {\n                await this.set({ key, value });\n                migrated.push(key);\n            }\n        }\n        return { migrated, existing };\n    }\n    async removeOld() {\n        const oldprefix = '_cap_';\n        const keys = Object.keys(this.impl).filter(k => k.indexOf(oldprefix) === 0);\n        for (const oldkey of keys) {\n            this.impl.removeItem(oldkey);\n        }\n    }\n    get impl() {\n        return window.localStorage;\n    }\n    get prefix() {\n        return this.group === 'NativeStorage' ? '' : `${this.group}.`;\n    }\n    rawKeys() {\n        return Object.keys(this.impl).filter(k => k.indexOf(this.prefix) === 0);\n    }\n    applyPrefix(key) {\n        return this.prefix + key;\n    }\n}\n//# sourceMappingURL=web.js.map","import { WebPlugin, CapacitorException } from '@capacitor/core';\nimport { CameraSource, CameraDirection } from './definitions';\nexport class CameraWeb extends WebPlugin {\n    async getPhoto(options) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            if (options.webUseInput || options.source === CameraSource.Photos) {\n                this.fileInputExperience(options, resolve);\n            }\n            else if (options.source === CameraSource.Prompt) {\n                let actionSheet = document.querySelector('pwa-action-sheet');\n                if (!actionSheet) {\n                    actionSheet = document.createElement('pwa-action-sheet');\n                    document.body.appendChild(actionSheet);\n                }\n                actionSheet.header = options.promptLabelHeader || 'Photo';\n                actionSheet.cancelable = false;\n                actionSheet.options = [\n                    { title: options.promptLabelPhoto || 'From Photos' },\n                    { title: options.promptLabelPicture || 'Take Picture' },\n                ];\n                actionSheet.addEventListener('onSelection', async (e) => {\n                    const selection = e.detail;\n                    if (selection === 0) {\n                        this.fileInputExperience(options, resolve);\n                    }\n                    else {\n                        this.cameraExperience(options, resolve, reject);\n                    }\n                });\n            }\n            else {\n                this.cameraExperience(options, resolve, reject);\n            }\n        });\n    }\n    async cameraExperience(options, resolve, reject) {\n        if (customElements.get('pwa-camera-modal')) {\n            const cameraModal = document.createElement('pwa-camera-modal');\n            document.body.appendChild(cameraModal);\n            try {\n                await cameraModal.componentOnReady();\n                cameraModal.addEventListener('onPhoto', async (e) => {\n                    const photo = e.detail;\n                    if (photo === null) {\n                        reject(new CapacitorException('User cancelled photos app'));\n                    }\n                    else if (photo instanceof Error) {\n                        reject(photo);\n                    }\n                    else {\n                        resolve(await this._getCameraPhoto(photo, options));\n                    }\n                    cameraModal.dismiss();\n                    document.body.removeChild(cameraModal);\n                });\n                cameraModal.present();\n            }\n            catch (e) {\n                this.fileInputExperience(options, resolve);\n            }\n        }\n        else {\n            console.error(`Unable to load PWA Element 'pwa-camera-modal'. See the docs: https://capacitorjs.com/docs/pwa-elements.`);\n            this.fileInputExperience(options, resolve);\n        }\n    }\n    fileInputExperience(options, resolve) {\n        let input = document.querySelector('#_capacitor-camera-input');\n        const cleanup = () => {\n            var _a;\n            (_a = input.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n        };\n        if (!input) {\n            input = document.createElement('input');\n            input.id = '_capacitor-camera-input';\n            input.type = 'file';\n            input.hidden = true;\n            document.body.appendChild(input);\n            input.addEventListener('change', (_e) => {\n                const file = input.files[0];\n                let format = 'jpeg';\n                if (file.type === 'image/png') {\n                    format = 'png';\n                }\n                else if (file.type === 'image/gif') {\n                    format = 'gif';\n                }\n                if (options.resultType === 'dataUrl' ||\n                    options.resultType === 'base64') {\n                    const reader = new FileReader();\n                    reader.addEventListener('load', () => {\n                        if (options.resultType === 'dataUrl') {\n                            resolve({\n                                dataUrl: reader.result,\n                                format,\n                            });\n                        }\n                        else if (options.resultType === 'base64') {\n                            const b64 = reader.result.split(',')[1];\n                            resolve({\n                                base64String: b64,\n                                format,\n                            });\n                        }\n                        cleanup();\n                    });\n                    reader.readAsDataURL(file);\n                }\n                else {\n                    resolve({\n                        webPath: URL.createObjectURL(file),\n                        format: format,\n                    });\n                    cleanup();\n                }\n            });\n        }\n        input.accept = 'image/*';\n        input.capture = true;\n        if (options.source === CameraSource.Photos ||\n            options.source === CameraSource.Prompt) {\n            input.removeAttribute('capture');\n        }\n        else if (options.direction === CameraDirection.Front) {\n            input.capture = 'user';\n        }\n        else if (options.direction === CameraDirection.Rear) {\n            input.capture = 'environment';\n        }\n        input.click();\n    }\n    _getCameraPhoto(photo, options) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            const format = photo.type.split('/')[1];\n            if (options.resultType === 'uri') {\n                resolve({\n                    webPath: URL.createObjectURL(photo),\n                    format: format,\n                    saved: false,\n                });\n            }\n            else {\n                reader.readAsDataURL(photo);\n                reader.onloadend = () => {\n                    const r = reader.result;\n                    if (options.resultType === 'dataUrl') {\n                        resolve({\n                            dataUrl: r,\n                            format: format,\n                            saved: false,\n                        });\n                    }\n                    else {\n                        resolve({\n                            base64String: r.split(',')[1],\n                            format: format,\n                            saved: false,\n                        });\n                    }\n                };\n                reader.onerror = e => {\n                    reject(e);\n                };\n            }\n        });\n    }\n    async checkPermissions() {\n        if (typeof navigator === 'undefined' || !navigator.permissions) {\n            throw this.unavailable('Permissions API not available in this browser');\n        }\n        try {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Permissions/query\n            // the specific permissions that are supported varies among browsers that implement the\n            // permissions API, so we need a try/catch in case 'camera' is invalid\n            const permission = await window.navigator.permissions.query({\n                name: 'camera',\n            });\n            return {\n                camera: permission.state,\n                photos: 'granted',\n            };\n        }\n        catch (_a) {\n            throw this.unavailable('Camera permissions are not available in this browser');\n        }\n    }\n    async requestPermissions() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n}\nconst Camera = new CameraWeb();\nexport { Camera };\n//# sourceMappingURL=web.js.map"],"sourceRoot":"webpack:///"}