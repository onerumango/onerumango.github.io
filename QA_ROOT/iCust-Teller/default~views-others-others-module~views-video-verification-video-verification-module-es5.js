(function () {
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

  (window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~views-others-others-module~views-video-verification-video-verification-module"], {
    /***/
    "5ZEx":
    /*!**********************************************!*\
      !*** ./node_modules/highcharts/highstock.js ***!
      \**********************************************/

    /*! no static exports found */

    /***/
    function ZEx(module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*
      Highstock JS v10.2.0 (2022-07-05)
      (c) 2009-2021 Torstein Honsi
      License: www.highcharts.com/license
      */


      (function (U, P) {
        true && module.exports ? (P["default"] = P, module.exports = U.document ? P(U) : P) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return P(U);
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
      })("undefined" !== typeof window ? window : this, function (U) {
        function P(d, C, g, E) {
          d.hasOwnProperty(C) || (d[C] = E.apply(null, g), "function" === typeof CustomEvent && U.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
            detail: {
              path: C,
              module: d[C]
            }
          })));
        }

        var g = {};
        P(g, "Core/Globals.js", [], function () {
          var d;

          (function (d) {
            d.SVG_NS = "http://www.w3.org/2000/svg";
            d.product = "Highcharts";
            d.version = "10.2.0";
            d.win = "undefined" !== typeof U ? U : {};
            d.doc = d.win.document;
            d.svg = d.doc && d.doc.createElementNS && !!d.doc.createElementNS(d.SVG_NS, "svg").createSVGRect;
            d.userAgent = d.win.navigator && d.win.navigator.userAgent || "";
            d.isChrome = -1 !== d.userAgent.indexOf("Chrome");
            d.isFirefox = -1 !== d.userAgent.indexOf("Firefox");
            d.isMS = /(edge|msie|trident)/i.test(d.userAgent) && !d.win.opera;
            d.isSafari = !d.isChrome && -1 !== d.userAgent.indexOf("Safari");
            d.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(d.userAgent);
            d.isWebKit = -1 !== d.userAgent.indexOf("AppleWebKit");
            d.deg2rad = 2 * Math.PI / 360;
            d.hasBidiBug = d.isFirefox && 4 > parseInt(d.userAgent.split("Firefox/")[1], 10);
            d.hasTouch = !!d.win.TouchEvent;
            d.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];

            d.noop = function () {};

            d.supportsPassiveEvents = function () {
              var g = !1;

              if (!d.isMS) {
                var C = Object.defineProperty({}, "passive", {
                  get: function get() {
                    g = !0;
                  }
                });
                d.win.addEventListener && d.win.removeEventListener && (d.win.addEventListener("testPassive", d.noop, C), d.win.removeEventListener("testPassive", d.noop, C));
              }

              return g;
            }();

            d.charts = [];
            d.dateFormats = {};
            d.seriesTypes = {};
            d.symbolSizes = {};
            d.chartCount = 0;
          })(d || (d = {}));

          "";
          return d;
        });
        P(g, "Core/Utilities.js", [g["Core/Globals.js"]], function (d) {
          function g(f, b, h, n) {
            var p = b ? "Highcharts error" : "Highcharts warning";
            32 === f && (f = "" + p + ": Deprecated member");
            var D = q(f),
                K = D ? "" + p + " #" + f + ": www.highcharts.com/errors/" + f + "/" : f.toString();

            if ("undefined" !== typeof n) {
              var H = "";
              D && (K += "?");
              L(n, function (b, f) {
                H += "\n - ".concat(f, ": ").concat(b);
                D && (K += encodeURI(f) + "=" + encodeURI(b));
              });
              K += H;
            }

            y(d, "displayError", {
              chart: h,
              code: f,
              message: K,
              params: n
            }, function () {
              if (b) throw Error(K);
              e.console && -1 === g.messages.indexOf(K) && console.warn(K);
            });
            g.messages.push(K);
          }

          function B(f, b) {
            var e = {};
            L(f, function (h, p) {
              if (I(f[p], !0) && !f.nodeType && b[p]) h = B(f[p], b[p]), Object.keys(h).length && (e[p] = h);else if (I(f[p]) || f[p] !== b[p] || p in f && !(p in b)) e[p] = f[p];
            });
            return e;
          }

          function E(f, b) {
            return parseInt(f, b || 10);
          }

          function x(f) {
            return "string" === typeof f;
          }

          function G(f) {
            f = Object.prototype.toString.call(f);
            return "[object Array]" === f || "[object Array Iterator]" === f;
          }

          function I(f, b) {
            return !!f && "object" === typeof f && (!b || !G(f));
          }

          function A(f) {
            return I(f) && "number" === typeof f.nodeType;
          }

          function t(f) {
            var b = f && f.constructor;
            return !(!I(f, !0) || A(f) || !b || !b.name || "Object" === b.name);
          }

          function q(f) {
            return "number" === typeof f && !isNaN(f) && Infinity > f && -Infinity < f;
          }

          function c(f) {
            return "undefined" !== typeof f && null !== f;
          }

          function l(f, b, e) {
            var h = x(b) && !c(e),
                p,
                D = function D(b, e) {
              c(b) ? f.setAttribute(e, b) : h ? (p = f.getAttribute(e)) || "class" !== e || (p = f.getAttribute(e + "Name")) : f.removeAttribute(e);
            };

            x(b) ? D(e, b) : L(b, D);
            return p;
          }

          function a(f, b) {
            var e;
            f || (f = {});

            for (e in b) {
              f[e] = b[e];
            }

            return f;
          }

          function k() {
            for (var f = arguments, b = f.length, e = 0; e < b; e++) {
              var h = f[e];
              if ("undefined" !== typeof h && null !== h) return h;
            }
          }

          function v(f, b) {
            d.isMS && !d.svg && b && c(b.opacity) && (b.filter = "alpha(opacity=".concat(100 * b.opacity, ")"));
            a(f.style, b);
          }

          function m(f) {
            return Math.pow(10, Math.floor(Math.log(f) / Math.LN10));
          }

          function N(f, b) {
            return 1E14 < f ? f : parseFloat(f.toPrecision(b || 14));
          }

          function F(f, b, h) {
            var D = d.getStyle || F;
            if ("width" === b) return b = Math.min(f.offsetWidth, f.scrollWidth), h = f.getBoundingClientRect && f.getBoundingClientRect().width, h < b && h >= b - 1 && (b = Math.floor(h)), Math.max(0, b - (D(f, "padding-left", !0) || 0) - (D(f, "padding-right", !0) || 0));
            if ("height" === b) return Math.max(0, Math.min(f.offsetHeight, f.scrollHeight) - (D(f, "padding-top", !0) || 0) - (D(f, "padding-bottom", !0) || 0));
            e.getComputedStyle || g(27, !0);

            if (f = e.getComputedStyle(f, void 0)) {
              var p = f.getPropertyValue(b);
              k(h, "opacity" !== b) && (p = E(p));
            }

            return p;
          }

          function L(f, b, e) {
            for (var h in f) {
              Object.hasOwnProperty.call(f, h) && b.call(e || f[h], f[h], h, f);
            }
          }

          function J(f, b, e) {
            function h(b, e) {
              var M = f.removeEventListener || d.removeEventListenerPolyfill;
              M && M.call(f, b, e, !1);
            }

            function p(e) {
              var M;

              if (f.nodeName) {
                if (b) {
                  var p = {};
                  p[b] = !0;
                } else p = e;

                L(p, function (b, f) {
                  if (e[f]) for (M = e[f].length; M--;) {
                    h(f, e[f][M].fn);
                  }
                });
              }
            }

            var D = "function" === typeof f && f.prototype || f;

            if (Object.hasOwnProperty.call(D, "hcEvents")) {
              var K = D.hcEvents;
              b ? (D = K[b] || [], e ? (K[b] = D.filter(function (b) {
                return e !== b.fn;
              }), h(b, e)) : (p(K), K[b] = [])) : (p(K), delete D.hcEvents);
            }
          }

          function y(f, b, e, h) {
            e = e || {};

            if (w.createEvent && (f.dispatchEvent || f.fireEvent && f !== d)) {
              var p = w.createEvent("Events");
              p.initEvent(b, !0, !0);
              e = a(p, e);
              f.dispatchEvent ? f.dispatchEvent(e) : f.fireEvent(b, e);
            } else if (f.hcEvents) {
              e.target || a(e, {
                preventDefault: function preventDefault() {
                  e.defaultPrevented = !0;
                },
                target: f,
                type: b
              });
              p = [];

              for (var n = f, K = !1; n.hcEvents;) {
                Object.hasOwnProperty.call(n, "hcEvents") && n.hcEvents[b] && (p.length && (K = !0), p.unshift.apply(p, n.hcEvents[b])), n = Object.getPrototypeOf(n);
              }

              K && p.sort(function (b, f) {
                return b.order - f.order;
              });
              p.forEach(function (b) {
                !1 === b.fn.call(f, e) && e.preventDefault();
              });
            }

            h && !e.defaultPrevented && h.call(f, e);
          }

          var z = d.charts,
              w = d.doc,
              e = d.win;
          (g || (g = {})).messages = [];

          Math.easeInOutSine = function (f) {
            return -.5 * (Math.cos(Math.PI * f) - 1);
          };

          var r = Array.prototype.find ? function (f, b) {
            return f.find(b);
          } : function (f, b) {
            var e,
                h = f.length;

            for (e = 0; e < h; e++) {
              if (b(f[e], e)) return f[e];
            }
          };
          L({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function (f, b) {
            d[b] = function (e) {
              var h;
              g(32, !1, void 0, (h = {}, h["Highcharts.".concat(b)] = "use Array.".concat(f), h));
              return Array.prototype[f].apply(e, [].slice.call(arguments, 1));
            };
          });

          var h,
              n = function () {
            var f = Math.random().toString(36).substring(2, 9) + "-",
                b = 0;
            return function () {
              return "highcharts-" + (h ? "" : f) + b++;
            };
          }();

          e.jQuery && (e.jQuery.fn.highcharts = function () {
            var f = [].slice.call(arguments);
            if (this[0]) return f[0] ? (new d[x(f[0]) ? f.shift() : "Chart"](this[0], f[0], f[1]), this) : z[l(this[0], "data-highcharts-chart")];
          });
          r = {
            addEvent: function addEvent(f, b, e, h) {
              void 0 === h && (h = {});
              var p = "function" === typeof f && f.prototype || f;
              Object.hasOwnProperty.call(p, "hcEvents") || (p.hcEvents = {});
              p = p.hcEvents;
              d.Point && f instanceof d.Point && f.series && f.series.chart && (f.series.chart.runTrackerClick = !0);
              var n = f.addEventListener || d.addEventListenerPolyfill;
              n && n.call(f, b, e, d.supportsPassiveEvents ? {
                passive: void 0 === h.passive ? -1 !== b.indexOf("touch") : h.passive,
                capture: !1
              } : !1);
              p[b] || (p[b] = []);
              p[b].push({
                fn: e,
                order: "number" === typeof h.order ? h.order : Infinity
              });
              p[b].sort(function (b, f) {
                return b.order - f.order;
              });
              return function () {
                J(f, b, e);
              };
            },
            arrayMax: function arrayMax(f) {
              for (var b = f.length, e = f[0]; b--;) {
                f[b] > e && (e = f[b]);
              }

              return e;
            },
            arrayMin: function arrayMin(f) {
              for (var b = f.length, e = f[0]; b--;) {
                f[b] < e && (e = f[b]);
              }

              return e;
            },
            attr: l,
            clamp: function clamp(f, b, e) {
              return f > b ? f < e ? f : e : b;
            },
            cleanRecursively: B,
            clearTimeout: function (_clearTimeout) {
              function clearTimeout(_x) {
                return _clearTimeout.apply(this, arguments);
              }

              clearTimeout.toString = function () {
                return _clearTimeout.toString();
              };

              return clearTimeout;
            }(function (f) {
              c(f) && clearTimeout(f);
            }),
            correctFloat: N,
            createElement: function createElement(f, b, e, h, p) {
              f = w.createElement(f);
              b && a(f, b);
              p && v(f, {
                padding: "0",
                border: "none",
                margin: "0"
              });
              e && v(f, e);
              h && h.appendChild(f);
              return f;
            },
            css: v,
            defined: c,
            destroyObjectProperties: function destroyObjectProperties(f, b) {
              L(f, function (e, h) {
                e && e !== b && e.destroy && e.destroy();
                delete f[h];
              });
            },
            discardElement: function discardElement(f) {
              f && f.parentElement && f.parentElement.removeChild(f);
            },
            erase: function erase(f, b) {
              for (var e = f.length; e--;) {
                if (f[e] === b) {
                  f.splice(e, 1);
                  break;
                }
              }
            },
            error: g,
            extend: a,
            extendClass: function extendClass(f, b) {
              var e = function e() {};

              e.prototype = new f();
              a(e.prototype, b);
              return e;
            },
            find: r,
            fireEvent: y,
            getMagnitude: m,
            getNestedProperty: function getNestedProperty(f, b) {
              for (f = f.split("."); f.length && c(b);) {
                var h = f.shift();
                if ("undefined" === typeof h || "__proto__" === h) return;
                b = b[h];
                if (!c(b) || "function" === typeof b || "number" === typeof b.nodeType || b === e) return;
              }

              return b;
            },
            getStyle: F,
            inArray: function inArray(f, b, e) {
              g(32, !1, void 0, {
                "Highcharts.inArray": "use Array.indexOf"
              });
              return b.indexOf(f, e);
            },
            isArray: G,
            isClass: t,
            isDOMElement: A,
            isFunction: function isFunction(f) {
              return "function" === typeof f;
            },
            isNumber: q,
            isObject: I,
            isString: x,
            keys: function keys(f) {
              g(32, !1, void 0, {
                "Highcharts.keys": "use Object.keys"
              });
              return Object.keys(f);
            },
            merge: function merge() {
              var f,
                  b = arguments,
                  e = {},
                  h = function h(b, f) {
                "object" !== typeof b && (b = {});
                L(f, function (e, M) {
                  "__proto__" !== M && "constructor" !== M && (!I(e, !0) || t(e) || A(e) ? b[M] = f[M] : b[M] = h(b[M] || {}, e));
                });
                return b;
              };

              !0 === b[0] && (e = b[1], b = Array.prototype.slice.call(b, 2));
              var p = b.length;

              for (f = 0; f < p; f++) {
                e = h(e, b[f]);
              }

              return e;
            },
            normalizeTickInterval: function normalizeTickInterval(f, b, e, h, p) {
              var n = f;
              e = k(e, m(f));
              var K = f / e;
              b || (b = p ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === h && (1 === e ? b = b.filter(function (b) {
                return 0 === b % 1;
              }) : .1 >= e && (b = [1 / e])));

              for (h = 0; h < b.length && !(n = b[h], p && n * e >= f || !p && K <= (b[h] + (b[h + 1] || b[h])) / 2); h++) {
                ;
              }

              return n = N(n * e, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: L,
            offset: function offset(f) {
              var b = w.documentElement;
              f = f.parentElement || f.parentNode ? f.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
              };
              return {
                top: f.top + (e.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: f.left + (e.pageXOffset || b.scrollLeft) - (b.clientLeft || 0),
                width: f.width,
                height: f.height
              };
            },
            pad: function pad(f, b, e) {
              return Array((b || 2) + 1 - String(f).replace("-", "").length).join(e || "0") + f;
            },
            pick: k,
            pInt: E,
            relativeLength: function relativeLength(f, b, e) {
              return /%$/.test(f) ? b * parseFloat(f) / 100 + (e || 0) : parseFloat(f);
            },
            removeEvent: J,
            splat: function splat(f) {
              return G(f) ? f : [f];
            },
            stableSort: function stableSort(f, b) {
              var e = f.length,
                  h,
                  p;

              for (p = 0; p < e; p++) {
                f[p].safeI = p;
              }

              f.sort(function (f, e) {
                h = b(f, e);
                return 0 === h ? f.safeI - e.safeI : h;
              });

              for (p = 0; p < e; p++) {
                delete f[p].safeI;
              }
            },
            syncTimeout: function syncTimeout(f, b, e) {
              if (0 < b) return setTimeout(f, b, e);
              f.call(0, e);
              return -1;
            },
            timeUnits: {
              millisecond: 1,
              second: 1E3,
              minute: 6E4,
              hour: 36E5,
              day: 864E5,
              week: 6048E5,
              month: 24192E5,
              year: 314496E5
            },
            uniqueKey: n,
            useSerialIds: function useSerialIds(f) {
              return h = k(f, h);
            },
            wrap: function wrap(f, b, e) {
              var h = f[b];

              f[b] = function () {
                var b = Array.prototype.slice.call(arguments),
                    f = arguments,
                    K = this;

                K.proceed = function () {
                  h.apply(K, arguments.length ? arguments : f);
                };

                b.unshift(h);
                b = e.apply(this, b);
                K.proceed = null;
                return b;
              };
            }
          };
          "";
          return r;
        });
        P(g, "Core/Chart/ChartDefaults.js", [], function () {
          return {
            alignThresholds: !1,
            panning: {
              enabled: !1,
              type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            allowMutatingData: !0,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: "#335cad",
            backgroundColor: "#ffffff",
            plotBorderColor: "#cccccc"
          };
        });
        P(g, "Core/Color/Color.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g) {
          var C = g.isNumber,
              E = g.merge,
              x = g.pInt;

          g = function () {
            function g(C) {
              this.rgba = [NaN, NaN, NaN, NaN];
              this.input = C;
              var A = d.Color;
              if (A && A !== g) return new A(C);
              if (!(this instanceof g)) return new g(C);
              this.init(C);
            }

            g.parse = function (d) {
              return d ? new g(d) : g.None;
            };

            g.prototype.init = function (d) {
              var A;
              if ("object" === typeof d && "undefined" !== typeof d.stops) this.stops = d.stops.map(function (c) {
                return new g(c[1]);
              });else if ("string" === typeof d) {
                this.input = d = g.names[d.toLowerCase()] || d;

                if ("#" === d.charAt(0)) {
                  var t = d.length;
                  var q = parseInt(d.substr(1), 16);
                  7 === t ? A = [(q & 16711680) >> 16, (q & 65280) >> 8, q & 255, 1] : 4 === t && (A = [(q & 3840) >> 4 | (q & 3840) >> 8, (q & 240) >> 4 | q & 240, (q & 15) << 4 | q & 15, 1]);
                }

                if (!A) for (q = g.parsers.length; q-- && !A;) {
                  var c = g.parsers[q];
                  (t = c.regex.exec(d)) && (A = c.parse(t));
                }
              }
              A && (this.rgba = A);
            };

            g.prototype.get = function (d) {
              var A = this.input,
                  t = this.rgba;

              if ("object" === typeof A && "undefined" !== typeof this.stops) {
                var q = E(A);
                q.stops = [].slice.call(q.stops);
                this.stops.forEach(function (c, l) {
                  q.stops[l] = [q.stops[l][0], c.get(d)];
                });
                return q;
              }

              return t && C(t[0]) ? "rgb" === d || !d && 1 === t[3] ? "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")" : "a" === d ? "".concat(t[3]) : "rgba(" + t.join(",") + ")" : A;
            };

            g.prototype.brighten = function (d) {
              var A = this.rgba;
              if (this.stops) this.stops.forEach(function (q) {
                q.brighten(d);
              });else if (C(d) && 0 !== d) for (var t = 0; 3 > t; t++) {
                A[t] += x(255 * d), 0 > A[t] && (A[t] = 0), 255 < A[t] && (A[t] = 255);
              }
              return this;
            };

            g.prototype.setOpacity = function (d) {
              this.rgba[3] = d;
              return this;
            };

            g.prototype.tweenTo = function (d, A) {
              var t = this.rgba,
                  q = d.rgba;
              if (!C(t[0]) || !C(q[0])) return d.input || "none";
              d = 1 !== q[3] || 1 !== t[3];
              return (d ? "rgba(" : "rgb(") + Math.round(q[0] + (t[0] - q[0]) * (1 - A)) + "," + Math.round(q[1] + (t[1] - q[1]) * (1 - A)) + "," + Math.round(q[2] + (t[2] - q[2]) * (1 - A)) + (d ? "," + (q[3] + (t[3] - q[3]) * (1 - A)) : "") + ")";
            };

            g.names = {
              white: "#ffffff",
              black: "#000000"
            };
            g.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(d) {
                return [x(d[1]), x(d[2]), x(d[3]), parseFloat(d[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(d) {
                return [x(d[1]), x(d[2]), x(d[3]), 1];
              }
            }];
            g.None = new g("");
            return g;
          }();

          "";
          return g;
        });
        P(g, "Core/Color/Palettes.js", [], function () {
          return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
          };
        });
        P(g, "Core/Time.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g) {
          var C = d.win,
              E = g.defined,
              x = g.error,
              G = g.extend,
              I = g.isObject,
              A = g.merge,
              t = g.objectEach,
              q = g.pad,
              c = g.pick,
              l = g.splat,
              a = g.timeUnits,
              k = d.isSafari && C.Intl && C.Intl.DateTimeFormat.prototype.formatRange,
              v = d.isSafari && C.Intl && !C.Intl.DateTimeFormat.prototype.formatRange;

          g = function () {
            function m(a) {
              this.options = {};
              this.variableTimezone = this.useUTC = !1;
              this.Date = C.Date;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.update(a);
            }

            m.prototype.get = function (a, c) {
              if (this.variableTimezone || this.timezoneOffset) {
                var m = c.getTime(),
                    N = m - this.getTimezoneOffset(c);
                c.setTime(N);
                a = c["getUTC" + a]();
                c.setTime(m);
                return a;
              }

              return this.useUTC ? c["getUTC" + a]() : c["get" + a]();
            };

            m.prototype.set = function (a, c, m) {
              if (this.variableTimezone || this.timezoneOffset) {
                if ("Milliseconds" === a || "Seconds" === a || "Minutes" === a && 0 === this.getTimezoneOffset(c) % 36E5) return c["setUTC" + a](m);
                var N = this.getTimezoneOffset(c);
                N = c.getTime() - N;
                c.setTime(N);
                c["setUTC" + a](m);
                a = this.getTimezoneOffset(c);
                N = c.getTime() + a;
                return c.setTime(N);
              }

              return this.useUTC || k && "FullYear" === a ? c["setUTC" + a](m) : c["set" + a](m);
            };

            m.prototype.update = function (a) {
              var m = c(a && a.useUTC, !0);
              this.options = a = A(!0, this.options || {}, a);
              this.Date = a.Date || C.Date || Date;
              this.timezoneOffset = (this.useUTC = m) && a.timezoneOffset || void 0;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.variableTimezone = m && !(!a.getTimezoneOffset && !a.timezone);
            };

            m.prototype.makeTime = function (a, m, k, l, y, z) {
              if (this.useUTC) {
                var w = this.Date.UTC.apply(0, arguments);
                var e = this.getTimezoneOffset(w);
                w += e;
                var r = this.getTimezoneOffset(w);
                e !== r ? w += r - e : e - 36E5 !== this.getTimezoneOffset(w - 36E5) || v || (w -= 36E5);
              } else w = new this.Date(a, m, c(k, 1), c(l, 0), c(y, 0), c(z, 0)).getTime();

              return w;
            };

            m.prototype.timezoneOffsetFunction = function () {
              var a = this,
                  c = this.options,
                  m = c.getTimezoneOffset,
                  k = c.moment || C.moment;
              if (!this.useUTC) return function (a) {
                return 6E4 * new Date(a.toString()).getTimezoneOffset();
              };

              if (c.timezone) {
                if (k) return function (a) {
                  return 6E4 * -k.tz(a, c.timezone).utcOffset();
                };
                x(25);
              }

              return this.useUTC && m ? function (a) {
                return 6E4 * m(a.valueOf());
              } : function () {
                return 6E4 * (a.timezoneOffset || 0);
              };
            };

            m.prototype.dateFormat = function (a, m, k) {
              if (!E(m) || isNaN(m)) return d.defaultOptions.lang && d.defaultOptions.lang.invalidDate || "";
              a = c(a, "%Y-%m-%d %H:%M:%S");
              var l = this,
                  y = new this.Date(m),
                  z = this.get("Hours", y),
                  w = this.get("Day", y),
                  e = this.get("Date", y),
                  r = this.get("Month", y),
                  h = this.get("FullYear", y),
                  n = d.defaultOptions.lang,
                  f = n && n.weekdays,
                  b = n && n.shortWeekdays;
              y = G({
                a: b ? b[w] : f[w].substr(0, 3),
                A: f[w],
                d: q(e),
                e: q(e, 2, " "),
                w: w,
                b: n.shortMonths[r],
                B: n.months[r],
                m: q(r + 1),
                o: r + 1,
                y: h.toString().substr(2, 2),
                Y: h,
                H: q(z),
                k: z,
                I: q(z % 12 || 12),
                l: z % 12 || 12,
                M: q(this.get("Minutes", y)),
                p: 12 > z ? "AM" : "PM",
                P: 12 > z ? "am" : "pm",
                S: q(y.getSeconds()),
                L: q(Math.floor(m % 1E3), 3)
              }, d.dateFormats);
              t(y, function (b, f) {
                for (; -1 !== a.indexOf("%" + f);) {
                  a = a.replace("%" + f, "function" === typeof b ? b.call(l, m) : b);
                }
              });
              return k ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;
            };

            m.prototype.resolveDTLFormat = function (a) {
              return I(a, !0) ? a : (a = l(a), {
                main: a[0],
                from: a[1],
                to: a[2]
              });
            };

            m.prototype.getTimeTicks = function (m, k, l, v) {
              var y = this,
                  z = [],
                  w = {},
                  e = new y.Date(k),
                  r = m.unitRange,
                  h = m.count || 1,
                  n;
              v = c(v, 1);

              if (E(k)) {
                y.set("Milliseconds", e, r >= a.second ? 0 : h * Math.floor(y.get("Milliseconds", e) / h));
                r >= a.second && y.set("Seconds", e, r >= a.minute ? 0 : h * Math.floor(y.get("Seconds", e) / h));
                r >= a.minute && y.set("Minutes", e, r >= a.hour ? 0 : h * Math.floor(y.get("Minutes", e) / h));
                r >= a.hour && y.set("Hours", e, r >= a.day ? 0 : h * Math.floor(y.get("Hours", e) / h));
                r >= a.day && y.set("Date", e, r >= a.month ? 1 : Math.max(1, h * Math.floor(y.get("Date", e) / h)));

                if (r >= a.month) {
                  y.set("Month", e, r >= a.year ? 0 : h * Math.floor(y.get("Month", e) / h));
                  var f = y.get("FullYear", e);
                }

                r >= a.year && y.set("FullYear", e, f - f % h);
                r === a.week && (f = y.get("Day", e), y.set("Date", e, y.get("Date", e) - f + v + (f < v ? -7 : 0)));
                f = y.get("FullYear", e);
                v = y.get("Month", e);
                var b = y.get("Date", e),
                    D = y.get("Hours", e);
                k = e.getTime();
                !y.variableTimezone && y.useUTC || !E(l) || (n = l - k > 4 * a.month || y.getTimezoneOffset(k) !== y.getTimezoneOffset(l));
                k = e.getTime();

                for (e = 1; k < l;) {
                  z.push(k), k = r === a.year ? y.makeTime(f + e * h, 0) : r === a.month ? y.makeTime(f, v + e * h) : !n || r !== a.day && r !== a.week ? n && r === a.hour && 1 < h ? y.makeTime(f, v, b, D + e * h) : k + r * h : y.makeTime(f, v, b + e * h * (r === a.day ? 1 : 7)), e++;
                }

                z.push(k);
                r <= a.hour && 1E4 > z.length && z.forEach(function (b) {
                  0 === b % 18E5 && "000000000" === y.dateFormat("%H%M%S%L", b) && (w[b] = "day");
                });
              }

              z.info = G(m, {
                higherRanks: w,
                totalRange: r * h
              });
              return z;
            };

            m.prototype.getDateFormat = function (c, m, k, l) {
              var y = this.dateFormat("%m-%d %H:%M:%S.%L", m),
                  z = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
              },
                  w = "millisecond";

              for (e in a) {
                if (c === a.week && +this.dateFormat("%w", m) === k && "00:00:00.000" === y.substr(6)) {
                  var e = "week";
                  break;
                }

                if (a[e] > c) {
                  e = w;
                  break;
                }

                if (z[e] && y.substr(z[e]) !== "01-01 00:00:00.000".substr(z[e])) break;
                "week" !== e && (w = e);
              }

              return this.resolveDTLFormat(l[e]).main;
            };

            return m;
          }();

          "";
          return g;
        });
        P(g, "Core/DefaultOptions.js", [g["Core/Chart/ChartDefaults.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Color/Palettes.js"], g["Core/Time.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G) {
          g = g.parse;
          var C = G.merge,
              A = {
            colors: E.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
              loading: "Loading...",
              months: "January February March April May June July August September October November December".split(" "),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
              weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
              decimalPoint: ".",
              numericSymbols: "kMGTPE".split(""),
              resetZoom: "Reset zoom",
              resetZoomTitle: "Reset zoom level 1:1",
              thousandsSep: " "
            },
            global: {},
            time: {
              Date: void 0,
              getTimezoneOffset: void 0,
              timezone: void 0,
              timezoneOffset: 0,
              useUTC: !0
            },
            chart: d,
            title: {
              text: "Chart title",
              align: "center",
              margin: 15,
              widthAdjust: -44
            },
            subtitle: {
              text: "",
              align: "center",
              widthAdjust: -44
            },
            caption: {
              margin: 15,
              text: "",
              align: "left",
              verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
              style: {
                position: "absolute",
                color: "#333333"
              }
            },
            legend: {
              enabled: !0,
              align: "center",
              alignColumns: !0,
              className: "highcharts-no-tooltip",
              layout: "horizontal",
              labelFormatter: function labelFormatter() {
                return this.name;
              },
              borderColor: "#999999",
              borderRadius: 0,
              navigation: {
                activeColor: "#003399",
                inactiveColor: "#cccccc"
              },
              itemStyle: {
                color: "#333333",
                cursor: "pointer",
                fontSize: "12px",
                fontWeight: "bold",
                textOverflow: "ellipsis"
              },
              itemHoverStyle: {
                color: "#000000"
              },
              itemHiddenStyle: {
                color: "#cccccc"
              },
              shadow: !1,
              itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
              },
              squareSymbol: !0,
              symbolPadding: 5,
              verticalAlign: "bottom",
              x: 0,
              y: 0,
              title: {
                style: {
                  fontWeight: "bold"
                }
              }
            },
            loading: {
              labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
              },
              style: {
                position: "absolute",
                backgroundColor: "#ffffff",
                opacity: .5,
                textAlign: "center"
              }
            },
            tooltip: {
              enabled: !0,
              animation: B.svg,
              borderRadius: 3,
              dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
              },
              footerFormat: "",
              headerShape: "callout",
              hideDelay: 500,
              padding: 8,
              shape: "callout",
              shared: !1,
              snap: B.isTouchDevice ? 25 : 10,
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
              backgroundColor: g("#f7f7f7").setOpacity(.85).get(),
              borderWidth: 1,
              shadow: !0,
              stickOnContact: !1,
              style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                whiteSpace: "nowrap"
              },
              useHTML: !1
            },
            credits: {
              enabled: !0,
              href: "https://www.highcharts.com?credits",
              position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
              },
              style: {
                cursor: "pointer",
                color: "#999999",
                fontSize: "9px"
              },
              text: "Highcharts.com"
            }
          };
          A.chart.styledMode = !1;
          "";
          var t = new x(C(A.global, A.time));
          d = {
            defaultOptions: A,
            defaultTime: t,
            getOptions: function getOptions() {
              return A;
            },
            setOptions: function setOptions(q) {
              C(!0, A, q);
              if (q.time || q.global) B.time ? B.time.update(C(A.global, A.time, q.global, q.time)) : B.time = t;
              return A;
            }
          };
          "";
          return d;
        });
        P(g, "Core/Animation/Fx.js", [g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = d.parse,
              x = g.win,
              G = B.isNumber,
              I = B.objectEach;
          return function () {
            function d(t, q, c) {
              this.pos = NaN;
              this.options = q;
              this.elem = t;
              this.prop = c;
            }

            d.prototype.dSetter = function () {
              var t = this.paths,
                  q = t && t[0];
              t = t && t[1];
              var c = this.now || 0,
                  l = [];
              if (1 !== c && q && t) {
                if (q.length === t.length && 1 > c) for (var a = 0; a < t.length; a++) {
                  for (var k = q[a], v = t[a], m = [], N = 0; N < v.length; N++) {
                    var F = k[N],
                        L = v[N];
                    G(F) && G(L) && ("A" !== v[0] || 4 !== N && 5 !== N) ? m[N] = F + c * (L - F) : m[N] = L;
                  }

                  l.push(m);
                } else l = t;
              } else l = this.toD || [];
              this.elem.attr("d", l, void 0, !0);
            };

            d.prototype.update = function () {
              var t = this.elem,
                  q = this.prop,
                  c = this.now,
                  l = this.options.step;
              if (this[q + "Setter"]) this[q + "Setter"]();else t.attr ? t.element && t.attr(q, c, null, !0) : t.style[q] = c + this.unit;
              l && l.call(t, c, this);
            };

            d.prototype.run = function (t, q, c) {
              var l = this,
                  a = l.options,
                  k = function k(a) {
                return k.stopped ? !1 : l.step(a);
              },
                  v = x.requestAnimationFrame || function (a) {
                setTimeout(a, 13);
              },
                  m = function m() {
                for (var a = 0; a < d.timers.length; a++) {
                  d.timers[a]() || d.timers.splice(a--, 1);
                }

                d.timers.length && v(m);
              };

              t !== q || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = t, this.end = q, this.unit = c, this.now = this.start, this.pos = 0, k.elem = this.elem, k.prop = this.prop, k() && 1 === d.timers.push(k) && v(m)) : (delete a.curAnim[this.prop], a.complete && 0 === Object.keys(a.curAnim).length && a.complete.call(this.elem));
            };

            d.prototype.step = function (t) {
              var q = +new Date(),
                  c = this.options,
                  l = this.elem,
                  a = c.complete,
                  k = c.duration,
                  v = c.curAnim;
              if (l.attr && !l.element) t = !1;else if (t || q >= k + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                var m = v[this.prop] = !0;
                I(v, function (a) {
                  !0 !== a && (m = !1);
                });
                m && a && a.call(l);
                t = !1;
              } else this.pos = c.easing((q - this.startTime) / k), this.now = this.start + (this.end - this.start) * this.pos, this.update(), t = !0;
              return t;
            };

            d.prototype.initPath = function (t, q, c) {
              function l(a, z) {
                for (; a.length < J;) {
                  var w = a[0],
                      e = z[J - a.length];
                  e && "M" === w[0] && (a[0] = "C" === e[0] ? ["C", w[1], w[2], w[1], w[2], w[1], w[2]] : ["L", w[1], w[2]]);
                  a.unshift(w);
                  m && (w = a.pop(), a.push(a[a.length - 1], w));
                }
              }

              function a(a, z) {
                for (; a.length < J;) {
                  if (z = a[Math.floor(a.length / N) - 1].slice(), "C" === z[0] && (z[1] = z[5], z[2] = z[6]), m) {
                    var w = a[Math.floor(a.length / N)].slice();
                    a.splice(a.length / 2, 0, z, w);
                  } else a.push(z);
                }
              }

              var k = t.startX,
                  v = t.endX;
              c = c.slice();
              var m = t.isArea,
                  N = m ? 2 : 1;
              q = q && q.slice();
              if (!q) return [c, c];

              if (k && v && v.length) {
                for (t = 0; t < k.length; t++) {
                  if (k[t] === v[0]) {
                    var F = t;
                    break;
                  } else if (k[0] === v[v.length - k.length + t]) {
                    F = t;
                    var L = !0;
                    break;
                  } else if (k[k.length - 1] === v[v.length - k.length + t]) {
                    F = k.length - t;
                    break;
                  }
                }

                "undefined" === typeof F && (q = []);
              }

              if (q.length && G(F)) {
                var J = c.length + F * N;
                L ? (l(q, c), a(c, q)) : (l(c, q), a(q, c));
              }

              return [q, c];
            };

            d.prototype.fillSetter = function () {
              d.prototype.strokeSetter.apply(this, arguments);
            };

            d.prototype.strokeSetter = function () {
              this.elem.attr(this.prop, C(this.start).tweenTo(C(this.end), this.pos), void 0, !0);
            };

            d.timers = [];
            return d;
          }();
        });
        P(g, "Core/Animation/AnimationUtilities.js", [g["Core/Animation/Fx.js"], g["Core/Utilities.js"]], function (d, g) {
          function C(a) {
            return t(a) ? q({
              duration: 500,
              defer: 0
            }, a) : {
              duration: a ? 500 : 0,
              defer: 0
            };
          }

          function E(a, c) {
            for (var k = d.timers.length; k--;) {
              d.timers[k].elem !== a || c && c !== d.timers[k].prop || (d.timers[k].stopped = !0);
            }
          }

          var x = g.defined,
              G = g.getStyle,
              I = g.isArray,
              A = g.isNumber,
              t = g.isObject,
              q = g.merge,
              c = g.objectEach,
              l = g.pick;
          return {
            animate: function animate(a, k, l) {
              var m,
                  v = "",
                  F,
                  L;

              if (!t(l)) {
                var J = arguments;
                l = {
                  duration: J[2],
                  easing: J[3],
                  complete: J[4]
                };
              }

              A(l.duration) || (l.duration = 400);
              l.easing = "function" === typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine;
              l.curAnim = q(k);
              c(k, function (c, z) {
                E(a, z);
                L = new d(a, l, z);
                F = void 0;
                "d" === z && I(k.d) ? (L.paths = L.initPath(a, a.pathArray, k.d), L.toD = k.d, m = 0, F = 1) : a.attr ? m = a.attr(z) : (m = parseFloat(G(a, z)) || 0, "opacity" !== z && (v = "px"));
                F || (F = c);
                "string" === typeof F && F.match("px") && (F = F.replace(/px/g, ""));
                L.run(m, F, v);
              });
            },
            animObject: C,
            getDeferredAnimation: function getDeferredAnimation(a, c, l) {
              var m = C(c),
                  k = 0,
                  v = 0;
              (l ? [l] : a.series).forEach(function (a) {
                a = C(a.options.animation);
                k = c && x(c.defer) ? m.defer : Math.max(k, a.duration + a.defer);
                v = Math.min(m.duration, a.duration);
              });
              a.renderer.forExport && (k = 0);
              return {
                defer: Math.max(0, k - v),
                duration: Math.min(k, v)
              };
            },
            setAnimation: function setAnimation(a, c) {
              c.renderer.globalAnimation = l(a, c.options.chart.animation, !0);
            },
            stop: E
          };
        });
        P(g, "Core/Renderer/HTML/AST.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g) {
          var C = d.SVG_NS,
              E = g.attr,
              x = g.createElement,
              G = g.css,
              I = g.error,
              A = g.isFunction,
              t = g.isString,
              q = g.objectEach,
              c = g.splat,
              l = (g = d.win.trustedTypes) && A(g.createPolicy) && g.createPolicy("highcharts", {
            createHTML: function createHTML(a) {
              return a;
            }
          }),
              a = l ? l.createHTML("") : "";

          try {
            var k = !!new DOMParser().parseFromString(a, "text/html");
          } catch (v) {
            k = !1;
          }

          A = function () {
            function v(a) {
              this.nodes = "string" === typeof a ? this.parseMarkup(a) : a;
            }

            v.filterUserAttributes = function (a) {
              q(a, function (c, m) {
                var k = !0;
                -1 === v.allowedAttributes.indexOf(m) && (k = !1);
                -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(m) && (k = t(c) && v.allowedReferences.some(function (a) {
                  return 0 === c.indexOf(a);
                }));
                k || (I(33, !1, void 0, {
                  "Invalid attribute in config": "".concat(m)
                }), delete a[m]);
              });
              return a;
            };

            v.parseStyle = function (a) {
              return a.split(";").reduce(function (a, c) {
                c = c.split(":").map(function (a) {
                  return a.trim();
                });
                var m = c.shift();
                m && c.length && (a[m.replace(/-([a-z])/g, function (a) {
                  return a[1].toUpperCase();
                })] = c.join(":"));
                return a;
              }, {});
            };

            v.setElementHTML = function (a, c) {
              a.innerHTML = v.emptyHTML;
              c && new v(c).addToDOM(a);
            };

            v.prototype.addToDOM = function (a) {
              function m(a, k) {
                var l;
                c(a).forEach(function (a) {
                  var c = a.tagName,
                      w = a.textContent ? d.doc.createTextNode(a.textContent) : void 0,
                      e = v.bypassHTMLFiltering;
                  if (c) if ("#text" === c) var r = w;else if (-1 !== v.allowedTags.indexOf(c) || e) {
                    c = d.doc.createElementNS("svg" === c ? C : k.namespaceURI || C, c);
                    var h = a.attributes || {};
                    q(a, function (e, f) {
                      "tagName" !== f && "attributes" !== f && "children" !== f && "style" !== f && "textContent" !== f && (h[f] = e);
                    });
                    E(c, e ? h : v.filterUserAttributes(h));
                    a.style && G(c, a.style);
                    w && c.appendChild(w);
                    m(a.children || [], c);
                    r = c;
                  } else I(33, !1, void 0, {
                    "Invalid tagName in config": c
                  });
                  r && k.appendChild(r);
                  l = r;
                });
                return l;
              }

              return m(this.nodes, a);
            };

            v.prototype.parseMarkup = function (a) {
              var c = [];
              a = a.trim().replace(/ style="/g, ' data-style="');
              if (k) a = new DOMParser().parseFromString(l ? l.createHTML(a) : a, "text/html");else {
                var m = x("div");
                m.innerHTML = a;
                a = {
                  body: m
                };
              }

              var q = function q(a, c) {
                var z = a.nodeName.toLowerCase(),
                    w = {
                  tagName: z
                };
                "#text" === z && (w.textContent = a.textContent || "");

                if (z = a.attributes) {
                  var e = {};
                  [].forEach.call(z, function (h) {
                    "data-style" === h.name ? w.style = v.parseStyle(h.value) : e[h.name] = h.value;
                  });
                  w.attributes = e;
                }

                if (a.childNodes.length) {
                  var r = [];
                  [].forEach.call(a.childNodes, function (e) {
                    q(e, r);
                  });
                  r.length && (w.children = r);
                }

                c.push(w);
              };

              [].forEach.call(a.body.childNodes, function (a) {
                return q(a, c);
              });
              return c;
            };

            v.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            v.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            v.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            v.emptyHTML = a;
            v.bypassHTMLFiltering = !1;
            return v;
          }();

          "";
          return A;
        });
        P(g, "Core/FormatUtilities.js", [g["Core/DefaultOptions.js"], g["Core/Utilities.js"]], function (d, g) {
          function C(q, c, l, a) {
            q = +q || 0;
            c = +c;
            var k = E.lang,
                v = (q.toString().split(".")[1] || "").split("e")[0].length,
                m = q.toString().split("e"),
                N = c;
            if (-1 === c) c = Math.min(v, 20);else if (!I(c)) c = 2;else if (c && m[1] && 0 > m[1]) {
              var F = c + +m[1];
              0 <= F ? (m[0] = (+m[0]).toExponential(F).split("e")[0], c = F) : (m[0] = m[0].split(".")[0] || 0, q = 20 > c ? (m[0] * Math.pow(10, m[1])).toFixed(c) : 0, m[1] = 0);
            }
            F = (Math.abs(m[1] ? m[0] : q) + Math.pow(10, -Math.max(c, v) - 1)).toFixed(c);
            v = String(t(F));
            var L = 3 < v.length ? v.length % 3 : 0;
            l = A(l, k.decimalPoint);
            a = A(a, k.thousandsSep);
            q = (0 > q ? "-" : "") + (L ? v.substr(0, L) + a : "");
            q = 0 > +m[1] && !N ? "0" : q + v.substr(L).replace(/(\d{3})(?=\d)/g, "$1" + a);
            c && (q += l + F.slice(-c));
            m[1] && 0 !== +q && (q += "e" + m[1]);
            return q;
          }

          var E = d.defaultOptions,
              x = d.defaultTime,
              G = g.getNestedProperty,
              I = g.isNumber,
              A = g.pick,
              t = g.pInt;
          return {
            dateFormat: function dateFormat(q, c, l) {
              return x.dateFormat(q, c, l);
            },
            format: function format(q, c, l) {
              var a = "{",
                  k = !1,
                  v = /f$/,
                  m = /\.([0-9])/,
                  N = E.lang,
                  F = l && l.time || x;
              l = l && l.numberFormatter || C;

              for (var L = []; q;) {
                var J = q.indexOf(a);
                if (-1 === J) break;
                var y = q.slice(0, J);

                if (k) {
                  y = y.split(":");
                  a = G(y.shift() || "", c);
                  if (y.length && "number" === typeof a) if (y = y.join(":"), v.test(y)) {
                    var z = parseInt((y.match(m) || ["", "-1"])[1], 10);
                    null !== a && (a = l(a, z, N.decimalPoint, -1 < y.indexOf(",") ? N.thousandsSep : ""));
                  } else a = F.dateFormat(y, a);
                  L.push(a);
                } else L.push(y);

                q = q.slice(J + 1);
                a = (k = !k) ? "}" : "{";
              }

              L.push(q);
              return L.join("");
            },
            numberFormat: C
          };
        });
        P(g, "Core/Renderer/RendererUtilities.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.clamp,
              B = d.pick,
              E = d.stableSort,
              x;

          (function (d) {
            function x(d, t, q) {
              var c = d,
                  l = c.reducedLen || t,
                  a = function a(_a, c) {
                return (c.rank || 0) - (_a.rank || 0);
              },
                  k = function k(a, c) {
                return a.target - c.target;
              },
                  v,
                  m = !0,
                  N = [],
                  F = 0;

              for (v = d.length; v--;) {
                F += d[v].size;
              }

              if (F > l) {
                E(d, a);

                for (F = v = 0; F <= l;) {
                  F += d[v].size, v++;
                }

                N = d.splice(v - 1, d.length);
              }

              E(d, k);

              for (d = d.map(function (a) {
                return {
                  size: a.size,
                  targets: [a.target],
                  align: B(a.align, .5)
                };
              }); m;) {
                for (v = d.length; v--;) {
                  l = d[v], a = (Math.min.apply(0, l.targets) + Math.max.apply(0, l.targets)) / 2, l.pos = g(a - l.size * l.align, 0, t - l.size);
                }

                v = d.length;

                for (m = !1; v--;) {
                  0 < v && d[v - 1].pos + d[v - 1].size > d[v].pos && (d[v - 1].size += d[v].size, d[v - 1].targets = d[v - 1].targets.concat(d[v].targets), d[v - 1].align = .5, d[v - 1].pos + d[v - 1].size > t && (d[v - 1].pos = t - d[v - 1].size), d.splice(v, 1), m = !0);
                }
              }

              c.push.apply(c, N);
              v = 0;
              d.some(function (a) {
                var m = 0;
                return (a.targets || []).some(function () {
                  c[v].pos = a.pos + m;
                  if ("undefined" !== typeof q && Math.abs(c[v].pos - c[v].target) > q) return c.slice(0, v + 1).forEach(function (a) {
                    return delete a.pos;
                  }), c.reducedLen = (c.reducedLen || t) - .1 * t, c.reducedLen > .1 * t && x(c, t, q), !0;
                  m += c[v].size;
                  v++;
                  return !1;
                });
              });
              E(c, k);
              return c;
            }

            d.distribute = x;
          })(x || (x = {}));

          return x;
        });
        P(g, "Core/Renderer/SVG/SVGElement.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Renderer/HTML/AST.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g, B, E, x) {
          var C = d.animate,
              I = d.animObject,
              A = d.stop,
              t = E.deg2rad,
              q = E.doc,
              c = E.noop,
              l = E.svg,
              a = E.SVG_NS,
              k = E.win,
              v = x.addEvent,
              m = x.attr,
              N = x.createElement,
              F = x.css,
              L = x.defined,
              J = x.erase,
              y = x.extend,
              z = x.fireEvent,
              w = x.isArray,
              e = x.isFunction,
              r = x.isNumber,
              h = x.isString,
              n = x.merge,
              f = x.objectEach,
              b = x.pick,
              D = x.pInt,
              H = x.syncTimeout,
              p = x.uniqueKey;

          d = function () {
            function u() {
              this.element = void 0;
              this.onEvents = {};
              this.opacity = 1;
              this.renderer = void 0;
              this.SVG_NS = a;
              this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }

            u.prototype._defaultGetter = function (f) {
              f = b(this[f + "Value"], this[f], this.element ? this.element.getAttribute(f) : null, 0);
              /^[\-0-9\.]+$/.test(f) && (f = parseFloat(f));
              return f;
            };

            u.prototype._defaultSetter = function (b, f, e) {
              e.setAttribute(f, b);
            };

            u.prototype.add = function (b) {
              var f = this.renderer,
                  e = this.element;
              b && (this.parentGroup = b);
              this.parentInverted = b && b.inverted;
              "undefined" !== typeof this.textStr && "text" === this.element.nodeName && f.buildText(this);
              this.added = !0;
              if (!b || b.handleZ || this.zIndex) var h = this.zIndexSetter();
              h || (b ? b.element : f.box).appendChild(e);
              if (this.onAdd) this.onAdd();
              return this;
            };

            u.prototype.addClass = function (b, f) {
              var e = f ? "" : this.attr("class") || "";
              b = (b || "").split(/ /g).reduce(function (b, f) {
                -1 === e.indexOf(f) && b.push(f);
                return b;
              }, e ? [e] : []).join(" ");
              b !== e && this.attr("class", b);
              return this;
            };

            u.prototype.afterSetters = function () {
              this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };

            u.prototype.align = function (f, e, M) {
              var p = {},
                  a = this.renderer,
                  n = a.alignedObjects,
                  K,
                  u,
                  Q;

              if (f) {
                if (this.alignOptions = f, this.alignByTranslate = e, !M || h(M)) this.alignTo = K = M || "renderer", J(n, this), n.push(this), M = void 0;
              } else f = this.alignOptions, e = this.alignByTranslate, K = this.alignTo;

              M = b(M, a[K], "scrollablePlotBox" === K ? a.plotBox : void 0, a);
              K = f.align;
              var r = f.verticalAlign;
              a = (M.x || 0) + (f.x || 0);
              n = (M.y || 0) + (f.y || 0);
              "right" === K ? u = 1 : "center" === K && (u = 2);
              u && (a += (M.width - (f.width || 0)) / u);
              p[e ? "translateX" : "x"] = Math.round(a);
              "bottom" === r ? Q = 1 : "middle" === r && (Q = 2);
              Q && (n += (M.height - (f.height || 0)) / Q);
              p[e ? "translateY" : "y"] = Math.round(n);
              this[this.placed ? "animate" : "attr"](p);
              this.placed = !0;
              this.alignAttr = p;
              return this;
            };

            u.prototype.alignSetter = function (b) {
              var f = {
                left: "start",
                center: "middle",
                right: "end"
              };
              f[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", f[b]));
            };

            u.prototype.animate = function (e, h, M) {
              var p = this,
                  a = I(b(h, this.renderer.globalAnimation, !0));
              h = a.defer;
              b(q.hidden, q.msHidden, q.webkitHidden, !1) && (a.duration = 0);
              0 !== a.duration ? (M && (a.complete = M), H(function () {
                p.element && C(p, e, a);
              }, h)) : (this.attr(e, void 0, M || a.complete), f(e, function (b, f) {
                a.step && a.step.call(this, b, {
                  prop: f,
                  pos: 1,
                  elem: this
                });
              }, this));
              return this;
            };

            u.prototype.applyTextOutline = function (b) {
              var f = this.element;
              -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(f.style.fill)));
              var e = b.split(" ");
              b = e[e.length - 1];

              if ((e = e[0]) && "none" !== e && E.svg) {
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                e = e.replace(/(^[\d\.]+)(.*?)$/g, function (b, f, e) {
                  return 2 * Number(f) + e;
                });
                this.removeTextOutline();
                var h = q.createElementNS(a, "tspan");
                m(h, {
                  "class": "highcharts-text-outline",
                  fill: b,
                  stroke: b,
                  "stroke-width": e,
                  "stroke-linejoin": "round"
                });
                [].forEach.call(f.childNodes, function (b) {
                  var f = b.cloneNode(!0);
                  f.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
                    return f.removeAttribute(b);
                  });
                  h.appendChild(f);
                });
                var p = q.createElementNS(a, "tspan");
                p.textContent = "\u200B";
                ["x", "y"].forEach(function (b) {
                  var e = f.getAttribute(b);
                  e && p.setAttribute(b, e);
                });
                h.appendChild(p);
                f.insertBefore(h, f.firstChild);
              }
            };

            u.prototype.attr = function (b, e, h, p) {
              var M = this.element,
                  a = this.symbolCustomAttribs,
                  O,
                  n = this,
                  K,
                  u;

              if ("string" === typeof b && "undefined" !== typeof e) {
                var r = b;
                b = {};
                b[r] = e;
              }

              "string" === typeof b ? n = (this[b + "Getter"] || this._defaultGetter).call(this, b, M) : (f(b, function (f, e) {
                K = !1;
                p || A(this, e);
                this.symbolName && -1 !== a.indexOf(e) && (O || (this.symbolAttr(b), O = !0), K = !0);
                !this.rotation || "x" !== e && "y" !== e || (this.doTransform = !0);
                K || (u = this[e + "Setter"] || this._defaultSetter, u.call(this, f, e, M), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(e) && this.updateShadows(e, f, u));
              }, this), this.afterSetters());
              h && h.call(this);
              return n;
            };

            u.prototype.clip = function (b) {
              return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
            };

            u.prototype.crisp = function (b, f) {
              f = f || b.strokeWidth || 0;
              var e = Math.round(f) % 2 / 2;
              b.x = Math.floor(b.x || this.x || 0) + e;
              b.y = Math.floor(b.y || this.y || 0) + e;
              b.width = Math.floor((b.width || this.width || 0) - 2 * e);
              b.height = Math.floor((b.height || this.height || 0) - 2 * e);
              L(b.strokeWidth) && (b.strokeWidth = f);
              return b;
            };

            u.prototype.complexColor = function (b, e, h) {
              var M = this.renderer,
                  a,
                  K,
                  u,
                  r,
                  Q,
                  c,
                  D,
                  H,
                  m,
                  k,
                  l = [],
                  y;
              z(this.renderer, "complexColor", {
                args: arguments
              }, function () {
                b.radialGradient ? K = "radialGradient" : b.linearGradient && (K = "linearGradient");

                if (K) {
                  u = b[K];
                  Q = M.gradients;
                  c = b.stops;
                  m = h.radialReference;
                  w(u) && (b[K] = u = {
                    x1: u[0],
                    y1: u[1],
                    x2: u[2],
                    y2: u[3],
                    gradientUnits: "userSpaceOnUse"
                  });
                  "radialGradient" === K && m && !L(u.gradientUnits) && (r = u, u = n(u, M.getRadialAttr(m, r), {
                    gradientUnits: "userSpaceOnUse"
                  }));
                  f(u, function (b, f) {
                    "id" !== f && l.push(f, b);
                  });
                  f(c, function (b) {
                    l.push(b);
                  });
                  l = l.join(",");
                  if (Q[l]) k = Q[l].attr("id");else {
                    u.id = k = p();
                    var O = Q[l] = M.createElement(K).attr(u).add(M.defs);
                    O.radAttr = r;
                    O.stops = [];
                    c.forEach(function (b) {
                      0 === b[1].indexOf("rgba") ? (a = B.parse(b[1]), D = a.get("rgb"), H = a.get("a")) : (D = b[1], H = 1);
                      b = M.createElement("stop").attr({
                        offset: b[0],
                        "stop-color": D,
                        "stop-opacity": H
                      }).add(O);
                      O.stops.push(b);
                    });
                  }
                  y = "url(" + M.url + "#" + k + ")";
                  h.setAttribute(e, y);
                  h.gradient = l;

                  b.toString = function () {
                    return y;
                  };
                }
              });
            };

            u.prototype.css = function (b) {
              var e = this.styles,
                  h = {},
                  p = this.element,
                  a = !e;
              b.color && (b.fill = b.color);
              e && f(b, function (b, f) {
                e && e[f] !== b && (h[f] = b, a = !0);
              });

              if (a) {
                e && (b = y(e, h));
                if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === p.nodeName.toLowerCase() && b.width) var u = this.textWidth = D(b.width);
                this.styles = b;
                u && !l && this.renderer.forExport && delete b.width;
                var K = n(b);
                p.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach(function (b) {
                  return K && delete K[b];
                });
                F(p, K);
                this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b.textOutline && this.applyTextOutline(b.textOutline));
              }

              return this;
            };

            u.prototype.dashstyleSetter = function (f) {
              var e = this["stroke-width"];
              "inherit" === e && (e = 1);

              if (f = f && f.toLowerCase()) {
                var h = f.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

                for (f = h.length; f--;) {
                  h[f] = "" + D(h[f]) * b(e, NaN);
                }

                f = h.join(",").replace(/NaN/g, "none");
                this.element.setAttribute("stroke-dasharray", f);
              }
            };

            u.prototype.destroy = function () {
              var b = this,
                  e = b.element || {},
                  h = b.renderer,
                  p = e.ownerSVGElement,
                  a = h.isSVG && "SPAN" === e.nodeName && b.parentGroup || void 0;
              e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null;
              A(b);

              if (b.clipPath && p) {
                var n = b.clipPath;
                [].forEach.call(p.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
                  -1 < b.getAttribute("clip-path").indexOf(n.element.id) && b.removeAttribute("clip-path");
                });
                b.clipPath = n.destroy();
              }

              if (b.stops) {
                for (p = 0; p < b.stops.length; p++) {
                  b.stops[p].destroy();
                }

                b.stops.length = 0;
                b.stops = void 0;
              }

              b.safeRemoveChild(e);

              for (h.styledMode || b.destroyShadows(); a && a.div && 0 === a.div.childNodes.length;) {
                e = a.parentGroup, b.safeRemoveChild(a.div), delete a.div, a = e;
              }

              b.alignTo && J(h.alignedObjects, b);
              f(b, function (f, e) {
                b[e] && b[e].parentGroup === b && b[e].destroy && b[e].destroy();
                delete b[e];
              });
            };

            u.prototype.destroyShadows = function () {
              (this.shadows || []).forEach(function (b) {
                this.safeRemoveChild(b);
              }, this);
              this.shadows = void 0;
            };

            u.prototype.destroyTextPath = function (b, f) {
              var e = b.getElementsByTagName("text")[0];

              if (e) {
                if (e.removeAttribute("dx"), e.removeAttribute("dy"), f.element.setAttribute("id", ""), this.textPathWrapper && e.getElementsByTagName("textPath").length) {
                  for (b = this.textPathWrapper.element.childNodes; b.length;) {
                    e.appendChild(b[0]);
                  }

                  e.removeChild(this.textPathWrapper.element);
                }
              } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");

              this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };

            u.prototype.dSetter = function (b, f, e) {
              w(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, f, e) {
                return f && f.join ? (e ? b + " " : "") + f.join(" ") : (f || "").toString();
              }, ""));
              /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
              this[f] !== b && (e.setAttribute(f, b), this[f] = b);
            };

            u.prototype.fadeOut = function (f) {
              var e = this;
              e.animate({
                opacity: 0
              }, {
                duration: b(f, 150),
                complete: function complete() {
                  e.hide();
                }
              });
            };

            u.prototype.fillSetter = function (b, f, e) {
              "string" === typeof b ? e.setAttribute(f, b) : b && this.complexColor(b, f, e);
            };

            u.prototype.getBBox = function (f, h) {
              var p = this.alignValue,
                  a = this.element,
                  n = this.renderer,
                  r = this.styles,
                  w = this.textStr,
                  c = n.cache,
                  Q = n.cacheKeys,
                  D = a.namespaceURI === this.SVG_NS;
              h = b(h, this.rotation, 0);
              var H = n.styledMode ? a && u.prototype.getStyle.call(a, "font-size") : r && r.fontSize,
                  K;

              if (L(w)) {
                var m = w.toString();
                -1 === m.indexOf("<") && (m = m.replace(/[0-9]/g, "0"));
                m += ["", h, H, this.textWidth, p, r && r.textOverflow, r && r.fontWeight].join();
              }

              m && !f && (K = c[m]);

              if (!K) {
                if (D || n.forExport) {
                  try {
                    var z = this.fakeTS && function (b) {
                      var f = a.querySelector(".highcharts-text-outline");
                      f && F(f, {
                        display: b
                      });
                    };

                    e(z) && z("none");
                    K = a.getBBox ? y({}, a.getBBox()) : {
                      width: a.offsetWidth,
                      height: a.offsetHeight
                    };
                    e(z) && z("");
                  } catch (da) {
                    "";
                  }

                  if (!K || 0 > K.width) K = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                } else K = this.htmlGetBBox();

                if (n.isSVG && (n = K.width, f = K.height, D && (K.height = f = {
                  "11px,17": 14,
                  "13px,20": 16
                }["" + (H || "") + ",".concat(Math.round(f))] || f), h)) {
                  D = Number(a.getAttribute("y") || 0) - K.y;
                  p = {
                    right: 1,
                    center: .5
                  }[p || 0] || 0;
                  r = h * t;
                  H = (h - 90) * t;
                  var k = n * Math.cos(r);
                  h = n * Math.sin(r);
                  z = Math.cos(H);
                  r = Math.sin(H);
                  n = K.x + p * (n - k) + D * z;
                  H = n + k;
                  z = H - f * z;
                  k = z - k;
                  D = K.y + D - p * h + D * r;
                  p = D + h;
                  f = p - f * r;
                  h = f - h;
                  K.x = Math.min(n, H, z, k);
                  K.y = Math.min(D, p, f, h);
                  K.width = Math.max(n, H, z, k) - K.x;
                  K.height = Math.max(D, p, f, h) - K.y;
                }

                if (m && ("" === w || 0 < K.height)) {
                  for (; 250 < Q.length;) {
                    delete c[Q.shift()];
                  }

                  c[m] || Q.push(m);
                  c[m] = K;
                }
              }

              return K;
            };

            u.prototype.getStyle = function (b) {
              return k.getComputedStyle(this.element || this, "").getPropertyValue(b);
            };

            u.prototype.hasClass = function (b) {
              return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
            };

            u.prototype.hide = function () {
              return this.attr({
                visibility: "hidden"
              });
            };

            u.prototype.htmlGetBBox = function () {
              return {
                height: 0,
                width: 0,
                x: 0,
                y: 0
              };
            };

            u.prototype.init = function (b, f) {
              this.element = "span" === f ? N(f) : q.createElementNS(this.SVG_NS, f);
              this.renderer = b;
              z(this, "afterInit");
            };

            u.prototype.invert = function (b) {
              this.inverted = b;
              this.updateTransform();
              return this;
            };

            u.prototype.on = function (b, f) {
              var e = this.onEvents;
              if (e[b]) e[b]();
              e[b] = v(this.element, b, f);
              return this;
            };

            u.prototype.opacitySetter = function (b, f, e) {
              this.opacity = b = Number(Number(b).toFixed(3));
              e.setAttribute(f, b);
            };

            u.prototype.removeClass = function (b) {
              return this.attr("class", ("" + this.attr("class")).replace(h(b) ? new RegExp("(^| )".concat(b, "( |$)")) : b, " ").replace(/ +/g, " ").trim());
            };

            u.prototype.removeTextOutline = function () {
              var b = this.element.querySelector("tspan.highcharts-text-outline");
              b && this.safeRemoveChild(b);
            };

            u.prototype.safeRemoveChild = function (b) {
              var f = b.parentNode;
              f && f.removeChild(b);
            };

            u.prototype.setRadialReference = function (b) {
              var f = this.element.gradient && this.renderer.gradients[this.element.gradient];
              this.element.radialReference = b;
              f && f.radAttr && f.animate(this.renderer.getRadialAttr(b, f.radAttr));
              return this;
            };

            u.prototype.setTextPath = function (b, e) {
              var h = this.element,
                  a = this.text ? this.text.element : h,
                  u = {
                textAnchor: "text-anchor"
              },
                  w = !1,
                  D = this.textPathWrapper,
                  H = !D;
              e = n(!0, {
                enabled: !0,
                attributes: {
                  dy: -5,
                  startOffset: "50%",
                  textAnchor: "middle"
                }
              }, e);
              var Q = g.filterUserAttributes(e.attributes);

              if (b && e && e.enabled) {
                D && null === D.element.parentNode ? (H = !0, D = D.destroy()) : D && this.removeTextOutline.call(D.parentGroup);
                this.options && this.options.padding && (Q.dx = -this.options.padding);
                D || (this.textPathWrapper = D = this.renderer.createElement("textPath"), w = !0);
                var m = D.element;
                (e = b.element.getAttribute("id")) || b.element.setAttribute("id", e = p());
                if (H) for (a.setAttribute("y", 0), r(Q.dx) && a.setAttribute("x", -Q.dx), b = [].slice.call(a.childNodes), H = 0; H < b.length; H++) {
                  var z = b[H];
                  z.nodeType !== k.Node.TEXT_NODE && "tspan" !== z.nodeName || m.appendChild(z);
                }
                w && D && D.add({
                  element: a
                });
                m.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + e);
                L(Q.dy) && (m.parentNode.setAttribute("dy", Q.dy), delete Q.dy);
                L(Q.dx) && (m.parentNode.setAttribute("dx", Q.dx), delete Q.dx);
                f(Q, function (b, f) {
                  m.setAttribute(u[f] || f, b);
                });
                h.removeAttribute("transform");
                this.removeTextOutline.call(D);
                this.text && !this.renderer.styledMode && this.attr({
                  fill: "none",
                  "stroke-width": 0
                });
                this.applyTextOutline = this.updateTransform = c;
              } else D && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(h, b), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

              return this;
            };

            u.prototype.shadow = function (b, e, h) {
              var p = [],
                  a = this.element,
                  M = this.oldShadowOptions,
                  n = {
                color: "#000000",
                offsetX: this.parentInverted ? -1 : 1,
                offsetY: this.parentInverted ? -1 : 1,
                opacity: .15,
                width: 3
              },
                  u = !1,
                  r;
              !0 === b ? r = n : "object" === typeof b && (r = y(n, b));
              r && (r && M && f(r, function (b, f) {
                b !== M[f] && (u = !0);
              }), u && this.destroyShadows(), this.oldShadowOptions = r);
              if (!r) this.destroyShadows();else if (!this.shadows) {
                var D = r.opacity / r.width;
                var w = this.parentInverted ? "translate(".concat(r.offsetY, ", ").concat(r.offsetX, ")") : "translate(".concat(r.offsetX, ", ").concat(r.offsetY, ")");

                for (n = 1; n <= r.width; n++) {
                  var c = a.cloneNode(!1);
                  var H = 2 * r.width + 1 - 2 * n;
                  m(c, {
                    stroke: b.color || "#000000",
                    "stroke-opacity": D * n,
                    "stroke-width": H,
                    transform: w,
                    fill: "none"
                  });
                  c.setAttribute("class", (c.getAttribute("class") || "") + " highcharts-shadow");
                  h && (m(c, "height", Math.max(m(c, "height") - H, 0)), c.cutHeight = H);
                  e ? e.element.appendChild(c) : a.parentNode && a.parentNode.insertBefore(c, a);
                  p.push(c);
                }

                this.shadows = p;
              }
              return this;
            };

            u.prototype.show = function (b) {
              void 0 === b && (b = !0);
              return this.attr({
                visibility: b ? "inherit" : "visible"
              });
            };

            u.prototype.strokeSetter = function (b, f, e) {
              this[f] = b;
              this.stroke && this["stroke-width"] ? (u.prototype.fillSetter.call(this, this.stroke, "stroke", e), e.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === f && 0 === b && this.hasStroke ? (e.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (e.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
            };

            u.prototype.strokeWidth = function () {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              var b = this.getStyle("stroke-width"),
                  f = 0;
              if (b.indexOf("px") === b.length - 2) f = D(b);else if ("" !== b) {
                var e = q.createElementNS(a, "rect");
                m(e, {
                  width: b,
                  "stroke-width": 0
                });
                this.element.parentNode.appendChild(e);
                f = e.getBBox().width;
                e.parentNode.removeChild(e);
              }
              return f;
            };

            u.prototype.symbolAttr = function (f) {
              var e = this;
              "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (h) {
                e[h] = b(f[h], e[h]);
              });
              e.attr({
                d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)
              });
            };

            u.prototype.textSetter = function (b) {
              b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
            };

            u.prototype.titleSetter = function (f) {
              var e = this.element,
                  h = e.getElementsByTagName("title")[0] || q.createElementNS(this.SVG_NS, "title");
              e.insertBefore ? e.insertBefore(h, e.firstChild) : e.appendChild(h);
              h.textContent = String(b(f, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };

            u.prototype.toFront = function () {
              var b = this.element;
              b.parentNode.appendChild(b);
              return this;
            };

            u.prototype.translate = function (b, f) {
              return this.attr({
                translateX: b,
                translateY: f
              });
            };

            u.prototype.updateShadows = function (b, f, e) {
              var h = this.shadows;
              if (h) for (var p = h.length; p--;) {
                e.call(h[p], "height" === b ? Math.max(f - (h[p].cutHeight || 0), 0) : "d" === b ? this.d : f, b, h[p]);
              }
            };

            u.prototype.updateTransform = function () {
              var f = this.scaleX,
                  e = this.scaleY,
                  h = this.inverted,
                  p = this.rotation,
                  a = this.matrix,
                  n = this.element,
                  u = this.translateX || 0,
                  r = this.translateY || 0;
              h && (u += this.width, r += this.height);
              u = ["translate(" + u + "," + r + ")"];
              L(a) && u.push("matrix(" + a.join(",") + ")");
              h ? u.push("rotate(90) scale(-1,1)") : p && u.push("rotate(" + p + " " + b(this.rotationOriginX, n.getAttribute("x"), 0) + " " + b(this.rotationOriginY, n.getAttribute("y") || 0) + ")");
              (L(f) || L(e)) && u.push("scale(" + b(f, 1) + " " + b(e, 1) + ")");
              u.length && n.setAttribute("transform", u.join(" "));
            };

            u.prototype.visibilitySetter = function (b, f, e) {
              "inherit" === b ? e.removeAttribute(f) : this[f] !== b && e.setAttribute(f, b);
              this[f] = b;
            };

            u.prototype.xGetter = function (b) {
              "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
              return this._defaultGetter(b);
            };

            u.prototype.zIndexSetter = function (b, f) {
              var e = this.renderer,
                  h = this.parentGroup,
                  p = (h || e).element || e.box,
                  a = this.element;
              e = p === e.box;
              var n = !1;
              var u = this.added;
              var r;
              L(b) ? (a.setAttribute("data-z-index", b), b = +b, this[f] === b && (u = !1)) : L(this[f]) && a.removeAttribute("data-z-index");
              this[f] = b;

              if (u) {
                (b = this.zIndex) && h && (h.handleZ = !0);
                f = p.childNodes;

                for (r = f.length - 1; 0 <= r && !n; r--) {
                  h = f[r];
                  u = h.getAttribute("data-z-index");
                  var w = !L(u);
                  if (h !== a) if (0 > b && w && !e && !r) p.insertBefore(a, f[r]), n = !0;else if (D(u) <= b || w && (!L(b) || 0 <= b)) p.insertBefore(a, f[r + 1] || null), n = !0;
                }

                n || (p.insertBefore(a, f[e ? 3 : 0] || null), n = !0);
              }

              return n;
            };

            return u;
          }();

          d.prototype["stroke-widthSetter"] = d.prototype.strokeSetter;
          d.prototype.yGetter = d.prototype.xGetter;

          d.prototype.matrixSetter = d.prototype.rotationOriginXSetter = d.prototype.rotationOriginYSetter = d.prototype.rotationSetter = d.prototype.scaleXSetter = d.prototype.scaleYSetter = d.prototype.translateXSetter = d.prototype.translateYSetter = d.prototype.verticalAlignSetter = function (b, f) {
            this[f] = b;
            this.doTransform = !0;
          };

          "";
          return d;
        });
        P(g, "Core/Renderer/RendererRegistry.js", [g["Core/Globals.js"]], function (d) {
          var g;

          (function (g) {
            g.rendererTypes = {};
            var C;

            g.getRendererType = function (d) {
              void 0 === d && (d = C);
              return g.rendererTypes[d] || g.rendererTypes[C];
            };

            g.registerRendererType = function (x, B, I) {
              g.rendererTypes[x] = B;
              if (!C || I) C = x, d.Renderer = B;
            };
          })(g || (g = {}));

          return g;
        });
        P(g, "Core/Renderer/SVG/SVGLabel.js", [g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (d, g) {
          var C = this && this.__extends || function () {
            var _q = function q(c, l) {
              _q = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var k in c) {
                  c.hasOwnProperty(k) && (a[k] = c[k]);
                }
              };

              return _q(c, l);
            };

            return function (c, l) {
              function a() {
                this.constructor = c;
              }

              _q(c, l);

              c.prototype = null === l ? Object.create(l) : (a.prototype = l.prototype, new a());
            };
          }(),
              E = g.defined,
              x = g.extend,
              G = g.isNumber,
              I = g.merge,
              A = g.pick,
              t = g.removeEvent;

          return function (q) {
            function c(l, a, k, v, m, N, F, d, J, y) {
              var z = q.call(this) || this;
              z.paddingLeftSetter = z.paddingSetter;
              z.paddingRightSetter = z.paddingSetter;
              z.init(l, "g");
              z.textStr = a;
              z.x = k;
              z.y = v;
              z.anchorX = N;
              z.anchorY = F;
              z.baseline = J;
              z.className = y;
              z.addClass("button" === y ? "highcharts-no-tooltip" : "highcharts-label");
              y && z.addClass("highcharts-" + y);
              z.text = l.text(void 0, 0, 0, d).attr({
                zIndex: 1
              });
              var w;
              "string" === typeof m && ((w = /^url\((.*?)\)$/.test(m)) || z.renderer.symbols[m]) && (z.symbolKey = m);
              z.bBox = c.emptyBBox;
              z.padding = 3;
              z.baselineOffset = 0;
              z.needsBox = l.styledMode || w;
              z.deferredAttr = {};
              z.alignFactor = 0;
              return z;
            }

            C(c, q);

            c.prototype.alignSetter = function (c) {
              c = {
                left: 0,
                center: .5,
                right: 1
              }[c];
              c !== this.alignFactor && (this.alignFactor = c, this.bBox && G(this.xSetting) && this.attr({
                x: this.xSetting
              }));
            };

            c.prototype.anchorXSetter = function (c, a) {
              this.anchorX = c;
              this.boxAttr(a, Math.round(c) - this.getCrispAdjust() - this.xSetting);
            };

            c.prototype.anchorYSetter = function (c, a) {
              this.anchorY = c;
              this.boxAttr(a, c - this.ySetting);
            };

            c.prototype.boxAttr = function (c, a) {
              this.box ? this.box.attr(c, a) : this.deferredAttr[c] = a;
            };

            c.prototype.css = function (l) {
              if (l) {
                var a = {};
                l = I(l);
                c.textProps.forEach(function (c) {
                  "undefined" !== typeof l[c] && (a[c] = l[c], delete l[c]);
                });
                this.text.css(a);
                var k = ("width" in a);
                "fontSize" in a || "fontWeight" in a ? this.updateTextPadding() : k && this.updateBoxSize();
              }

              return d.prototype.css.call(this, l);
            };

            c.prototype.destroy = function () {
              t(this.element, "mouseenter");
              t(this.element, "mouseleave");
              this.text && this.text.destroy();
              this.box && (this.box = this.box.destroy());
              d.prototype.destroy.call(this);
            };

            c.prototype.fillSetter = function (c, a) {
              c && (this.needsBox = !0);
              this.fill = c;
              this.boxAttr(a, c);
            };

            c.prototype.getBBox = function () {
              this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
              var c = this.padding,
                  a = A(this.paddingLeft, c);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - a,
                y: this.bBox.y - c
              };
            };

            c.prototype.getCrispAdjust = function () {
              return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };

            c.prototype.heightSetter = function (c) {
              this.heightSetting = c;
            };

            c.prototype.onAdd = function () {
              var c = this.textStr;
              this.text.add(this);
              this.attr({
                text: E(c) ? c : "",
                x: this.x,
                y: this.y
              });
              this.box && E(this.anchorX) && this.attr({
                anchorX: this.anchorX,
                anchorY: this.anchorY
              });
            };

            c.prototype.paddingSetter = function (c, a) {
              G(c) ? c !== this[a] && (this[a] = c, this.updateTextPadding()) : this[a] = void 0;
            };

            c.prototype.rSetter = function (c, a) {
              this.boxAttr(a, c);
            };

            c.prototype.shadow = function (c) {
              c && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(c));
              return this;
            };

            c.prototype.strokeSetter = function (c, a) {
              this.stroke = c;
              this.boxAttr(a, c);
            };

            c.prototype["stroke-widthSetter"] = function (c, a) {
              c && (this.needsBox = !0);
              this["stroke-width"] = c;
              this.boxAttr(a, c);
            };

            c.prototype["text-alignSetter"] = function (c) {
              this.textAlign = c;
            };

            c.prototype.textSetter = function (c) {
              "undefined" !== typeof c && this.text.attr({
                text: c
              });
              this.updateTextPadding();
            };

            c.prototype.updateBoxSize = function () {
              var l = this.text.element.style,
                  a = {},
                  k = this.padding,
                  v = this.bBox = G(this.widthSetting) && G(this.heightSetting) && !this.textAlign || !E(this.text.textStr) ? c.emptyBBox : this.text.getBBox();
              this.width = this.getPaddedWidth();
              this.height = (this.heightSetting || v.height || 0) + 2 * k;
              l = this.renderer.fontMetrics(l && l.fontSize, this.text);
              this.baselineOffset = k + Math.min((this.text.firstLineMetrics || l).b, v.height || Infinity);
              this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2);
              this.needsBox && (this.box || (k = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), k.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), k.add(this)), k = this.getCrispAdjust(), a.x = k, a.y = (this.baseline ? -this.baselineOffset : 0) + k, a.width = Math.round(this.width), a.height = Math.round(this.height), this.box.attr(x(a, this.deferredAttr)), this.deferredAttr = {});
            };

            c.prototype.updateTextPadding = function () {
              var c = this.text;
              this.updateBoxSize();
              var a = this.baseline ? 0 : this.baselineOffset,
                  k = A(this.paddingLeft, this.padding);
              E(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (k += {
                center: .5,
                right: 1
              }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (k !== c.x || a !== c.y) c.attr("x", k), c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0)), "undefined" !== typeof a && c.attr("y", a);
              c.x = k;
              c.y = a;
            };

            c.prototype.widthSetter = function (c) {
              this.widthSetting = G(c) ? c : void 0;
            };

            c.prototype.getPaddedWidth = function () {
              var c = this.padding,
                  a = A(this.paddingLeft, c);
              c = A(this.paddingRight, c);
              return (this.widthSetting || this.bBox.width || 0) + a + c;
            };

            c.prototype.xSetter = function (c) {
              this.x = c;
              this.alignFactor && (c -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
              this.xSetting = Math.round(c);
              this.attr("translateX", this.xSetting);
            };

            c.prototype.ySetter = function (c) {
              this.ySetting = this.y = Math.round(c);
              this.attr("translateY", this.ySetting);
            };

            c.emptyBBox = {
              width: 0,
              height: 0,
              x: 0,
              y: 0
            };
            c.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return c;
          }(d);
        });
        P(g, "Core/Renderer/SVG/Symbols.js", [g["Core/Utilities.js"]], function (d) {
          function g(d, t, q, c, l) {
            var a = [];

            if (l) {
              var k = l.start || 0,
                  v = I(l.r, q);
              q = I(l.r, c || q);
              var m = (l.end || 0) - .001;
              c = l.innerR;
              var N = I(l.open, .001 > Math.abs((l.end || 0) - k - 2 * Math.PI)),
                  F = Math.cos(k),
                  L = Math.sin(k),
                  J = Math.cos(m),
                  y = Math.sin(m);
              k = I(l.longArc, .001 > m - k - Math.PI ? 0 : 1);
              a.push(["M", d + v * F, t + q * L], ["A", v, q, 0, k, I(l.clockwise, 1), d + v * J, t + q * y]);
              x(c) && a.push(N ? ["M", d + c * J, t + c * y] : ["L", d + c * J, t + c * y], ["A", c, c, 0, k, x(l.clockwise) ? 1 - l.clockwise : 0, d + c * F, t + c * L]);
              N || a.push(["Z"]);
            }

            return a;
          }

          function B(d, t, q, c, l) {
            return l && l.r ? E(d, t, q, c, l) : [["M", d, t], ["L", d + q, t], ["L", d + q, t + c], ["L", d, t + c], ["Z"]];
          }

          function E(d, t, q, c, l) {
            l = l && l.r || 0;
            return [["M", d + l, t], ["L", d + q - l, t], ["C", d + q, t, d + q, t, d + q, t + l], ["L", d + q, t + c - l], ["C", d + q, t + c, d + q, t + c, d + q - l, t + c], ["L", d + l, t + c], ["C", d, t + c, d, t + c, d, t + c - l], ["L", d, t + l], ["C", d, t, d, t, d + l, t]];
          }

          var x = d.defined,
              G = d.isNumber,
              I = d.pick;
          return {
            arc: g,
            callout: function callout(d, t, q, c, l) {
              var a = Math.min(l && l.r || 0, q, c),
                  k = a + 6,
                  v = l && l.anchorX;
              l = l && l.anchorY || 0;
              var m = E(d, t, q, c, {
                r: a
              });
              if (!G(v)) return m;
              d + v >= q ? l > t + k && l < t + c - k ? m.splice(3, 1, ["L", d + q, l - 6], ["L", d + q + 6, l], ["L", d + q, l + 6], ["L", d + q, t + c - a]) : m.splice(3, 1, ["L", d + q, c / 2], ["L", v, l], ["L", d + q, c / 2], ["L", d + q, t + c - a]) : 0 >= d + v ? l > t + k && l < t + c - k ? m.splice(7, 1, ["L", d, l + 6], ["L", d - 6, l], ["L", d, l - 6], ["L", d, t + a]) : m.splice(7, 1, ["L", d, c / 2], ["L", v, l], ["L", d, c / 2], ["L", d, t + a]) : l && l > c && v > d + k && v < d + q - k ? m.splice(5, 1, ["L", v + 6, t + c], ["L", v, t + c + 6], ["L", v - 6, t + c], ["L", d + a, t + c]) : l && 0 > l && v > d + k && v < d + q - k && m.splice(1, 1, ["L", v - 6, t], ["L", v, t - 6], ["L", v + 6, t], ["L", q - a, t]);
              return m;
            },
            circle: function circle(d, t, q, c) {
              return g(d + q / 2, t + c / 2, q / 2, c / 2, {
                start: .5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1
              });
            },
            diamond: function diamond(d, t, q, c) {
              return [["M", d + q / 2, t], ["L", d + q, t + c / 2], ["L", d + q / 2, t + c], ["L", d, t + c / 2], ["Z"]];
            },
            rect: B,
            roundedRect: E,
            square: B,
            triangle: function triangle(d, t, q, c) {
              return [["M", d + q / 2, t], ["L", d + q, t + c], ["L", d, t + c], ["Z"]];
            },
            "triangle-down": function triangleDown(d, t, q, c) {
              return [["M", d, t], ["L", d + q, t], ["L", d + q / 2, t + c], ["Z"]];
            }
          };
        });
        P(g, "Core/Renderer/SVG/TextBuilder.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = g.doc,
              x = g.SVG_NS,
              G = g.win,
              I = B.attr,
              A = B.extend,
              t = B.isString,
              q = B.objectEach,
              c = B.pick;
          return function () {
            function l(a) {
              var c = a.styles;
              this.renderer = a.renderer;
              this.svgElement = a;
              this.width = a.textWidth;
              this.textLineHeight = c && c.lineHeight;
              this.textOutline = c && c.textOutline;
              this.ellipsis = !(!c || "ellipsis" !== c.textOverflow);
              this.noWrap = !(!c || "nowrap" !== c.whiteSpace);
              this.fontSize = c && c.fontSize;
            }

            l.prototype.buildSVG = function () {
              var a = this.svgElement,
                  k = a.element,
                  v = a.renderer,
                  m = c(a.textStr, "").toString(),
                  l = -1 !== m.indexOf("<"),
                  q = k.childNodes;
              v = this.width && !a.added && v.box;
              var L = /<br.*?>/g,
                  J = [m, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();

              if (J !== a.textCache) {
                a.textCache = J;
                delete a.actualWidth;

                for (J = q.length; J--;) {
                  k.removeChild(q[J]);
                }

                l || this.ellipsis || this.width || -1 !== m.indexOf(" ") && (!this.noWrap || L.test(m)) ? "" !== m && (v && v.appendChild(k), m = new d(m), this.modifyTree(m.nodes), m.addToDOM(a.element), this.modifyDOM(), this.ellipsis && -1 !== (k.textContent || "").indexOf("\u2026") && a.attr("title", this.unescapeEntities(a.textStr || "", ["&lt;", "&gt;"])), v && v.removeChild(k)) : k.appendChild(C.createTextNode(this.unescapeEntities(m)));
                t(this.textOutline) && a.applyTextOutline && a.applyTextOutline(this.textOutline);
              }
            };

            l.prototype.modifyDOM = function () {
              var a = this,
                  c = this.svgElement,
                  d = I(c.element, "x");
              c.firstLineMetrics = void 0;

              for (var m; m = c.element.firstChild;) {
                if (/^[\s\u200B]*$/.test(m.textContent || " ")) c.element.removeChild(m);else break;
              }

              [].forEach.call(c.element.querySelectorAll("tspan.highcharts-br"), function (m, k) {
                m.nextSibling && m.previousSibling && (0 === k && 1 === m.previousSibling.nodeType && (c.firstLineMetrics = c.renderer.fontMetrics(void 0, m.previousSibling)), I(m, {
                  dy: a.getLineHeight(m.nextSibling),
                  x: d
                }));
              });
              var l = this.width || 0;

              if (l) {
                var q = function q(m, k) {
                  var z = m.textContent || "",
                      w = z.replace(/([^\^])-/g, "$1- ").split(" "),
                      e = !a.noWrap && (1 < w.length || 1 < c.element.childNodes.length),
                      r = a.getLineHeight(k),
                      h = 0,
                      n = c.actualWidth;
                  if (a.ellipsis) z && a.truncate(m, z, void 0, 0, Math.max(0, l - parseInt(a.fontSize || 12, 10)), function (f, b) {
                    return f.substring(0, b) + "\u2026";
                  });else if (e) {
                    z = [];

                    for (e = []; k.firstChild && k.firstChild !== m;) {
                      e.push(k.firstChild), k.removeChild(k.firstChild);
                    }

                    for (; w.length;) {
                      w.length && !a.noWrap && 0 < h && (z.push(m.textContent || ""), m.textContent = w.join(" ").replace(/- /g, "-")), a.truncate(m, void 0, w, 0 === h ? n || 0 : 0, l, function (f, b) {
                        return w.slice(0, b).join(" ").replace(/- /g, "-");
                      }), n = c.actualWidth, h++;
                    }

                    e.forEach(function (f) {
                      k.insertBefore(f, m);
                    });
                    z.forEach(function (f) {
                      k.insertBefore(C.createTextNode(f), m);
                      f = C.createElementNS(x, "tspan");
                      f.textContent = "\u200B";
                      I(f, {
                        dy: r,
                        x: d
                      });
                      k.insertBefore(f, m);
                    });
                  }
                },
                    L = function L(a) {
                  [].slice.call(a.childNodes).forEach(function (m) {
                    m.nodeType === G.Node.TEXT_NODE ? q(m, a) : (-1 !== m.className.baseVal.indexOf("highcharts-br") && (c.actualWidth = 0), L(m));
                  });
                };

                L(c.element);
              }
            };

            l.prototype.getLineHeight = function (a) {
              var c;
              a = a.nodeType === G.Node.TEXT_NODE ? a.parentElement : a;
              this.renderer.styledMode || (c = a && /(px|em)$/.test(a.style.fontSize) ? a.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
              return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(c, a || this.svgElement.element).h;
            };

            l.prototype.modifyTree = function (a) {
              var c = this,
                  d = function d(m, k) {
                var l = m.attributes;
                l = void 0 === l ? {} : l;
                var v = m.children,
                    q = m.style;
                q = void 0 === q ? {} : q;
                var y = m.tagName,
                    z = c.renderer.styledMode;
                if ("b" === y || "strong" === y) z ? l["class"] = "highcharts-strong" : q.fontWeight = "bold";else if ("i" === y || "em" === y) z ? l["class"] = "highcharts-emphasized" : q.fontStyle = "italic";
                q && q.color && (q.fill = q.color);
                "br" === y ? (l["class"] = "highcharts-br", m.textContent = "\u200B", (k = a[k + 1]) && k.textContent && (k.textContent = k.textContent.replace(/^ +/gm, ""))) : "a" === y && v && v.some(function (a) {
                  return "#text" === a.tagName;
                }) && (m.children = [{
                  children: v,
                  tagName: "tspan"
                }]);
                "#text" !== y && "a" !== y && (m.tagName = "tspan");
                A(m, {
                  attributes: l,
                  style: q
                });
                v && v.filter(function (a) {
                  return "#text" !== a.tagName;
                }).forEach(d);
              };

              a.forEach(d);
            };

            l.prototype.truncate = function (a, c, d, m, l, q) {
              var k = this.svgElement,
                  v = k.renderer,
                  y = k.rotation,
                  z = [],
                  w = d ? 1 : 0,
                  e = (c || d || "").length,
                  r = e,
                  h,
                  n = function n(b, f) {
                f = f || b;
                var e = a.parentNode;
                if (e && "undefined" === typeof z[f]) if (e.getSubStringLength) try {
                  z[f] = m + e.getSubStringLength(0, d ? f + 1 : f);
                } catch (p) {
                  "";
                } else v.getSpanWidth && (a.textContent = q(c || d, b), z[f] = m + v.getSpanWidth(k, a));
                return z[f];
              };

              k.rotation = 0;
              var f = n(a.textContent.length);

              if (m + f > l) {
                for (; w <= e;) {
                  r = Math.ceil((w + e) / 2), d && (h = q(d, r)), f = n(r, h && h.length - 1), w === e ? w = e + 1 : f > l ? e = r - 1 : w = r;
                }

                0 === e ? a.textContent = "" : c && e === c.length - 1 || (a.textContent = h || q(c || d, r));
              }

              d && d.splice(0, r);
              k.actualWidth = f;
              k.rotation = y;
            };

            l.prototype.unescapeEntities = function (a, c) {
              q(this.renderer.escapes, function (k, m) {
                c && -1 !== c.indexOf(k) || (a = a.toString().replace(new RegExp(k, "g"), m));
              });
              return a;
            };

            return l;
          }();
        });
        P(g, "Core/Renderer/SVG/SVGRenderer.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGLabel.js"], g["Core/Renderer/SVG/Symbols.js"], g["Core/Renderer/SVG/TextBuilder.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I, A, t) {
          var q = B.charts,
              c = B.deg2rad,
              l = B.doc,
              a = B.isFirefox,
              k = B.isMS,
              v = B.isWebKit,
              m = B.noop,
              N = B.SVG_NS,
              F = B.symbolSizes,
              L = B.win,
              J = t.addEvent,
              y = t.attr,
              z = t.createElement,
              w = t.css,
              e = t.defined,
              r = t.destroyObjectProperties,
              h = t.extend,
              n = t.isArray,
              f = t.isNumber,
              b = t.isObject,
              D = t.isString,
              H = t.merge,
              p = t.pick,
              u = t.pInt,
              K = t.uniqueKey,
              T;

          B = function () {
            function M(b, f, e, h, p, a, c) {
              this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
              this.init(b, f, e, h, p, a, c);
            }

            M.prototype.init = function (b, f, e, h, p, c, n) {
              var M = this.createElement("svg").attr({
                version: "1.1",
                "class": "highcharts-root"
              }),
                  u = M.element;
              n || M.css(this.getStyle(h));
              b.appendChild(u);
              y(b, "dir", "ltr");
              -1 === b.innerHTML.indexOf("xmlns") && y(u, "xmlns", this.SVG_NS);
              this.isSVG = !0;
              this.box = u;
              this.boxWrapper = M;
              this.alignedObjects = [];
              this.url = this.getReferenceURL();
              this.createElement("desc").add().element.appendChild(l.createTextNode("Created with Highcharts 10.2.0"));
              this.defs = this.createElement("defs").add();
              this.allowHTML = c;
              this.forExport = p;
              this.styledMode = n;
              this.gradients = {};
              this.cache = {};
              this.cacheKeys = [];
              this.imgCount = 0;
              this.setSize(f, e, !1);
              var r;
              a && b.getBoundingClientRect && (f = function f() {
                w(b, {
                  left: 0,
                  top: 0
                });
                r = b.getBoundingClientRect();
                w(b, {
                  left: Math.ceil(r.left) - r.left + "px",
                  top: Math.ceil(r.top) - r.top + "px"
                });
              }, f(), this.unSubPixelFix = J(L, "resize", f));
            };

            M.prototype.definition = function (b) {
              return new d([b]).addToDOM(this.defs.element);
            };

            M.prototype.getReferenceURL = function () {
              if ((a || v) && l.getElementsByTagName("base").length) {
                if (!e(T)) {
                  var b = K();
                  b = new d([{
                    tagName: "svg",
                    attributes: {
                      width: 8,
                      height: 8
                    },
                    children: [{
                      tagName: "defs",
                      children: [{
                        tagName: "clipPath",
                        attributes: {
                          id: b
                        },
                        children: [{
                          tagName: "rect",
                          attributes: {
                            width: 4,
                            height: 4
                          }
                        }]
                      }]
                    }, {
                      tagName: "rect",
                      attributes: {
                        id: "hitme",
                        width: 8,
                        height: 8,
                        "clip-path": "url(#".concat(b, ")"),
                        fill: "rgba(0,0,0,0.001)"
                      }
                    }]
                  }]).addToDOM(l.body);
                  w(b, {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    zIndex: 9E5
                  });
                  var f = l.elementFromPoint(6, 6);
                  T = "hitme" === (f && f.id);
                  l.body.removeChild(b);
                }

                if (T) return L.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
              }

              return "";
            };

            M.prototype.getStyle = function (b) {
              return this.style = h({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
              }, b);
            };

            M.prototype.setStyle = function (b) {
              this.boxWrapper.css(this.getStyle(b));
            };

            M.prototype.isHidden = function () {
              return !this.boxWrapper.getBBox().width;
            };

            M.prototype.destroy = function () {
              var b = this.defs;
              this.box = null;
              this.boxWrapper = this.boxWrapper.destroy();
              r(this.gradients || {});
              this.gradients = null;
              b && (this.defs = b.destroy());
              this.unSubPixelFix && this.unSubPixelFix();
              return this.alignedObjects = null;
            };

            M.prototype.createElement = function (b) {
              var f = new this.Element();
              f.init(this, b);
              return f;
            };

            M.prototype.getRadialAttr = function (b, f) {
              return {
                cx: b[0] - b[2] / 2 + (f.cx || 0) * b[2],
                cy: b[1] - b[2] / 2 + (f.cy || 0) * b[2],
                r: (f.r || 0) * b[2]
              };
            };

            M.prototype.buildText = function (b) {
              new A(b).buildSVG();
            };

            M.prototype.getContrast = function (b) {
              b = g.parse(b).rgba.map(function (b) {
                b /= 255;
                return .03928 >= b ? b / 12.92 : Math.pow((b + .055) / 1.055, 2.4);
              });
              b = .2126 * b[0] + .7152 * b[1] + .0722 * b[2];
              return 1.05 / (b + .05) > (b + .05) / .05 ? "#FFFFFF" : "#000000";
            };

            M.prototype.button = function (f, e, p, a, c, n, M, u, r, w) {
              void 0 === c && (c = {});
              var D = this.label(f, e, p, r, void 0, void 0, w, void 0, "button"),
                  O = this.styledMode;
              f = c.states || {};
              var m = 0;
              c = H(c);
              delete c.states;
              var Q = H({
                color: "#333333",
                cursor: "pointer",
                fontWeight: "normal"
              }, c.style);
              delete c.style;
              var z = d.filterUserAttributes(c);
              D.attr(H({
                padding: 8,
                r: 2
              }, z));

              if (!O) {
                z = H({
                  fill: "#f7f7f7",
                  stroke: "#cccccc",
                  "stroke-width": 1
                }, z);
                n = H(z, {
                  fill: "#e6e6e6"
                }, d.filterUserAttributes(n || f.hover || {}));
                var K = n.style;
                delete n.style;
                M = H(z, {
                  fill: "#e6ebf5",
                  style: {
                    color: "#000000",
                    fontWeight: "bold"
                  }
                }, d.filterUserAttributes(M || f.select || {}));
                var X = M.style;
                delete M.style;
                u = H(z, {
                  style: {
                    color: "#cccccc"
                  }
                }, d.filterUserAttributes(u || f.disabled || {}));
                var l = u.style;
                delete u.style;
              }

              J(D.element, k ? "mouseover" : "mouseenter", function () {
                3 !== m && D.setState(1);
              });
              J(D.element, k ? "mouseout" : "mouseleave", function () {
                3 !== m && D.setState(m);
              });

              D.setState = function (f) {
                1 !== f && (D.state = m = f);
                D.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][f || 0]);
                O || (D.attr([z, n, M, u][f || 0]), f = [Q, K, X, l][f || 0], b(f) && D.css(f));
              };

              O || D.attr(z).css(h({
                cursor: "default"
              }, Q));
              return D.on("touchstart", function (b) {
                return b.stopPropagation();
              }).on("click", function (b) {
                3 !== m && a.call(D, b);
              });
            };

            M.prototype.crispLine = function (b, f, h) {
              void 0 === h && (h = "round");
              var p = b[0],
                  a = b[1];
              e(p[1]) && p[1] === a[1] && (p[1] = a[1] = Math[h](p[1]) - f % 2 / 2);
              e(p[2]) && p[2] === a[2] && (p[2] = a[2] = Math[h](p[2]) + f % 2 / 2);
              return b;
            };

            M.prototype.path = function (f) {
              var e = this.styledMode ? {} : {
                fill: "none"
              };
              n(f) ? e.d = f : b(f) && h(e, f);
              return this.createElement("path").attr(e);
            };

            M.prototype.circle = function (f, e, h) {
              f = b(f) ? f : "undefined" === typeof f ? {} : {
                x: f,
                y: e,
                r: h
              };
              e = this.createElement("circle");

              e.xSetter = e.ySetter = function (b, f, e) {
                e.setAttribute("c" + f, b);
              };

              return e.attr(f);
            };

            M.prototype.arc = function (f, e, h, p, a, c) {
              b(f) ? (p = f, e = p.y, h = p.r, f = p.x) : p = {
                innerR: p,
                start: a,
                end: c
              };
              f = this.symbol("arc", f, e, h, h, p);
              f.r = h;
              return f;
            };

            M.prototype.rect = function (f, e, h, p, a, c) {
              a = b(f) ? f.r : a;
              var n = this.createElement("rect");
              f = b(f) ? f : "undefined" === typeof f ? {} : {
                x: f,
                y: e,
                width: Math.max(h, 0),
                height: Math.max(p, 0)
              };
              this.styledMode || ("undefined" !== typeof c && (f["stroke-width"] = c, f = n.crisp(f)), f.fill = "none");
              a && (f.r = a);

              n.rSetter = function (b, f, e) {
                n.r = b;
                y(e, {
                  rx: b,
                  ry: b
                });
              };

              n.rGetter = function () {
                return n.r || 0;
              };

              return n.attr(f);
            };

            M.prototype.setSize = function (b, f, e) {
              this.width = b;
              this.height = f;
              this.boxWrapper.animate({
                width: b,
                height: f
              }, {
                step: function step() {
                  this.attr({
                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                  });
                },
                duration: p(e, !0) ? void 0 : 0
              });
              this.alignElements();
            };

            M.prototype.g = function (b) {
              var f = this.createElement("g");
              return b ? f.attr({
                "class": "highcharts-" + b
              }) : f;
            };

            M.prototype.image = function (b, e, h, p, a, c) {
              var n = {
                preserveAspectRatio: "none"
              },
                  M = function M(b, f) {
                b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", f) : b.setAttribute("hc-svg-href", f);
              };

              f(e) && (n.x = e);
              f(h) && (n.y = h);
              f(p) && (n.width = p);
              f(a) && (n.height = a);
              var u = this.createElement("image").attr(n);

              e = function e(f) {
                M(u.element, b);
                c.call(u, f);
              };

              c ? (M(u.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), h = new L.Image(), J(h, "load", e), h.src = b, h.complete && e({})) : M(u.element, b);
              return u;
            };

            M.prototype.symbol = function (b, f, a, c, n, M) {
              var u = this,
                  r = /^url\((.*?)\)$/,
                  D = r.test(b),
                  H = !D && (this.symbols[b] ? b : "circle"),
                  m = H && this.symbols[H],
                  Q;

              if (m) {
                "number" === typeof f && (Q = m.call(this.symbols, Math.round(f || 0), Math.round(a || 0), c || 0, n || 0, M));
                var O = this.path(Q);
                u.styledMode || O.attr("fill", "none");
                h(O, {
                  symbolName: H || void 0,
                  x: f,
                  y: a,
                  width: c,
                  height: n
                });
                M && h(O, M);
              } else if (D) {
                var k = b.match(r)[1];
                var d = O = this.image(k);
                d.imgwidth = p(F[k] && F[k].width, M && M.width);
                d.imgheight = p(F[k] && F[k].height, M && M.height);

                var K = function K(b) {
                  return b.attr({
                    width: b.width,
                    height: b.height
                  });
                };

                ["width", "height"].forEach(function (b) {
                  d[b + "Setter"] = function (b, f) {
                    var h = this["img" + f];
                    this[f] = b;
                    e(h) && (M && "within" === M.backgroundSize && this.width && this.height && (h = Math.round(h * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(f, h), this.alignByTranslate || (b = ((this[f] || 0) - h) / 2, this.attr("width" === f ? {
                      translateX: b
                    } : {
                      translateY: b
                    })));
                  };
                });
                e(f) && d.attr({
                  x: f,
                  y: a
                });
                d.isImg = !0;
                e(d.imgwidth) && e(d.imgheight) ? K(d) : (d.attr({
                  width: 0,
                  height: 0
                }), z("img", {
                  onload: function onload() {
                    var b = q[u.chartIndex];
                    0 === this.width && (w(this, {
                      position: "absolute",
                      top: "-999em"
                    }), l.body.appendChild(this));
                    F[k] = {
                      width: this.width,
                      height: this.height
                    };
                    d.imgwidth = this.width;
                    d.imgheight = this.height;
                    d.element && K(d);
                    this.parentNode && this.parentNode.removeChild(this);
                    u.imgCount--;
                    if (!u.imgCount && b && !b.hasLoaded) b.onload();
                  },
                  src: k
                }), this.imgCount++);
              }

              return O;
            };

            M.prototype.clipRect = function (b, f, e, h) {
              var p = K() + "-",
                  a = this.createElement("clipPath").attr({
                id: p
              }).add(this.defs);
              b = this.rect(b, f, e, h, 0).add(a);
              b.id = p;
              b.clipPath = a;
              b.count = 0;
              return b;
            };

            M.prototype.text = function (b, f, h, p) {
              var a = {};
              if (p && (this.allowHTML || !this.forExport)) return this.html(b, f, h);
              a.x = Math.round(f || 0);
              h && (a.y = Math.round(h));
              e(b) && (a.text = b);
              b = this.createElement("text").attr(a);
              if (!p || this.forExport && !this.allowHTML) b.xSetter = function (b, f, e) {
                for (var h = e.getElementsByTagName("tspan"), p = e.getAttribute(f), a = 0, c; a < h.length; a++) {
                  c = h[a], c.getAttribute(f) === p && c.setAttribute(f, b);
                }

                e.setAttribute(f, b);
              };
              return b;
            };

            M.prototype.fontMetrics = function (b, f) {
              b = !this.styledMode && /px/.test(b) || !L.getComputedStyle ? b || f && f.style && f.style.fontSize || this.style && this.style.fontSize : f && x.prototype.getStyle.call(f, "font-size");
              b = /px/.test(b) ? u(b) : 12;
              f = 24 > b ? b + 3 : Math.round(1.2 * b);
              return {
                h: f,
                b: Math.round(.8 * f),
                f: b
              };
            };

            M.prototype.rotCorr = function (b, f, e) {
              var h = b;
              f && e && (h = Math.max(h * Math.cos(f * c), 4));
              return {
                x: -b / 3 * Math.sin(f * c),
                y: h
              };
            };

            M.prototype.pathToSegments = function (b) {
              for (var e = [], h = [], p = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
              }, a = 0; a < b.length; a++) {
                D(h[0]) && f(b[a]) && h.length === p[h[0].toUpperCase()] && b.splice(a, 0, h[0].replace("M", "L").replace("m", "l")), "string" === typeof b[a] && (h.length && e.push(h.slice(0)), h.length = 0), h.push(b[a]);
              }

              e.push(h.slice(0));
              return e;
            };

            M.prototype.label = function (b, f, e, h, p, a, c, n, M) {
              return new G(this, b, f, e, h, p, a, c, n, M);
            };

            M.prototype.alignElements = function () {
              this.alignedObjects.forEach(function (b) {
                return b.align();
              });
            };

            return M;
          }();

          h(B.prototype, {
            Element: x,
            SVG_NS: N,
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            symbols: I,
            draw: m
          });
          E.registerRendererType("svg", B, !0);
          "";
          return B;
        });
        P(g, "Core/Renderer/HTML/HTMLElement.js", [g["Core/Globals.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = this && this.__extends || function () {
            var _a2 = function a(c, m) {
              _a2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var m in c) {
                  c.hasOwnProperty(m) && (a[m] = c[m]);
                }
              };

              return _a2(c, m);
            };

            return function (c, m) {
              function k() {
                this.constructor = c;
              }

              _a2(c, m);

              c.prototype = null === m ? Object.create(m) : (k.prototype = m.prototype, new k());
            };
          }(),
              x = d.isFirefox,
              G = d.isMS,
              I = d.isWebKit,
              A = d.win,
              t = B.css,
              q = B.defined,
              c = B.extend,
              l = B.pick,
              a = B.pInt;

          return function (k) {
            function d() {
              return null !== k && k.apply(this, arguments) || this;
            }

            C(d, k);

            d.compose = function (a) {
              if (-1 === d.composedClasses.indexOf(a)) {
                d.composedClasses.push(a);
                var c = d.prototype,
                    m = a.prototype;
                m.getSpanCorrection = c.getSpanCorrection;
                m.htmlCss = c.htmlCss;
                m.htmlGetBBox = c.htmlGetBBox;
                m.htmlUpdateTransform = c.htmlUpdateTransform;
                m.setSpanRotation = c.setSpanRotation;
              }

              return a;
            };

            d.prototype.getSpanCorrection = function (a, c, k) {
              this.xCorr = -a * k;
              this.yCorr = -c;
            };

            d.prototype.htmlCss = function (a) {
              var m = "SPAN" === this.element.tagName && a && "width" in a,
                  k = l(m && a.width, void 0);

              if (m) {
                delete a.width;
                this.textWidth = k;
                var d = !0;
              }

              a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
              this.styles = c(this.styles, a);
              t(this.element, a);
              d && this.htmlUpdateTransform();
              return this;
            };

            d.prototype.htmlGetBBox = function () {
              var a = this.element;
              return {
                x: a.offsetLeft,
                y: a.offsetTop,
                width: a.offsetWidth,
                height: a.offsetHeight
              };
            };

            d.prototype.htmlUpdateTransform = function () {
              if (this.added) {
                var c = this.renderer,
                    k = this.element,
                    d = this.translateX || 0,
                    l = this.translateY || 0,
                    v = this.x || 0,
                    y = this.y || 0,
                    z = this.textAlign || "left",
                    w = {
                  left: 0,
                  center: .5,
                  right: 1
                }[z],
                    e = this.styles;
                e = e && e.whiteSpace;
                t(k, {
                  marginLeft: d,
                  marginTop: l
                });
                !c.styledMode && this.shadows && this.shadows.forEach(function (b) {
                  t(b, {
                    marginLeft: d + 1,
                    marginTop: l + 1
                  });
                });
                this.inverted && [].forEach.call(k.childNodes, function (b) {
                  c.invertChild(b, k);
                });

                if ("SPAN" === k.tagName) {
                  var r = this.rotation,
                      h = this.textWidth && a(this.textWidth),
                      n = [r, z, k.innerHTML, this.textWidth, this.textAlign].join(),
                      f = void 0;
                  f = !1;

                  if (h !== this.oldTextWidth) {
                    if (this.textPxLength) var b = this.textPxLength;else t(k, {
                      width: "",
                      whiteSpace: e || "nowrap"
                    }), b = k.offsetWidth;
                    (h > this.oldTextWidth || b > h) && (/[ \-]/.test(k.textContent || k.innerText) || "ellipsis" === k.style.textOverflow) && (t(k, {
                      width: b > h || r ? h + "px" : "auto",
                      display: "block",
                      whiteSpace: e || "normal"
                    }), this.oldTextWidth = h, f = !0);
                  }

                  this.hasBoxWidthChanged = f;
                  n !== this.cTT && (f = c.fontMetrics(k.style.fontSize, k).b, !q(r) || r === (this.oldRotation || 0) && z === this.oldAlign || this.setSpanRotation(r, w, f), this.getSpanCorrection(!q(r) && this.textPxLength || k.offsetWidth, f, w, r, z));
                  t(k, {
                    left: v + (this.xCorr || 0) + "px",
                    top: y + (this.yCorr || 0) + "px"
                  });
                  this.cTT = n;
                  this.oldRotation = r;
                  this.oldAlign = z;
                }
              } else this.alignOnAdd = !0;
            };

            d.prototype.setSpanRotation = function (a, c, k) {
              var m = {},
                  d = G && !/Edge/.test(A.navigator.userAgent) ? "-ms-transform" : I ? "-webkit-transform" : x ? "MozTransform" : A.opera ? "-o-transform" : void 0;
              d && (m[d] = m.transform = "rotate(" + a + "deg)", m[d + (x ? "Origin" : "-origin")] = m.transformOrigin = 100 * c + "% " + k + "px", t(this.element, m));
            };

            d.composedClasses = [];
            return d;
          }(g);
        });
        P(g, "Core/Renderer/HTML/HTMLRenderer.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Utilities.js"]], function (d, g, B, E) {
          var x = this && this.__extends || function () {
            var _d = function d(c, l) {
              _d = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var k in c) {
                  c.hasOwnProperty(k) && (a[k] = c[k]);
                }
              };

              return _d(c, l);
            };

            return function (c, l) {
              function a() {
                this.constructor = c;
              }

              _d(c, l);

              c.prototype = null === l ? Object.create(l) : (a.prototype = l.prototype, new a());
            };
          }(),
              C = E.attr,
              I = E.createElement,
              A = E.extend,
              t = E.pick;

          return function (q) {
            function c() {
              return null !== q && q.apply(this, arguments) || this;
            }

            x(c, q);

            c.compose = function (d) {
              -1 === c.composedClasses.indexOf(d) && (c.composedClasses.push(d), d.prototype.html = c.prototype.html);
              return d;
            };

            c.prototype.html = function (c, a, k) {
              var l = this.createElement("span"),
                  m = l.element,
                  q = l.renderer,
                  F = q.isSVG,
                  L = function L(a, c) {
                ["opacity", "visibility"].forEach(function (m) {
                  a[m + "Setter"] = function (w, e, r) {
                    var h = a.div ? a.div.style : c;
                    g.prototype[m + "Setter"].call(this, w, e, r);
                    h && (h[e] = w);
                  };
                });
                a.addedSetters = !0;
              };

              l.textSetter = function (a) {
                a !== this.textStr && (delete this.bBox, delete this.oldTextWidth, d.setElementHTML(this.element, t(a, "")), this.textStr = a, l.doTransform = !0);
              };

              F && L(l, l.element.style);

              l.xSetter = l.ySetter = l.alignSetter = l.rotationSetter = function (a, c) {
                "align" === c ? l.alignValue = l.textAlign = a : l[c] = a;
                l.doTransform = !0;
              };

              l.afterSetters = function () {
                this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
              };

              l.attr({
                text: c,
                x: Math.round(a),
                y: Math.round(k)
              }).css({
                position: "absolute"
              });
              q.styledMode || l.css({
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
              });
              m.style.whiteSpace = "nowrap";
              l.css = l.htmlCss;
              F && (l.add = function (a) {
                var c = q.box.parentNode,
                    z = [];

                if (this.parentGroup = a) {
                  var w = a.div;

                  if (!w) {
                    for (; a;) {
                      z.push(a), a = a.parentGroup;
                    }

                    z.reverse().forEach(function (e) {
                      function a(b, h) {
                        e[h] = b;
                        "translateX" === h ? f.left = b + "px" : f.top = b + "px";
                        e.doTransform = !0;
                      }

                      var h = C(e.element, "class"),
                          n = e.styles || {};
                      w = e.div = e.div || I("div", h ? {
                        className: h
                      } : void 0, {
                        position: "absolute",
                        left: (e.translateX || 0) + "px",
                        top: (e.translateY || 0) + "px",
                        display: e.display,
                        opacity: e.opacity,
                        cursor: n.cursor,
                        pointerEvents: n.pointerEvents,
                        visibility: e.visibility
                      }, w || c);
                      var f = w.style;
                      A(e, {
                        classSetter: function (b) {
                          return function (f) {
                            this.element.setAttribute("class", f);
                            b.className = f;
                          };
                        }(w),
                        on: function on() {
                          z[0].div && l.on.apply({
                            element: z[0].div,
                            onEvents: e.onEvents
                          }, arguments);
                          return e;
                        },
                        translateXSetter: a,
                        translateYSetter: a
                      });
                      e.addedSetters || L(e);
                    });
                  }
                } else w = c;

                w.appendChild(m);
                l.added = !0;
                l.alignOnAdd && l.htmlUpdateTransform();
                return l;
              });
              return l;
            };

            c.composedClasses = [];
            return c;
          }(B);
        });
        P(g, "Core/Axis/AxisDefaults.js", [], function () {
          var d;

          (function (d) {
            d.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: !1
                },
                second: {
                  main: "%H:%M:%S",
                  range: !1
                },
                minute: {
                  main: "%H:%M",
                  range: !1
                },
                hour: {
                  main: "%H:%M",
                  range: !1
                },
                day: {
                  main: "%e. %b"
                },
                week: {
                  main: "%e. %b"
                },
                month: {
                  main: "%b '%y"
                },
                year: {
                  main: "%Y"
                }
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: void 0,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                x: 0,
                zIndex: 7,
                style: {
                  color: "#666666",
                  cursor: "default",
                  fontSize: "11px"
                }
              },
              maxPadding: .01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minPadding: .01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                  color: "#666666"
                }
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: "#f2f2f2",
              minorGridLineWidth: 1,
              minorTickColor: "#999999",
              lineColor: "#ccd6eb",
              lineWidth: 1,
              gridLineColor: "#e6e6e6",
              gridLineWidth: void 0,
              tickColor: "#ccd6eb"
            };
            d.defaultYAxisOptions = {
              reversedStacks: !0,
              endOnTick: !0,
              maxPadding: .05,
              minPadding: .05,
              tickPixelInterval: 72,
              showLastLabel: !0,
              labels: {
                x: -8
              },
              startOnTick: !0,
              title: {
                rotation: 270,
                text: "Values"
              },
              stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function formatter() {
                  var d = this.axis.chart.numberFormatter;
                  return d(this.total, -1);
                },
                style: {
                  color: "#000000",
                  fontSize: "11px",
                  fontWeight: "bold",
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
            };
            d.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            d.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            d.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            d.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(d || (d = {}));

          return d;
        });
        P(g, "Core/Foundation.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.addEvent,
              B = d.isFunction,
              E = d.objectEach,
              x = d.removeEvent,
              G;

          (function (d) {
            d.registerEventOptions = function (d, t) {
              d.eventOptions = d.eventOptions || {};
              E(t.events, function (q, c) {
                d.eventOptions[c] !== q && (d.eventOptions[c] && (x(d, c, d.eventOptions[c]), delete d.eventOptions[c]), B(q) && (d.eventOptions[c] = q, g(d, c, q)));
              });
            };
          })(G || (G = {}));

          return G;
        });
        P(g, "Core/Axis/Tick.js", [g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = g.deg2rad,
              x = B.clamp,
              G = B.correctFloat,
              I = B.defined,
              A = B.destroyObjectProperties,
              t = B.extend,
              q = B.fireEvent,
              c = B.isNumber,
              l = B.merge,
              a = B.objectEach,
              k = B.pick;

          g = function () {
            function v(a, c, k, d, l) {
              this.isNewLabel = this.isNew = !0;
              this.axis = a;
              this.pos = c;
              this.type = k || "";
              this.parameters = l || {};
              this.tickmarkOffset = this.parameters.tickmarkOffset;
              this.options = this.parameters.options;
              q(this, "init");
              k || d || this.addLabel();
            }

            v.prototype.addLabel = function () {
              var a = this,
                  l = a.axis,
                  v = l.options,
                  g = l.chart,
                  J = l.categories,
                  y = l.logarithmic,
                  z = l.names,
                  w = a.pos,
                  e = k(a.options && a.options.labels, v.labels),
                  r = l.tickPositions,
                  h = w === r[0],
                  n = w === r[r.length - 1],
                  f = (!e.step || 1 === e.step) && 1 === l.tickInterval;
              r = r.info;
              var b = a.label,
                  D;
              J = this.parameters.category || (J ? k(J[w], z[w], w) : w);
              y && c(J) && (J = G(y.lin2log(J)));
              if (l.dateTime) if (r) {
                var H = g.time.resolveDTLFormat(v.dateTimeLabelFormats[!v.grid && r.higherRanks[w] || r.unitName]);
                var p = H.main;
              } else c(J) && (p = l.dateTime.getXDateFormat(J, v.dateTimeLabelFormats || {}));
              a.isFirst = h;
              a.isLast = n;
              var u = {
                axis: l,
                chart: g,
                dateTimeLabelFormat: p,
                isFirst: h,
                isLast: n,
                pos: w,
                tick: a,
                tickPositionInfo: r,
                value: J
              };
              q(this, "labelFormat", u);

              var K = function K(b) {
                return e.formatter ? e.formatter.call(b, b) : e.format ? (b.text = l.defaultLabelFormatter.call(b), d.format(e.format, b, g)) : l.defaultLabelFormatter.call(b, b);
              };

              v = K.call(u, u);
              var T = H && H.list;
              a.shortenLabel = T ? function () {
                for (D = 0; D < T.length; D++) {
                  if (t(u, {
                    dateTimeLabelFormat: T[D]
                  }), b.attr({
                    text: K.call(u, u)
                  }), b.getBBox().width < l.getSlotWidth(a) - 2 * e.padding) return;
                }

                b.attr({
                  text: ""
                });
              } : void 0;
              f && l._addedPlotLB && a.moveLabel(v, e);
              I(b) || a.movedLabel ? b && b.textStr !== v && !f && (!b.textWidth || e.style.width || b.styles.width || b.css({
                width: null
              }), b.attr({
                text: v
              }), b.textPxLength = b.getBBox().width) : (a.label = b = a.createLabel({
                x: 0,
                y: 0
              }, v, e), a.rotation = 0);
            };

            v.prototype.createLabel = function (a, c, k) {
              var d = this.axis,
                  m = d.chart;
              if (a = I(c) && k.enabled ? m.renderer.text(c, a.x, a.y, k.useHTML).add(d.labelGroup) : null) m.styledMode || a.css(l(k.style)), a.textPxLength = a.getBBox().width;
              return a;
            };

            v.prototype.destroy = function () {
              A(this, this.axis);
            };

            v.prototype.getPosition = function (a, c, k, d) {
              var m = this.axis,
                  l = m.chart,
                  z = d && l.oldChartHeight || l.chartHeight;
              a = {
                x: a ? G(m.translate(c + k, void 0, void 0, d) + m.transB) : m.left + m.offset + (m.opposite ? (d && l.oldChartWidth || l.chartWidth) - m.right - m.left : 0),
                y: a ? z - m.bottom + m.offset - (m.opposite ? m.height : 0) : G(z - m.translate(c + k, void 0, void 0, d) - m.transB)
              };
              a.y = x(a.y, -1E5, 1E5);
              q(this, "afterGetPosition", {
                pos: a
              });
              return a;
            };

            v.prototype.getLabelPosition = function (a, c, k, d, l, y, z, w) {
              var e = this.axis,
                  r = e.transA,
                  h = e.isLinked && e.linkedParent ? e.linkedParent.reversed : e.reversed,
                  n = e.staggerLines,
                  f = e.tickRotCorr || {
                x: 0,
                y: 0
              },
                  b = d || e.reserveSpaceDefault ? 0 : -e.labelOffset * ("center" === e.labelAlign ? .5 : 1),
                  D = {};
              k = 0 === e.side ? k.rotation ? -8 : -k.getBBox().height : 2 === e.side ? f.y + 8 : Math.cos(k.rotation * C) * (f.y - k.getBBox(!1, 0).height / 2);
              I(l.y) && (k = 0 === e.side && e.horiz ? l.y + k : l.y);
              a = a + l.x + b + f.x - (y && d ? y * r * (h ? -1 : 1) : 0);
              c = c + k - (y && !d ? y * r * (h ? 1 : -1) : 0);
              n && (d = z / (w || 1) % n, e.opposite && (d = n - d - 1), c += e.labelOffset / n * d);
              D.x = a;
              D.y = Math.round(c);
              q(this, "afterGetLabelPosition", {
                pos: D,
                tickmarkOffset: y,
                index: z
              });
              return D;
            };

            v.prototype.getLabelSize = function () {
              return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };

            v.prototype.getMarkPath = function (a, c, k, d, l, y) {
              return y.crispLine([["M", a, c], ["L", a + (l ? 0 : -k), c + (l ? k : 0)]], d);
            };

            v.prototype.handleOverflow = function (a) {
              var c = this.axis,
                  d = c.options.labels,
                  m = a.x,
                  l = c.chart.chartWidth,
                  y = c.chart.spacing,
                  z = k(c.labelLeft, Math.min(c.pos, y[3]));
              y = k(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, l - y[1]));
              var w = this.label,
                  e = this.rotation,
                  r = {
                left: 0,
                center: .5,
                right: 1
              }[c.labelAlign || w.attr("align")],
                  h = w.getBBox().width,
                  n = c.getSlotWidth(this),
                  f = {},
                  b = n,
                  D = 1,
                  H;
              if (e || "justify" !== d.overflow) 0 > e && m - r * h < z ? H = Math.round(m / Math.cos(e * C) - z) : 0 < e && m + r * h > y && (H = Math.round((l - m) / Math.cos(e * C)));else if (l = m + (1 - r) * h, m - r * h < z ? b = a.x + b * (1 - r) - z : l > y && (b = y - a.x + b * r, D = -1), b = Math.min(n, b), b < n && "center" === c.labelAlign && (a.x += D * (n - b - r * (n - Math.min(h, b)))), h > b || c.autoRotation && (w.styles || {}).width) H = b;
              H && (this.shortenLabel ? this.shortenLabel() : (f.width = Math.floor(H) + "px", (d.style || {}).textOverflow || (f.textOverflow = "ellipsis"), w.css(f)));
            };

            v.prototype.moveLabel = function (c, k) {
              var d = this,
                  m = d.label,
                  l = d.axis,
                  y = l.reversed,
                  z = !1;
              m && m.textStr === c ? (d.movedLabel = m, z = !0, delete d.label) : a(l.ticks, function (e) {
                z || e.isNew || e === d || !e.label || e.label.textStr !== c || (d.movedLabel = e.label, z = !0, e.labelPos = d.movedLabel.xy, delete e.label);
              });

              if (!z && (d.labelPos || m)) {
                var w = d.labelPos || m.xy;
                m = l.horiz ? y ? 0 : l.width + l.left : w.x;
                l = l.horiz ? w.y : y ? l.width + l.left : 0;
                d.movedLabel = d.createLabel({
                  x: m,
                  y: l
                }, c, k);
                d.movedLabel && d.movedLabel.attr({
                  opacity: 0
                });
              }
            };

            v.prototype.render = function (a, c, d) {
              var m = this.axis,
                  l = m.horiz,
                  y = this.pos,
                  z = k(this.tickmarkOffset, m.tickmarkOffset);
              y = this.getPosition(l, y, z, c);
              z = y.x;
              var w = y.y;
              m = l && z === m.pos + m.len || !l && w === m.pos ? -1 : 1;
              l = k(d, this.label && this.label.newOpacity, 1);
              d = k(d, 1);
              this.isActive = !0;
              this.renderGridLine(c, d, m);
              this.renderMark(y, d, m);
              this.renderLabel(y, c, l, a);
              this.isNew = !1;
              q(this, "afterRender");
            };

            v.prototype.renderGridLine = function (a, c, d) {
              var m = this.axis,
                  l = m.options,
                  y = {},
                  z = this.pos,
                  w = this.type,
                  e = k(this.tickmarkOffset, m.tickmarkOffset),
                  r = m.chart.renderer,
                  h = this.gridLine,
                  n = l.gridLineWidth,
                  f = l.gridLineColor,
                  b = l.gridLineDashStyle;
              "minor" === this.type && (n = l.minorGridLineWidth, f = l.minorGridLineColor, b = l.minorGridLineDashStyle);
              h || (m.chart.styledMode || (y.stroke = f, y["stroke-width"] = n || 0, y.dashstyle = b), w || (y.zIndex = 1), a && (c = 0), this.gridLine = h = r.path().attr(y).addClass("highcharts-" + (w ? w + "-" : "") + "grid-line").add(m.gridGroup));
              if (h && (d = m.getPlotLinePath({
                value: z + e,
                lineWidth: h.strokeWidth() * d,
                force: "pass",
                old: a
              }))) h[a || this.isNew ? "attr" : "animate"]({
                d: d,
                opacity: c
              });
            };

            v.prototype.renderMark = function (a, c, d) {
              var m = this.axis,
                  l = m.options,
                  y = m.chart.renderer,
                  z = this.type,
                  w = m.tickSize(z ? z + "Tick" : "tick"),
                  e = a.x;
              a = a.y;
              var r = k(l["minor" !== z ? "tickWidth" : "minorTickWidth"], !z && m.isXAxis ? 1 : 0);
              l = l["minor" !== z ? "tickColor" : "minorTickColor"];
              var h = this.mark,
                  n = !h;
              w && (m.opposite && (w[0] = -w[0]), h || (this.mark = h = y.path().addClass("highcharts-" + (z ? z + "-" : "") + "tick").add(m.axisGroup), m.chart.styledMode || h.attr({
                stroke: l,
                "stroke-width": r
              })), h[n ? "attr" : "animate"]({
                d: this.getMarkPath(e, a, w[0], h.strokeWidth() * d, m.horiz, y),
                opacity: c
              }));
            };

            v.prototype.renderLabel = function (a, d, l, q) {
              var m = this.axis,
                  y = m.horiz,
                  z = m.options,
                  w = this.label,
                  e = z.labels,
                  r = e.step;
              m = k(this.tickmarkOffset, m.tickmarkOffset);
              var h = a.x;
              a = a.y;
              var n = !0;
              w && c(h) && (w.xy = a = this.getLabelPosition(h, a, w, y, e, m, q, r), this.isFirst && !this.isLast && !z.showFirstLabel || this.isLast && !this.isFirst && !z.showLastLabel ? n = !1 : !y || e.step || e.rotation || d || 0 === l || this.handleOverflow(a), r && q % r && (n = !1), n && c(a.y) ? (a.opacity = l, w[this.isNewLabel ? "attr" : "animate"](a).show(!0), this.isNewLabel = !1) : (w.hide(), this.isNewLabel = !0));
            };

            v.prototype.replaceMovedLabel = function () {
              var a = this.label,
                  c = this.axis,
                  d = c.reversed;

              if (a && !this.isNew) {
                var k = c.horiz ? d ? c.left : c.width + c.left : a.xy.x;
                d = c.horiz ? a.xy.y : d ? c.width + c.top : c.top;
                a.animate({
                  x: k,
                  y: d,
                  opacity: 0
                }, void 0, a.destroy);
                delete this.label;
              }

              c.isDirty = !0;
              this.label = this.movedLabel;
              delete this.movedLabel;
            };

            return v;
          }();

          "";
          return g;
        });
        P(g, "Core/Axis/Axis.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/AxisDefaults.js"], g["Core/Color/Color.js"], g["Core/DefaultOptions.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Axis/Tick.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I, A) {
          var t = d.animObject,
              q = E.defaultOptions,
              c = x.registerEventOptions,
              l = G.deg2rad,
              a = A.arrayMax,
              k = A.arrayMin,
              v = A.clamp,
              m = A.correctFloat,
              N = A.defined,
              F = A.destroyObjectProperties,
              L = A.erase,
              J = A.error,
              y = A.extend,
              z = A.fireEvent,
              w = A.isArray,
              e = A.isNumber,
              r = A.isString,
              h = A.merge,
              n = A.normalizeTickInterval,
              f = A.objectEach,
              b = A.pick,
              D = A.relativeLength,
              H = A.removeEvent,
              p = A.splat,
              u = A.syncTimeout,
              K = function K(f, e) {
            return n(e, void 0, void 0, b(f.options.allowDecimals, .5 > e || void 0 !== f.tickAmount), !!f.tickAmount);
          };

          d = function () {
            function n(b, f) {
              this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
              this.init(b, f);
            }

            n.prototype.init = function (f, a) {
              var h = a.isX;
              this.chart = f;
              this.horiz = f.inverted && !this.isZAxis ? !h : h;
              this.isXAxis = h;
              this.coll = this.coll || (h ? "xAxis" : "yAxis");
              z(this, "init", {
                userOptions: a
              });
              this.opposite = b(a.opposite, this.opposite);
              this.side = b(a.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
              this.setOptions(a);
              var n = this.options,
                  u = n.labels,
                  M = n.type;
              this.userOptions = a;
              this.minPixelPadding = 0;
              this.reversed = b(n.reversed, this.reversed);
              this.visible = n.visible;
              this.zoomEnabled = n.zoomEnabled;
              this.hasNames = "category" === M || !0 === n.categories;
              this.categories = n.categories || (this.hasNames ? [] : void 0);
              this.names || (this.names = [], this.names.keys = {});
              this.plotLinesAndBandsGroups = {};
              this.positiveValuesOnly = !!this.logarithmic;
              this.isLinked = N(n.linkedTo);
              this.ticks = {};
              this.labelEdge = [];
              this.minorTicks = {};
              this.plotLinesAndBands = [];
              this.alternateBands = {};
              this.len = 0;
              this.minRange = this.userMinRange = n.minRange || n.maxZoom;
              this.range = n.range;
              this.offset = n.offset || 0;
              this.min = this.max = null;
              a = b(n.crosshair, p(f.options.tooltip.crosshairs)[h ? 0 : 1]);
              this.crosshair = !0 === a ? {} : a;
              -1 === f.axes.indexOf(this) && (h ? f.axes.splice(f.xAxis.length, 0, this) : f.axes.push(this), f[this.coll].push(this));
              this.series = this.series || [];
              f.inverted && !this.isZAxis && h && "undefined" === typeof this.reversed && (this.reversed = !0);
              this.labelRotation = e(u.rotation) ? u.rotation : void 0;
              c(this, n);
              z(this, "afterInit");
            };

            n.prototype.setOptions = function (b) {
              this.options = h(g.defaultXAxisOptions, "yAxis" === this.coll && g.defaultYAxisOptions, [g.defaultTopAxisOptions, g.defaultRightAxisOptions, g.defaultBottomAxisOptions, g.defaultLeftAxisOptions][this.side], h(q[this.coll], b));
              z(this, "afterSetOptions", {
                userOptions: b
              });
            };

            n.prototype.defaultLabelFormatter = function (b) {
              var f = this.axis;
              b = this.chart.numberFormatter;
              var a = e(this.value) ? this.value : NaN,
                  h = f.chart.time,
                  c = this.dateTimeLabelFormat,
                  p = q.lang,
                  n = p.numericSymbols;
              p = p.numericSymbolMagnitude || 1E3;
              var u = f.logarithmic ? Math.abs(a) : f.tickInterval,
                  M = n && n.length;
              if (f.categories) var r = "".concat(this.value);else if (c) r = h.dateFormat(c, a);else if (M && 1E3 <= u) for (; M-- && "undefined" === typeof r;) {
                f = Math.pow(p, M + 1), u >= f && 0 === 10 * a % f && null !== n[M] && 0 !== a && (r = b(a / f, -1) + n[M]);
              }
              "undefined" === typeof r && (r = 1E4 <= Math.abs(a) ? b(a, -1) : b(a, -1, void 0, ""));
              return r;
            };

            n.prototype.getSeriesExtremes = function () {
              var f = this,
                  a = f.chart,
                  h;
              z(this, "getSeriesExtremes", null, function () {
                f.hasVisibleSeries = !1;
                f.dataMin = f.dataMax = f.threshold = null;
                f.softThreshold = !f.isXAxis;
                f.stacking && f.stacking.buildStacks();
                f.series.forEach(function (c) {
                  if (c.visible || !a.options.chart.ignoreHiddenSeries) {
                    var p = c.options,
                        n = p.threshold;
                    f.hasVisibleSeries = !0;
                    f.positiveValuesOnly && 0 >= n && (n = null);

                    if (f.isXAxis) {
                      if (p = c.xData, p.length) {
                        p = f.logarithmic ? p.filter(f.validatePositiveValue) : p;
                        h = c.getXExtremes(p);
                        var u = h.min;
                        var r = h.max;
                        e(u) || u instanceof Date || (p = p.filter(e), h = c.getXExtremes(p), u = h.min, r = h.max);
                        p.length && (f.dataMin = Math.min(b(f.dataMin, u), u), f.dataMax = Math.max(b(f.dataMax, r), r));
                      }
                    } else if (c = c.applyExtremes(), e(c.dataMin) && (u = c.dataMin, f.dataMin = Math.min(b(f.dataMin, u), u)), e(c.dataMax) && (r = c.dataMax, f.dataMax = Math.max(b(f.dataMax, r), r)), N(n) && (f.threshold = n), !p.softThreshold || f.positiveValuesOnly) f.softThreshold = !1;
                  }
                });
              });
              z(this, "afterGetSeriesExtremes");
            };

            n.prototype.translate = function (b, f, a, h, c, p) {
              var n = this.linkedParent || this,
                  u = h && n.old ? n.old.min : n.min;
              if (!e(u)) return NaN;
              var r = n.minPixelPadding;
              c = (n.isOrdinal || n.brokenAxis && n.brokenAxis.hasBreaks || n.logarithmic && c) && n.lin2val;
              var M = 1,
                  w = 0;
              h = h && n.old ? n.old.transA : n.transA;
              h || (h = n.transA);
              a && (M *= -1, w = n.len);
              n.reversed && (M *= -1, w -= M * (n.sector || n.len));
              f ? (p = (b * M + w - r) / h + u, c && (p = n.lin2val(p))) : (c && (b = n.val2lin(b)), b = M * (b - u) * h, p = (n.isRadial ? b : m(b)) + w + M * r + (e(p) ? h * p : 0));
              return p;
            };

            n.prototype.toPixels = function (b, f) {
              return this.translate(b, !1, !this.horiz, void 0, !0) + (f ? 0 : this.pos);
            };

            n.prototype.toValue = function (b, f) {
              return this.translate(b - (f ? 0 : this.pos), !0, !this.horiz, void 0, !0);
            };

            n.prototype.getPlotLinePath = function (f) {
              function a(b, f, e) {
                if ("pass" !== k && b < f || b > e) k ? b = v(b, f, e) : q = !0;
                return b;
              }

              var h = this,
                  c = h.chart,
                  p = h.left,
                  n = h.top,
                  u = f.old,
                  r = f.value,
                  M = f.lineWidth,
                  w = u && c.oldChartHeight || c.chartHeight,
                  D = u && c.oldChartWidth || c.chartWidth,
                  d = h.transB,
                  H = f.translatedValue,
                  k = f.force,
                  l,
                  m,
                  K,
                  y,
                  q;
              f = {
                value: r,
                lineWidth: M,
                old: u,
                force: k,
                acrossPanes: f.acrossPanes,
                translatedValue: H
              };
              z(this, "getPlotLinePath", f, function (f) {
                H = b(H, h.translate(r, void 0, void 0, u));
                H = v(H, -1E5, 1E5);
                l = K = Math.round(H + d);
                m = y = Math.round(w - H - d);
                e(H) ? h.horiz ? (m = n, y = w - h.bottom, l = K = a(l, p, p + h.width)) : (l = p, K = D - h.right, m = y = a(m, n, n + h.height)) : (q = !0, k = !1);
                f.path = q && !k ? null : c.renderer.crispLine([["M", l, m], ["L", K, y]], M || 1);
              });
              return f.path;
            };

            n.prototype.getLinearTickPositions = function (b, f, e) {
              var a = m(Math.floor(f / b) * b);
              e = m(Math.ceil(e / b) * b);
              var h = [],
                  c;
              m(a + b) === a && (c = 20);
              if (this.single) return [f];

              for (f = a; f <= e;) {
                h.push(f);
                f = m(f + b, c);
                if (f === p) break;
                var p = f;
              }

              return h;
            };

            n.prototype.getMinorTickInterval = function () {
              var f = this.options;
              return !0 === f.minorTicks ? b(f.minorTickInterval, "auto") : !1 === f.minorTicks ? null : f.minorTickInterval;
            };

            n.prototype.getMinorTickPositions = function () {
              var b = this.options,
                  f = this.tickPositions,
                  e = this.minorTickInterval,
                  a = this.pointRangePadding || 0,
                  h = this.min - a;
              a = this.max + a;
              var c = a - h,
                  p = [];

              if (c && c / e < this.len / 3) {
                var n = this.logarithmic;
                if (n) this.paddedTicks.forEach(function (b, f, a) {
                  f && p.push.apply(p, n.getLogTickPositions(e, a[f - 1], a[f], !0));
                });else if (this.dateTime && "auto" === this.getMinorTickInterval()) p = p.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(e), h, a, b.startOfWeek));else for (b = h + (f[0] - h) % e; b <= a && b !== p[0]; b += e) {
                  p.push(b);
                }
              }

              0 !== p.length && this.trimTicks(p);
              return p;
            };

            n.prototype.adjustForMinRange = function () {
              var f = this.options,
                  e = this.logarithmic,
                  h = this.min,
                  c = this.max,
                  p = 0,
                  n,
                  u,
                  r,
                  w;
              this.isXAxis && "undefined" === typeof this.minRange && !e && (N(f.min) || N(f.max) || N(f.floor) || N(f.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {
                r = b.xData;
                w = b.xIncrement ? 1 : r.length - 1;
                if (1 < r.length) for (n = w; 0 < n; n--) {
                  if (u = r[n] - r[n - 1], !p || u < p) p = u;
                }
              }), this.minRange = Math.min(5 * p, this.dataMax - this.dataMin)));

              if (c - h < this.minRange) {
                var D = this.dataMax - this.dataMin >= this.minRange;
                var d = this.minRange;
                var H = (d - c + h) / 2;
                H = [h - H, b(f.min, h - H)];
                D && (H[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                h = a(H);
                c = [h + d, b(f.max, h + d)];
                D && (c[2] = e ? e.log2lin(this.dataMax) : this.dataMax);
                c = k(c);
                c - h < d && (H[0] = c - d, H[1] = b(f.min, c - d), h = a(H));
              }

              this.min = h;
              this.max = c;
            };

            n.prototype.getClosest = function () {
              var b;
              this.categories ? b = 1 : this.series.forEach(function (f) {
                var e = f.closestPointRange,
                    h = f.visible || !f.chart.options.chart.ignoreHiddenSeries;
                !f.noSharedTooltip && N(e) && h && (b = N(b) ? Math.min(b, e) : e);
              });
              return b;
            };

            n.prototype.nameToX = function (f) {
              var e = w(this.options.categories),
                  h = e ? this.categories : this.names,
                  a = f.options.x;
              f.series.requireSorting = !1;
              N(a) || (a = this.options.uniqueNames && h ? e ? h.indexOf(f.name) : b(h.keys[f.name], -1) : f.series.autoIncrement());

              if (-1 === a) {
                if (!e && h) var c = h.length;
              } else c = a;

              "undefined" !== typeof c && (this.names[c] = f.name, this.names.keys[f.name] = c);
              return c;
            };

            n.prototype.updateNames = function () {
              var b = this,
                  f = this.names;
              0 < f.length && (Object.keys(f.keys).forEach(function (b) {
                delete f.keys[b];
              }), f.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (f) {
                f.xIncrement = null;
                if (!f.points || f.isDirtyData) b.max = Math.max(b.max, f.xData.length - 1), f.processData(), f.generatePoints();
                f.data.forEach(function (e, h) {
                  if (e && e.options && "undefined" !== typeof e.name) {
                    var a = b.nameToX(e);
                    "undefined" !== typeof a && a !== e.x && (e.x = a, f.xData[h] = a);
                  }
                });
              }));
            };

            n.prototype.setAxisTranslation = function () {
              var f = this,
                  e = f.max - f.min,
                  h = f.linkedParent,
                  a = !!f.categories,
                  c = f.isXAxis,
                  p = f.axisPointRange || 0,
                  n = 0,
                  u = 0,
                  w = f.transA;

              if (c || a || p) {
                var D = f.getClosest();
                h ? (n = h.minPointOffset, u = h.pointRangePadding) : f.series.forEach(function (e) {
                  var h = a ? 1 : c ? b(e.options.pointRange, D, 0) : f.axisPointRange || 0,
                      w = e.options.pointPlacement;
                  p = Math.max(p, h);
                  if (!f.single || a) e = e.is("xrange") ? !c : c, n = Math.max(n, e && r(w) ? 0 : h / 2), u = Math.max(u, e && "on" === w ? 0 : h);
                });
                h = f.ordinal && f.ordinal.slope && D ? f.ordinal.slope / D : 1;
                f.minPointOffset = n *= h;
                f.pointRangePadding = u *= h;
                f.pointRange = Math.min(p, f.single && a ? 1 : e);
                c && (f.closestPointRange = D);
              }

              f.translationSlope = f.transA = w = f.staticScale || f.len / (e + u || 1);
              f.transB = f.horiz ? f.left : f.bottom;
              f.minPixelPadding = w * n;
              z(this, "afterSetAxisTranslation");
            };

            n.prototype.minFromRange = function () {
              return this.max - this.range;
            };

            n.prototype.setTickInterval = function (f) {
              var h = this.chart,
                  a = this.logarithmic,
                  c = this.options,
                  p = this.isXAxis,
                  n = this.isLinked,
                  u = c.tickPixelInterval,
                  r = this.categories,
                  w = this.softThreshold,
                  D = c.maxPadding,
                  d = c.minPadding,
                  H = e(c.tickInterval) && 0 <= c.tickInterval ? c.tickInterval : void 0,
                  k = e(this.threshold) ? this.threshold : null;
              this.dateTime || r || n || this.getTickAmount();
              var l = b(this.userMin, c.min);
              var M = b(this.userMax, c.max);

              if (n) {
                this.linkedParent = h[this.coll][c.linkedTo];
                var y = this.linkedParent.getExtremes();
                this.min = b(y.min, y.dataMin);
                this.max = b(y.max, y.dataMax);
                c.type !== this.linkedParent.options.type && J(11, 1, h);
              } else {
                if (w && N(k)) if (this.dataMin >= k) y = k, d = 0;else if (this.dataMax <= k) {
                  var q = k;
                  D = 0;
                }
                this.min = b(l, y, this.dataMin);
                this.max = b(M, q, this.dataMax);
              }

              a && (this.positiveValuesOnly && !f && 0 >= Math.min(this.min, b(this.dataMin, this.min)) && J(10, 1, h), this.min = m(a.log2lin(this.min), 16), this.max = m(a.log2lin(this.max), 16));
              this.range && N(this.max) && (this.userMin = this.min = l = Math.max(this.dataMin, this.minFromRange()), this.userMax = M = this.max, this.range = null);
              z(this, "foundExtremes");
              this.beforePadding && this.beforePadding();
              this.adjustForMinRange();
              !(r || this.axisPointRange || this.stacking && this.stacking.usePercentage || n) && N(this.min) && N(this.max) && (h = this.max - this.min) && (!N(l) && d && (this.min -= h * d), !N(M) && D && (this.max += h * D));
              e(this.userMin) || (e(c.softMin) && c.softMin < this.min && (this.min = l = c.softMin), e(c.floor) && (this.min = Math.max(this.min, c.floor)));
              e(this.userMax) || (e(c.softMax) && c.softMax > this.max && (this.max = M = c.softMax), e(c.ceiling) && (this.max = Math.min(this.max, c.ceiling)));
              w && N(this.dataMin) && (k = k || 0, !N(l) && this.min < k && this.dataMin >= k ? this.min = this.options.minRange ? Math.min(k, this.max - this.minRange) : k : !N(M) && this.max > k && this.dataMax <= k && (this.max = this.options.minRange ? Math.max(k, this.min + this.minRange) : k));
              e(this.min) && e(this.max) && !this.chart.polar && this.min > this.max && (N(this.options.min) ? this.max = this.min : N(this.options.max) && (this.min = this.max));
              this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : n && this.linkedParent && !H && u === this.linkedParent.options.tickPixelInterval ? H = this.linkedParent.tickInterval : b(H, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, r ? 1 : (this.max - this.min) * u / Math.max(this.len, u));

              if (p && !f) {
                var v = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
                this.series.forEach(function (b) {
                  b.forceCrop = b.forceCropping && b.forceCropping();
                  b.processData(v);
                });
                z(this, "postProcessData", {
                  hasExtemesChanged: v
                });
              }

              this.setAxisTranslation();
              z(this, "initialAxisTranslation");
              this.pointRange && !H && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
              f = b(c.minTickInterval, this.dateTime && !this.series.some(function (b) {
                return b.noSharedTooltip;
              }) ? this.closestPointRange : 0);
              !H && this.tickInterval < f && (this.tickInterval = f);
              this.dateTime || this.logarithmic || H || (this.tickInterval = K(this, this.tickInterval));
              this.tickAmount || (this.tickInterval = this.unsquish());
              this.setTickPositions();
            };

            n.prototype.setTickPositions = function () {
              var b = this.options,
                  f = b.tickPositions,
                  e = this.getMinorTickInterval(),
                  h = this.hasVerticalPanning(),
                  a = "colorAxis" === this.coll,
                  c = (a || !h) && b.startOnTick;
              h = (a || !h) && b.endOnTick;
              a = b.tickPositioner;
              this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
              this.minorTickInterval = "auto" === e && this.tickInterval ? this.tickInterval / 5 : e;
              this.single = this.min === this.max && N(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
              this.tickPositions = e = f && f.slice();

              if (!e) {
                if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {
                  if (this.dateTime) e = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) e = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (var p = b = this.tickInterval; p <= 2 * b;) {
                    if (e = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && e.length > this.tickAmount) this.tickInterval = K(this, p *= 1.1);else break;
                  }
                } else e = [this.min, this.max], J(19, !1, this.chart);
                e.length > this.len && (e = [e[0], e.pop()], e[0] === e[1] && (e.length = 1));
                this.tickPositions = e;
                a && (a = a.apply(this, [this.min, this.max])) && (this.tickPositions = e = a);
              }

              this.paddedTicks = e.slice(0);
              this.trimTicks(e, c, h);
              this.isLinked || (this.single && 2 > e.length && !this.categories && !this.series.some(function (b) {
                return b.is("heatmap") && "between" === b.options.pointPlacement;
              }) && (this.min -= .5, this.max += .5), f || a || this.adjustTickAmount());
              z(this, "afterSetTickPositions");
            };

            n.prototype.trimTicks = function (b, f, e) {
              var h = b[0],
                  a = b[b.length - 1],
                  c = !this.isOrdinal && this.minPointOffset || 0;
              z(this, "trimTicks");

              if (!this.isLinked) {
                if (f && -Infinity !== h) this.min = h;else for (; this.min - c > b[0];) {
                  b.shift();
                }
                if (e) this.max = a;else for (; this.max + c < b[b.length - 1];) {
                  b.pop();
                }
                0 === b.length && N(h) && !this.options.tickPositions && b.push((a + h) / 2);
              }
            };

            n.prototype.alignToOthers = function () {
              var b = this,
                  f = [this],
                  h = b.options,
                  a = "yAxis" === this.coll && this.chart.options.chart.alignThresholds,
                  c = [],
                  p;
              b.thresholdAlignment = void 0;

              if ((!1 !== this.chart.options.chart.alignTicks && h.alignTicks || a) && !1 !== h.startOnTick && !1 !== h.endOnTick && !b.logarithmic) {
                var n = function n(b) {
                  var f = b.options;
                  return [b.horiz ? f.left : f.top, f.width, f.height, f.pane].join();
                },
                    u = n(this);

                this.chart[this.coll].forEach(function (e) {
                  var h = e.series;
                  h.length && h.some(function (b) {
                    return b.visible;
                  }) && e !== b && n(e) === u && (p = !0, f.push(e));
                });
              }

              if (p && a) {
                f.forEach(function (f) {
                  f = f.getThresholdAlignment(b);
                  e(f) && c.push(f);
                });
                var r = 1 < c.length ? c.reduce(function (b, f) {
                  return b + f;
                }, 0) / c.length : void 0;
                f.forEach(function (b) {
                  b.thresholdAlignment = r;
                });
              }

              return p;
            };

            n.prototype.getThresholdAlignment = function (b) {
              (!e(this.dataMin) || this !== b && this.series.some(function (b) {
                return b.isDirty || b.isDirtyData;
              })) && this.getSeriesExtremes();
              if (e(this.threshold)) return b = v((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (b = 1 - b), b;
            };

            n.prototype.getTickAmount = function () {
              var b = this.options,
                  f = b.tickPixelInterval,
                  e = b.tickAmount;
              !N(b.tickInterval) && !e && this.len < f && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (e = 2);
              !e && this.alignToOthers() && (e = Math.ceil(this.len / f) + 1);
              4 > e && (this.finalTickAmt = e, e = 5);
              this.tickAmount = e;
            };

            n.prototype.adjustTickAmount = function () {
              var f = this,
                  h = f.finalTickAmt,
                  a = f.max,
                  c = f.min,
                  p = f.options,
                  n = f.tickPositions,
                  u = f.tickAmount,
                  r = f.thresholdAlignment,
                  w = n && n.length,
                  D = b(f.threshold, f.softThreshold ? 0 : null);
              var H = f.tickInterval;

              if (e(r)) {
                var d = .5 > r ? Math.ceil(r * (u - 1)) : Math.floor(r * (u - 1));
                p.reversed && (d = u - 1 - d);
              }

              if (f.hasData() && e(c) && e(a)) {
                r = function r() {
                  f.transA *= (w - 1) / (u - 1);
                  f.min = p.startOnTick ? n[0] : Math.min(c, n[0]);
                  f.max = p.endOnTick ? n[n.length - 1] : Math.max(a, n[n.length - 1]);
                };

                if (e(d) && e(f.threshold)) {
                  for (; n[d] !== D || n.length !== u || n[0] > c || n[n.length - 1] < a;) {
                    n.length = 0;

                    for (n.push(f.threshold); n.length < u;) {
                      void 0 === n[d] || n[d] > f.threshold ? n.unshift(m(n[0] - H)) : n.push(m(n[n.length - 1] + H));
                    }

                    if (H > 8 * f.tickInterval) break;
                    H *= 2;
                  }

                  r();
                } else if (w < u) {
                  for (; n.length < u;) {
                    n.length % 2 || c === D ? n.push(m(n[n.length - 1] + H)) : n.unshift(m(n[0] - H));
                  }

                  r();
                }

                if (N(h)) {
                  for (H = D = n.length; H--;) {
                    (3 === h && 1 === H % 2 || 2 >= h && 0 < H && H < D - 1) && n.splice(H, 1);
                  }

                  f.finalTickAmt = void 0;
                }
              }
            };

            n.prototype.setScale = function () {
              var b = !1,
                  f = !1;
              this.series.forEach(function (e) {
                b = b || e.isDirtyData || e.isDirty;
                f = f || e.xAxis && e.xAxis.isDirty || !1;
              });
              this.setAxisSize();
              var e = this.len !== (this.old && this.old.len);
              e || b || f || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = e || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
              b && this.panningState && (this.panningState.isDirty = !0);
              z(this, "afterSetScale");
            };

            n.prototype.setExtremes = function (f, e, h, a, c) {
              var n = this,
                  p = n.chart;
              h = b(h, !0);
              n.series.forEach(function (b) {
                delete b.kdTree;
              });
              c = y(c, {
                min: f,
                max: e
              });
              z(n, "setExtremes", c, function () {
                n.userMin = f;
                n.userMax = e;
                n.eventArgs = c;
                h && p.redraw(a);
              });
            };

            n.prototype.zoom = function (f, e) {
              var h = this,
                  a = this.dataMin,
                  c = this.dataMax,
                  n = this.options,
                  p = Math.min(a, b(n.min, a)),
                  u = Math.max(c, b(n.max, c));
              f = {
                newMin: f,
                newMax: e
              };
              z(this, "zoom", f, function (b) {
                var f = b.newMin,
                    e = b.newMax;
                if (f !== h.min || e !== h.max) h.allowZoomOutside || (N(a) && (f < p && (f = p), f > u && (f = u)), N(c) && (e < p && (e = p), e > u && (e = u))), h.displayBtn = "undefined" !== typeof f || "undefined" !== typeof e, h.setExtremes(f, e, !1, void 0, {
                  trigger: "zoom"
                });
                b.zoomed = !0;
              });
              return f.zoomed;
            };

            n.prototype.setAxisSize = function () {
              var f = this.chart,
                  e = this.options,
                  h = e.offsets || [0, 0, 0, 0],
                  a = this.horiz,
                  c = this.width = Math.round(D(b(e.width, f.plotWidth - h[3] + h[1]), f.plotWidth)),
                  n = this.height = Math.round(D(b(e.height, f.plotHeight - h[0] + h[2]), f.plotHeight)),
                  p = this.top = Math.round(D(b(e.top, f.plotTop + h[0]), f.plotHeight, f.plotTop));
              e = this.left = Math.round(D(b(e.left, f.plotLeft + h[3]), f.plotWidth, f.plotLeft));
              this.bottom = f.chartHeight - n - p;
              this.right = f.chartWidth - c - e;
              this.len = Math.max(a ? c : n, 0);
              this.pos = a ? e : p;
            };

            n.prototype.getExtremes = function () {
              var b = this.logarithmic;
              return {
                min: b ? m(b.lin2log(this.min)) : this.min,
                max: b ? m(b.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
              };
            };

            n.prototype.getThreshold = function (b) {
              var f = this.logarithmic,
                  e = f ? f.lin2log(this.min) : this.min;
              f = f ? f.lin2log(this.max) : this.max;
              null === b || -Infinity === b ? b = e : Infinity === b ? b = f : e > b ? b = e : f < b && (b = f);
              return this.translate(b, 0, 1, 0, 1);
            };

            n.prototype.autoLabelAlign = function (f) {
              var e = (b(f, 0) - 90 * this.side + 720) % 360;
              f = {
                align: "center"
              };
              z(this, "autoLabelAlign", f, function (b) {
                15 < e && 165 > e ? b.align = "right" : 195 < e && 345 > e && (b.align = "left");
              });
              return f.align;
            };

            n.prototype.tickSize = function (f) {
              var e = this.options,
                  h = b(e["tick" === f ? "tickWidth" : "minorTickWidth"], "tick" === f && this.isXAxis && !this.categories ? 1 : 0),
                  a = e["tick" === f ? "tickLength" : "minorTickLength"];

              if (h && a) {
                "inside" === e[f + "Position"] && (a = -a);
                var c = [a, h];
              }

              f = {
                tickSize: c
              };
              z(this, "afterTickSize", f);
              return f.tickSize;
            };

            n.prototype.labelMetrics = function () {
              var b = this.tickPositions && this.tickPositions[0] || 0;
              return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
            };

            n.prototype.unsquish = function () {
              var f = this.options.labels,
                  h = this.horiz,
                  a = this.tickInterval,
                  c = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a),
                  n = f.rotation,
                  p = this.labelMetrics(),
                  u = Math.max(this.max - this.min, 0),
                  r = function r(b) {
                var f = b / (c || 1);
                f = 1 < f ? Math.ceil(f) : 1;
                f * a > u && Infinity !== b && Infinity !== c && u && (f = Math.ceil(u / a));
                return m(f * a);
              },
                  w = a,
                  H,
                  D,
                  d = Number.MAX_VALUE;

              if (h) {
                if (!f.staggerLines && !f.step) if (e(n)) var k = [n];else c < f.autoRotationLimit && (k = f.autoRotation);
                k && k.forEach(function (b) {
                  if (b === n || b && -90 <= b && 90 >= b) {
                    D = r(Math.abs(p.h / Math.sin(l * b)));
                    var f = D + Math.abs(b / 360);
                    f < d && (d = f, H = b, w = D);
                  }
                });
              } else f.step || (w = r(p.h));

              this.autoRotation = k;
              this.labelRotation = b(H, e(n) ? n : 0);
              return w;
            };

            n.prototype.getSlotWidth = function (b) {
              var f = this.chart,
                  h = this.horiz,
                  a = this.options.labels,
                  c = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                  n = f.margin[3];
              if (b && e(b.slotWidth)) return b.slotWidth;
              if (h && 2 > a.step) return a.rotation ? 0 : (this.staggerLines || 1) * this.len / c;

              if (!h) {
                b = a.style.width;
                if (void 0 !== b) return parseInt(String(b), 10);
                if (n) return n - f.spacing[3];
              }

              return .33 * f.chartWidth;
            };

            n.prototype.renderUnsquish = function () {
              var b = this.chart,
                  f = b.renderer,
                  e = this.tickPositions,
                  h = this.ticks,
                  a = this.options.labels,
                  c = a.style,
                  n = this.horiz,
                  p = this.getSlotWidth(),
                  u = Math.max(1, Math.round(p - 2 * a.padding)),
                  w = {},
                  H = this.labelMetrics(),
                  D = c.textOverflow,
                  d = 0;
              r(a.rotation) || (w.rotation = a.rotation || 0);
              e.forEach(function (b) {
                b = h[b];
                b.movedLabel && b.replaceMovedLabel();
                b && b.label && b.label.textPxLength > d && (d = b.label.textPxLength);
              });
              this.maxLabelLength = d;
              if (this.autoRotation) d > u && d > H.h ? w.rotation = this.labelRotation : this.labelRotation = 0;else if (p) {
                var k = u;

                if (!D) {
                  var l = "clip";

                  for (u = e.length; !n && u--;) {
                    var m = e[u];
                    if (m = h[m].label) m.styles && "ellipsis" === m.styles.textOverflow ? m.css({
                      textOverflow: "clip"
                    }) : m.textPxLength > p && m.css({
                      width: p + "px"
                    }), m.getBBox().height > this.len / e.length - (H.h - H.f) && (m.specificTextOverflow = "ellipsis");
                  }
                }
              }
              w.rotation && (k = d > .5 * b.chartHeight ? .33 * b.chartHeight : d, D || (l = "ellipsis"));
              if (this.labelAlign = a.align || this.autoLabelAlign(this.labelRotation)) w.align = this.labelAlign;
              e.forEach(function (b) {
                var f = (b = h[b]) && b.label,
                    e = c.width,
                    a = {};
                f && (f.attr(w), b.shortenLabel ? b.shortenLabel() : k && !e && "nowrap" !== c.whiteSpace && (k < f.textPxLength || "SPAN" === f.element.tagName) ? (a.width = k + "px", D || (a.textOverflow = f.specificTextOverflow || l), f.css(a)) : f.styles && f.styles.width && !a.width && !e && f.css({
                  width: null
                }), delete f.specificTextOverflow, b.rotation = w.rotation);
              }, this);
              this.tickRotCorr = f.rotCorr(H.b, this.labelRotation || 0, 0 !== this.side);
            };

            n.prototype.hasData = function () {
              return this.series.some(function (b) {
                return b.hasData();
              }) || this.options.showEmpty && N(this.min) && N(this.max);
            };

            n.prototype.addTitle = function (b) {
              var f = this.chart.renderer,
                  e = this.horiz,
                  a = this.opposite,
                  c = this.options.title,
                  n = this.chart.styledMode,
                  p;
              this.axisTitle || ((p = c.textAlign) || (p = (e ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: a ? "right" : "left",
                middle: "center",
                high: a ? "left" : "right"
              })[c.align]), this.axisTitle = f.text(c.text || "", 0, 0, c.useHTML).attr({
                zIndex: 7,
                rotation: c.rotation,
                align: p
              }).addClass("highcharts-axis-title"), n || this.axisTitle.css(h(c.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
              n || c.style.width || this.isRadial || this.axisTitle.css({
                width: this.len + "px"
              });
              this.axisTitle[b ? "show" : "hide"](b);
            };

            n.prototype.generateTick = function (b) {
              var f = this.ticks;
              f[b] ? f[b].addLabel() : f[b] = new I(this, b);
            };

            n.prototype.getOffset = function () {
              var e = this,
                  h = this,
                  a = h.chart,
                  c = h.horiz,
                  n = h.options,
                  p = h.side,
                  u = h.ticks,
                  r = h.tickPositions,
                  w = h.coll,
                  H = h.axisParent,
                  D = a.renderer,
                  d = a.inverted && !h.isZAxis ? [1, 0, 3, 2][p] : p,
                  k = h.hasData(),
                  l = n.title,
                  m = n.labels,
                  K = a.axisOffset;
              a = a.clipOffset;
              var y = [-1, 1, 1, -1][p],
                  q = n.className,
                  v,
                  g = 0,
                  t = 0,
                  F = 0;
              h.showAxis = v = k || n.showEmpty;
              h.staggerLines = h.horiz && m.staggerLines || void 0;

              if (!h.axisGroup) {
                var L = function L(b, f, h) {
                  return D.g(b).attr({
                    zIndex: h
                  }).addClass("highcharts-".concat(w.toLowerCase()).concat(f, " ") + (e.isRadial ? "highcharts-radial-axis".concat(f, " ") : "") + (q || "")).add(H);
                };

                h.gridGroup = L("grid", "-grid", n.gridZIndex);
                h.axisGroup = L("axis", "", n.zIndex);
                h.labelGroup = L("axis-labels", "-labels", m.zIndex);
              }

              k || h.isLinked ? (r.forEach(function (b) {
                h.generateTick(b);
              }), h.renderUnsquish(), h.reserveSpaceDefault = 0 === p || 2 === p || {
                1: "left",
                3: "right"
              }[p] === h.labelAlign, b(m.reserveSpace, "center" === h.labelAlign ? !0 : null, h.reserveSpaceDefault) && r.forEach(function (b) {
                F = Math.max(u[b].getLabelSize(), F);
              }), h.staggerLines && (F *= h.staggerLines), h.labelOffset = F * (h.opposite ? -1 : 1)) : f(u, function (b, f) {
                b.destroy();
                delete u[f];
              });

              if (l && l.text && !1 !== l.enabled && (h.addTitle(v), v && !1 !== l.reserveSpace)) {
                h.titleOffset = g = h.axisTitle.getBBox()[c ? "height" : "width"];
                var J = l.offset;
                t = N(J) ? 0 : b(l.margin, c ? 5 : 10);
              }

              h.renderLine();
              h.offset = y * b(n.offset, K[p] ? K[p] + (n.margin || 0) : 0);
              h.tickRotCorr = h.tickRotCorr || {
                x: 0,
                y: 0
              };
              l = 0 === p ? -h.labelMetrics().h : 2 === p ? h.tickRotCorr.y : 0;
              k = Math.abs(F) + t;
              F && (k = k - l + y * (c ? b(m.y, h.tickRotCorr.y + 8 * y) : m.x));
              h.axisTitleMargin = b(J, k);
              h.getMaxLabelDimensions && (h.maxLabelDimensions = h.getMaxLabelDimensions(u, r));
              "colorAxis" !== w && (c = this.tickSize("tick"), K[p] = Math.max(K[p], (h.axisTitleMargin || 0) + g + y * h.offset, k, r && r.length && c ? c[0] + y * h.offset : 0), n = !h.axisLine || n.offset ? 0 : 2 * Math.floor(h.axisLine.strokeWidth() / 2), a[d] = Math.max(a[d], n));
              z(this, "afterGetOffset");
            };

            n.prototype.getLinePath = function (b) {
              var f = this.chart,
                  e = this.opposite,
                  h = this.offset,
                  a = this.horiz,
                  c = this.left + (e ? this.width : 0) + h;
              h = f.chartHeight - this.bottom - (e ? this.height : 0) + h;
              e && (b *= -1);
              return f.renderer.crispLine([["M", a ? this.left : c, a ? h : this.top], ["L", a ? f.chartWidth - this.right : c, a ? h : f.chartHeight - this.bottom]], b);
            };

            n.prototype.renderLine = function () {
              this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              }));
            };

            n.prototype.getTitlePosition = function () {
              var b = this.horiz,
                  f = this.left,
                  e = this.top,
                  h = this.len,
                  a = this.options.title,
                  c = b ? f : e,
                  n = this.opposite,
                  p = this.offset,
                  u = a.x,
                  r = a.y,
                  w = this.axisTitle,
                  H = this.chart.renderer.fontMetrics(a.style.fontSize, w);
              w = w ? Math.max(w.getBBox(!1, 0).height - H.h - 1, 0) : 0;
              h = {
                low: c + (b ? 0 : h),
                middle: c + h / 2,
                high: c + (b ? h : 0)
              }[a.align];
              f = (b ? e + this.height : f) + (b ? 1 : -1) * (n ? -1 : 1) * (this.axisTitleMargin || 0) + [-w, w, H.f, -w][this.side];
              b = {
                x: b ? h + u : f + (n ? this.width : 0) + p + u,
                y: b ? f + r - (n ? this.height : 0) + p : h + r
              };
              z(this, "afterGetTitlePosition", {
                titlePosition: b
              });
              return b;
            };

            n.prototype.renderMinorTick = function (b, f) {
              var e = this.minorTicks;
              e[b] || (e[b] = new I(this, b, "minor"));
              f && e[b].isNew && e[b].render(null, !0);
              e[b].render(null, !1, 1);
            };

            n.prototype.renderTick = function (b, f, e) {
              var h = this.ticks;
              if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) h[b] || (h[b] = new I(this, b)), e && h[b].isNew && h[b].render(f, !0, -1), h[b].render(f);
            };

            n.prototype.render = function () {
              var b = this,
                  h = b.chart,
                  a = b.logarithmic,
                  c = b.options,
                  n = b.isLinked,
                  p = b.tickPositions,
                  r = b.axisTitle,
                  w = b.ticks,
                  H = b.minorTicks,
                  D = b.alternateBands,
                  d = c.stackLabels,
                  k = c.alternateGridColor,
                  l = b.tickmarkOffset,
                  m = b.axisLine,
                  K = b.showAxis,
                  y = t(h.renderer.globalAnimation),
                  q,
                  v;
              b.labelEdge.length = 0;
              b.overlap = !1;
              [w, H, D].forEach(function (b) {
                f(b, function (b) {
                  b.isActive = !1;
                });
              });

              if (b.hasData() || n) {
                var g = b.chart.hasRendered && b.old && e(b.old.min);
                b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (f) {
                  b.renderMinorTick(f, g);
                });
                p.length && (p.forEach(function (f, e) {
                  b.renderTick(f, e, g);
                }), l && (0 === b.min || b.single) && (w[-1] || (w[-1] = new I(b, -1, null, !0)), w[-1].render(-1)));
                k && p.forEach(function (f, e) {
                  v = "undefined" !== typeof p[e + 1] ? p[e + 1] + l : b.max - l;
                  0 === e % 2 && f < b.max && v <= b.max + (h.polar ? -l : l) && (D[f] || (D[f] = new G.PlotLineOrBand(b)), q = f + l, D[f].options = {
                    from: a ? a.lin2log(q) : q,
                    to: a ? a.lin2log(v) : v,
                    color: k,
                    className: "highcharts-alternate-grid"
                  }, D[f].render(), D[f].isActive = !0);
                });
                b._addedPlotLB || (b._addedPlotLB = !0, (c.plotLines || []).concat(c.plotBands || []).forEach(function (f) {
                  b.addPlotBandOrLine(f);
                }));
              }

              [w, H, D].forEach(function (b) {
                var e = [],
                    a = y.duration;
                f(b, function (b, f) {
                  b.isActive || (b.render(f, !1, 0), b.isActive = !1, e.push(f));
                });
                u(function () {
                  for (var f = e.length; f--;) {
                    b[e[f]] && !b[e[f]].isActive && (b[e[f]].destroy(), delete b[e[f]]);
                  }
                }, b !== D && h.hasRendered && a ? a : 0);
              });
              m && (m[m.isPlaced ? "animate" : "attr"]({
                d: this.getLinePath(m.strokeWidth())
              }), m.isPlaced = !0, m[K ? "show" : "hide"](K));
              r && K && (c = b.getTitlePosition(), r[r.isNew ? "attr" : "animate"](c), r.isNew = !1);
              d && d.enabled && b.stacking && b.stacking.renderStackTotals();
              b.old = {
                len: b.len,
                max: b.max,
                min: b.min,
                transA: b.transA,
                userMax: b.userMax,
                userMin: b.userMin
              };
              b.isDirty = !1;
              z(this, "afterRender");
            };

            n.prototype.redraw = function () {
              this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
                b.render();
              }));
              this.series.forEach(function (b) {
                b.isDirty = !0;
              });
            };

            n.prototype.getKeepProps = function () {
              return this.keepProps || n.keepProps;
            };

            n.prototype.destroy = function (b) {
              var e = this,
                  h = e.plotLinesAndBands,
                  a = this.eventOptions;
              z(this, "destroy", {
                keepEvents: b
              });
              b || H(e);
              [e.ticks, e.minorTicks, e.alternateBands].forEach(function (b) {
                F(b);
              });
              if (h) for (b = h.length; b--;) {
                h[b].destroy();
              }
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
                e[b] && (e[b] = e[b].destroy());
              });

              for (var c in e.plotLinesAndBandsGroups) {
                e.plotLinesAndBandsGroups[c] = e.plotLinesAndBandsGroups[c].destroy();
              }

              f(e, function (b, f) {
                -1 === e.getKeepProps().indexOf(f) && delete e[f];
              });
              this.eventOptions = a;
            };

            n.prototype.drawCrosshair = function (f, e) {
              var h = this.crosshair,
                  a = b(h && h.snap, !0),
                  c = this.chart,
                  n,
                  p = this.cross;
              z(this, "drawCrosshair", {
                e: f,
                point: e
              });
              f || (f = this.cross && this.cross.e);

              if (h && !1 !== (N(e) || !a)) {
                a ? N(e) && (n = b("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : n = f && (this.horiz ? f.chartX - this.pos : this.len - f.chartY + this.pos);

                if (N(n)) {
                  var u = {
                    value: e && (this.isXAxis ? e.x : b(e.stackY, e.y)),
                    translatedValue: n
                  };
                  c.polar && y(u, {
                    isCrosshair: !0,
                    chartX: f && f.chartX,
                    chartY: f && f.chartY,
                    point: e
                  });
                  u = this.getPlotLinePath(u) || null;
                }

                if (!N(u)) {
                  this.hideCrosshair();
                  return;
                }

                a = this.categories && !this.isRadial;
                p || (this.cross = p = c.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a ? "category " : "thin ") + (h.className || "")).attr({
                  zIndex: b(h.zIndex, 2)
                }).add(), c.styledMode || (p.attr({
                  stroke: h.color || (a ? B.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                  "stroke-width": b(h.width, 1)
                }).css({
                  "pointer-events": "none"
                }), h.dashStyle && p.attr({
                  dashstyle: h.dashStyle
                })));
                p.show().attr({
                  d: u
                });
                a && !h.width && p.attr({
                  "stroke-width": this.transA
                });
                this.cross.e = f;
              } else this.hideCrosshair();

              z(this, "afterDrawCrosshair", {
                e: f,
                point: e
              });
            };

            n.prototype.hideCrosshair = function () {
              this.cross && this.cross.hide();
              z(this, "afterHideCrosshair");
            };

            n.prototype.hasVerticalPanning = function () {
              var b = this.chart.options.chart.panning;
              return !!(b && b.enabled && /y/.test(b.type));
            };

            n.prototype.validatePositiveValue = function (b) {
              return e(b) && 0 < b;
            };

            n.prototype.update = function (f, e) {
              var a = this.chart;
              f = h(this.userOptions, f);
              this.destroy(!0);
              this.init(a, f);
              a.isDirtyBox = !0;
              b(e, !0) && a.redraw();
            };

            n.prototype.remove = function (f) {
              for (var e = this.chart, h = this.coll, a = this.series, c = a.length; c--;) {
                a[c] && a[c].remove(!1);
              }

              L(e.axes, this);
              L(e[h], this);
              e[h].forEach(function (b, f) {
                b.options.index = b.userOptions.index = f;
              });
              this.destroy();
              e.isDirtyBox = !0;
              b(f, !0) && e.redraw();
            };

            n.prototype.setTitle = function (b, f) {
              this.update({
                title: b
              }, f);
            };

            n.prototype.setCategories = function (b, f) {
              this.update({
                categories: b
              }, f);
            };

            n.defaultOptions = g.defaultXAxisOptions;
            n.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return n;
          }();

          "";
          return d;
        });
        P(g, "Core/Axis/DateTimeAxis.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.addEvent,
              B = d.getMagnitude,
              E = d.normalizeTickInterval,
              x = d.timeUnits,
              G;

          (function (d) {
            function A() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }

            function t(d) {
              "datetime" !== d.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new c(this));
            }

            var q = [];

            d.compose = function (c) {
              -1 === q.indexOf(c) && (q.push(c), c.keepProps.push("dateTime"), c.prototype.getTimeTicks = A, g(c, "init", t));
              return c;
            };

            var c = function () {
              function c(a) {
                this.axis = a;
              }

              c.prototype.normalizeTimeTickInterval = function (a, c) {
                var d = c || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                c = d[d.length - 1];
                var k = x[c[0]],
                    l = c[1],
                    q;

                for (q = 0; q < d.length && !(c = d[q], k = x[c[0]], l = c[1], d[q + 1] && a <= (k * l[l.length - 1] + x[d[q + 1][0]]) / 2); q++) {
                  ;
                }

                k === x.year && a < 5 * k && (l = [1, 2, 5]);
                a = E(a / k, l, "year" === c[0] ? Math.max(B(a / k), 1) : 1);
                return {
                  unitRange: k,
                  count: a,
                  unitName: c[0]
                };
              };

              c.prototype.getXDateFormat = function (a, c) {
                var d = this.axis,
                    k = d.chart.time;
                return d.closestPointRange ? k.getDateFormat(d.closestPointRange, a, d.options.startOfWeek, c) || k.resolveDTLFormat(c.year).main : k.resolveDTLFormat(c.day).main;
              };

              return c;
            }();

            d.Additions = c;
          })(G || (G = {}));

          return G;
        });
        P(g, "Core/Axis/LogarithmicAxis.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.addEvent,
              B = d.normalizeTickInterval,
              E = d.pick,
              x;

          (function (d) {
            function x(c) {
              var d = this.logarithmic;
              "logarithmic" !== c.userOptions.type ? this.logarithmic = void 0 : d || (this.logarithmic = new q(this));
            }

            function A() {
              var c = this.logarithmic;
              c && (this.lin2val = function (d) {
                return c.lin2log(d);
              }, this.val2lin = function (d) {
                return c.log2lin(d);
              });
            }

            var t = [];

            d.compose = function (c) {
              -1 === t.indexOf(c) && (t.push(c), c.keepProps.push("logarithmic"), g(c, "init", x), g(c, "afterInit", A));
              return c;
            };

            var q = function () {
              function c(c) {
                this.axis = c;
              }

              c.prototype.getLogTickPositions = function (c, a, d, q) {
                var k = this.axis,
                    l = k.len,
                    v = k.options,
                    g = [];
                q || (this.minorAutoInterval = void 0);
                if (.5 <= c) c = Math.round(c), g = k.getLinearTickPositions(c, a, d);else if (.08 <= c) {
                  var t = Math.floor(a),
                      y,
                      z = v = void 0;

                  for (l = .3 < c ? [1, 2, 4] : .15 < c ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; t < d + 1 && !z; t++) {
                    var w = l.length;

                    for (y = 0; y < w && !z; y++) {
                      var e = this.log2lin(this.lin2log(t) * l[y]);
                      e > a && (!q || v <= d) && "undefined" !== typeof v && g.push(v);
                      v > d && (z = !0);
                      v = e;
                    }
                  }
                } else a = this.lin2log(a), d = this.lin2log(d), c = q ? k.getMinorTickInterval() : v.tickInterval, c = E("auto" === c ? null : c, this.minorAutoInterval, v.tickPixelInterval / (q ? 5 : 1) * (d - a) / ((q ? l / k.tickPositions.length : l) || 1)), c = B(c), g = k.getLinearTickPositions(c, a, d).map(this.log2lin), q || (this.minorAutoInterval = c / 5);
                q || (k.tickInterval = c);
                return g;
              };

              c.prototype.lin2log = function (c) {
                return Math.pow(10, c);
              };

              c.prototype.log2lin = function (c) {
                return Math.log(c) / Math.LN10;
              };

              return c;
            }();

            d.Additions = q;
          })(x || (x = {}));

          return x;
        });
        P(g, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.erase,
              B = d.extend,
              E = d.isNumber,
              x;

          (function (d) {
            var x = [],
                A;

            d.compose = function (d, c) {
              A || (A = d);
              -1 === x.indexOf(c) && (x.push(c), B(c.prototype, t.prototype));
              return c;
            };

            var t = function () {
              function d() {}

              d.prototype.getPlotBandPath = function (c, d, a) {
                void 0 === a && (a = this.options);
                var k = this.getPlotLinePath({
                  value: d,
                  force: !0,
                  acrossPanes: a.acrossPanes
                }),
                    l = [],
                    m = this.horiz;
                d = !E(this.min) || !E(this.max) || c < this.min && d < this.min || c > this.max && d > this.max;
                c = this.getPlotLinePath({
                  value: c,
                  force: !0,
                  acrossPanes: a.acrossPanes
                });
                a = 1;

                if (c && k) {
                  if (d) {
                    var q = c.toString() === k.toString();
                    a = 0;
                  }

                  for (d = 0; d < c.length; d += 2) {
                    var g = c[d],
                        t = c[d + 1],
                        J = k[d],
                        y = k[d + 1];
                    "M" !== g[0] && "L" !== g[0] || "M" !== t[0] && "L" !== t[0] || "M" !== J[0] && "L" !== J[0] || "M" !== y[0] && "L" !== y[0] || (m && J[1] === g[1] ? (J[1] += a, y[1] += a) : m || J[2] !== g[2] || (J[2] += a, y[2] += a), l.push(["M", g[1], g[2]], ["L", t[1], t[2]], ["L", y[1], y[2]], ["L", J[1], J[2]], ["Z"]));
                    l.isFlat = q;
                  }
                }

                return l;
              };

              d.prototype.addPlotBand = function (c) {
                return this.addPlotBandOrLine(c, "plotBands");
              };

              d.prototype.addPlotLine = function (c) {
                return this.addPlotBandOrLine(c, "plotLines");
              };

              d.prototype.addPlotBandOrLine = function (c, d) {
                var a = this,
                    k = this.userOptions,
                    l = new A(this, c);
                this.visible && (l = l.render());

                if (l) {
                  this._addedPlotLB || (this._addedPlotLB = !0, (k.plotLines || []).concat(k.plotBands || []).forEach(function (c) {
                    a.addPlotBandOrLine(c);
                  }));

                  if (d) {
                    var m = k[d] || [];
                    m.push(c);
                    k[d] = m;
                  }

                  this.plotLinesAndBands.push(l);
                }

                return l;
              };

              d.prototype.removePlotBandOrLine = function (c) {
                var d = this.plotLinesAndBands,
                    a = this.options,
                    k = this.userOptions;

                if (d) {
                  for (var q = d.length; q--;) {
                    d[q].id === c && d[q].destroy();
                  }

                  [a.plotLines || [], k.plotLines || [], a.plotBands || [], k.plotBands || []].forEach(function (a) {
                    for (q = a.length; q--;) {
                      (a[q] || {}).id === c && g(a, a[q]);
                    }
                  });
                }
              };

              d.prototype.removePlotBand = function (c) {
                this.removePlotBandOrLine(c);
              };

              d.prototype.removePlotLine = function (c) {
                this.removePlotBandOrLine(c);
              };

              return d;
            }();
          })(x || (x = {}));

          return x;
        });
        P(g, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [g["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], g["Core/Utilities.js"]], function (d, g) {
          var B = g.arrayMax,
              C = g.arrayMin,
              x = g.defined,
              G = g.destroyObjectProperties,
              I = g.erase,
              A = g.fireEvent,
              t = g.merge,
              q = g.objectEach,
              c = g.pick;

          g = function () {
            function l(a, c) {
              this.axis = a;
              c && (this.options = c, this.id = c.id);
            }

            l.compose = function (a) {
              return d.compose(l, a);
            };

            l.prototype.render = function () {
              A(this, "render");
              var a = this,
                  d = a.axis,
                  l = d.horiz,
                  m = d.logarithmic,
                  g = a.options,
                  F = g.color,
                  L = c(g.zIndex, 0),
                  J = g.events,
                  y = {},
                  z = d.chart.renderer,
                  w = g.label,
                  e = a.label,
                  r = g.to,
                  h = g.from,
                  n = g.value,
                  f = a.svgElem,
                  b = [],
                  D = x(h) && x(r);
              b = x(n);
              var H = !f,
                  p = {
                "class": "highcharts-plot-" + (D ? "band " : "line ") + (g.className || "")
              },
                  u = D ? "bands" : "lines";
              m && (h = m.log2lin(h), r = m.log2lin(r), n = m.log2lin(n));
              d.chart.styledMode || (b ? (p.stroke = F || "#999999", p["stroke-width"] = c(g.width, 1), g.dashStyle && (p.dashstyle = g.dashStyle)) : D && (p.fill = F || "#e6ebf5", g.borderWidth && (p.stroke = g.borderColor, p["stroke-width"] = g.borderWidth)));
              y.zIndex = L;
              u += "-" + L;
              (m = d.plotLinesAndBandsGroups[u]) || (d.plotLinesAndBandsGroups[u] = m = z.g("plot-" + u).attr(y).add());
              H && (a.svgElem = f = z.path().attr(p).add(m));
              if (b) b = d.getPlotLinePath({
                value: n,
                lineWidth: f.strokeWidth(),
                acrossPanes: g.acrossPanes
              });else if (D) b = d.getPlotBandPath(h, r, g);else return;
              !a.eventsAdded && J && (q(J, function (b, e) {
                f.on(e, function (b) {
                  J[e].apply(a, [b]);
                });
              }), a.eventsAdded = !0);
              (H || !f.d) && b && b.length ? f.attr({
                d: b
              }) : f && (b ? (f.show(), f.animate({
                d: b
              })) : f.d && (f.hide(), e && (a.label = e = e.destroy())));
              w && (x(w.text) || x(w.formatter)) && b && b.length && 0 < d.width && 0 < d.height && !b.isFlat ? (w = t({
                align: l && D && "center",
                x: l ? !D && 4 : 10,
                verticalAlign: !l && D && "middle",
                y: l ? D ? 16 : 10 : D ? 6 : -4,
                rotation: l && !D && 90
              }, w), this.renderLabel(w, b, D, L)) : e && e.hide();
              return a;
            };

            l.prototype.renderLabel = function (a, c, d, m) {
              var k = this.axis,
                  l = k.chart.renderer,
                  q = this.label;
              q || (this.label = q = l.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
                align: a.textAlign || a.align,
                rotation: a.rotation,
                "class": "highcharts-plot-" + (d ? "band" : "line") + "-label " + (a.className || ""),
                zIndex: m
              }).add(), k.chart.styledMode || q.css(t({
                textOverflow: "ellipsis"
              }, a.style)));
              m = c.xBounds || [c[0][1], c[1][1], d ? c[2][1] : c[0][1]];
              c = c.yBounds || [c[0][2], c[1][2], d ? c[2][2] : c[0][2]];
              d = C(m);
              l = C(c);
              q.align(a, !1, {
                x: d,
                y: l,
                width: B(m) - d,
                height: B(c) - l
              });
              q.alignValue && "left" !== q.alignValue || q.css({
                width: (90 === q.rotation ? k.height - (q.alignAttr.y - k.top) : k.width - (q.alignAttr.x - k.left)) + "px"
              });
              q.show(!0);
            };

            l.prototype.getLabelText = function (a) {
              return x(a.formatter) ? a.formatter.call(this) : a.text;
            };

            l.prototype.destroy = function () {
              I(this.axis.plotLinesAndBands, this);
              delete this.axis;
              G(this);
            };

            return l;
          }();

          "";
          "";
          return g;
        });
        P(g, "Core/Tooltip.js", [g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Utilities.js"]], function (d, g, B, E, x) {
          var C = d.format,
              I = g.doc,
              A = B.distribute,
              t = x.addEvent,
              q = x.clamp,
              c = x.css,
              l = x.defined,
              a = x.discardElement,
              k = x.extend,
              v = x.fireEvent,
              m = x.isArray,
              N = x.isNumber,
              F = x.isString,
              L = x.merge,
              J = x.pick,
              y = x.splat,
              z = x.syncTimeout;

          d = function () {
            function d(e, a) {
              this.allowShared = !0;
              this.container = void 0;
              this.crosshairs = [];
              this.distance = 0;
              this.isHidden = !0;
              this.isSticky = !1;
              this.now = {};
              this.options = {};
              this.outside = !1;
              this.chart = e;
              this.init(e, a);
            }

            d.prototype.applyFilter = function () {
              var e = this.chart;
              e.renderer.definition({
                tagName: "filter",
                attributes: {
                  id: "drop-shadow-" + e.index,
                  opacity: .5
                },
                children: [{
                  tagName: "feGaussianBlur",
                  attributes: {
                    "in": "SourceAlpha",
                    stdDeviation: 1
                  }
                }, {
                  tagName: "feOffset",
                  attributes: {
                    dx: 1,
                    dy: 1
                  }
                }, {
                  tagName: "feComponentTransfer",
                  children: [{
                    tagName: "feFuncA",
                    attributes: {
                      type: "linear",
                      slope: .3
                    }
                  }]
                }, {
                  tagName: "feMerge",
                  children: [{
                    tagName: "feMergeNode"
                  }, {
                    tagName: "feMergeNode",
                    attributes: {
                      "in": "SourceGraphic"
                    }
                  }]
                }]
              });
            };

            d.prototype.bodyFormatter = function (e) {
              return e.map(function (e) {
                var h = e.series.tooltipOptions;
                return (h[(e.point.formatPrefix || "point") + "Formatter"] || e.point.tooltipFormatter).call(e.point, h[(e.point.formatPrefix || "point") + "Format"] || "");
              });
            };

            d.prototype.cleanSplit = function (e) {
              this.chart.series.forEach(function (a) {
                var h = a && a.tt;
                h && (!h.isActive || e ? a.tt = h.destroy() : h.isActive = !1);
              });
            };

            d.prototype.defaultFormatter = function (e) {
              var a = this.points || y(this);
              var h = [e.tooltipFooterHeaderFormatter(a[0])];
              h = h.concat(e.bodyFormatter(a));
              h.push(e.tooltipFooterHeaderFormatter(a[0], !0));
              return h;
            };

            d.prototype.destroy = function () {
              this.label && (this.label = this.label.destroy());
              this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
              this.renderer && (this.renderer = this.renderer.destroy(), a(this.container));
              x.clearTimeout(this.hideTimer);
              x.clearTimeout(this.tooltipTimeout);
            };

            d.prototype.getAnchor = function (e, a) {
              var h = this.chart,
                  c = h.pointer,
                  f = h.inverted,
                  b = h.plotTop,
                  d = h.plotLeft,
                  r,
                  p,
                  u = 0,
                  w = 0;
              e = y(e);
              this.followPointer && a ? ("undefined" === typeof a.chartX && (a = c.normalize(a)), c = [a.chartX - d, a.chartY - b]) : e[0].tooltipPos ? c = e[0].tooltipPos : (e.forEach(function (e) {
                r = e.series.yAxis;
                p = e.series.xAxis;
                u += e.plotX || 0;
                w += e.plotLow ? (e.plotLow + (e.plotHigh || 0)) / 2 : e.plotY || 0;
                p && r && (f ? (u += b + h.plotHeight - p.len - p.pos, w += d + h.plotWidth - r.len - r.pos) : (u += p.pos - d, w += r.pos - b));
              }), u /= e.length, w /= e.length, c = [f ? h.plotWidth - w : u, f ? h.plotHeight - u : w], this.shared && 1 < e.length && a && (f ? c[0] = a.chartX - d : c[1] = a.chartY - b));
              return c.map(Math.round);
            };

            d.prototype.getLabel = function () {
              var e = this,
                  a = this.chart.styledMode,
                  h = this.options,
                  n = this.split && this.allowShared,
                  f = "tooltip" + (l(h.className) ? " " + h.className : ""),
                  b = h.style.pointerEvents || (!this.followPointer && h.stickOnContact ? "auto" : "none"),
                  d = function d() {
                e.inContact = !0;
              },
                  w = function w(b) {
                var f = e.chart.hoverSeries;
                e.inContact = e.shouldStickOnContact() && e.chart.pointer.inClass(b.relatedTarget, "highcharts-tooltip");
                if (!e.inContact && f && f.onMouseOut) f.onMouseOut();
              },
                  p,
                  u = this.chart.renderer;

              if (e.label) {
                var k = !e.label.hasClass("highcharts-label");
                (n && !k || !n && k) && e.destroy();
              }

              if (!this.label) {
                if (this.outside) {
                  k = this.chart.options.chart.style;
                  var m = E.getRendererType();
                  this.container = p = g.doc.createElement("div");
                  p.className = "highcharts-tooltip-container";
                  c(p, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: b,
                    zIndex: Math.max(this.options.style.zIndex || 0, (k && k.zIndex || 0) + 3)
                  });
                  t(p, "mouseenter", d);
                  t(p, "mouseleave", w);
                  g.doc.body.appendChild(p);
                  this.renderer = u = new m(p, 0, 0, k, void 0, void 0, u.styledMode);
                }

                n ? this.label = u.g(f) : (this.label = u.label("", 0, 0, h.shape, void 0, void 0, h.useHTML, void 0, f).attr({
                  padding: h.padding,
                  r: h.borderRadius
                }), a || this.label.attr({
                  fill: h.backgroundColor,
                  "stroke-width": h.borderWidth
                }).css(h.style).css({
                  pointerEvents: b
                }).shadow(h.shadow));
                a && h.shadow && (this.applyFilter(), this.label.attr({
                  filter: "url(#drop-shadow-" + this.chart.index + ")"
                }));

                if (e.outside && !e.split) {
                  var z = this.label,
                      q = z.xSetter,
                      y = z.ySetter;

                  z.xSetter = function (b) {
                    q.call(z, e.distance);
                    p.style.left = b + "px";
                  };

                  z.ySetter = function (b) {
                    y.call(z, e.distance);
                    p.style.top = b + "px";
                  };
                }

                this.label.on("mouseenter", d).on("mouseleave", w).attr({
                  zIndex: 8
                }).add();
              }

              return this.label;
            };

            d.prototype.getPosition = function (e, a, h) {
              var c = this.chart,
                  f = this.distance,
                  b = {},
                  d = c.inverted && h.h || 0,
                  r = this.outside,
                  p = r ? I.documentElement.clientWidth - 2 * f : c.chartWidth,
                  u = r ? Math.max(I.body.scrollHeight, I.documentElement.scrollHeight, I.body.offsetHeight, I.documentElement.offsetHeight, I.documentElement.clientHeight) : c.chartHeight,
                  w = c.pointer.getChartPosition(),
                  k = function k(b) {
                var n = "x" === b;
                return [b, n ? p : u, n ? e : a].concat(r ? [n ? e * w.scaleX : a * w.scaleY, n ? w.left - f + (h.plotX + c.plotLeft) * w.scaleX : w.top - f + (h.plotY + c.plotTop) * w.scaleY, 0, n ? p : u] : [n ? e : a, n ? h.plotX + c.plotLeft : h.plotY + c.plotTop, n ? c.plotLeft : c.plotTop, n ? c.plotLeft + c.plotWidth : c.plotTop + c.plotHeight]);
              },
                  m = k("y"),
                  l = k("x"),
                  z;

              k = !!h.negative;
              !c.polar && c.hoverSeries && c.hoverSeries.yAxis && c.hoverSeries.yAxis.reversed && (k = !k);

              var q = !this.followPointer && J(h.ttBelow, !c.inverted === k),
                  y = function y(e, h, a, c, p, n, u) {
                var D = r ? "y" === e ? f * w.scaleY : f * w.scaleX : f,
                    H = (a - c) / 2,
                    k = c < p - f,
                    m = p + f + c < h,
                    l = p - D - a + H;
                p = p + D - H;
                if (q && m) b[e] = p;else if (!q && k) b[e] = l;else if (k) b[e] = Math.min(u - c, 0 > l - d ? l : l - d);else if (m) b[e] = Math.max(n, p + d + a > h ? p : p + d);else return !1;
              },
                  g = function g(e, h, a, c, p) {
                var n;
                p < f || p > h - f ? n = !1 : b[e] = p < a / 2 ? 1 : p > h - c / 2 ? h - c - 2 : p - a / 2;
                return n;
              },
                  Q = function Q(b) {
                var f = m;
                m = l;
                l = f;
                z = b;
              },
                  t = function t() {
                !1 !== y.apply(0, m) ? !1 !== g.apply(0, l) || z || (Q(!0), t()) : z ? b.x = b.y = 0 : (Q(!0), t());
              };

              (c.inverted || 1 < this.len) && Q();
              t();
              return b;
            };

            d.prototype.hide = function (e) {
              var a = this;
              x.clearTimeout(this.hideTimer);
              e = J(e, this.options.hideDelay);
              this.isHidden || (this.hideTimer = z(function () {
                a.getLabel().fadeOut(e ? void 0 : e);
                a.isHidden = !0;
              }, e));
            };

            d.prototype.init = function (e, a) {
              this.chart = e;
              this.options = a;
              this.crosshairs = [];
              this.now = {
                x: 0,
                y: 0
              };
              this.isHidden = !0;
              this.split = a.split && !e.inverted && !e.polar;
              this.shared = a.shared || this.split;
              this.outside = J(a.outside, !(!e.scrollablePixelsX && !e.scrollablePixelsY));
            };

            d.prototype.shouldStickOnContact = function () {
              return !(this.followPointer || !this.options.stickOnContact);
            };

            d.prototype.isStickyOnContact = function () {
              return !(!this.shouldStickOnContact() || !this.inContact);
            };

            d.prototype.move = function (e, a, h, c) {
              var f = this,
                  b = f.now,
                  n = !1 !== f.options.animation && !f.isHidden && (1 < Math.abs(e - b.x) || 1 < Math.abs(a - b.y)),
                  d = f.followPointer || 1 < f.len;
              k(b, {
                x: n ? (2 * b.x + e) / 3 : e,
                y: n ? (b.y + a) / 2 : a,
                anchorX: d ? void 0 : n ? (2 * b.anchorX + h) / 3 : h,
                anchorY: d ? void 0 : n ? (b.anchorY + c) / 2 : c
              });
              f.getLabel().attr(b);
              f.drawTracker();
              n && (x.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                f && f.move(e, a, h, c);
              }, 32));
            };

            d.prototype.refresh = function (e, a) {
              var h = this.chart,
                  c = this.options,
                  f = y(e),
                  b = f[0],
                  d = [],
                  r = c.formatter || this.defaultFormatter,
                  p = this.shared,
                  u = h.styledMode,
                  w = {};

              if (c.enabled && b.series) {
                x.clearTimeout(this.hideTimer);
                this.allowShared = !(!m(e) && e.series && e.series.noSharedTooltip);
                this.followPointer = !this.split && b.series.tooltipOptions.followPointer;
                e = this.getAnchor(e, a);
                var k = e[0],
                    l = e[1];
                p && this.allowShared ? (h.pointer.applyInactiveState(f), f.forEach(function (b) {
                  b.setState("hover");
                  d.push(b.getLabelConfig());
                }), w = {
                  x: b.category,
                  y: b.y
                }, w.points = d) : w = b.getLabelConfig();
                this.len = d.length;
                r = r.call(w, this);
                p = b.series;
                this.distance = J(p.tooltipOptions.distance, 16);
                if (!1 === r) this.hide();else {
                  if (this.split && this.allowShared) this.renderSplit(r, f);else {
                    var z = k,
                        q = l;
                    a && h.pointer.isDirectTouch && (z = a.chartX - h.plotLeft, q = a.chartY - h.plotTop);
                    if (h.polar || !1 === p.options.clip || f.some(function (b) {
                      return b.series.shouldShowTooltip(z, q);
                    })) a = this.getLabel(), c.style.width && !u || a.css({
                      width: this.chart.spacingBox.width + "px"
                    }), a.attr({
                      text: r && r.join ? r.join("") : r
                    }), a.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + J(b.colorIndex, p.colorIndex)), u || a.attr({
                      stroke: c.borderColor || b.color || p.color || "#666666"
                    }), this.updatePosition({
                      plotX: k,
                      plotY: l,
                      negative: b.negative,
                      ttBelow: b.ttBelow,
                      h: e[2] || 0
                    });else {
                      this.hide();
                      return;
                    }
                  }
                  this.isHidden && this.label && this.label.attr({
                    opacity: 1
                  }).show();
                  this.isHidden = !1;
                }
                v(this, "refresh");
              }
            };

            d.prototype.renderSplit = function (e, a) {
              function h(b, f, e, a, h) {
                void 0 === h && (h = !0);
                e ? (f = B ? 0 : ea, b = q(b - a / 2, S.left, S.right - a - (c.outside ? C : 0))) : (f -= G, b = h ? b - a - v : b + v, b = q(b, h ? b : S.left, S.right));
                return {
                  x: b,
                  y: f
                };
              }

              var c = this,
                  f = c.chart,
                  b = c.chart,
                  d = b.chartWidth,
                  r = b.chartHeight,
                  p = b.plotHeight,
                  u = b.plotLeft,
                  w = b.plotTop,
                  l = b.pointer,
                  m = b.scrollablePixelsY;
              m = void 0 === m ? 0 : m;
              var z = b.scrollablePixelsX,
                  y = b.scrollingContainer;
              y = void 0 === y ? {
                scrollLeft: 0,
                scrollTop: 0
              } : y;
              var g = y.scrollLeft;
              y = y.scrollTop;
              var t = b.styledMode,
                  v = c.distance,
                  Q = c.options,
                  L = c.options.positioner,
                  S = c.outside && "number" !== typeof z ? I.documentElement.getBoundingClientRect() : {
                left: g,
                right: g + d,
                top: y,
                bottom: y + r
              },
                  N = c.getLabel(),
                  x = this.renderer || f.renderer,
                  B = !(!f.xAxis[0] || !f.xAxis[0].opposite);
              f = l.getChartPosition();
              var C = f.left;
              f = f.top;
              var G = w + y,
                  E = 0,
                  ea = p - m;
              F(e) && (e = [!1, e]);
              e = e.slice(0, a.length + 1).reduce(function (b, f, e) {
                if (!1 !== f && "" !== f) {
                  e = a[e - 1] || {
                    isHeader: !0,
                    plotX: a[0].plotX,
                    plotY: p,
                    series: {}
                  };
                  var n = e.isHeader,
                      d = n ? c : e.series;
                  f = f.toString();
                  var r = d.tt,
                      D = e.isHeader;
                  var H = e.series;
                  var k = "highcharts-color-" + J(e.colorIndex, H.colorIndex, "none");
                  r || (r = {
                    padding: Q.padding,
                    r: Q.borderRadius
                  }, t || (r.fill = Q.backgroundColor, r["stroke-width"] = Q.borderWidth), r = x.label("", 0, 0, Q[D ? "headerShape" : "shape"], void 0, void 0, Q.useHTML).addClass((D ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + k).attr(r).add(N));
                  r.isActive = !0;
                  r.attr({
                    text: f
                  });
                  t || r.css(Q.style).shadow(Q.shadow).attr({
                    stroke: Q.borderColor || e.color || H.color || "#333333"
                  });
                  d = d.tt = r;
                  D = d.getBBox();
                  f = D.width + d.strokeWidth();
                  n && (E = D.height, ea += E, B && (G -= E));
                  H = e.plotX;
                  H = void 0 === H ? 0 : H;
                  k = e.plotY;
                  k = void 0 === k ? 0 : k;
                  r = e.series;

                  if (e.isHeader) {
                    H = u + H;
                    var m = w + p / 2;
                  } else {
                    var l = r.xAxis,
                        z = r.yAxis;
                    H = l.pos + q(H, -v, l.len + v);
                    r.shouldShowTooltip(0, z.pos - w + k, {
                      ignoreX: !0
                    }) && (m = z.pos + k);
                  }

                  H = q(H, S.left - v, S.right + v);
                  "number" === typeof m ? (D = D.height + 1, k = L ? L.call(c, f, D, e) : h(H, m, n, f), b.push({
                    align: L ? 0 : void 0,
                    anchorX: H,
                    anchorY: m,
                    boxWidth: f,
                    point: e,
                    rank: J(k.rank, n ? 1 : 0),
                    size: D,
                    target: k.y,
                    tt: d,
                    x: k.x
                  })) : d.isActive = !1;
                }

                return b;
              }, []);
              !L && e.some(function (b) {
                var f = (c.outside ? C : 0) + b.anchorX;
                return f < S.left && f + b.boxWidth < S.right ? !0 : f < C - S.left + b.boxWidth && S.right - f > f;
              }) && (e = e.map(function (b) {
                var f = h(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
                return k(b, {
                  target: f.y,
                  x: f.x
                });
              }));
              c.cleanSplit();
              A(e, ea);
              var P = C,
                  Y = C;
              e.forEach(function (b) {
                var f = b.x,
                    e = b.boxWidth;
                b = b.isHeader;
                b || (c.outside && C + f < P && (P = C + f), !b && c.outside && P + e > Y && (Y = C + f));
              });
              e.forEach(function (b) {
                var f = b.x,
                    e = b.anchorX,
                    a = b.pos,
                    h = b.point.isHeader;
                a = {
                  visibility: "undefined" === typeof a ? "hidden" : "inherit",
                  x: f,
                  y: a + G,
                  anchorX: e,
                  anchorY: b.anchorY
                };

                if (c.outside && f < e) {
                  var p = C - P;
                  0 < p && (h || (a.x = f + p, a.anchorX = e + p), h && (a.x = (Y - P) / 2, a.anchorX = e + p));
                }

                b.tt.attr(a);
              });
              e = c.container;
              m = c.renderer;
              c.outside && e && m && (b = N.getBBox(), m.setSize(b.width + b.x, b.height + b.y, !1), e.style.left = P + "px", e.style.top = f + "px");
            };

            d.prototype.drawTracker = function () {
              if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
                var e = this.chart,
                    a = this.label,
                    h = this.shared ? e.hoverPoints : e.hoverPoint;

                if (a && h) {
                  var c = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                  h = this.getAnchor(h);
                  var f = a.getBBox();
                  h[0] += e.plotLeft - a.translateX;
                  h[1] += e.plotTop - a.translateY;
                  c.x = Math.min(0, h[0]);
                  c.y = Math.min(0, h[1]);
                  c.width = 0 > h[0] ? Math.max(Math.abs(h[0]), f.width - h[0]) : Math.max(Math.abs(h[0]), f.width);
                  c.height = 0 > h[1] ? Math.max(Math.abs(h[1]), f.height - Math.abs(h[1])) : Math.max(Math.abs(h[1]), f.height);
                  this.tracker ? this.tracker.attr(c) : (this.tracker = a.renderer.rect(c).addClass("highcharts-tracker").add(a), e.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                  }));
                }
              }
            };

            d.prototype.styledModeFormat = function (e) {
              return e.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };

            d.prototype.tooltipFooterHeaderFormatter = function (e, a) {
              var h = e.series,
                  c = h.tooltipOptions,
                  f = h.xAxis,
                  b = f && f.dateTime;
              f = {
                isFooter: a,
                labelConfig: e
              };
              var d = c.xDateFormat,
                  r = c[a ? "footerFormat" : "headerFormat"];
              v(this, "headerFormatter", f, function (f) {
                b && !d && N(e.key) && (d = b.getXDateFormat(e.key, c.dateTimeLabelFormats));
                b && d && (e.point && e.point.tooltipDateKeys || ["key"]).forEach(function (b) {
                  r = r.replace("{point." + b + "}", "{point." + b + ":" + d + "}");
                });
                h.chart.styledMode && (r = this.styledModeFormat(r));
                f.text = C(r, {
                  point: e,
                  series: h
                }, this.chart);
              });
              return f.text;
            };

            d.prototype.update = function (e) {
              this.destroy();
              L(!0, this.chart.options.tooltip.userOptions, e);
              this.init(this.chart, L(!0, this.options, e));
            };

            d.prototype.updatePosition = function (e) {
              var a = this.chart,
                  h = this.options,
                  n = a.pointer,
                  f = this.getLabel();
              n = n.getChartPosition();
              var b = (h.positioner || this.getPosition).call(this, f.width, f.height, e),
                  d = e.plotX + a.plotLeft;
              e = e.plotY + a.plotTop;

              if (this.outside) {
                h = h.borderWidth + 2 * this.distance;
                this.renderer.setSize(f.width + h, f.height + h, !1);
                if (1 !== n.scaleX || 1 !== n.scaleY) c(this.container, {
                  transform: "scale(".concat(n.scaleX, ", ").concat(n.scaleY, ")")
                }), d *= n.scaleX, e *= n.scaleY;
                d += n.left - b.x;
                e += n.top - b.y;
              }

              this.move(Math.round(b.x), Math.round(b.y || 0), d, e);
            };

            return d;
          }();

          "";
          return d;
        });
        P(g, "Core/Series/Point.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Animation/AnimationUtilities.js"], g["Core/DefaultOptions.js"], g["Core/FormatUtilities.js"], g["Core/Utilities.js"]], function (d, g, B, E, x) {
          var C = g.animObject,
              I = B.defaultOptions,
              A = E.format,
              t = x.addEvent,
              q = x.defined,
              c = x.erase,
              l = x.extend,
              a = x.fireEvent,
              k = x.getNestedProperty,
              v = x.isArray,
              m = x.isFunction,
              N = x.isNumber,
              F = x.isObject,
              L = x.merge,
              J = x.objectEach,
              y = x.pick,
              z = x.syncTimeout,
              w = x.removeEvent,
              e = x.uniqueKey;

          g = function () {
            function r() {
              this.colorIndex = this.category = void 0;
              this.formatPrefix = "point";
              this.id = void 0;
              this.isNull = !1;
              this.percentage = this.options = this.name = void 0;
              this.selected = !1;
              this.total = this.shapeArgs = this.series = void 0;
              this.visible = !0;
              this.x = void 0;
            }

            r.prototype.animateBeforeDestroy = function () {
              var e = this,
                  a = {
                x: e.startXPos,
                opacity: 0
              },
                  f = e.getGraphicalProps();
              f.singular.forEach(function (b) {
                e[b] = e[b].animate("dataLabel" === b ? {
                  x: e[b].startXPos,
                  y: e[b].startYPos,
                  opacity: 0
                } : a);
              });
              f.plural.forEach(function (b) {
                e[b].forEach(function (b) {
                  b.element && b.animate(l({
                    x: e.startXPos
                  }, b.startYPos ? {
                    x: b.startXPos,
                    y: b.startYPos
                  } : {}));
                });
              });
            };

            r.prototype.applyOptions = function (e, a) {
              var f = this.series,
                  b = f.options.pointValKey || f.pointValKey;
              e = r.prototype.optionsToObject.call(this, e);
              l(this, e);
              this.options = this.options ? l(this.options, e) : e;
              e.group && delete this.group;
              e.dataLabels && delete this.dataLabels;
              b && (this.y = r.prototype.getNestedProperty.call(this, b));
              this.formatPrefix = (this.isNull = y(this.isValid && !this.isValid(), null === this.x || !N(this.y))) ? "null" : "point";
              this.selected && (this.state = "select");
              "name" in this && "undefined" === typeof a && f.xAxis && f.xAxis.hasNames && (this.x = f.xAxis.nameToX(this));
              "undefined" === typeof this.x && f ? this.x = "undefined" === typeof a ? f.autoIncrement() : a : N(e.x) && f.options.relativeXValue && (this.x = f.autoIncrement(e.x));
              return this;
            };

            r.prototype.destroy = function () {
              function e() {
                if (a.graphic || a.dataLabel || a.dataLabels) w(a), a.destroyElements();

                for (p in a) {
                  a[p] = null;
                }
              }

              var a = this,
                  f = a.series,
                  b = f.chart;
              f = f.options.dataSorting;
              var d = b.hoverPoints,
                  r = C(a.series.chart.renderer.globalAnimation),
                  p;
              a.legendItem && b.legend.destroyItem(a);
              d && (a.setState(), c(d, a), d.length || (b.hoverPoints = null));
              if (a === b.hoverPoint) a.onMouseOut();
              f && f.enabled ? (this.animateBeforeDestroy(), z(e, r.duration)) : e();
              b.pointCount--;
            };

            r.prototype.destroyElements = function (e) {
              var a = this;
              e = a.getGraphicalProps(e);
              e.singular.forEach(function (f) {
                a[f] = a[f].destroy();
              });
              e.plural.forEach(function (f) {
                a[f].forEach(function (b) {
                  b.element && b.destroy();
                });
                delete a[f];
              });
            };

            r.prototype.firePointEvent = function (e, c, f) {
              var b = this,
                  h = this.series.options;
              (h.point.events[e] || b.options && b.options.events && b.options.events[e]) && b.importEvents();
              "click" === e && h.allowPointSelect && (f = function f(_f) {
                b.select && b.select(null, _f.ctrlKey || _f.metaKey || _f.shiftKey);
              });
              a(b, e, c, f);
            };

            r.prototype.getClassName = function () {
              return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };

            r.prototype.getGraphicalProps = function (e) {
              var a = this,
                  f = [],
                  b = {
                singular: [],
                plural: []
              },
                  c;
              e = e || {
                graphic: 1,
                dataLabel: 1
              };
              e.graphic && f.push("graphic", "upperGraphic", "shadowGroup");
              e.dataLabel && f.push("dataLabel", "dataLabelUpper", "connector");

              for (c = f.length; c--;) {
                var h = f[c];
                a[h] && b.singular.push(h);
              }

              ["dataLabel", "connector"].forEach(function (f) {
                var c = f + "s";
                e[f] && a[c] && b.plural.push(c);
              });
              return b;
            };

            r.prototype.getLabelConfig = function () {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
              };
            };

            r.prototype.getNestedProperty = function (e) {
              if (e) return 0 === e.indexOf("custom.") ? k(e, this.options) : this[e];
            };

            r.prototype.getZone = function () {
              var e = this.series,
                  a = e.zones;
              e = e.zoneAxis || "y";
              var f,
                  b = 0;

              for (f = a[b]; this[e] >= f.value;) {
                f = a[++b];
              }

              this.nonZonedColor || (this.nonZonedColor = this.color);
              this.color = f && f.color && !this.options.color ? f.color : this.nonZonedColor;
              return f;
            };

            r.prototype.hasNewShapeType = function () {
              return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };

            r.prototype.init = function (c, n, f) {
              this.series = c;
              this.applyOptions(n, f);
              this.id = q(this.id) ? this.id : e();
              this.resolveColor();
              c.chart.pointCount++;
              a(this, "afterInit");
              return this;
            };

            r.prototype.optionsToObject = function (e) {
              var a = this.series,
                  f = a.options.keys,
                  b = f || a.pointArrayMap || ["y"],
                  c = b.length,
                  h = {},
                  p = 0,
                  d = 0;
              if (N(e) || null === e) h[b[0]] = e;else if (v(e)) for (!f && e.length > c && (a = typeof e[0], "string" === a ? h.name = e[0] : "number" === a && (h.x = e[0]), p++); d < c;) {
                f && "undefined" === typeof e[p] || (0 < b[d].indexOf(".") ? r.prototype.setNestedProperty(h, e[p], b[d]) : h[b[d]] = e[p]), p++, d++;
              } else "object" === typeof e && (h = e, e.dataLabels && (a._hasPointLabels = !0), e.marker && (a._hasPointMarkers = !0));
              return h;
            };

            r.prototype.resolveColor = function () {
              var e = this.series,
                  a = e.chart.styledMode;
              var f = e.chart.options.chart.colorCount;
              delete this.nonZonedColor;

              if (e.options.colorByPoint) {
                if (!a) {
                  f = e.options.colors || e.chart.options.colors;
                  var b = f[e.colorCounter];
                  f = f.length;
                }

                a = e.colorCounter;
                e.colorCounter++;
                e.colorCounter === f && (e.colorCounter = 0);
              } else a || (b = e.color), a = e.colorIndex;

              this.colorIndex = y(this.options.colorIndex, a);
              this.color = y(this.options.color, b);
            };

            r.prototype.setNestedProperty = function (e, a, f) {
              f.split(".").reduce(function (b, f, e, c) {
                b[f] = c.length - 1 === e ? a : F(b[f], !0) ? b[f] : {};
                return b[f];
              }, e);
              return e;
            };

            r.prototype.tooltipFormatter = function (e) {
              var a = this.series,
                  f = a.tooltipOptions,
                  b = y(f.valueDecimals, ""),
                  c = f.valuePrefix || "",
                  h = f.valueSuffix || "";
              a.chart.styledMode && (e = a.chart.tooltip.styledModeFormat(e));
              (a.pointArrayMap || ["y"]).forEach(function (f) {
                f = "{point." + f;
                if (c || h) e = e.replace(RegExp(f + "}", "g"), c + f + "}" + h);
                e = e.replace(RegExp(f + "}", "g"), f + ":,." + b + "f}");
              });
              return A(e, {
                point: this,
                series: this.series
              }, a.chart);
            };

            r.prototype.update = function (e, a, f, b) {
              function c() {
                h.applyOptions(e);
                var b = n && h.hasDummyGraphic;
                b = null === h.y ? !b : b;
                n && b && (h.graphic = n.destroy(), delete h.hasDummyGraphic);
                F(e, !0) && (n && n.element && e && e.marker && "undefined" !== typeof e.marker.symbol && (h.graphic = n.destroy()), e && e.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));
                w = h.index;
                p.updateParallelArrays(h, w);
                r.data[w] = F(r.data[w], !0) || F(e, !0) ? h.options : y(e, r.data[w]);
                p.isDirty = p.isDirtyData = !0;
                !p.fixedBox && p.hasCartesianSeries && (d.isDirtyBox = !0);
                "point" === r.legendType && (d.isDirtyLegend = !0);
                a && d.redraw(f);
              }

              var h = this,
                  p = h.series,
                  n = h.graphic,
                  d = p.chart,
                  r = p.options,
                  w;
              a = y(a, !0);
              !1 === b ? c() : h.firePointEvent("update", {
                options: e
              }, c);
            };

            r.prototype.remove = function (e, a) {
              this.series.removePoint(this.series.data.indexOf(this), e, a);
            };

            r.prototype.select = function (e, a) {
              var f = this,
                  b = f.series,
                  c = b.chart;
              this.selectedStaging = e = y(e, !f.selected);
              f.firePointEvent(e ? "select" : "unselect", {
                accumulate: a
              }, function () {
                f.selected = f.options.selected = e;
                b.options.data[b.data.indexOf(f)] = f.options;
                f.setState(e && "select");
                a || c.getSelectedPoints().forEach(function (b) {
                  var e = b.series;
                  b.selected && b !== f && (b.selected = b.options.selected = !1, e.options.data[e.data.indexOf(b)] = b.options, b.setState(c.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
                });
              });
              delete this.selectedStaging;
            };

            r.prototype.onMouseOver = function (e) {
              var a = this.series.chart,
                  f = a.pointer;
              e = e ? f.normalize(e) : f.getChartCoordinatesFromPoint(this, a.inverted);
              f.runPointActions(e, this);
            };

            r.prototype.onMouseOut = function () {
              var e = this.series.chart;
              this.firePointEvent("mouseOut");
              this.series.options.inactiveOtherPoints || (e.hoverPoints || []).forEach(function (e) {
                e.setState();
              });
              e.hoverPoints = e.hoverPoint = null;
            };

            r.prototype.importEvents = function () {
              if (!this.hasImportedEvents) {
                var e = this,
                    a = L(e.series.options.point, e.options).events;
                e.events = a;
                J(a, function (f, b) {
                  m(f) && t(e, b, f);
                });
                this.hasImportedEvents = !0;
              }
            };

            r.prototype.setState = function (e, c) {
              var f = this.series,
                  b = this.state,
                  h = f.options.states[e || "normal"] || {},
                  n = I.plotOptions[f.type].marker && f.options.marker,
                  p = n && !1 === n.enabled,
                  u = n && n.states && n.states[e || "normal"] || {},
                  r = !1 === u.enabled,
                  w = this.marker || {},
                  k = f.chart,
                  m = n && f.markerAttribs,
                  z = f.halo,
                  q,
                  g = f.stateMarkerGraphic;
              e = e || "";

              if (!(e === this.state && !c || this.selected && "select" !== e || !1 === h.enabled || e && (r || p && !1 === u.enabled) || e && w.states && w.states[e] && !1 === w.states[e].enabled)) {
                this.state = e;
                m && (q = f.markerAttribs(this, e));

                if (this.graphic && !this.hasDummyGraphic) {
                  b && this.graphic.removeClass("highcharts-point-" + b);
                  e && this.graphic.addClass("highcharts-point-" + e);

                  if (!k.styledMode) {
                    var t = f.pointAttribs(this, e);
                    var Q = y(k.options.chart.animation, h.animation);
                    f.options.inactiveOtherPoints && N(t.opacity) && ((this.dataLabels || []).forEach(function (b) {
                      b && b.animate({
                        opacity: t.opacity
                      }, Q);
                    }), this.connector && this.connector.animate({
                      opacity: t.opacity
                    }, Q));
                    this.graphic.animate(t, Q);
                  }

                  q && this.graphic.animate(q, y(k.options.chart.animation, u.animation, n.animation));
                  g && g.hide();
                } else {
                  if (e && u) {
                    b = w.symbol || f.symbol;
                    g && g.currentSymbol !== b && (g = g.destroy());
                    if (q) if (g) g[c ? "animate" : "attr"]({
                      x: q.x,
                      y: q.y
                    });else b && (f.stateMarkerGraphic = g = k.renderer.symbol(b, q.x, q.y, q.width, q.height).add(f.markerGroup), g.currentSymbol = b);
                    !k.styledMode && g && "inactive" !== this.state && g.attr(f.pointAttribs(this, e));
                  }

                  g && (g[e && this.isInside ? "show" : "hide"](), g.element.point = this, g.addClass(this.getClassName(), !0));
                }

                h = h.halo;
                q = (g = this.graphic || g) && g.visibility || "inherit";
                h && h.size && g && "hidden" !== q && !this.isCluster ? (z || (f.halo = z = k.renderer.path().add(g.parentGroup)), z.show()[c ? "animate" : "attr"]({
                  d: this.haloPath(h.size)
                }), z.attr({
                  "class": "highcharts-halo highcharts-color-" + y(this.colorIndex, f.colorIndex) + (this.className ? " " + this.className : ""),
                  visibility: q,
                  zIndex: -1
                }), z.point = this, k.styledMode || z.attr(l({
                  fill: this.color || f.color,
                  "fill-opacity": h.opacity
                }, d.filterUserAttributes(h.attributes || {})))) : z && z.point && z.point.haloPath && z.animate({
                  d: z.point.haloPath(0)
                }, null, z.hide);
                a(this, "afterSetState", {
                  state: e
                });
              }
            };

            r.prototype.haloPath = function (e) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - e, this.plotY - e, 2 * e, 2 * e);
            };

            return r;
          }();

          "";
          return g;
        });
        P(g, "Core/Pointer.js", [g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Tooltip.js"], g["Core/Utilities.js"]], function (d, g, B, E) {
          var x = d.parse,
              C = g.charts,
              I = g.noop,
              A = E.addEvent,
              t = E.attr,
              q = E.css,
              c = E.defined,
              l = E.extend,
              a = E.find,
              k = E.fireEvent,
              v = E.isNumber,
              m = E.isObject,
              N = E.objectEach,
              F = E.offset,
              L = E.pick,
              J = E.splat;

          d = function () {
            function d(a, c) {
              this.lastValidTouch = {};
              this.pinchDown = [];
              this.runChartClick = !1;
              this.eventsToUnbind = [];
              this.chart = a;
              this.hasDragged = !1;
              this.options = c;
              this.init(a, c);
            }

            d.prototype.applyInactiveState = function (a) {
              var c = [],
                  e;
              (a || []).forEach(function (a) {
                e = a.series;
                c.push(e);
                e.linkedParent && c.push(e.linkedParent);
                e.linkedSeries && (c = c.concat(e.linkedSeries));
                e.navigatorSeries && c.push(e.navigatorSeries);
              });
              this.chart.series.forEach(function (e) {
                -1 === c.indexOf(e) ? e.setState("inactive", !0) : e.options.inactiveOtherPoints && e.setAllPointsToState("inactive");
              });
            };

            d.prototype.destroy = function () {
              var a = this;
              this.eventsToUnbind.forEach(function (a) {
                return a();
              });
              this.eventsToUnbind = [];
              g.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));
              clearInterval(a.tooltipTimeout);
              N(a, function (c, e) {
                a[e] = void 0;
              });
            };

            d.prototype.drag = function (a) {
              var c = this.chart,
                  e = c.options.chart,
                  d = this.zoomHor,
                  h = this.zoomVert,
                  n = c.plotLeft,
                  f = c.plotTop,
                  b = c.plotWidth,
                  k = c.plotHeight,
                  l = this.mouseDownX || 0,
                  p = this.mouseDownY || 0,
                  u = m(e.panning) ? e.panning && e.panning.enabled : e.panning,
                  z = e.panKey && a[e.panKey + "Key"],
                  q = a.chartX,
                  g = a.chartY,
                  y = this.selectionMarker;
              if (!y || !y.touch) if (q < n ? q = n : q > n + b && (q = n + b), g < f ? g = f : g > f + k && (g = f + k), this.hasDragged = Math.sqrt(Math.pow(l - q, 2) + Math.pow(p - g, 2)), 10 < this.hasDragged) {
                var t = c.isInsidePlot(l - n, p - f, {
                  visiblePlotOnly: !0
                });
                !c.hasCartesianSeries && !c.mapView || !this.zoomX && !this.zoomY || !t || z || y || (this.selectionMarker = y = c.renderer.rect(n, f, d ? 1 : b, h ? 1 : k, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add(), c.styledMode || y.attr({
                  fill: e.selectionMarkerFill || x("#335cad").setOpacity(.25).get()
                }));
                y && d && (d = q - l, y.attr({
                  width: Math.abs(d),
                  x: (0 < d ? 0 : d) + l
                }));
                y && h && (d = g - p, y.attr({
                  height: Math.abs(d),
                  y: (0 < d ? 0 : d) + p
                }));
                t && !y && u && c.pan(a, e.panning);
              }
            };

            d.prototype.dragStart = function (a) {
              var c = this.chart;
              c.mouseIsDown = a.type;
              c.cancelClick = !1;
              c.mouseDownX = this.mouseDownX = a.chartX;
              c.mouseDownY = this.mouseDownY = a.chartY;
            };

            d.prototype.drop = function (a) {
              var d = this,
                  e = this.chart,
                  r = this.hasPinched;

              if (this.selectionMarker) {
                var h = this.selectionMarker,
                    n = h.attr ? h.attr("x") : h.x,
                    f = h.attr ? h.attr("y") : h.y,
                    b = h.attr ? h.attr("width") : h.width,
                    m = h.attr ? h.attr("height") : h.height,
                    z = {
                  originalEvent: a,
                  xAxis: [],
                  yAxis: [],
                  x: n,
                  y: f,
                  width: b,
                  height: m
                },
                    p = !!e.mapView;
                if (this.hasDragged || r) e.axes.forEach(function (e) {
                  if (e.zoomEnabled && c(e.min) && (r || d[{
                    xAxis: "zoomX",
                    yAxis: "zoomY"
                  }[e.coll]]) && v(n) && v(f)) {
                    var h = e.horiz,
                        u = "touchend" === a.type ? e.minPixelPadding : 0,
                        w = e.toValue((h ? n : f) + u);
                    h = e.toValue((h ? n + b : f + m) - u);
                    z[e.coll].push({
                      axis: e,
                      min: Math.min(w, h),
                      max: Math.max(w, h)
                    });
                    p = !0;
                  }
                }), p && k(e, "selection", z, function (b) {
                  e.zoom(l(b, r ? {
                    animation: !1
                  } : null));
                });
                v(e.index) && (this.selectionMarker = this.selectionMarker.destroy());
                r && this.scaleGroups();
              }

              e && v(e.index) && (q(e.container, {
                cursor: e._cursor
              }), e.cancelClick = 10 < this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
            };

            d.prototype.findNearestKDPoint = function (a, c, e) {
              var d = this.chart,
                  h = d.hoverPoint;
              d = d.tooltip;
              if (h && d && d.isStickyOnContact()) return h;
              var n;
              a.forEach(function (f) {
                var b = !(f.noSharedTooltip && c) && 0 > f.options.findNearestPointBy.indexOf("y");
                f = f.searchPoint(e, b);

                if ((b = m(f, !0) && f.series) && !(b = !m(n, !0))) {
                  b = n.distX - f.distX;
                  var a = n.dist - f.dist,
                      h = (f.series.group && f.series.group.zIndex) - (n.series.group && n.series.group.zIndex);
                  b = 0 < (0 !== b && c ? b : 0 !== a ? a : 0 !== h ? h : n.series.index > f.series.index ? -1 : 1);
                }

                b && (n = f);
              });
              return n;
            };

            d.prototype.getChartCoordinatesFromPoint = function (a, c) {
              var e = a.series,
                  d = e.xAxis;
              e = e.yAxis;
              var h = a.shapeArgs;

              if (d && e) {
                var n = L(a.clientX, a.plotX),
                    f = a.plotY || 0;
                a.isNode && h && v(h.x) && v(h.y) && (n = h.x, f = h.y);
                return c ? {
                  chartX: e.len + e.pos - f,
                  chartY: d.len + d.pos - n
                } : {
                  chartX: n + d.pos,
                  chartY: f + e.pos
                };
              }

              if (h && h.x && h.y) return {
                chartX: h.x,
                chartY: h.y
              };
            };

            d.prototype.getChartPosition = function () {
              if (this.chartPosition) return this.chartPosition;
              var a = this.chart.container,
                  c = F(a);
              this.chartPosition = {
                left: c.left,
                top: c.top,
                scaleX: 1,
                scaleY: 1
              };
              var e = a.offsetWidth;
              a = a.offsetHeight;
              2 < e && 2 < a && (this.chartPosition.scaleX = c.width / e, this.chartPosition.scaleY = c.height / a);
              return this.chartPosition;
            };

            d.prototype.getCoordinates = function (a) {
              var c = {
                xAxis: [],
                yAxis: []
              };
              this.chart.axes.forEach(function (e) {
                c[e.isXAxis ? "xAxis" : "yAxis"].push({
                  axis: e,
                  value: e.toValue(a[e.horiz ? "chartX" : "chartY"])
                });
              });
              return c;
            };

            d.prototype.getHoverData = function (c, d, e, r, h, n) {
              var f = [];
              r = !(!r || !c);
              var b = {
                chartX: n ? n.chartX : void 0,
                chartY: n ? n.chartY : void 0,
                shared: h
              };
              k(this, "beforeGetHoverData", b);
              var w = d && !d.stickyTracking ? [d] : e.filter(function (f) {
                return b.filter ? b.filter(f) : f.visible && !(!h && f.directTouch) && L(f.options.enableMouseTracking, !0) && f.stickyTracking;
              });
              var l = r || !n ? c : this.findNearestKDPoint(w, h, n);
              d = l && l.series;
              l && (h && !d.noSharedTooltip ? (w = e.filter(function (f) {
                return b.filter ? b.filter(f) : f.visible && !(!h && f.directTouch) && L(f.options.enableMouseTracking, !0) && !f.noSharedTooltip;
              }), w.forEach(function (b) {
                var e = a(b.points, function (b) {
                  return b.x === l.x && !b.isNull;
                });
                m(e) && (b.chart.isBoosting && (e = b.getPoint(e)), f.push(e));
              })) : f.push(l));
              b = {
                hoverPoint: l
              };
              k(this, "afterGetHoverData", b);
              return {
                hoverPoint: b.hoverPoint,
                hoverSeries: d,
                hoverPoints: f
              };
            };

            d.prototype.getPointFromEvent = function (a) {
              a = a.target;

              for (var c; a && !c;) {
                c = a.point, a = a.parentNode;
              }

              return c;
            };

            d.prototype.onTrackerMouseOut = function (a) {
              a = a.relatedTarget || a.toElement;
              var c = this.chart.hoverSeries;
              this.isDirectTouch = !1;
              if (!(!c || !a || c.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + c.index) && this.inClass(a, "highcharts-tracker"))) c.onMouseOut();
            };

            d.prototype.inClass = function (a, c) {
              for (var e; a;) {
                if (e = t(a, "class")) {
                  if (-1 !== e.indexOf(c)) return !0;
                  if (-1 !== e.indexOf("highcharts-container")) return !1;
                }

                a = a.parentElement;
              }
            };

            d.prototype.init = function (a, c) {
              this.options = c;
              this.chart = a;
              this.runChartClick = !(!c.chart.events || !c.chart.events.click);
              this.pinchDown = [];
              this.lastValidTouch = {};
              B && (a.tooltip = new B(a, c.tooltip), this.followTouchMove = L(c.tooltip.followTouchMove, !0));
              this.setDOMEvents();
            };

            d.prototype.normalize = function (a, c) {
              var e = a.touches,
                  d = e ? e.length ? e.item(0) : L(e.changedTouches, a.changedTouches)[0] : a;
              c || (c = this.getChartPosition());
              e = d.pageX - c.left;
              d = d.pageY - c.top;
              e /= c.scaleX;
              d /= c.scaleY;
              return l(a, {
                chartX: Math.round(e),
                chartY: Math.round(d)
              });
            };

            d.prototype.onContainerClick = function (a) {
              var c = this.chart,
                  e = c.hoverPoint;
              a = this.normalize(a);
              var d = c.plotLeft,
                  h = c.plotTop;
              c.cancelClick || (e && this.inClass(a.target, "highcharts-tracker") ? (k(e.series, "click", l(a, {
                point: e
              })), c.hoverPoint && e.firePointEvent("click", a)) : (l(a, this.getCoordinates(a)), c.isInsidePlot(a.chartX - d, a.chartY - h, {
                visiblePlotOnly: !0
              }) && k(c, "click", a)));
            };

            d.prototype.onContainerMouseDown = function (a) {
              var c = 1 === ((a.buttons || a.button) & 1);
              a = this.normalize(a);
              if (g.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
              if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);
            };

            d.prototype.onContainerMouseLeave = function (a) {
              var c = C[L(d.hoverChartIndex, -1)],
                  e = this.chart.tooltip;
              e && e.shouldStickOnContact() && this.inClass(a.relatedTarget, "highcharts-tooltip-container") || (a = this.normalize(a), c && (a.relatedTarget || a.toElement) && (c.pointer.reset(), c.pointer.chartPosition = void 0), e && !e.isHidden && this.reset());
            };

            d.prototype.onContainerMouseEnter = function (a) {
              delete this.chartPosition;
            };

            d.prototype.onContainerMouseMove = function (a) {
              var c = this.chart;
              a = this.normalize(a);
              this.setHoverChartIndex();
              a.preventDefault || (a.returnValue = !1);
              ("mousedown" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);
              c.openMenu || !this.inClass(a.target, "highcharts-tracker") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
            };

            d.prototype.onDocumentTouchEnd = function (a) {
              var c = C[L(d.hoverChartIndex, -1)];
              c && c.pointer.drop(a);
            };

            d.prototype.onContainerTouchMove = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
            };

            d.prototype.onContainerTouchStart = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
            };

            d.prototype.onDocumentMouseMove = function (a) {
              var c = this.chart,
                  e = this.chartPosition;
              a = this.normalize(a, e);
              var d = c.tooltip;
              !e || d && d.isStickyOnContact() || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
            };

            d.prototype.onDocumentMouseUp = function (a) {
              var c = C[L(d.hoverChartIndex, -1)];
              c && c.pointer.drop(a);
            };

            d.prototype.pinch = function (a) {
              var c = this,
                  e = c.chart,
                  d = c.pinchDown,
                  h = a.touches || [],
                  n = h.length,
                  f = c.lastValidTouch,
                  b = c.hasZoom,
                  m = {},
                  H = 1 === n && (c.inClass(a.target, "highcharts-tracker") && e.runTrackerClick || c.runChartClick),
                  p = {},
                  u = c.selectionMarker;
              1 < n ? c.initiated = !0 : 1 === n && this.followTouchMove && (c.initiated = !1);
              b && c.initiated && !H && !1 !== a.cancelable && a.preventDefault();
              [].map.call(h, function (b) {
                return c.normalize(b);
              });
              "touchstart" === a.type ? ([].forEach.call(h, function (b, f) {
                d[f] = {
                  chartX: b.chartX,
                  chartY: b.chartY
                };
              }), f.x = [d[0].chartX, d[1] && d[1].chartX], f.y = [d[0].chartY, d[1] && d[1].chartY], e.axes.forEach(function (b) {
                if (b.zoomEnabled) {
                  var f = e.bounds[b.horiz ? "h" : "v"],
                      a = b.minPixelPadding,
                      c = b.toPixels(Math.min(L(b.options.min, b.dataMin), b.dataMin)),
                      h = b.toPixels(Math.max(L(b.options.max, b.dataMax), b.dataMax)),
                      p = Math.max(c, h);
                  f.min = Math.min(b.pos, Math.min(c, h) - a);
                  f.max = Math.max(b.pos + b.len, p + a);
                }
              }), c.res = !0) : c.followTouchMove && 1 === n ? this.runPointActions(c.normalize(a)) : d.length && (k(e, "touchpan", {
                originalEvent: a
              }, function () {
                u || (c.selectionMarker = u = l({
                  destroy: I,
                  touch: !0
                }, e.plotBox));
                c.pinchTranslate(d, h, m, u, p, f);
                c.hasPinched = b;
                c.scaleGroups(m, p);
              }), c.res && (c.res = !1, this.reset(!1, 0)));
            };

            d.prototype.pinchTranslate = function (a, c, e, d, h, n) {
              this.zoomHor && this.pinchTranslateDirection(!0, a, c, e, d, h, n);
              this.zoomVert && this.pinchTranslateDirection(!1, a, c, e, d, h, n);
            };

            d.prototype.pinchTranslateDirection = function (a, c, e, d, h, n, f, b) {
              var k = this.chart,
                  r = a ? "x" : "y",
                  p = a ? "X" : "Y",
                  u = "chart" + p,
                  m = a ? "width" : "height",
                  l = k["plot" + (a ? "Left" : "Top")],
                  w = k.inverted,
                  q = k.bounds[a ? "h" : "v"],
                  g = 1 === c.length,
                  z = c[0][u],
                  y = !g && c[1][u];

              c = function c() {
                "number" === typeof F && 20 < Math.abs(z - y) && (v = b || Math.abs(S - F) / Math.abs(z - y));
                Q = (l - S) / v + z;
                t = k["plot" + (a ? "Width" : "Height")] / v;
              };

              var t,
                  Q,
                  v = b || 1,
                  S = e[0][u],
                  F = !g && e[1][u];
              c();
              e = Q;

              if (e < q.min) {
                e = q.min;
                var L = !0;
              } else e + t > q.max && (e = q.max - t, L = !0);

              L ? (S -= .8 * (S - f[r][0]), "number" === typeof F && (F -= .8 * (F - f[r][1])), c()) : f[r] = [S, F];
              w || (n[r] = Q - l, n[m] = t);
              n = w ? 1 / v : v;
              h[m] = t;
              h[r] = e;
              d[w ? a ? "scaleY" : "scaleX" : "scale" + p] = v;
              d["translate" + p] = n * l + (S - n * z);
            };

            d.prototype.reset = function (a, c) {
              var e = this.chart,
                  d = e.hoverSeries,
                  h = e.hoverPoint,
                  n = e.hoverPoints,
                  f = e.tooltip,
                  b = f && f.shared ? n : h;
              a && b && J(b).forEach(function (b) {
                b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
              });
              if (a) f && b && J(b).length && (f.refresh(b), f.shared && n ? n.forEach(function (b) {
                b.setState(b.state, !0);
                b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
              }) : h && (h.setState(h.state, !0), e.axes.forEach(function (b) {
                b.crosshair && h.series[b.coll] === b && b.drawCrosshair(null, h);
              })));else {
                if (h) h.onMouseOut();
                n && n.forEach(function (b) {
                  b.setState();
                });
                if (d) d.onMouseOut();
                f && f.hide(c);
                this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                e.axes.forEach(function (b) {
                  b.hideCrosshair();
                });
                this.hoverX = e.hoverPoints = e.hoverPoint = null;
              }
            };

            d.prototype.runPointActions = function (c, k) {
              var e = this.chart,
                  r = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,
                  h = r ? r.shared : !1,
                  n = k || e.hoverPoint,
                  f = n && n.series || e.hoverSeries;
              k = this.getHoverData(n, f, e.series, (!c || "touchmove" !== c.type) && (!!k || f && f.directTouch && this.isDirectTouch), h, c);
              n = k.hoverPoint;
              f = k.hoverSeries;
              var b = k.hoverPoints;
              k = f && f.tooltipOptions.followPointer && !f.tooltipOptions.split;
              var m = h && f && !f.noSharedTooltip;

              if (n && (n !== e.hoverPoint || r && r.isHidden)) {
                (e.hoverPoints || []).forEach(function (f) {
                  -1 === b.indexOf(f) && f.setState();
                });
                if (e.hoverSeries !== f) f.onMouseOver();
                this.applyInactiveState(b);
                (b || []).forEach(function (b) {
                  b.setState("hover");
                });
                e.hoverPoint && e.hoverPoint.firePointEvent("mouseOut");
                if (!n.series) return;
                e.hoverPoints = b;
                e.hoverPoint = n;
                n.firePointEvent("mouseOver", void 0, function () {
                  r && n && r.refresh(m ? b : n, c);
                });
              } else k && r && !r.isHidden && (h = r.getAnchor([{}], c), e.isInsidePlot(h[0], h[1], {
                visiblePlotOnly: !0
              }) && r.updatePosition({
                plotX: h[0],
                plotY: h[1]
              }));

              this.unDocMouseMove || (this.unDocMouseMove = A(e.container.ownerDocument, "mousemove", function (b) {
                var f = C[d.hoverChartIndex];
                if (f) f.pointer.onDocumentMouseMove(b);
              }), this.eventsToUnbind.push(this.unDocMouseMove));
              e.axes.forEach(function (f) {
                var h = L((f.crosshair || {}).snap, !0),
                    d;
                h && ((d = e.hoverPoint) && d.series[f.coll] === f || (d = a(b, function (b) {
                  return b.series && b.series[f.coll] === f;
                })));
                d || !h ? f.drawCrosshair(c, d) : f.hideCrosshair();
              });
            };

            d.prototype.scaleGroups = function (a, c) {
              var e = this.chart;
              e.series.forEach(function (d) {
                var h = a || d.getPlotBox();
                d.group && (d.xAxis && d.xAxis.zoomEnabled || e.mapView) && (d.group.attr(h), d.markerGroup && (d.markerGroup.attr(h), d.markerGroup.clip(c ? e.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(h));
              });
              e.clipRect.attr(c || e.clipBox);
            };

            d.prototype.setDOMEvents = function () {
              var a = this,
                  c = this.chart.container,
                  e = c.ownerDocument;
              c.onmousedown = this.onContainerMouseDown.bind(this);
              c.onmousemove = this.onContainerMouseMove.bind(this);
              c.onclick = this.onContainerClick.bind(this);
              this.eventsToUnbind.push(A(c, "mouseenter", this.onContainerMouseEnter.bind(this)));
              this.eventsToUnbind.push(A(c, "mouseleave", this.onContainerMouseLeave.bind(this)));
              d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = A(e, "mouseup", this.onDocumentMouseUp.bind(this)));

              for (var k = this.chart.renderTo.parentElement; k && "BODY" !== k.tagName;) {
                this.eventsToUnbind.push(A(k, "scroll", function () {
                  delete a.chartPosition;
                })), k = k.parentElement;
              }

              g.hasTouch && (this.eventsToUnbind.push(A(c, "touchstart", this.onContainerTouchStart.bind(this), {
                passive: !1
              })), this.eventsToUnbind.push(A(c, "touchmove", this.onContainerTouchMove.bind(this), {
                passive: !1
              })), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = A(e, "touchend", this.onDocumentTouchEnd.bind(this), {
                passive: !1
              })));
            };

            d.prototype.setHoverChartIndex = function () {
              var a = this.chart,
                  c = g.charts[L(d.hoverChartIndex, -1)];
              if (c && c !== a) c.pointer.onContainerMouseLeave({
                relatedTarget: a.container
              });
              c && c.mouseIsDown || (d.hoverChartIndex = a.index);
            };

            d.prototype.touch = function (a, c) {
              var e = this.chart,
                  d;
              this.setHoverChartIndex();
              if (1 === a.touches.length) {
                if (a = this.normalize(a), (d = e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {
                  visiblePlotOnly: !0
                })) && !e.openMenu) {
                  c && this.runPointActions(a);

                  if ("touchmove" === a.type) {
                    c = this.pinchDown;
                    var h = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1;
                  }

                  L(h, !0) && this.pinch(a);
                } else c && this.reset();
              } else 2 === a.touches.length && this.pinch(a);
            };

            d.prototype.touchSelect = function (a) {
              return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
            };

            d.prototype.zoomOption = function (a) {
              var c = this.chart,
                  e = c.options.chart;
              c = c.inverted;
              var d = e.zoomType || "";
              /touch/.test(a.type) && (d = L(e.pinchType, d));
              this.zoomX = a = /x/.test(d);
              this.zoomY = e = /y/.test(d);
              this.zoomHor = a && !c || e && c;
              this.zoomVert = e && !c || a && c;
              this.hasZoom = a || e;
            };

            return d;
          }();

          "";
          return d;
        });
        P(g, "Core/MSPointer.js", [g["Core/Globals.js"], g["Core/Pointer.js"], g["Core/Utilities.js"]], function (d, g, B) {
          function C() {
            var c = [];

            c.item = function (a) {
              return this[a];
            };

            a(v, function (a) {
              c.push({
                pageX: a.pageX,
                pageY: a.pageY,
                target: a.target
              });
            });
            return c;
          }

          function x(a, c, d, k) {
            var m = I[g.hoverChartIndex || NaN];
            "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !m || (m = m.pointer, k(a), m[c]({
              type: d,
              target: a.currentTarget,
              preventDefault: t,
              touches: C()
            }));
          }

          var G = this && this.__extends || function () {
            var _a3 = function a(c, d) {
              _a3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _a3(c, d);
            };

            return function (c, d) {
              function k() {
                this.constructor = c;
              }

              _a3(c, d);

              c.prototype = null === d ? Object.create(d) : (k.prototype = d.prototype, new k());
            };
          }(),
              I = d.charts,
              A = d.doc,
              t = d.noop,
              q = d.win,
              c = B.addEvent,
              l = B.css,
              a = B.objectEach,
              k = B.removeEvent,
              v = {},
              m = !!q.PointerEvent;

          return function (a) {
            function g() {
              return null !== a && a.apply(this, arguments) || this;
            }

            G(g, a);

            g.isRequired = function () {
              return !(d.hasTouch || !q.PointerEvent && !q.MSPointerEvent);
            };

            g.prototype.batchMSEvents = function (a) {
              a(this.chart.container, m ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              a(this.chart.container, m ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              a(A, m ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };

            g.prototype.destroy = function () {
              this.batchMSEvents(k);
              a.prototype.destroy.call(this);
            };

            g.prototype.init = function (c, d) {
              a.prototype.init.call(this, c, d);
              this.hasZoom && l(c.container, {
                "-ms-touch-action": "none",
                "touch-action": "none"
              });
            };

            g.prototype.onContainerPointerDown = function (a) {
              x(a, "onContainerTouchStart", "touchstart", function (a) {
                v[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY,
                  target: a.currentTarget
                };
              });
            };

            g.prototype.onContainerPointerMove = function (a) {
              x(a, "onContainerTouchMove", "touchmove", function (a) {
                v[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY
                };
                v[a.pointerId].target || (v[a.pointerId].target = a.currentTarget);
              });
            };

            g.prototype.onDocumentPointerUp = function (a) {
              x(a, "onDocumentTouchEnd", "touchend", function (a) {
                delete v[a.pointerId];
              });
            };

            g.prototype.setDOMEvents = function () {
              a.prototype.setDOMEvents.call(this);
              (this.hasZoom || this.followTouchMove) && this.batchMSEvents(c);
            };

            return g;
          }(g);
        });
        P(g, "Core/Legend/Legend.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Series/Point.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G) {
          var C = d.animObject,
              A = d.setAnimation,
              t = g.format;
          d = B.isFirefox;
          var q = B.marginNames;
          B = B.win;
          var c = x.distribute,
              l = G.addEvent,
              a = G.createElement,
              k = G.css,
              v = G.defined,
              m = G.discardElement,
              N = G.find,
              F = G.fireEvent,
              L = G.isNumber,
              J = G.merge,
              y = G.pick,
              z = G.relativeLength,
              w = G.stableSort,
              e = G.syncTimeout;
          x = G.wrap;

          G = function () {
            function d(e, a) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = !1;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = void 0;
              this.padding = 0;
              this.pages = [];
              this.proximate = !1;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = e;
              this.init(e, a);
            }

            d.prototype.init = function (e, a) {
              this.chart = e;
              this.setOptions(a);
              a.enabled && (this.render(), l(this.chart, "endResize", function () {
                this.legend.positionCheckboxes();
              }), this.proximate ? this.unchartrender = l(this.chart, "render", function () {
                this.legend.proximatePositions();
                this.legend.positionItems();
              }) : this.unchartrender && this.unchartrender());
            };

            d.prototype.setOptions = function (e) {
              var a = y(e.padding, 8);
              this.options = e;
              this.chart.styledMode || (this.itemStyle = e.itemStyle, this.itemHiddenStyle = J(this.itemStyle, e.itemHiddenStyle));
              this.itemMarginTop = e.itemMarginTop || 0;
              this.itemMarginBottom = e.itemMarginBottom || 0;
              this.padding = a;
              this.initialItemY = a - 5;
              this.symbolWidth = y(e.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === e.layout && !this.chart.inverted;
              this.baseline = void 0;
            };

            d.prototype.update = function (e, a) {
              var f = this.chart;
              this.setOptions(J(!0, this.options, e));
              this.destroy();
              f.isDirtyLegend = f.isDirtyBox = !0;
              y(a, !0) && f.redraw();
              F(this, "afterUpdate");
            };

            d.prototype.colorizeItem = function (e, a) {
              e.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

              if (!this.chart.styledMode) {
                var f = this.options,
                    b = e.legendItem,
                    c = e.legendLine,
                    h = e.legendSymbol,
                    d = this.itemHiddenStyle.color;
                f = a ? f.itemStyle.color : d;
                var n = a ? e.color || d : d,
                    k = e.options && e.options.marker,
                    m = {
                  fill: n
                };
                b && b.css({
                  fill: f,
                  color: f
                });
                c && c.attr({
                  stroke: n
                });
                h && (k && h.isMarker && (m = e.pointAttribs(), a || (m.stroke = m.fill = d)), h.attr(m));
              }

              F(this, "afterColorizeItem", {
                item: e,
                visible: a
              });
            };

            d.prototype.positionItems = function () {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            };

            d.prototype.positionItem = function (e) {
              var a = this,
                  f = this.options,
                  b = f.symbolPadding,
                  c = !f.rtl,
                  h = e._legendItemPos;
              f = h[0];
              h = h[1];
              var d = e.checkbox,
                  u = e.legendGroup;
              u && u.element && (b = {
                translateX: c ? f : this.legendWidth - f - 2 * b - 4,
                translateY: h
              }, c = function c() {
                F(a, "afterPositionItem", {
                  item: e
                });
              }, v(u.translateY) ? u.animate(b, void 0, c) : (u.attr(b), c()));
              d && (d.x = f, d.y = h);
            };

            d.prototype.destroyItem = function (e) {
              var a = e.checkbox;
              ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (f) {
                e[f] && (e[f] = e[f].destroy());
              });
              a && m(e.checkbox);
            };

            d.prototype.destroy = function () {
              function e(e) {
                this[e] && (this[e] = this[e].destroy());
              }

              this.getAllItems().forEach(function (a) {
                ["legendItem", "legendGroup"].forEach(e, a);
              });
              "clipRect up down pager nav box title group".split(" ").forEach(e, this);
              this.display = null;
            };

            d.prototype.positionCheckboxes = function () {
              var e = this.group && this.group.alignAttr,
                  a = this.clipHeight || this.legendHeight,
                  f = this.titleHeight;

              if (e) {
                var b = e.translateY;
                this.allItems.forEach(function (c) {
                  var h = c.checkbox;

                  if (h) {
                    var d = b + f + h.y + (this.scrollOffset || 0) + 3;
                    k(h, {
                      left: e.translateX + c.checkboxOffset + h.x - 20 + "px",
                      top: d + "px",
                      display: this.proximate || d > b - 6 && d < b + a - 6 ? "" : "none"
                    });
                  }
                }, this);
              }
            };

            d.prototype.renderTitle = function () {
              var e = this.options,
                  a = this.padding,
                  f = e.title,
                  b = 0;
              f.text && (this.title || (this.title = this.chart.renderer.label(f.text, a - 3, a - 4, void 0, void 0, void 0, e.useHTML, void 0, "legend-title").attr({
                zIndex: 1
              }), this.chart.styledMode || this.title.css(f.style), this.title.add(this.group)), f.width || this.title.css({
                width: this.maxLegendWidth + "px"
              }), e = this.title.getBBox(), b = e.height, this.offsetWidth = e.width, this.contentGroup.attr({
                translateY: b
              }));
              this.titleHeight = b;
            };

            d.prototype.setText = function (e) {
              var a = this.options;
              e.legendItem.attr({
                text: a.labelFormat ? t(a.labelFormat, e, this.chart) : a.labelFormatter.call(e)
              });
            };

            d.prototype.renderItem = function (e) {
              var a = this.chart,
                  f = a.renderer,
                  b = this.options,
                  c = this.symbolWidth,
                  h = b.symbolPadding || 0,
                  d = this.itemStyle,
                  u = this.itemHiddenStyle,
                  k = "horizontal" === b.layout ? y(b.itemDistance, 20) : 0,
                  m = !b.rtl,
                  l = !e.series,
                  r = !l && e.series.drawLegendSymbol ? e.series : e,
                  q = r.options,
                  g = this.createCheckboxForItem && q && q.showCheckbox,
                  w = b.useHTML,
                  t = e.options.className,
                  Q = e.legendItem;
              q = c + h + k + (g ? 20 : 0);
              Q || (e.legendGroup = f.g("legend-item").addClass("highcharts-" + r.type + "-series highcharts-color-" + e.colorIndex + (t ? " " + t : "") + (l ? " highcharts-series-" + e.index : "")).attr({
                zIndex: 1
              }).add(this.scrollGroup), e.legendItem = Q = f.text("", m ? c + h : -h, this.baseline || 0, w), a.styledMode || Q.css(J(e.visible ? d : u)), Q.attr({
                align: m ? "left" : "right",
                zIndex: 2
              }).add(e.legendGroup), this.baseline || (this.fontMetrics = f.fontMetrics(a.styledMode ? 12 : d.fontSize, Q), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, Q.attr("y", this.baseline), this.symbolHeight = b.symbolHeight || this.fontMetrics.f, b.squareSymbol && (this.symbolWidth = y(b.symbolWidth, Math.max(this.symbolHeight, 16)), q = this.symbolWidth + h + k + (g ? 20 : 0), m && Q.attr("x", this.symbolWidth + h))), r.drawLegendSymbol(this, e), this.setItemEvents && this.setItemEvents(e, Q, w));
              g && !e.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(e);
              this.colorizeItem(e, e.visible);
              !a.styledMode && d.width || Q.css({
                width: (b.itemWidth || this.widthOption || a.spacingBox.width) - q + "px"
              });
              this.setText(e);
              a = Q.getBBox();
              f = this.fontMetrics && this.fontMetrics.h || 0;
              e.itemWidth = e.checkboxOffset = b.itemWidth || e.legendItemWidth || a.width + q;
              this.maxItemWidth = Math.max(this.maxItemWidth, e.itemWidth);
              this.totalItemWidth += e.itemWidth;
              this.itemHeight = e.itemHeight = Math.round(e.legendItemHeight || (a.height > 1.5 * f ? a.height : f));
            };

            d.prototype.layoutItem = function (e) {
              var a = this.options,
                  f = this.padding,
                  b = "horizontal" === a.layout,
                  c = e.itemHeight,
                  h = this.itemMarginBottom,
                  d = this.itemMarginTop,
                  u = b ? y(a.itemDistance, 20) : 0,
                  k = this.maxLegendWidth;
              a = a.alignColumns && this.totalItemWidth > k ? this.maxItemWidth : e.itemWidth;
              b && this.itemX - f + a > k && (this.itemX = f, this.lastLineHeight && (this.itemY += d + this.lastLineHeight + h), this.lastLineHeight = 0);
              this.lastItemY = d + this.itemY + h;
              this.lastLineHeight = Math.max(c, this.lastLineHeight);
              e._legendItemPos = [this.itemX, this.itemY];
              b ? this.itemX += a : (this.itemY += d + c + h, this.lastLineHeight = c);
              this.offsetWidth = this.widthOption || Math.max((b ? this.itemX - f - (e.checkbox ? 0 : u) : a) + f, this.offsetWidth);
            };

            d.prototype.getAllItems = function () {
              var e = [];
              this.chart.series.forEach(function (a) {
                var f = a && a.options;
                a && y(f.showInLegend, v(f.linkedTo) ? !1 : void 0, !0) && (e = e.concat(a.legendItems || ("point" === f.legendType ? a.data : a)));
              });
              F(this, "afterGetAllItems", {
                allItems: e
              });
              return e;
            };

            d.prototype.getAlignment = function () {
              var e = this.options;
              return this.proximate ? e.align.charAt(0) + "tv" : e.floating ? "" : e.align.charAt(0) + e.verticalAlign.charAt(0) + e.layout.charAt(0);
            };

            d.prototype.adjustMargins = function (e, a) {
              var f = this.chart,
                  b = this.options,
                  c = this.getAlignment();
              c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (d, h) {
                d.test(c) && !v(e[h]) && (f[q[h]] = Math.max(f[q[h]], f.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * b[h % 2 ? "x" : "y"] + y(b.margin, 12) + a[h] + (f.titleOffset[h] || 0)));
              });
            };

            d.prototype.proximatePositions = function () {
              var e = this.chart,
                  a = [],
                  f = "left" === this.options.align;
              this.allItems.forEach(function (b) {
                var c;
                var d = f;

                if (b.yAxis) {
                  b.xAxis.options.reversed && (d = !d);
                  b.points && (c = N(d ? b.points : b.points.slice(0).reverse(), function (b) {
                    return L(b.plotY);
                  }));
                  d = this.itemMarginTop + b.legendItem.getBBox().height + this.itemMarginBottom;
                  var h = b.yAxis.top - e.plotTop;
                  b.visible ? (c = c ? c.plotY : b.yAxis.height, c += h - .3 * d) : c = h + b.yAxis.height;
                  a.push({
                    target: c,
                    size: d,
                    item: b
                  });
                }
              }, this);
              c(a, e.plotHeight).forEach(function (b) {
                b.item._legendItemPos && b.pos && (b.item._legendItemPos[1] = e.plotTop - e.spacing[0] + b.pos);
              });
            };

            d.prototype.render = function () {
              var e = this.chart,
                  a = e.renderer,
                  f = this.options,
                  b = this.padding,
                  c = this.getAllItems(),
                  d = this.group,
                  p = this.box;
              this.itemX = b;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = z(f.width, e.spacingBox.width - b);
              var u = e.spacingBox.width - 2 * b - f.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (u /= 2);
              this.maxLegendWidth = this.widthOption || u;
              d || (this.group = d = a.g("legend").addClass(f.className || "").attr({
                zIndex: 7
              }).add(), this.contentGroup = a.g().attr({
                zIndex: 1
              }).add(d), this.scrollGroup = a.g().add(this.contentGroup));
              this.renderTitle();
              w(c, function (b, f) {
                return (b.options && b.options.legendIndex || 0) - (f.options && f.options.legendIndex || 0);
              });
              f.reversed && c.reverse();
              this.allItems = c;
              this.display = u = !!c.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              c.forEach(this.renderItem, this);
              c.forEach(this.layoutItem, this);
              c = (this.widthOption || this.offsetWidth) + b;
              var k = this.lastItemY + this.lastLineHeight + this.titleHeight;
              k = this.handleOverflow(k);
              k += b;
              p || (this.box = p = a.rect().addClass("highcharts-legend-box").attr({
                r: f.borderRadius
              }).add(d));
              e.styledMode || p.attr({
                stroke: f.borderColor,
                "stroke-width": f.borderWidth || 0,
                fill: f.backgroundColor || "none"
              }).shadow(f.shadow);
              if (0 < c && 0 < k) p[p.placed ? "animate" : "attr"](p.crisp.call({}, {
                x: 0,
                y: 0,
                width: c,
                height: k
              }, p.strokeWidth()));
              d[u ? "show" : "hide"]();
              e.styledMode && "none" === d.getStyle("display") && (c = k = 0);
              this.legendWidth = c;
              this.legendHeight = k;
              u && this.align();
              this.proximate || this.positionItems();
              F(this, "afterRender");
            };

            d.prototype.align = function (e) {
              void 0 === e && (e = this.chart.spacingBox);
              var a = this.chart,
                  f = this.options,
                  b = e.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? b += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (b -= a.titleOffset[2]);
              b !== e.y && (e = J(e, {
                y: b
              }));
              a.hasRendered || (this.group.placed = !1);
              this.group.align(J(f, {
                width: this.legendWidth,
                height: this.legendHeight,
                verticalAlign: this.proximate ? "top" : f.verticalAlign
              }), !0, e);
            };

            d.prototype.handleOverflow = function (e) {
              var a = this,
                  f = this.chart,
                  b = f.renderer,
                  c = this.options,
                  d = c.y,
                  h = "top" === c.verticalAlign,
                  u = this.padding,
                  k = c.maxHeight,
                  m = c.navigation,
                  l = y(m.animation, !0),
                  r = m.arrowSize || 12,
                  q = this.pages,
                  g = this.allItems,
                  w = function w(b) {
                "number" === typeof b ? F.attr({
                  height: b
                }) : F && (a.clipRect = F.destroy(), a.contentGroup.clip());
                a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + u + "px,9999px," + (u + b) + "px,0)" : "auto");
              },
                  t = function t(e) {
                a[e] = b.circle(0, 0, 1.3 * r).translate(r / 2, r / 2).add(v);
                f.styledMode || a[e].attr("fill", "rgba(0,0,0,0.0001)");
                return a[e];
              },
                  Q,
                  z;

              d = f.spacingBox.height + (h ? -d : d) - u;
              var v = this.nav,
                  F = this.clipRect;
              "horizontal" !== c.layout || "middle" === c.verticalAlign || c.floating || (d /= 2);
              k && (d = Math.min(d, k));
              q.length = 0;
              e && 0 < d && e > d && !1 !== m.enabled ? (this.clipHeight = Q = Math.max(d - 20 - this.titleHeight - u, 0), this.currentPage = y(this.currentPage, 1), this.fullHeight = e, g.forEach(function (b, f) {
                var e = b._legendItemPos[1],
                    a = Math.round(b.legendItem.getBBox().height),
                    c = q.length;
                if (!c || e - q[c - 1] > Q && (z || e) !== q[c - 1]) q.push(z || e), c++;
                b.pageIx = c - 1;
                z && (g[f - 1].pageIx = c - 1);
                f === g.length - 1 && e + a - q[c - 1] > Q && a <= Q && (q.push(e), b.pageIx = c);
                e !== z && (z = e);
              }), F || (F = a.clipRect = b.clipRect(0, u, 9999, 0), a.contentGroup.clip(F)), w(Q), v || (this.nav = v = b.g().attr({
                zIndex: 1
              }).add(this.group), this.up = b.symbol("triangle", 0, 0, r, r).add(v), t("upTracker").on("click", function () {
                a.scroll(-1, l);
              }), this.pager = b.text("", 15, 10).addClass("highcharts-legend-navigation"), !f.styledMode && m.style && this.pager.css(m.style), this.pager.add(v), this.down = b.symbol("triangle-down", 0, 0, r, r).add(v), t("downTracker").on("click", function () {
                a.scroll(1, l);
              })), a.scroll(0), e = d) : v && (w(), this.nav = v.destroy(), this.scrollGroup.attr({
                translateY: 1
              }), this.clipHeight = 0);
              return e;
            };

            d.prototype.scroll = function (a, c) {
              var f = this,
                  b = this.chart,
                  d = this.pages,
                  h = d.length,
                  p = this.clipHeight,
                  n = this.options.navigation,
                  k = this.pager,
                  m = this.padding,
                  r = this.currentPage + a;
              r > h && (r = h);
              0 < r && ("undefined" !== typeof c && A(c, b), this.nav.attr({
                translateX: m,
                translateY: p + this.padding + 7 + this.titleHeight,
                visibility: "inherit"
              }), [this.up, this.upTracker].forEach(function (b) {
                b.attr({
                  "class": 1 === r ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }), k.attr({
                text: r + "/" + h
              }), [this.down, this.downTracker].forEach(function (b) {
                b.attr({
                  x: 18 + this.pager.getBBox().width,
                  "class": r === h ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }, this), b.styledMode || (this.up.attr({
                fill: 1 === r ? n.inactiveColor : n.activeColor
              }), this.upTracker.css({
                cursor: 1 === r ? "default" : "pointer"
              }), this.down.attr({
                fill: r === h ? n.inactiveColor : n.activeColor
              }), this.downTracker.css({
                cursor: r === h ? "default" : "pointer"
              })), this.scrollOffset = -d[r - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: this.scrollOffset
              }), this.currentPage = r, this.positionCheckboxes(), a = C(y(c, b.renderer.globalAnimation, !0)), e(function () {
                F(f, "afterScroll", {
                  currentPage: r
                });
              }, a.duration));
            };

            d.prototype.setItemEvents = function (e, a, f) {
              var b = this,
                  c = b.chart.renderer.boxWrapper,
                  d = e instanceof E,
                  h = "highcharts-legend-" + (d ? "point" : "series") + "-active",
                  n = b.chart.styledMode,
                  k = function k(f) {
                b.allItems.forEach(function (b) {
                  e !== b && [b].concat(b.linkedSeries || []).forEach(function (b) {
                    b.setState(f, !d);
                  });
                });
              };

              (f ? [a, e.legendSymbol] : [e.legendGroup]).forEach(function (f) {
                if (f) f.on("mouseover", function () {
                  e.visible && k("inactive");
                  e.setState("hover");
                  e.visible && c.addClass(h);
                  n || a.css(b.options.itemHoverStyle);
                }).on("mouseout", function () {
                  b.chart.styledMode || a.css(J(e.visible ? b.itemStyle : b.itemHiddenStyle));
                  k("");
                  c.removeClass(h);
                  e.setState();
                }).on("click", function (b) {
                  var f = function f() {
                    e.setVisible && e.setVisible();
                    k(e.visible ? "inactive" : "");
                  };

                  c.removeClass(h);
                  b = {
                    browserEvent: b
                  };
                  e.firePointEvent ? e.firePointEvent("legendItemClick", b, f) : F(e, "legendItemClick", b, f);
                });
              });
            };

            d.prototype.createCheckboxForItem = function (e) {
              e.checkbox = a("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: e.selected,
                defaultChecked: e.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              l(e.checkbox, "click", function (a) {
                F(e.series || e, "checkboxClick", {
                  checked: a.target.checked,
                  item: e
                }, function () {
                  e.select();
                });
              });
            };

            return d;
          }();

          (/Trident\/7\.0/.test(B.navigator && B.navigator.userAgent) || d) && x(G.prototype, "positionItem", function (e, a) {
            var c = this,
                f = function f() {
              a._legendItemPos && e.call(c, a);
            };

            f();
            c.bubbleLegend || setTimeout(f);
          });
          "";
          return G;
        });
        P(g, "Core/Series/SeriesRegistry.js", [g["Core/Globals.js"], g["Core/DefaultOptions.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"]], function (d, g, B, E) {
          var x = g.defaultOptions,
              C = E.error,
              I = E.extendClass,
              A = E.merge,
              t;

          (function (q) {
            function c(c, a) {
              var d = x.plotOptions || {},
                  l = a.defaultOptions;
              a.prototype.pointClass || (a.prototype.pointClass = B);
              a.prototype.type = c;
              l && (d[c] = l);
              q.seriesTypes[c] = a;
            }

            q.seriesTypes = d.seriesTypes;

            q.getSeries = function (c, a) {
              void 0 === a && (a = {});
              var d = c.options.chart;
              d = a.type || d.type || d.defaultSeriesType || "";
              var l = q.seriesTypes[d];
              q || C(17, !0, c, {
                missingModuleFor: d
              });
              d = new l();
              "function" === typeof d.init && d.init(c, a);
              return d;
            };

            q.registerSeriesType = c;

            q.seriesType = function (d, a, k, g, m) {
              var l = x.plotOptions || {};
              a = a || "";
              l[d] = A(l[a], k);
              c(d, I(q.seriesTypes[a] || function () {}, g));
              q.seriesTypes[d].prototype.type = d;
              m && (q.seriesTypes[d].prototype.pointClass = I(B, m));
              return q.seriesTypes[d];
            };
          })(t || (t = {}));

          return t;
        });
        P(g, "Core/Chart/Chart.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/FormatUtilities.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Legend/Legend.js"], g["Core/MSPointer.js"], g["Core/DefaultOptions.js"], g["Core/Pointer.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Time.js"], g["Core/Utilities.js"], g["Core/Renderer/HTML/AST.js"]], function (d, g, B, E, x, G, I, A, t, q, c, l, a, k, v) {
          var m = d.animate,
              N = d.animObject,
              F = d.setAnimation,
              L = B.numberFormat,
              J = E.registerEventOptions,
              y = x.charts,
              z = x.doc,
              w = x.marginNames,
              e = x.svg,
              r = x.win,
              h = A.defaultOptions,
              n = A.defaultTime,
              f = c.seriesTypes,
              b = k.addEvent,
              D = k.attr,
              H = k.cleanRecursively,
              p = k.createElement,
              u = k.css,
              K = k.defined,
              T = k.discardElement,
              M = k.erase,
              O = k.error,
              X = k.extend,
              Z = k.find,
              C = k.fireEvent,
              aa = k.getStyle,
              Q = k.isArray,
              ba = k.isNumber,
              S = k.isObject,
              ca = k.isString,
              W = k.merge,
              V = k.objectEach,
              R = k.pick,
              da = k.pInt,
              ia = k.relativeLength,
              P = k.removeEvent,
              fa = k.splat,
              Y = k.syncTimeout,
              ja = k.uniqueKey;

          d = function () {
            function c(b, f, e) {
              this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
              this.sharedClips = {};
              this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
              this.getArgs(b, f, e);
            }

            c.chart = function (b, f, e) {
              return new c(b, f, e);
            };

            c.prototype.getArgs = function (b, f, e) {
              ca(b) || b.nodeName ? (this.renderTo = b, this.init(f, e)) : this.init(b, f);
            };

            c.prototype.init = function (b, f) {
              var e = b.plotOptions || {};
              C(this, "init", {
                args: arguments
              }, function () {
                var c = W(h, b),
                    d = c.chart;
                V(c.plotOptions, function (b, f) {
                  S(b) && (b.tooltip = e[f] && W(e[f].tooltip) || void 0);
                });
                c.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
                this.userOptions = b;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                  h: {},
                  v: {}
                };
                this.labelCollectors = [];
                this.callback = f;
                this.isResizing = 0;
                this.options = c;
                this.axes = [];
                this.series = [];
                this.time = b.time && Object.keys(b.time).length ? new a(b.time) : x.time;
                this.numberFormatter = d.numberFormatter || L;
                this.styledMode = d.styledMode;
                this.hasCartesianSeries = d.showAxes;
                this.index = y.length;
                y.push(this);
                x.chartCount++;
                J(this, d);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                C(this, "afterInit");
                this.firstRender();
              });
            };

            c.prototype.initSeries = function (b) {
              var e = this.options.chart;
              e = b.type || e.type || e.defaultSeriesType;
              var a = f[e];
              a || O(17, !0, this, {
                missingModuleFor: e
              });
              e = new a();
              "function" === typeof e.init && e.init(this, b);
              return e;
            };

            c.prototype.setSeriesData = function () {
              this.getSeriesOrderByLinks().forEach(function (b) {
                b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
              });
            };

            c.prototype.getSeriesOrderByLinks = function () {
              return this.series.concat().sort(function (b, f) {
                return b.linkedSeries.length || f.linkedSeries.length ? f.linkedSeries.length - b.linkedSeries.length : 0;
              });
            };

            c.prototype.orderSeries = function (b) {
              var f = this.series;
              b = b || 0;

              for (var e = f.length; b < e; ++b) {
                f[b] && (f[b].index = b, f[b].name = f[b].getName());
              }
            };

            c.prototype.isInsidePlot = function (b, f, e) {
              void 0 === e && (e = {});
              var a = this.inverted,
                  c = this.plotBox,
                  d = this.plotLeft,
                  h = this.plotTop,
                  p = this.scrollablePlotBox,
                  n = 0;
              var u = 0;
              e.visiblePlotOnly && this.scrollingContainer && (u = this.scrollingContainer, n = u.scrollLeft, u = u.scrollTop);
              var k = e.series;
              c = e.visiblePlotOnly && p || c;
              p = e.inverted ? f : b;
              f = e.inverted ? b : f;
              b = {
                x: p,
                y: f,
                isInsidePlot: !0
              };

              if (!e.ignoreX) {
                var m = k && (a ? k.yAxis : k.xAxis) || {
                  pos: d,
                  len: Infinity
                };
                p = e.paneCoordinates ? m.pos + p : d + p;
                p >= Math.max(n + d, m.pos) && p <= Math.min(n + d + c.width, m.pos + m.len) || (b.isInsidePlot = !1);
              }

              !e.ignoreY && b.isInsidePlot && (a = k && (a ? k.xAxis : k.yAxis) || {
                pos: h,
                len: Infinity
              }, e = e.paneCoordinates ? a.pos + f : h + f, e >= Math.max(u + h, a.pos) && e <= Math.min(u + h + c.height, a.pos + a.len) || (b.isInsidePlot = !1));
              C(this, "afterIsInsidePlot", b);
              return b.isInsidePlot;
            };

            c.prototype.redraw = function (b) {
              C(this, "beforeRedraw");
              var f = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                  e = this.series,
                  a = this.pointer,
                  c = this.legend,
                  d = this.userOptions.legend,
                  h = this.renderer,
                  p = h.isHidden(),
                  n = [],
                  u = this.isDirtyBox,
                  k = this.isDirtyLegend;
              this.setResponsive && this.setResponsive(!1);
              F(this.hasRendered ? b : !1, this);
              p && this.temporaryDisplay();
              this.layOutTitles();

              for (b = e.length; b--;) {
                var m = e[b];

                if (m.options.stacking || m.options.centerInCategory) {
                  var r = !0;

                  if (m.isDirty) {
                    var l = !0;
                    break;
                  }
                }
              }

              if (l) for (b = e.length; b--;) {
                m = e[b], m.options.stacking && (m.isDirty = !0);
              }
              e.forEach(function (b) {
                b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), k = !0) : d && (d.labelFormatter || d.labelFormat) && (k = !0));
                b.isDirtyData && C(b, "updatedData");
              });
              k && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);
              r && this.getStacks();
              f.forEach(function (b) {
                b.updateNames();
                b.setScale();
              });
              this.getMargins();
              f.forEach(function (b) {
                b.isDirty && (u = !0);
              });
              f.forEach(function (b) {
                var f = b.min + "," + b.max;
                b.extKey !== f && (b.extKey = f, n.push(function () {
                  C(b, "afterSetExtremes", X(b.eventArgs, b.getExtremes()));
                  delete b.eventArgs;
                }));
                (u || r) && b.redraw();
              });
              u && this.drawChartBox();
              C(this, "predraw");
              e.forEach(function (b) {
                (u || b.isDirty) && b.visible && b.redraw();
                b.isDirtyData = !1;
              });
              a && a.reset(!0);
              h.draw();
              C(this, "redraw");
              C(this, "render");
              p && this.temporaryDisplay(!0);
              n.forEach(function (b) {
                b.call();
              });
            };

            c.prototype.get = function (b) {
              function f(f) {
                return f.id === b || f.options && f.options.id === b;
              }

              for (var e = this.series, a = Z(this.axes, f) || Z(this.series, f), c = 0; !a && c < e.length; c++) {
                a = Z(e[c].points || [], f);
              }

              return a;
            };

            c.prototype.getAxes = function () {
              var b = this,
                  f = this.options,
                  e = f.xAxis = fa(f.xAxis || {});
              f = f.yAxis = fa(f.yAxis || {});
              C(this, "getAxes");
              e.forEach(function (b, f) {
                b.index = f;
                b.isX = !0;
              });
              f.forEach(function (b, f) {
                b.index = f;
              });
              e.concat(f).forEach(function (f) {
                new g(b, f);
              });
              C(this, "afterGetAxes");
            };

            c.prototype.getSelectedPoints = function () {
              return this.series.reduce(function (b, f) {
                f.getPointsCollection().forEach(function (f) {
                  R(f.selectedStaging, f.selected) && b.push(f);
                });
                return b;
              }, []);
            };

            c.prototype.getSelectedSeries = function () {
              return this.series.filter(function (b) {
                return b.selected;
              });
            };

            c.prototype.setTitle = function (b, f, e) {
              this.applyDescription("title", b);
              this.applyDescription("subtitle", f);
              this.applyDescription("caption", void 0);
              this.layOutTitles(e);
            };

            c.prototype.applyDescription = function (b, f) {
              var e = this,
                  a = "title" === b ? {
                color: "#333333",
                fontSize: this.options.isStock ? "16px" : "18px"
              } : {
                color: "#666666"
              };
              a = this.options[b] = W(!this.styledMode && {
                style: a
              }, this.options[b], f);
              var c = this[b];
              c && f && (this[b] = c = c.destroy());
              a && !c && (c = this.renderer.text(a.text, 0, 0, a.useHTML).attr({
                align: a.align,
                "class": "highcharts-" + b,
                zIndex: a.zIndex || 4
              }).add(), c.update = function (f) {
                e[{
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }[b]](f);
              }, this.styledMode || c.css(a.style), this[b] = c);
            };

            c.prototype.layOutTitles = function (b) {
              var f = [0, 0, 0],
                  e = this.renderer,
                  a = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (b) {
                var c = this[b],
                    d = this.options[b],
                    h = d.verticalAlign || "top";
                b = "title" === b ? "top" === h ? -3 : 0 : "top" === h ? f[0] + 2 : 0;
                var p;

                if (c) {
                  this.styledMode || (p = d.style && d.style.fontSize);
                  p = e.fontMetrics(p, c).b;
                  c.css({
                    width: (d.width || a.width + (d.widthAdjust || 0)) + "px"
                  });
                  var n = Math.round(c.getBBox(d.useHTML).height);
                  c.align(X({
                    y: "bottom" === h ? p : b + p,
                    height: n
                  }, d), !1, "spacingBox");
                  d.floating || ("top" === h ? f[0] = Math.ceil(f[0] + n) : "bottom" === h && (f[2] = Math.ceil(f[2] + n)));
                }
              }, this);
              f[0] && "top" === (this.options.title.verticalAlign || "top") && (f[0] += this.options.title.margin);
              f[2] && "bottom" === this.options.caption.verticalAlign && (f[2] += this.options.caption.margin);
              var c = !this.titleOffset || this.titleOffset.join(",") !== f.join(",");
              this.titleOffset = f;
              C(this, "afterLayOutTitles");
              !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && R(b, !0) && this.isDirtyBox && this.redraw());
            };

            c.prototype.getChartSize = function () {
              var b = this.options.chart,
                  f = b.width;
              b = b.height;
              var e = this.renderTo;
              K(f) || (this.containerWidth = aa(e, "width"));
              K(b) || (this.containerHeight = aa(e, "height"));
              this.chartWidth = Math.max(0, f || this.containerWidth || 600);
              this.chartHeight = Math.max(0, ia(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };

            c.prototype.temporaryDisplay = function (b) {
              var f = this.renderTo;
              if (b) for (; f && f.style;) {
                f.hcOrigStyle && (u(f, f.hcOrigStyle), delete f.hcOrigStyle), f.hcOrigDetached && (z.body.removeChild(f), f.hcOrigDetached = !1), f = f.parentNode;
              } else for (; f && f.style;) {
                z.body.contains(f) || f.parentNode || (f.hcOrigDetached = !0, z.body.appendChild(f));
                if ("none" === aa(f, "display", !1) || f.hcOricDetached) f.hcOrigStyle = {
                  display: f.style.display,
                  height: f.style.height,
                  overflow: f.style.overflow
                }, b = {
                  display: "block",
                  overflow: "hidden"
                }, f !== this.renderTo && (b.height = 0), u(f, b), f.offsetWidth || f.style.setProperty("display", "block", "important");
                f = f.parentNode;
                if (f === z.body) break;
              }
            };

            c.prototype.setClassName = function (b) {
              this.container.className = "highcharts-container " + (b || "");
            };

            c.prototype.getContainer = function () {
              var b = this.options,
                  f = b.chart,
                  a = ja(),
                  c,
                  d = this.renderTo;
              d || (this.renderTo = d = f.renderTo);
              ca(d) && (this.renderTo = d = z.getElementById(d));
              d || O(13, !0, this);
              var h = da(D(d, "data-highcharts-chart"));
              ba(h) && y[h] && y[h].hasRendered && y[h].destroy();
              D(d, "data-highcharts-chart", this.index);
              d.innerHTML = v.emptyHTML;
              f.skipClone || d.offsetWidth || this.temporaryDisplay();
              this.getChartSize();
              h = this.chartWidth;
              var n = this.chartHeight;
              u(d, {
                overflow: "hidden"
              });
              this.styledMode || (c = X({
                position: "relative",
                overflow: "hidden",
                width: h + "px",
                height: n + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                userSelect: "none",
                "touch-action": "manipulation",
                outline: "none"
              }, f.style || {}));
              this.container = a = p("div", {
                id: a
              }, c, d);
              this._cursor = a.style.cursor;
              this.renderer = new (f.renderer || !e ? q.getRendererType(f.renderer) : l)(a, h, n, void 0, f.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
              F(void 0, this);
              this.setClassName(f.className);
              if (this.styledMode) for (var k in b.defs) {
                this.renderer.definition(b.defs[k]);
              } else this.renderer.setStyle(f.style);
              this.renderer.chartIndex = this.index;
              C(this, "afterGetContainer");
            };

            c.prototype.getMargins = function (b) {
              var f = this.spacing,
                  e = this.margin,
                  a = this.titleOffset;
              this.resetMargins();
              a[0] && !K(e[0]) && (this.plotTop = Math.max(this.plotTop, a[0] + f[0]));
              a[2] && !K(e[2]) && (this.marginBottom = Math.max(this.marginBottom, a[2] + f[2]));
              this.legend && this.legend.display && this.legend.adjustMargins(e, f);
              C(this, "getMargins");
              b || this.getAxisMargins();
            };

            c.prototype.getAxisMargins = function () {
              var b = this,
                  f = b.axisOffset = [0, 0, 0, 0],
                  e = b.colorAxis,
                  a = b.margin,
                  c = function c(b) {
                b.forEach(function (b) {
                  b.visible && b.getOffset();
                });
              };

              b.hasCartesianSeries ? c(b.axes) : e && e.length && c(e);
              w.forEach(function (e, c) {
                K(a[c]) || (b[e] += f[c]);
              });
              b.setChartSize();
            };

            c.prototype.reflow = function (b) {
              var f = this,
                  e = f.options.chart,
                  a = f.renderTo,
                  c = K(e.width) && K(e.height),
                  d = e.width || aa(a, "width");
              e = e.height || aa(a, "height");
              a = b ? b.target : r;
              delete f.pointer.chartPosition;

              if (!c && !f.isPrinting && d && e && (a === r || a === z)) {
                if (d !== f.containerWidth || e !== f.containerHeight) k.clearTimeout(f.reflowTimeout), f.reflowTimeout = Y(function () {
                  f.container && f.setSize(void 0, void 0, !1);
                }, b ? 100 : 0);
                f.containerWidth = d;
                f.containerHeight = e;
              }
            };

            c.prototype.setReflow = function (f) {
              var e = this;
              !1 === f || this.unbindReflow ? !1 === f && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = b(r, "resize", function (b) {
                e.options && e.reflow(b);
              }), b(this, "destroy", this.unbindReflow));
            };

            c.prototype.setSize = function (b, f, e) {
              var a = this,
                  c = a.renderer;
              a.isResizing += 1;
              F(e, a);
              e = c.globalAnimation;
              a.oldChartHeight = a.chartHeight;
              a.oldChartWidth = a.chartWidth;
              "undefined" !== typeof b && (a.options.chart.width = b);
              "undefined" !== typeof f && (a.options.chart.height = f);
              a.getChartSize();
              a.styledMode || (e ? m : u)(a.container, {
                width: a.chartWidth + "px",
                height: a.chartHeight + "px"
              }, e);
              a.setChartSize(!0);
              c.setSize(a.chartWidth, a.chartHeight, e);
              a.axes.forEach(function (b) {
                b.isDirty = !0;
                b.setScale();
              });
              a.isDirtyLegend = !0;
              a.isDirtyBox = !0;
              a.layOutTitles();
              a.getMargins();
              a.redraw(e);
              a.oldChartHeight = null;
              C(a, "resize");
              Y(function () {
                a && C(a, "endResize", null, function () {
                  --a.isResizing;
                });
              }, N(e).duration);
            };

            c.prototype.setChartSize = function (b) {
              var f = this.inverted,
                  e = this.renderer,
                  a = this.chartWidth,
                  c = this.chartHeight,
                  d = this.options.chart,
                  h = this.spacing,
                  p = this.clipOffset,
                  n,
                  u,
                  k,
                  m;
              this.plotLeft = n = Math.round(this.plotLeft);
              this.plotTop = u = Math.round(this.plotTop);
              this.plotWidth = k = Math.max(0, Math.round(a - n - this.marginRight));
              this.plotHeight = m = Math.max(0, Math.round(c - u - this.marginBottom));
              this.plotSizeX = f ? m : k;
              this.plotSizeY = f ? k : m;
              this.plotBorderWidth = d.plotBorderWidth || 0;
              this.spacingBox = e.spacingBox = {
                x: h[3],
                y: h[0],
                width: a - h[3] - h[1],
                height: c - h[0] - h[2]
              };
              this.plotBox = e.plotBox = {
                x: n,
                y: u,
                width: k,
                height: m
              };
              f = 2 * Math.floor(this.plotBorderWidth / 2);
              a = Math.ceil(Math.max(f, p[3]) / 2);
              c = Math.ceil(Math.max(f, p[0]) / 2);
              this.clipBox = {
                x: a,
                y: c,
                width: Math.floor(this.plotSizeX - Math.max(f, p[1]) / 2 - a),
                height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, p[2]) / 2 - c))
              };
              b || (this.axes.forEach(function (b) {
                b.setAxisSize();
                b.setAxisTranslation();
              }), e.alignElements());
              C(this, "afterSetChartSize", {
                skipAxes: b
              });
            };

            c.prototype.resetMargins = function () {
              C(this, "resetMargins");
              var b = this,
                  f = b.options.chart;
              ["margin", "spacing"].forEach(function (e) {
                var a = f[e],
                    c = S(a) ? a : [a, a, a, a];
                ["Top", "Right", "Bottom", "Left"].forEach(function (a, d) {
                  b[e][d] = R(f[e + a], c[d]);
                });
              });
              w.forEach(function (f, e) {
                b[f] = R(b.margin[e], b.spacing[e]);
              });
              b.axisOffset = [0, 0, 0, 0];
              b.clipOffset = [0, 0, 0, 0];
            };

            c.prototype.drawChartBox = function () {
              var b = this.options.chart,
                  f = this.renderer,
                  e = this.chartWidth,
                  a = this.chartHeight,
                  c = this.styledMode,
                  d = this.plotBGImage,
                  h = b.backgroundColor,
                  p = b.plotBackgroundColor,
                  n = b.plotBackgroundImage,
                  u = this.plotLeft,
                  k = this.plotTop,
                  m = this.plotWidth,
                  r = this.plotHeight,
                  l = this.plotBox,
                  q = this.clipRect,
                  g = this.clipBox,
                  w = this.chartBackground,
                  D = this.plotBackground,
                  H = this.plotBorder,
                  y,
                  Q = "animate";
              w || (this.chartBackground = w = f.rect().addClass("highcharts-background").add(), Q = "attr");
              if (c) var t = y = w.strokeWidth();else {
                t = b.borderWidth || 0;
                y = t + (b.shadow ? 8 : 0);
                h = {
                  fill: h || "none"
                };
                if (t || w["stroke-width"]) h.stroke = b.borderColor, h["stroke-width"] = t;
                w.attr(h).shadow(b.shadow);
              }
              w[Q]({
                x: y / 2,
                y: y / 2,
                width: e - y - t % 2,
                height: a - y - t % 2,
                r: b.borderRadius
              });
              Q = "animate";
              D || (Q = "attr", this.plotBackground = D = f.rect().addClass("highcharts-plot-background").add());
              D[Q](l);
              c || (D.attr({
                fill: p || "none"
              }).shadow(b.plotShadow), n && (d ? (n !== d.attr("href") && d.attr("href", n), d.animate(l)) : this.plotBGImage = f.image(n, u, k, m, r).add()));
              q ? q.animate({
                width: g.width,
                height: g.height
              }) : this.clipRect = f.clipRect(g);
              Q = "animate";
              H || (Q = "attr", this.plotBorder = H = f.rect().addClass("highcharts-plot-border").attr({
                zIndex: 1
              }).add());
              c || H.attr({
                stroke: b.plotBorderColor,
                "stroke-width": b.plotBorderWidth || 0,
                fill: "none"
              });
              H[Q](H.crisp({
                x: u,
                y: k,
                width: m,
                height: r
              }, -H.strokeWidth()));
              this.isDirtyBox = !1;
              C(this, "afterDrawChartBox");
            };

            c.prototype.propFromSeries = function () {
              var b = this,
                  e = b.options.chart,
                  a = b.options.series,
                  c,
                  d,
                  h;
              ["inverted", "angular", "polar"].forEach(function (p) {
                d = f[e.type || e.defaultSeriesType];
                h = e[p] || d && d.prototype[p];

                for (c = a && a.length; !h && c--;) {
                  (d = f[a[c].type]) && d.prototype[p] && (h = !0);
                }

                b[p] = h;
              });
            };

            c.prototype.linkSeries = function () {
              var b = this,
                  f = b.series;
              f.forEach(function (b) {
                b.linkedSeries.length = 0;
              });
              f.forEach(function (f) {
                var e = f.options.linkedTo;
                ca(e) && (e = ":previous" === e ? b.series[f.index - 1] : b.get(e)) && e.linkedParent !== f && (e.linkedSeries.push(f), f.linkedParent = e, e.enabledDataSorting && f.setDataSortingOptions(), f.visible = R(f.options.visible, e.options.visible, f.visible));
              });
              C(this, "afterLinkSeries");
            };

            c.prototype.renderSeries = function () {
              this.series.forEach(function (b) {
                b.translate();
                b.render();
              });
            };

            c.prototype.renderLabels = function () {
              var b = this,
                  f = b.options.labels;
              f.items && f.items.forEach(function (e) {
                var a = X(f.style, e.style),
                    c = da(a.left) + b.plotLeft,
                    d = da(a.top) + b.plotTop + 12;
                delete a.left;
                delete a.top;
                b.renderer.text(e.html, c, d).attr({
                  zIndex: 2
                }).css(a).add();
              });
            };

            c.prototype.render = function () {
              var b = this.axes,
                  f = this.colorAxis,
                  e = this.renderer,
                  a = this.options,
                  c = function c(b) {
                b.forEach(function (b) {
                  b.visible && b.render();
                });
              },
                  d = 0;

              this.setTitle();
              this.legend = new G(this, a.legend);
              this.getStacks && this.getStacks();
              this.getMargins(!0);
              this.setChartSize();
              a = this.plotWidth;
              b.some(function (b) {
                if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return d = 21, !0;
              });
              var h = this.plotHeight = Math.max(this.plotHeight - d, 0);
              b.forEach(function (b) {
                b.setScale();
              });
              this.getAxisMargins();
              var p = 1.1 < a / this.plotWidth,
                  n = 1.05 < h / this.plotHeight;
              if (p || n) b.forEach(function (b) {
                (b.horiz && p || !b.horiz && n) && b.setTickInterval(!0);
              }), this.getMargins();
              this.drawChartBox();
              this.hasCartesianSeries ? c(b) : f && f.length && c(f);
              this.seriesGroup || (this.seriesGroup = e.g("series-group").attr({
                zIndex: 3
              }).add());
              this.renderSeries();
              this.renderLabels();
              this.addCredits();
              this.setResponsive && this.setResponsive();
              this.hasRendered = !0;
            };

            c.prototype.addCredits = function (b) {
              var f = this,
                  e = W(!0, this.options.credits, b);
              e.enabled && !this.credits && (this.credits = this.renderer.text(e.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                e.href && (r.location.href = e.href);
              }).attr({
                align: e.position.align,
                zIndex: 8
              }), f.styledMode || this.credits.css(e.style), this.credits.add().align(e.position), this.credits.update = function (b) {
                f.credits = f.credits.destroy();
                f.addCredits(b);
              });
            };

            c.prototype.destroy = function () {
              var b = this,
                  f = b.axes,
                  e = b.series,
                  a = b.container,
                  c = a && a.parentNode,
                  d;
              C(b, "destroy");
              b.renderer.forExport ? M(y, b) : y[b.index] = void 0;
              x.chartCount--;
              b.renderTo.removeAttribute("data-highcharts-chart");
              P(b);

              for (d = f.length; d--;) {
                f[d] = f[d].destroy();
              }

              this.scroller && this.scroller.destroy && this.scroller.destroy();

              for (d = e.length; d--;) {
                e[d] = e[d].destroy();
              }

              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (f) {
                var e = b[f];
                e && e.destroy && (b[f] = e.destroy());
              });
              a && (a.innerHTML = v.emptyHTML, P(a), c && T(a));
              V(b, function (f, e) {
                delete b[e];
              });
            };

            c.prototype.firstRender = function () {
              var b = this,
                  f = b.options;

              if (!b.isReadyToRender || b.isReadyToRender()) {
                b.getContainer();
                b.resetMargins();
                b.setChartSize();
                b.propFromSeries();
                b.getAxes();
                (Q(f.series) ? f.series : []).forEach(function (f) {
                  b.initSeries(f);
                });
                b.linkSeries();
                b.setSeriesData();
                C(b, "beforeRender");
                t && (I.isRequired() ? b.pointer = new I(b, f) : b.pointer = new t(b, f));
                b.render();
                b.pointer.getChartPosition();
                if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
                b.temporaryDisplay(!0);
              }
            };

            c.prototype.onload = function () {
              this.callbacks.concat([this.callback]).forEach(function (b) {
                b && "undefined" !== typeof this.index && b.apply(this, [this]);
              }, this);
              C(this, "load");
              C(this, "render");
              K(this.index) && this.setReflow(this.options.chart.reflow);
              this.warnIfA11yModuleNotLoaded();
              this.hasLoaded = !0;
            };

            c.prototype.warnIfA11yModuleNotLoaded = function () {
              var b = this.options,
                  f = this.title;
              b && !this.accessibility && (this.renderer.boxWrapper.attr({
                role: "img",
                "aria-label": f && f.element.textContent || ""
              }), b.accessibility && !1 === b.accessibility.enabled || O('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
            };

            c.prototype.addSeries = function (b, f, e) {
              var a = this,
                  c;
              b && (f = R(f, !0), C(a, "addSeries", {
                options: b
              }, function () {
                c = a.initSeries(b);
                a.isDirtyLegend = !0;
                a.linkSeries();
                c.enabledDataSorting && c.setData(b.data, !1);
                C(a, "afterAddSeries", {
                  series: c
                });
                f && a.redraw(e);
              }));
              return c;
            };

            c.prototype.addAxis = function (b, f, e, a) {
              return this.createAxis(f ? "xAxis" : "yAxis", {
                axis: b,
                redraw: e,
                animation: a
              });
            };

            c.prototype.addColorAxis = function (b, f, e) {
              return this.createAxis("colorAxis", {
                axis: b,
                redraw: f,
                animation: e
              });
            };

            c.prototype.createAxis = function (b, f) {
              b = new g(this, W(f.axis, {
                index: this[b].length,
                isX: "xAxis" === b
              }));
              R(f.redraw, !0) && this.redraw(f.animation);
              return b;
            };

            c.prototype.showLoading = function (f) {
              var e = this,
                  a = e.options,
                  c = a.loading,
                  d = function d() {
                h && u(h, {
                  left: e.plotLeft + "px",
                  top: e.plotTop + "px",
                  width: e.plotWidth + "px",
                  height: e.plotHeight + "px"
                });
              },
                  h = e.loadingDiv,
                  n = e.loadingSpan;

              h || (e.loadingDiv = h = p("div", {
                className: "highcharts-loading highcharts-loading-hidden"
              }, null, e.container));
              n || (e.loadingSpan = n = p("span", {
                className: "highcharts-loading-inner"
              }, null, h), b(e, "redraw", d));
              h.className = "highcharts-loading";
              v.setElementHTML(n, R(f, a.lang.loading, ""));
              e.styledMode || (u(h, X(c.style, {
                zIndex: 10
              })), u(n, c.labelStyle), e.loadingShown || (u(h, {
                opacity: 0,
                display: ""
              }), m(h, {
                opacity: c.style.opacity || .5
              }, {
                duration: c.showDuration || 0
              })));
              e.loadingShown = !0;
              d();
            };

            c.prototype.hideLoading = function () {
              var b = this.options,
                  f = this.loadingDiv;
              f && (f.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || m(f, {
                opacity: 0
              }, {
                duration: b.loading.hideDuration || 100,
                complete: function complete() {
                  u(f, {
                    display: "none"
                  });
                }
              }));
              this.loadingShown = !1;
            };

            c.prototype.update = function (b, f, e, c) {
              var d = this,
                  h = {
                credits: "addCredits",
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              },
                  p = b.isResponsiveOptions,
                  u = [],
                  k,
                  m;
              C(d, "update", {
                options: b
              });
              p || d.setResponsive(!1, !0);
              b = H(b, d.options);
              d.userOptions = W(d.userOptions, b);
              var r = b.chart;

              if (r) {
                W(!0, d.options.chart, r);
                "className" in r && d.setClassName(r.className);
                "reflow" in r && d.setReflow(r.reflow);

                if ("inverted" in r || "polar" in r || "type" in r) {
                  d.propFromSeries();
                  var l = !0;
                }

                "alignTicks" in r && (l = !0);
                "events" in r && J(this, r);
                V(r, function (b, f) {
                  -1 !== d.propsRequireUpdateSeries.indexOf("chart." + f) && (k = !0);
                  -1 !== d.propsRequireDirtyBox.indexOf(f) && (d.isDirtyBox = !0);
                  -1 !== d.propsRequireReflow.indexOf(f) && (p ? d.isDirtyBox = !0 : m = !0);
                });
                !d.styledMode && r.style && d.renderer.setStyle(d.options.chart.style || {});
              }

              !d.styledMode && b.colors && (this.options.colors = b.colors);
              b.time && (this.time === n && (this.time = new a(b.time)), W(!0, d.options.time, b.time));
              V(b, function (f, e) {
                if (d[e] && "function" === typeof d[e].update) d[e].update(f, !1);else if ("function" === typeof d[h[e]]) d[h[e]](f);else "colors" !== e && -1 === d.collectionsWithUpdate.indexOf(e) && W(!0, d.options[e], b[e]);
                "chart" !== e && -1 !== d.propsRequireUpdateSeries.indexOf(e) && (k = !0);
              });
              this.collectionsWithUpdate.forEach(function (f) {
                if (b[f]) {
                  var a = [];
                  d[f].forEach(function (b, f) {
                    b.options.isInternal || a.push(R(b.options.index, f));
                  });
                  fa(b[f]).forEach(function (b, c) {
                    var h = K(b.id),
                        p;
                    h && (p = d.get(b.id));
                    !p && d[f] && (p = d[f][a ? a[c] : c]) && h && K(p.options.id) && (p = void 0);
                    p && p.coll === f && (p.update(b, !1), e && (p.touched = !0));
                    !p && e && d.collectionsWithInit[f] && (d.collectionsWithInit[f][0].apply(d, [b].concat(d.collectionsWithInit[f][1] || []).concat([!1])).touched = !0);
                  });
                  e && d[f].forEach(function (b) {
                    b.touched || b.options.isInternal ? delete b.touched : u.push(b);
                  });
                }
              });
              u.forEach(function (b) {
                b.chart && b.remove && b.remove(!1);
              });
              l && d.axes.forEach(function (b) {
                b.update({}, !1);
              });
              k && d.getSeriesOrderByLinks().forEach(function (b) {
                b.chart && b.update({}, !1);
              }, this);
              l = r && r.width;
              r = r && (ca(r.height) ? ia(r.height, l || d.chartWidth) : r.height);
              m || ba(l) && l !== d.chartWidth || ba(r) && r !== d.chartHeight ? d.setSize(l, r, c) : R(f, !0) && d.redraw(c);
              C(d, "afterUpdate", {
                options: b,
                redraw: f,
                animation: c
              });
            };

            c.prototype.setSubtitle = function (b, f) {
              this.applyDescription("subtitle", b);
              this.layOutTitles(f);
            };

            c.prototype.setCaption = function (b, f) {
              this.applyDescription("caption", b);
              this.layOutTitles(f);
            };

            c.prototype.showResetZoom = function () {
              function b() {
                f.zoomOut();
              }

              var f = this,
                  e = h.lang,
                  a = f.options.chart.resetZoomButton,
                  c = a.theme,
                  d = "chart" === a.relativeTo || "spacingBox" === a.relativeTo ? null : "scrollablePlotBox";
              C(this, "beforeShowResetZoom", null, function () {
                f.resetZoomButton = f.renderer.button(e.resetZoom, null, null, b, c).attr({
                  align: a.position.align,
                  title: e.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(a.position, !1, d);
              });
              C(this, "afterShowResetZoom");
            };

            c.prototype.zoomOut = function () {
              C(this, "selection", {
                resetSelection: !0
              }, this.zoom);
            };

            c.prototype.zoom = function (b) {
              var f = this,
                  e = f.pointer,
                  a = f.inverted ? e.mouseDownX : e.mouseDownY,
                  c = !1,
                  d;
              !b || b.resetSelection ? (f.axes.forEach(function (b) {
                d = b.zoom();
              }), e.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
                var h = b.axis,
                    p = f.inverted ? h.left : h.top,
                    n = f.inverted ? p + h.width : p + h.height,
                    u = h.isXAxis,
                    k = !1;
                if (!u && a >= p && a <= n || u || !K(a)) k = !0;
                e[u ? "zoomX" : "zoomY"] && k && (d = h.zoom(b.min, b.max), h.displayBtn && (c = !0));
              });
              var h = f.resetZoomButton;
              c && !h ? f.showResetZoom() : !c && S(h) && (f.resetZoomButton = h.destroy());
              d && f.redraw(R(f.options.chart.animation, b && b.animation, 100 > f.pointCount));
            };

            c.prototype.pan = function (b, f) {
              var e = this,
                  a = e.hoverPoints;
              f = "object" === typeof f ? f : {
                enabled: f,
                type: "x"
              };
              var c = e.options.chart;
              c && c.panning && (c.panning = f);
              var d = f.type,
                  h;
              C(this, "pan", {
                originalEvent: b
              }, function () {
                a && a.forEach(function (b) {
                  b.setState();
                });
                var f = e.xAxis;
                "xy" === d ? f = f.concat(e.yAxis) : "y" === d && (f = e.yAxis);
                var c = {};
                f.forEach(function (f) {
                  if (f.options.panningEnabled && !f.options.isInternal) {
                    var a = f.horiz,
                        p = b[a ? "chartX" : "chartY"];
                    a = a ? "mouseDownX" : "mouseDownY";
                    var n = e[a],
                        u = f.minPointOffset || 0,
                        k = f.reversed && !e.inverted || !f.reversed && e.inverted ? -1 : 1,
                        r = f.getExtremes(),
                        m = f.toValue(n - p, !0) + u * k,
                        l = f.toValue(n + f.len - p, !0) - (u * k || f.isXAxis && f.pointRangePadding || 0),
                        q = l < m;
                    k = f.hasVerticalPanning();
                    n = q ? l : m;
                    m = q ? m : l;
                    var g = f.panningState;
                    !k || f.isXAxis || g && !g.isDirty || f.series.forEach(function (b) {
                      var f = b.getProcessedData(!0);
                      f = b.getExtremes(f.yData, !0);
                      g || (g = {
                        startMin: Number.MAX_VALUE,
                        startMax: -Number.MAX_VALUE
                      });
                      ba(f.dataMin) && ba(f.dataMax) && (g.startMin = Math.min(R(b.options.threshold, Infinity), f.dataMin, g.startMin), g.startMax = Math.max(R(b.options.threshold, -Infinity), f.dataMax, g.startMax));
                    });
                    k = Math.min(R(g && g.startMin, r.dataMin), u ? r.min : f.toValue(f.toPixels(r.min) - f.minPixelPadding));
                    l = Math.max(R(g && g.startMax, r.dataMax), u ? r.max : f.toValue(f.toPixels(r.max) + f.minPixelPadding));
                    f.panningState = g;
                    f.isOrdinal || (u = k - n, 0 < u && (m += u, n = k), u = m - l, 0 < u && (m = l, n -= u), f.series.length && n !== r.min && m !== r.max && n >= k && m <= l && (f.setExtremes(n, m, !1, !1, {
                      trigger: "pan"
                    }), !e.resetZoomButton && n !== k && m !== l && d.match("y") && (e.showResetZoom(), f.displayBtn = !1), h = !0), c[a] = p);
                  }
                });
                V(c, function (b, f) {
                  e[f] = b;
                });
                h && e.redraw(!1);
                u(e.container, {
                  cursor: "move"
                });
              });
            };

            return c;
          }();

          X(d.prototype, {
            callbacks: [],
            collectionsWithInit: {
              xAxis: [d.prototype.addAxis, [!0]],
              yAxis: [d.prototype.addAxis, [!1]],
              series: [d.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
          });
          "";
          return d;
        });
        P(g, "Core/Legend/LegendSymbol.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.merge,
              B = d.pick,
              E;

          (function (d) {
            d.drawLineMarker = function (d) {
              var x = this.options,
                  A = d.symbolWidth,
                  t = d.symbolHeight,
                  q = t / 2,
                  c = this.chart.renderer,
                  l = this.legendGroup;
              d = d.baseline - Math.round(.3 * d.fontMetrics.b);
              var a = {},
                  k = x.marker;
              this.chart.styledMode || (a = {
                "stroke-width": x.lineWidth || 0
              }, x.dashStyle && (a.dashstyle = x.dashStyle));
              this.legendLine = c.path([["M", 0, d], ["L", A, d]]).addClass("highcharts-graph").attr(a).add(l);
              k && !1 !== k.enabled && A && (x = Math.min(B(k.radius, q), q), 0 === this.symbol.indexOf("url") && (k = g(k, {
                width: t,
                height: t
              }), x = 0), this.legendSymbol = A = c.symbol(this.symbol, A / 2 - x, d - x, 2 * x, 2 * x, k).addClass("highcharts-point").add(l), A.isMarker = !0);
            };

            d.drawRectangle = function (d, g) {
              var x = d.symbolHeight,
                  t = d.options.squareSymbol;
              g.legendSymbol = this.chart.renderer.rect(t ? (d.symbolWidth - x) / 2 : 0, d.baseline - x + 1, t ? x : d.symbolWidth, x, B(d.options.symbolRadius, x / 2)).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(g.legendGroup);
            };
          })(E || (E = {}));

          return E;
        });
        P(g, "Core/Series/SeriesDefaults.js", [], function () {
          return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
              duration: 1E3
            },
            events: {},
            marker: {
              enabledThreshold: 2,
              lineColor: "#ffffff",
              lineWidth: 0,
              radius: 4,
              states: {
                normal: {
                  animation: !0
                },
                hover: {
                  animation: {
                    duration: 50
                  },
                  enabled: !0,
                  radiusPlus: 2,
                  lineWidthPlus: 1
                },
                select: {
                  fillColor: "#cccccc",
                  lineColor: "#000000",
                  lineWidth: 2
                }
              }
            },
            point: {
              events: {}
            },
            dataLabels: {
              animation: {},
              align: "center",
              defer: !0,
              formatter: function formatter() {
                var d = this.series.chart.numberFormatter;
                return "number" !== typeof this.y ? "" : d(this.y, -1);
              },
              padding: 5,
              style: {
                fontSize: "11px",
                fontWeight: "bold",
                color: "contrast",
                textOutline: "1px contrast"
              },
              verticalAlign: "bottom",
              x: 0,
              y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                lineWidthPlus: 1,
                marker: {},
                halo: {
                  size: 10,
                  opacity: .25
                }
              },
              select: {
                animation: {
                  duration: 0
                }
              },
              inactive: {
                animation: {
                  duration: 50
                },
                opacity: .2
              }
            },
            stickyTracking: !0,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
          };
        });
        P(g, "Core/Series/Series.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/DefaultOptions.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/Point.js"], g["Core/Series/SeriesDefaults.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I, A, t, q) {
          var c = d.animObject,
              l = d.setAnimation,
              a = g.defaultOptions,
              k = B.registerEventOptions,
              v = E.hasTouch,
              m = E.svg,
              N = E.win,
              F = A.seriesTypes,
              L = q.addEvent,
              J = q.arrayMax,
              y = q.arrayMin,
              z = q.clamp,
              w = q.cleanRecursively,
              e = q.correctFloat,
              r = q.defined,
              h = q.erase,
              n = q.error,
              f = q.extend,
              b = q.find,
              D = q.fireEvent,
              H = q.getNestedProperty,
              p = q.isArray,
              u = q.isNumber,
              K = q.isString,
              T = q.merge,
              M = q.objectEach,
              O = q.pick,
              C = q.removeEvent,
              Z = q.splat,
              ha = q.syncTimeout;

          d = function () {
            function d() {
              this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }

            d.prototype.init = function (b, e) {
              D(this, "init", {
                options: e
              });
              var a = this,
                  c = b.series;
              this.eventsToUnbind = [];
              a.chart = b;
              a.options = a.setOptions(e);
              e = a.options;
              a.linkedSeries = [];
              a.bindAxes();
              f(a, {
                name: e.name,
                state: "",
                visible: !1 !== e.visible,
                selected: !0 === e.selected
              });
              k(this, e);
              var d = e.events;
              if (d && d.click || e.point && e.point.events && e.point.events.click || e.allowPointSelect) b.runTrackerClick = !0;
              a.getColor();
              a.getSymbol();
              a.parallelArrays.forEach(function (b) {
                a[b + "Data"] || (a[b + "Data"] = []);
              });
              a.isCartesian && (b.hasCartesianSeries = !0);
              var h;
              c.length && (h = c[c.length - 1]);
              a._i = O(h && h._i, -1) + 1;
              a.opacity = a.options.opacity;
              b.orderSeries(this.insert(c));
              e.dataSorting && e.dataSorting.enabled ? a.setDataSortingOptions() : a.points || a.data || a.setData(e.data, !1);
              D(this, "afterInit");
            };

            d.prototype.is = function (b) {
              return F[b] && this instanceof F[b];
            };

            d.prototype.insert = function (b) {
              var f = this.options.index,
                  e;

              if (u(f)) {
                for (e = b.length; e--;) {
                  if (f >= O(b[e].options.index, b[e]._i)) {
                    b.splice(e + 1, 0, this);
                    break;
                  }
                }

                -1 === e && b.unshift(this);
                e += 1;
              } else b.push(this);

              return O(e, b.length - 1);
            };

            d.prototype.bindAxes = function () {
              var b = this,
                  f = b.options,
                  e = b.chart,
                  a;
              D(this, "bindAxes", null, function () {
                (b.axisTypes || []).forEach(function (c) {
                  var d = 0;
                  e[c].forEach(function (e) {
                    a = e.options;
                    if (f[c] === d && !a.isInternal || "undefined" !== typeof f[c] && f[c] === a.id || "undefined" === typeof f[c] && 0 === a.index) b.insert(e.series), b[c] = e, e.isDirty = !0;
                    a.isInternal || d++;
                  });
                  b[c] || b.optionalAxis === c || n(18, !0, e);
                });
              });
              D(this, "afterBindAxes");
            };

            d.prototype.updateParallelArrays = function (b, f) {
              var e = b.series,
                  a = arguments,
                  c = u(f) ? function (a) {
                var c = "y" === a && e.toYData ? e.toYData(b) : b[a];
                e[a + "Data"][f] = c;
              } : function (b) {
                Array.prototype[f].apply(e[b + "Data"], Array.prototype.slice.call(a, 2));
              };
              e.parallelArrays.forEach(c);
            };

            d.prototype.hasData = function () {
              return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };

            d.prototype.autoIncrement = function (b) {
              var f = this.options,
                  e = f.pointIntervalUnit,
                  a = f.relativeXValue,
                  c = this.chart.time,
                  d = this.xIncrement,
                  h;
              d = O(d, f.pointStart, 0);
              this.pointInterval = h = O(this.pointInterval, f.pointInterval, 1);
              a && u(b) && (h *= b);
              e && (f = new c.Date(d), "day" === e ? c.set("Date", f, c.get("Date", f) + h) : "month" === e ? c.set("Month", f, c.get("Month", f) + h) : "year" === e && c.set("FullYear", f, c.get("FullYear", f) + h), h = f.getTime() - d);
              if (a && u(b)) return d + h;
              this.xIncrement = d + h;
              return d;
            };

            d.prototype.setDataSortingOptions = function () {
              var b = this.options;
              f(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1
              });
              r(b.pointRange) || (b.pointRange = 1);
            };

            d.prototype.setOptions = function (b) {
              var f = this.chart,
                  e = f.options,
                  c = e.plotOptions,
                  d = f.userOptions || {};
              b = T(b);
              f = f.styledMode;
              var h = {
                plotOptions: c,
                userOptions: b
              };
              D(this, "setOptions", h);
              var p = h.plotOptions[this.type],
                  n = d.plotOptions || {};
              this.userOptions = h.userOptions;
              d = T(p, c.series, d.plotOptions && d.plotOptions[this.type], b);
              this.tooltipOptions = T(a.tooltip, a.plotOptions.series && a.plotOptions.series.tooltip, a.plotOptions[this.type].tooltip, e.tooltip.userOptions, c.series && c.series.tooltip, c[this.type].tooltip, b.tooltip);
              this.stickyTracking = O(b.stickyTracking, n[this.type] && n[this.type].stickyTracking, n.series && n.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);
              null === p.marker && delete d.marker;
              this.zoneAxis = d.zoneAxis;
              c = this.zones = (d.zones || []).slice();
              !d.negativeColor && !d.negativeFillColor || d.zones || (e = {
                value: d[this.zoneAxis + "Threshold"] || d.threshold || 0,
                className: "highcharts-negative"
              }, f || (e.color = d.negativeColor, e.fillColor = d.negativeFillColor), c.push(e));
              c.length && r(c[c.length - 1].value) && c.push(f ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
              D(this, "afterSetOptions", {
                options: d
              });
              return d;
            };

            d.prototype.getName = function () {
              return O(this.options.name, "Series " + (this.index + 1));
            };

            d.prototype.getCyclic = function (b, f, e) {
              var a = this.chart,
                  c = this.userOptions,
                  d = b + "Index",
                  h = b + "Counter",
                  p = e ? e.length : O(a.options.chart[b + "Count"], a[b + "Count"]);

              if (!f) {
                var n = O(c[d], c["_" + d]);
                r(n) || (a.series.length || (a[h] = 0), c["_" + d] = n = a[h] % p, a[h] += 1);
                e && (f = e[n]);
              }

              "undefined" !== typeof n && (this[d] = n);
              this[b] = f;
            };

            d.prototype.getColor = function () {
              this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || a.plotOptions[this.type].color, this.chart.options.colors);
            };

            d.prototype.getPointsCollection = function () {
              return (this.hasGroupedData ? this.points : this.data) || [];
            };

            d.prototype.getSymbol = function () {
              this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };

            d.prototype.findPointIndex = function (f, e) {
              var a = f.id,
                  c = f.x,
                  d = this.points,
                  h = this.options.dataSorting,
                  p,
                  n;
              if (a) h = this.chart.get(a), h instanceof G && (p = h);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (p = function p(b) {
                return !b.touched && b.index === f.index;
              }, h && h.matchByName ? p = function p(b) {
                return !b.touched && b.name === f.name;
              } : this.options.relativeXValue && (p = function p(b) {
                return !b.touched && b.options.x === f.x;
              }), p = b(d, p), !p) return;

              if (p) {
                var k = p && p.index;
                "undefined" !== typeof k && (n = !0);
              }

              "undefined" === typeof k && u(c) && (k = this.xData.indexOf(c, e));
              -1 !== k && "undefined" !== typeof k && this.cropped && (k = k >= this.cropStart ? k - this.cropStart : k);
              !n && u(k) && d[k] && d[k].touched && (k = void 0);
              return k;
            };

            d.prototype.updateData = function (b, f) {
              var e = this.options,
                  a = e.dataSorting,
                  c = this.points,
                  d = [],
                  h = this.requireSorting,
                  p = b.length === c.length,
                  n,
                  k,
                  m,
                  l = !0;
              this.xIncrement = null;
              b.forEach(function (b, f) {
                var k = r(b) && this.pointClass.prototype.optionsToObject.call({
                  series: this
                }, b) || {},
                    l = k.x;

                if (k.id || u(l)) {
                  if (k = this.findPointIndex(k, m), -1 === k || "undefined" === typeof k ? d.push(b) : c[k] && b !== e.data[k] ? (c[k].update(b, !1, null, !1), c[k].touched = !0, h && (m = k + 1)) : c[k] && (c[k].touched = !0), !p || f !== k || a && a.enabled || this.hasDerivedData) n = !0;
                } else d.push(b);
              }, this);
              if (n) for (b = c.length; b--;) {
                (k = c[b]) && !k.touched && k.remove && k.remove(!1, f);
              } else !p || a && a.enabled ? l = !1 : (b.forEach(function (b, f) {
                b !== c[f].y && c[f].update && c[f].update(b, !1, null, !1);
              }), d.length = 0);
              c.forEach(function (b) {
                b && (b.touched = !1);
              });
              if (!l) return !1;
              d.forEach(function (b) {
                this.addPoint(b, !1, null, null, !1);
              }, this);
              null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = J(this.xData), this.autoIncrement());
              return !0;
            };

            d.prototype.setData = function (b, f, e, a) {
              var c = this,
                  d = c.points,
                  h = d && d.length || 0,
                  k = c.options,
                  m = c.chart,
                  r = k.dataSorting,
                  l = c.xAxis,
                  g = k.turboThreshold,
                  q = this.xData,
                  w = this.yData,
                  D = c.pointArrayMap;
              D = D && D.length;
              var H = k.keys,
                  y,
                  t = 0,
                  z = 1,
                  v = null;

              if (!m.options.chart.allowMutatingData) {
                k.data && delete c.options.data;
                c.userOptions.data && delete c.userOptions.data;
                var Q = T(!0, b);
              }

              b = Q || b || [];
              Q = b.length;
              f = O(f, !0);
              r && r.enabled && (b = this.sortData(b));
              m.options.chart.allowMutatingData && !1 !== a && Q && h && !c.cropped && !c.hasGroupedData && c.visible && !c.isSeriesBoosting && (y = this.updateData(b, e));

              if (!y) {
                c.xIncrement = null;
                c.colorCounter = 0;
                this.parallelArrays.forEach(function (b) {
                  c[b + "Data"].length = 0;
                });
                if (g && Q > g) {
                  if (v = c.getFirstValidPoint(b), u(v)) for (e = 0; e < Q; e++) {
                    q[e] = this.autoIncrement(), w[e] = b[e];
                  } else if (p(v)) {
                    if (D) {
                      if (v.length === D) for (e = 0; e < Q; e++) {
                        q[e] = this.autoIncrement(), w[e] = b[e];
                      } else for (e = 0; e < Q; e++) {
                        a = b[e], q[e] = a[0], w[e] = a.slice(1, D + 1);
                      }
                    } else if (H && (t = H.indexOf("x"), z = H.indexOf("y"), t = 0 <= t ? t : 0, z = 0 <= z ? z : 1), 1 === v.length && (z = 0), t === z) for (e = 0; e < Q; e++) {
                      q[e] = this.autoIncrement(), w[e] = b[e][z];
                    } else for (e = 0; e < Q; e++) {
                      a = b[e], q[e] = a[t], w[e] = a[z];
                    }
                  } else n(12, !1, m);
                } else for (e = 0; e < Q; e++) {
                  "undefined" !== typeof b[e] && (a = {
                    series: c
                  }, c.pointClass.prototype.applyOptions.apply(a, [b[e]]), c.updateParallelArrays(a, e));
                }
                w && K(w[0]) && n(14, !0, m);
                c.data = [];
                c.options.data = c.userOptions.data = b;

                for (e = h; e--;) {
                  d[e] && d[e].destroy && d[e].destroy();
                }

                l && (l.minRange = l.userMinRange);
                c.isDirty = m.isDirtyBox = !0;
                c.isDirtyData = !!d;
                e = !1;
              }

              "point" === k.legendType && (this.processData(), this.generatePoints());
              f && m.redraw(e);
            };

            d.prototype.sortData = function (b) {
              var f = this,
                  e = f.options.dataSorting.sortKey || "y",
                  a = function a(b, f) {
                return r(f) && b.pointClass.prototype.optionsToObject.call({
                  series: b
                }, f) || {};
              };

              b.forEach(function (e, c) {
                b[c] = a(f, e);
                b[c].index = c;
              }, this);
              b.concat().sort(function (b, f) {
                b = H(e, b);
                f = H(e, f);
                return f < b ? -1 : f > b ? 1 : 0;
              }).forEach(function (b, f) {
                b.x = f;
              }, this);
              f.linkedSeries && f.linkedSeries.forEach(function (f) {
                var e = f.options,
                    c = e.data;
                e.dataSorting && e.dataSorting.enabled || !c || (c.forEach(function (e, d) {
                  c[d] = a(f, e);
                  b[d] && (c[d].x = b[d].x, c[d].index = d);
                }), f.setData(c, !1));
              });
              return b;
            };

            d.prototype.getProcessedData = function (b) {
              var f = this.xAxis,
                  e = this.options,
                  a = e.cropThreshold,
                  c = b || this.getExtremesFromAll || e.getExtremesFromAll,
                  d = this.isCartesian;
              b = f && f.val2lin;
              e = !(!f || !f.logarithmic);
              var h = 0,
                  p = this.xData,
                  k = this.yData,
                  u = this.requireSorting;
              var m = !1;
              var r = p.length;

              if (f) {
                m = f.getExtremes();
                var l = m.min;
                var g = m.max;
                m = !(!f.categories || f.names.length);
              }

              if (d && this.sorted && !c && (!a || r > a || this.forceCrop)) if (p[r - 1] < l || p[0] > g) p = [], k = [];else if (this.yData && (p[0] < l || p[r - 1] > g)) {
                var q = this.cropData(this.xData, this.yData, l, g);
                p = q.xData;
                k = q.yData;
                h = q.start;
                q = !0;
              }

              for (a = p.length || 1; --a;) {
                if (f = e ? b(p[a]) - b(p[a - 1]) : p[a] - p[a - 1], 0 < f && ("undefined" === typeof w || f < w)) var w = f;else 0 > f && u && !m && (n(15, !1, this.chart), u = !1);
              }

              return {
                xData: p,
                yData: k,
                cropped: q,
                cropStart: h,
                closestPointRange: w
              };
            };

            d.prototype.processData = function (b) {
              var f = this.xAxis;
              if (this.isCartesian && !this.isDirty && !f.isDirty && !this.yAxis.isDirty && !b) return !1;
              b = this.getProcessedData();
              this.cropped = b.cropped;
              this.cropStart = b.cropStart;
              this.processedXData = b.xData;
              this.processedYData = b.yData;
              this.closestPointRange = this.basePointRange = b.closestPointRange;
              D(this, "afterProcessData");
            };

            d.prototype.cropData = function (b, f, e, a, c) {
              var d = b.length,
                  h,
                  p = 0,
                  n = d;
              c = O(c, this.cropShoulder);

              for (h = 0; h < d; h++) {
                if (b[h] >= e) {
                  p = Math.max(0, h - c);
                  break;
                }
              }

              for (e = h; e < d; e++) {
                if (b[e] > a) {
                  n = e + c;
                  break;
                }
              }

              return {
                xData: b.slice(p, n),
                yData: f.slice(p, n),
                start: p,
                end: n
              };
            };

            d.prototype.generatePoints = function () {
              var b = this.options,
                  e = this.processedData || b.data,
                  a = this.processedXData,
                  c = this.processedYData,
                  d = this.pointClass,
                  h = a.length,
                  p = this.cropStart || 0,
                  n = this.hasGroupedData,
                  k = b.keys,
                  u = [];
              b = b.dataGrouping && b.dataGrouping.groupAll ? p : 0;
              var m,
                  r,
                  l = this.data;

              if (!l && !n) {
                var g = [];
                g.length = e.length;
                l = this.data = g;
              }

              k && n && (this.options.keys = !1);

              for (r = 0; r < h; r++) {
                g = p + r;

                if (n) {
                  var q = new d().init(this, [a[r]].concat(Z(c[r])));
                  q.dataGroup = this.groupMap[b + r];
                  q.dataGroup.options && (q.options = q.dataGroup.options, f(q, q.dataGroup.options), delete q.dataLabels);
                } else (q = l[g]) || "undefined" === typeof e[g] || (l[g] = q = new d().init(this, e[g], a[r]));

                q && (q.index = n ? b + r : g, u[r] = q);
              }

              this.options.keys = k;
              if (l && (h !== (m = l.length) || n)) for (r = 0; r < m; r++) {
                r !== p || n || (r += h), l[r] && (l[r].destroyElements(), l[r].plotX = void 0);
              }
              this.data = l;
              this.points = u;
              D(this, "afterGeneratePoints");
            };

            d.prototype.getXExtremes = function (b) {
              return {
                min: y(b),
                max: J(b)
              };
            };

            d.prototype.getExtremes = function (b, f) {
              var e = this.xAxis,
                  a = this.yAxis,
                  c = this.processedXData || this.xData,
                  d = [],
                  h = this.requireSorting ? this.cropShoulder : 0;
              a = a ? a.positiveValuesOnly : !1;
              var n,
                  k = 0,
                  r = 0,
                  m = 0;
              b = b || this.stackedYData || this.processedYData || [];
              var l = b.length;

              if (e) {
                var g = e.getExtremes();
                k = g.min;
                r = g.max;
              }

              for (n = 0; n < l; n++) {
                var q = c[n];
                g = b[n];
                var w = (u(g) || p(g)) && (g.length || 0 < g || !a);
                q = f || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !e || (c[n + h] || q) >= k && (c[n - h] || q) <= r;
                if (w && q) if (w = g.length) for (; w--;) {
                  u(g[w]) && (d[m++] = g[w]);
                } else d[m++] = g;
              }

              b = {
                activeYData: d,
                dataMin: y(d),
                dataMax: J(d)
              };
              D(this, "afterGetExtremes", {
                dataExtremes: b
              });
              return b;
            };

            d.prototype.applyExtremes = function () {
              var b = this.getExtremes();
              this.dataMin = b.dataMin;
              this.dataMax = b.dataMax;
              return b;
            };

            d.prototype.getFirstValidPoint = function (b) {
              for (var f = b.length, e = 0, a = null; null === a && e < f;) {
                a = b[e], e++;
              }

              return a;
            };

            d.prototype.translate = function () {
              this.processedXData || this.processData();
              this.generatePoints();
              var b = this.options,
                  f = b.stacking,
                  a = this.xAxis,
                  c = a.categories,
                  d = this.enabledDataSorting,
                  h = this.yAxis,
                  n = this.points,
                  k = n.length,
                  m = this.pointPlacementToXValue(),
                  l = !!m,
                  g = b.threshold,
                  q = b.startFromThreshold ? g : 0,
                  w = this.zoneAxis || "y",
                  H,
                  y,
                  t = Number.MAX_VALUE;

              for (H = 0; H < k; H++) {
                var v = n[H],
                    K = v.x,
                    F = void 0,
                    L = void 0,
                    J = v.y,
                    N = v.low,
                    M = f && h.stacking && h.stacking.stacks[(this.negStacks && J < (q ? 0 : g) ? "-" : "") + this.stackKey];
                if (h.positiveValuesOnly && !h.validatePositiveValue(J) || a.positiveValuesOnly && !a.validatePositiveValue(K)) v.isNull = !0;
                v.plotX = y = e(z(a.translate(K, 0, 0, 0, 1, m, "flags" === this.type), -1E5, 1E5));

                if (f && this.visible && M && M[K]) {
                  var x = this.getStackIndicator(x, K, this.index);
                  v.isNull || (F = M[K], L = F.points[x.key]);
                }

                p(L) && (N = L[0], J = L[1], N === q && x.key === M[K].base && (N = O(u(g) && g, h.min)), h.positiveValuesOnly && 0 >= N && (N = null), v.total = v.stackTotal = F.total, v.percentage = F.total && v.y / F.total * 100, v.stackY = J, this.irregularWidths || F.setOffset(this.pointXOffset || 0, this.barW || 0));
                v.yBottom = r(N) ? z(h.translate(N, 0, 1, 0, 1), -1E5, 1E5) : null;
                this.dataModify && (J = this.dataModify.modifyValue(J, H));
                v.plotY = void 0;
                u(J) && (F = h.translate(J, !1, !0, !1, !0), "undefined" !== typeof F && (v.plotY = z(F, -1E5, 1E5)));
                v.isInside = this.isPointInside(v);
                v.clientX = l ? e(a.translate(K, 0, 0, 0, 1, m)) : y;
                v.negative = v[w] < (b[w + "Threshold"] || g || 0);
                v.category = O(c && c[v.x], v.x);

                if (!v.isNull && !1 !== v.visible) {
                  "undefined" !== typeof A && (t = Math.min(t, Math.abs(y - A)));
                  var A = y;
                }

                v.zone = this.zones.length ? v.getZone() : void 0;
                !v.graphic && this.group && d && (v.isNew = !0);
              }

              this.closestPointRangePx = t;
              D(this, "afterTranslate");
            };

            d.prototype.getValidPoints = function (b, f, e) {
              var a = this.chart;
              return (b || this.points || []).filter(function (b) {
                return f && !a.isInsidePlot(b.plotX, b.plotY, {
                  inverted: a.inverted
                }) ? !1 : !1 !== b.visible && (e || !b.isNull);
              });
            };

            d.prototype.getClipBox = function () {
              var b = this.chart,
                  f = this.xAxis,
                  e = this.yAxis,
                  a = T(b.clipBox);
              f && f.len !== b.plotSizeX && (a.width = f.len);
              e && e.len !== b.plotSizeY && (a.height = e.len);
              return a;
            };

            d.prototype.getSharedClipKey = function () {
              return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
            };

            d.prototype.setClip = function () {
              var b = this.chart,
                  f = this.group,
                  e = this.markerGroup,
                  a = b.sharedClips;
              b = b.renderer;
              var c = this.getClipBox(),
                  d = this.getSharedClipKey(),
                  h = a[d];
              h ? h.animate(c) : a[d] = h = b.clipRect(c);
              f && f.clip(!1 === this.options.clip ? void 0 : h);
              e && e.clip();
            };

            d.prototype.animate = function (b) {
              var f = this.chart,
                  e = this.group,
                  a = this.markerGroup,
                  d = f.inverted,
                  h = c(this.options.animation),
                  p = [this.getSharedClipKey(), h.duration, h.easing, h.defer].join(),
                  n = f.sharedClips[p],
                  k = f.sharedClips[p + "m"];
              if (b && e) h = this.getClipBox(), n ? n.attr("height", h.height) : (h.width = 0, d && (h.x = f.plotHeight), n = f.renderer.clipRect(h), f.sharedClips[p] = n, k = f.renderer.clipRect({
                x: d ? (f.plotSizeX || 0) + 99 : -99,
                y: d ? -f.plotLeft : -f.plotTop,
                width: 99,
                height: d ? f.chartWidth : f.chartHeight
              }), f.sharedClips[p + "m"] = k), e.clip(n), a && a.clip(k);else if (n && !n.hasClass("highcharts-animating")) {
                f = this.getClipBox();
                var u = h.step;
                a && a.element.childNodes.length && (h.step = function (b, f) {
                  u && u.apply(f, arguments);
                  k && k.element && k.attr(f.prop, "width" === f.prop ? b + 99 : b);
                });
                n.addClass("highcharts-animating").animate(f, h);
              }
            };

            d.prototype.afterAnimate = function () {
              var b = this;
              this.setClip();
              M(this.chart.sharedClips, function (f, e, a) {
                f && !b.chart.container.querySelector('[clip-path="url(#'.concat(f.id, ')"]')) && (f.destroy(), delete a[e]);
              });
              this.finishedAnimating = !0;
              D(this, "afterAnimate");
            };

            d.prototype.drawPoints = function () {
              var b = this.points,
                  f = this.chart,
                  e = this.options.marker,
                  a = this[this.specialGroup] || this.markerGroup,
                  c = this.xAxis,
                  d = O(e.enabled, !c || c.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius),
                  h,
                  p;
              if (!1 !== e.enabled || this._hasPointMarkers) for (h = 0; h < b.length; h++) {
                var n = b[h];
                var k = (p = n.graphic) ? "animate" : "attr";
                var u = n.marker || {};
                var r = !!n.marker;

                if ((d && "undefined" === typeof u.enabled || u.enabled) && !n.isNull && !1 !== n.visible) {
                  var m = O(u.symbol, this.symbol, "rect");
                  var l = this.markerAttribs(n, n.selected && "select");
                  this.enabledDataSorting && (n.startXPos = c.reversed ? -(l.width || 0) : c.width);
                  var g = !1 !== n.isInside;
                  p ? p[g ? "show" : "hide"](g).animate(l) : g && (0 < (l.width || 0) || n.hasImage) && (n.graphic = p = f.renderer.symbol(m, l.x, l.y, l.width, l.height, r ? u : e).add(a), this.enabledDataSorting && f.hasRendered && (p.attr({
                    x: n.startXPos
                  }), k = "animate"));
                  p && "animate" === k && p[g ? "show" : "hide"](g).animate(l);
                  if (p && !f.styledMode) p[k](this.pointAttribs(n, n.selected && "select"));
                  p && p.addClass(n.getClassName(), !0);
                } else p && (n.graphic = p.destroy());
              }
            };

            d.prototype.markerAttribs = function (b, f) {
              var e = this.options,
                  a = e.marker,
                  c = b.marker || {},
                  d = c.symbol || a.symbol,
                  h = O(c.radius, a && a.radius);
              f && (a = a.states[f], f = c.states && c.states[f], h = O(f && f.radius, a && a.radius, h && h + (a && a.radiusPlus || 0)));
              b.hasImage = d && 0 === d.indexOf("url");
              b.hasImage && (h = 0);
              b = u(h) ? {
                x: e.crisp ? Math.floor(b.plotX - h) : b.plotX - h,
                y: b.plotY - h
              } : {};
              h && (b.width = b.height = 2 * h);
              return b;
            };

            d.prototype.pointAttribs = function (b, f) {
              var e = this.options.marker,
                  a = b && b.options,
                  c = a && a.marker || {},
                  d = a && a.color,
                  h = b && b.color,
                  p = b && b.zone && b.zone.color,
                  n = this.color;
              b = O(c.lineWidth, e.lineWidth);
              a = 1;
              n = d || p || h || n;
              d = c.fillColor || e.fillColor || n;
              h = c.lineColor || e.lineColor || n;
              f = f || "normal";
              e = e.states[f] || {};
              f = c.states && c.states[f] || {};
              b = O(f.lineWidth, e.lineWidth, b + O(f.lineWidthPlus, e.lineWidthPlus, 0));
              d = f.fillColor || e.fillColor || d;
              h = f.lineColor || e.lineColor || h;
              a = O(f.opacity, e.opacity, a);
              return {
                stroke: h,
                "stroke-width": b,
                fill: d,
                opacity: a
              };
            };

            d.prototype.destroy = function (b) {
              var f = this,
                  e = f.chart,
                  a = /AppleWebKit\/533/.test(N.navigator.userAgent),
                  c = f.data || [],
                  d,
                  p,
                  n,
                  k;
              D(f, "destroy", {
                keepEventsForUpdate: b
              });
              this.removeEvents(b);
              (f.axisTypes || []).forEach(function (b) {
                (k = f[b]) && k.series && (h(k.series, f), k.isDirty = k.forceRedraw = !0);
              });
              f.legendItem && f.chart.legend.destroyItem(f);

              for (p = c.length; p--;) {
                (n = c[p]) && n.destroy && n.destroy();
              }

              f.clips && f.clips.forEach(function (b) {
                return b.destroy();
              });
              q.clearTimeout(f.animationTimeout);
              M(f, function (b, f) {
                b instanceof t && !b.survive && (d = a && "group" === f ? "hide" : "destroy", b[d]());
              });
              e.hoverSeries === f && (e.hoverSeries = void 0);
              h(e.series, f);
              e.orderSeries();
              M(f, function (e, a) {
                b && "hcEvents" === a || delete f[a];
              });
            };

            d.prototype.applyZones = function () {
              var b = this,
                  f = this.chart,
                  e = f.renderer,
                  a = this.zones,
                  c = this.clips || [],
                  d = this.graph,
                  h = this.area,
                  p = Math.max(f.chartWidth, f.chartHeight),
                  n = this[(this.zoneAxis || "y") + "Axis"],
                  k = f.inverted,
                  u,
                  r,
                  m,
                  l,
                  g,
                  q,
                  w,
                  D,
                  H = !1;

              if (a.length && (d || h) && n && "undefined" !== typeof n.min) {
                var y = n.reversed;
                var t = n.horiz;
                d && !this.showLine && d.hide();
                h && h.hide();
                var v = n.getExtremes();
                a.forEach(function (a, K) {
                  u = y ? t ? f.plotWidth : 0 : t ? 0 : n.toPixels(v.min) || 0;
                  u = z(O(r, u), 0, p);
                  r = z(Math.round(n.toPixels(O(a.value, v.max), !0) || 0), 0, p);
                  H && (u = r = n.toPixels(v.max));
                  l = Math.abs(u - r);
                  g = Math.min(u, r);
                  q = Math.max(u, r);
                  n.isXAxis ? (m = {
                    x: k ? q : g,
                    y: 0,
                    width: l,
                    height: p
                  }, t || (m.x = f.plotHeight - m.x)) : (m = {
                    x: 0,
                    y: k ? q : g,
                    width: p,
                    height: l
                  }, t && (m.y = f.plotWidth - m.y));
                  k && e.isVML && (m = n.isXAxis ? {
                    x: 0,
                    y: y ? g : q,
                    height: m.width,
                    width: f.chartWidth
                  } : {
                    x: m.y - f.plotLeft - f.spacingBox.x,
                    y: 0,
                    width: m.height,
                    height: f.chartHeight
                  });
                  c[K] ? c[K].animate(m) : c[K] = e.clipRect(m);
                  w = b["zone-area-" + K];
                  D = b["zone-graph-" + K];
                  d && D && D.clip(c[K]);
                  h && w && w.clip(c[K]);
                  H = a.value > v.max;
                  b.resetZones && 0 === r && (r = void 0);
                });
                this.clips = c;
              } else b.visible && (d && d.show(), h && h.show());
            };

            d.prototype.invertGroups = function (b) {
              function f() {
                ["group", "markerGroup"].forEach(function (f) {
                  e[f] && (a.renderer.isVML && e[f].attr({
                    width: e.yAxis.len,
                    height: e.xAxis.len
                  }), e[f].width = e.yAxis.len, e[f].height = e.xAxis.len, e[f].invert(e.isRadialSeries ? !1 : b));
                });
              }

              var e = this,
                  a = e.chart;
              e.xAxis && (e.eventsToUnbind.push(L(a, "resize", f)), f(), e.invertGroups = f);
            };

            d.prototype.plotGroup = function (b, f, e, a, c) {
              var d = this[b],
                  h = !d;
              e = {
                visibility: e,
                zIndex: a || .1
              };
              "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (e.opacity = this.opacity);
              h && (this[b] = d = this.chart.renderer.g().add(c));
              d.addClass("highcharts-" + f + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (r(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (d.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
              d.attr(e)[h ? "attr" : "animate"](this.getPlotBox());
              return d;
            };

            d.prototype.getPlotBox = function () {
              var b = this.chart,
                  f = this.xAxis,
                  e = this.yAxis;
              b.inverted && (f = e, e = this.xAxis);
              return {
                translateX: f ? f.left : b.plotLeft,
                translateY: e ? e.top : b.plotTop,
                scaleX: 1,
                scaleY: 1
              };
            };

            d.prototype.removeEvents = function (b) {
              b || C(this);
              this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
                b();
              }), this.eventsToUnbind.length = 0);
            };

            d.prototype.render = function () {
              var b = this,
                  f = b.chart,
                  e = b.options,
                  a = c(e.animation),
                  d = b.visible ? "inherit" : "hidden",
                  h = e.zIndex,
                  p = b.hasRendered,
                  n = f.seriesGroup,
                  k = f.inverted;
              f = !b.finishedAnimating && f.renderer.isSVG ? a.duration : 0;
              D(this, "render");
              var u = b.plotGroup("group", "series", d, h, n);
              b.markerGroup = b.plotGroup("markerGroup", "markers", d, h, n);
              !1 !== e.clip && b.setClip();
              b.animate && f && b.animate(!0);
              u.inverted = O(b.invertible, b.isCartesian) ? k : !1;
              b.drawGraph && (b.drawGraph(), b.applyZones());
              b.visible && b.drawPoints();
              b.drawDataLabels && b.drawDataLabels();
              b.redrawPoints && b.redrawPoints();
              b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();
              b.invertGroups(k);
              b.animate && f && b.animate();
              p || (f && a.defer && (f += a.defer), b.animationTimeout = ha(function () {
                b.afterAnimate();
              }, f || 0));
              b.isDirty = !1;
              b.hasRendered = !0;
              D(b, "afterRender");
            };

            d.prototype.redraw = function () {
              var b = this.chart,
                  f = this.isDirty || this.isDirtyData,
                  e = this.group,
                  a = this.xAxis,
                  c = this.yAxis;
              e && (b.inverted && e.attr({
                width: b.plotWidth,
                height: b.plotHeight
              }), e.animate({
                translateX: O(a && a.left, b.plotLeft),
                translateY: O(c && c.top, b.plotTop)
              }));
              this.translate();
              this.render();
              f && delete this.kdTree;
            };

            d.prototype.searchPoint = function (b, f) {
              var e = this.xAxis,
                  a = this.yAxis,
                  c = this.chart.inverted;
              return this.searchKDTree({
                clientX: c ? e.len - b.chartY + e.pos : b.chartX - e.pos,
                plotY: c ? a.len - b.chartX + a.pos : b.chartY - a.pos
              }, f, b);
            };

            d.prototype.buildKDTree = function (b) {
              function f(b, a, c) {
                var d = b && b.length;

                if (d) {
                  var h = e.kdAxisArray[a % c];
                  b.sort(function (b, f) {
                    return b[h] - f[h];
                  });
                  d = Math.floor(d / 2);
                  return {
                    point: b[d],
                    left: f(b.slice(0, d), a + 1, c),
                    right: f(b.slice(d + 1), a + 1, c)
                  };
                }
              }

              this.buildingKdTree = !0;
              var e = this,
                  a = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete e.kdTree;
              ha(function () {
                e.kdTree = f(e.getValidPoints(null, !e.directTouch), a, a);
                e.buildingKdTree = !1;
              }, e.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
            };

            d.prototype.searchKDTree = function (b, f, e) {
              function a(b, f, e, n) {
                var k = f.point,
                    u = c.kdAxisArray[e % n],
                    m = k,
                    l = r(b[d]) && r(k[d]) ? Math.pow(b[d] - k[d], 2) : null;
                var g = r(b[h]) && r(k[h]) ? Math.pow(b[h] - k[h], 2) : null;
                g = (l || 0) + (g || 0);
                k.dist = r(g) ? Math.sqrt(g) : Number.MAX_VALUE;
                k.distX = r(l) ? Math.sqrt(l) : Number.MAX_VALUE;
                u = b[u] - k[u];
                g = 0 > u ? "left" : "right";
                l = 0 > u ? "right" : "left";
                f[g] && (g = a(b, f[g], e + 1, n), m = g[p] < m[p] ? g : k);
                f[l] && Math.sqrt(u * u) < m[p] && (b = a(b, f[l], e + 1, n), m = b[p] < m[p] ? b : m);
                return m;
              }

              var c = this,
                  d = this.kdAxisArray[0],
                  h = this.kdAxisArray[1],
                  p = f ? "distX" : "dist";
              f = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              this.kdTree || this.buildingKdTree || this.buildKDTree(e);
              if (this.kdTree) return a(b, this.kdTree, f, f);
            };

            d.prototype.pointPlacementToXValue = function () {
              var b = this.options,
                  f = b.pointRange,
                  e = this.xAxis;
              b = b.pointPlacement;
              "between" === b && (b = e.reversed ? -.5 : .5);
              return u(b) ? b * (f || e.pointRange) : 0;
            };

            d.prototype.isPointInside = function (b) {
              var f = this.chart,
                  e = this.xAxis,
                  a = this.yAxis;
              return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (a ? a.len : f.plotHeight) && 0 <= b.plotX && b.plotX <= (e ? e.len : f.plotWidth);
            };

            d.prototype.drawTracker = function () {
              var b = this,
                  f = b.options,
                  e = f.trackByArea,
                  a = [].concat(e ? b.areaPath : b.graphPath),
                  c = b.chart,
                  d = c.pointer,
                  h = c.renderer,
                  p = c.options.tooltip.snap,
                  n = b.tracker,
                  k = function k(f) {
                if (c.hoverSeries !== b) b.onMouseOver();
              },
                  u = "rgba(192,192,192," + (m ? .0001 : .002) + ")";

              n ? n.attr({
                d: a
              }) : b.graph && (b.tracker = h.path(a).attr({
                visibility: b.visible ? "inherit" : "hidden",
                zIndex: 2
              }).addClass(e ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), c.styledMode || b.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: u,
                fill: e ? u : "none",
                "stroke-width": b.graph.strokeWidth() + (e ? 0 : 2 * p)
              }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
                if (b && (b.addClass("highcharts-tracker").on("mouseover", k).on("mouseout", function (b) {
                  d.onTrackerMouseOut(b);
                }), f.cursor && !c.styledMode && b.css({
                  cursor: f.cursor
                }), v)) b.on("touchstart", k);
              }));
              D(this, "afterDrawTracker");
            };

            d.prototype.addPoint = function (b, f, e, a, c) {
              var d = this.options,
                  h = this.data,
                  p = this.chart,
                  n = this.xAxis;
              n = n && n.hasNames && n.names;
              var k = d.data,
                  u = this.xData,
                  m;
              f = O(f, !0);
              var r = {
                series: this
              };
              this.pointClass.prototype.applyOptions.apply(r, [b]);
              var l = r.x;
              var g = u.length;
              if (this.requireSorting && l < u[g - 1]) for (m = !0; g && u[g - 1] > l;) {
                g--;
              }
              this.updateParallelArrays(r, "splice", g, 0, 0);
              this.updateParallelArrays(r, g);
              n && r.name && (n[l] = r.name);
              k.splice(g, 0, b);
              if (m || this.processedData) this.data.splice(g, 0, null), this.processData();
              "point" === d.legendType && this.generatePoints();
              e && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(r, "shift"), k.shift()));
              !1 !== c && D(this, "addPoint", {
                point: r
              });
              this.isDirtyData = this.isDirty = !0;
              f && p.redraw(a);
            };

            d.prototype.removePoint = function (b, f, e) {
              var a = this,
                  c = a.data,
                  d = c[b],
                  h = a.points,
                  p = a.chart,
                  n = function n() {
                h && h.length === c.length && h.splice(b, 1);
                c.splice(b, 1);
                a.options.data.splice(b, 1);
                a.updateParallelArrays(d || {
                  series: a
                }, "splice", b, 1);
                d && d.destroy();
                a.isDirty = !0;
                a.isDirtyData = !0;
                f && p.redraw();
              };

              l(e, p);
              f = O(f, !0);
              d ? d.firePointEvent("remove", null, n) : n();
            };

            d.prototype.remove = function (b, f, e, a) {
              function c() {
                d.destroy(a);
                h.isDirtyLegend = h.isDirtyBox = !0;
                h.linkSeries();
                O(b, !0) && h.redraw(f);
              }

              var d = this,
                  h = d.chart;
              !1 !== e ? D(d, "remove", null, c) : c();
            };

            d.prototype.update = function (b, e) {
              b = w(b, this.userOptions);
              D(this, "update", {
                options: b
              });
              var a = this,
                  c = a.chart,
                  d = a.userOptions,
                  h = a.initialType || a.type,
                  p = c.options.plotOptions,
                  k = F[h].prototype,
                  u = a.finishedAnimating && {
                animation: !1
              },
                  m = {},
                  r,
                  l = ["eventOptions", "navigatorSeries", "baseSeries"],
                  g = b.type || d.type || c.options.chart.type,
                  q = !(this.hasDerivedData || g && g !== this.type || "undefined" !== typeof b.pointStart || "undefined" !== typeof b.pointInterval || "undefined" !== typeof b.relativeXValue || b.joinBy || b.mapData || a.hasOptionChanged("dataGrouping") || a.hasOptionChanged("pointStart") || a.hasOptionChanged("pointInterval") || a.hasOptionChanged("pointIntervalUnit") || a.hasOptionChanged("keys"));
              g = g || h;
              q && (l.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== b.visible && l.push("area", "graph"), a.parallelArrays.forEach(function (b) {
                l.push(b + "Data");
              }), b.data && (b.dataSorting && f(a.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));
              b = T(d, u, {
                index: "undefined" === typeof d.index ? a.index : d.index,
                pointStart: O(p && p.series && p.series.pointStart, d.pointStart, a.xData[0])
              }, !q && {
                data: a.options.data
              }, b);
              q && b.data && (b.data = a.options.data);
              l = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(l);
              l.forEach(function (b) {
                l[b] = a[b];
                delete a[b];
              });
              p = !1;

              if (F[g]) {
                if (p = g !== a.type, a.remove(!1, !1, !1, !0), p) if (Object.setPrototypeOf) Object.setPrototypeOf(a, F[g].prototype);else {
                  u = Object.hasOwnProperty.call(a, "hcEvents") && a.hcEvents;

                  for (r in k) {
                    a[r] = void 0;
                  }

                  f(a, F[g].prototype);
                  u ? a.hcEvents = u : delete a.hcEvents;
                }
              } else n(17, !0, c, {
                missingModuleFor: g
              });

              l.forEach(function (b) {
                a[b] = l[b];
              });
              a.init(c, b);

              if (q && this.points) {
                var H = a.options;
                !1 === H.visible ? (m.graphic = 1, m.dataLabel = 1) : a._hasPointLabels || (b = H.marker, k = H.dataLabels, !b || !1 !== b.enabled && (d.marker && d.marker.symbol) === b.symbol || (m.graphic = 1), k && !1 === k.enabled && (m.dataLabel = 1));
                this.points.forEach(function (b) {
                  b && b.series && (b.resolveColor(), Object.keys(m).length && b.destroyElements(m), !1 === H.showInLegend && b.legendItem && c.legend.destroyItem(b));
                }, this);
              }

              a.initialType = h;
              c.linkSeries();
              p && a.linkedSeries.length && (a.isDirtyData = !0);
              D(this, "afterUpdate");
              O(e, !0) && c.redraw(q ? void 0 : !1);
            };

            d.prototype.setName = function (b) {
              this.name = this.options.name = this.userOptions.name = b;
              this.chart.isDirtyLegend = !0;
            };

            d.prototype.hasOptionChanged = function (b) {
              var f = this.options[b],
                  e = this.chart.options.plotOptions,
                  a = this.userOptions[b];
              return a ? f !== a : f !== O(e && e[this.type] && e[this.type][b], e && e.series && e.series[b], f);
            };

            d.prototype.onMouseOver = function () {
              var b = this.chart,
                  f = b.hoverSeries;
              b.pointer.setHoverChartIndex();
              if (f && f !== this) f.onMouseOut();
              this.options.events.mouseOver && D(this, "mouseOver");
              this.setState("hover");
              b.hoverSeries = this;
            };

            d.prototype.onMouseOut = function () {
              var b = this.options,
                  f = this.chart,
                  e = f.tooltip,
                  a = f.hoverPoint;
              f.hoverSeries = null;
              if (a) a.onMouseOut();
              this && b.events.mouseOut && D(this, "mouseOut");
              !e || this.stickyTracking || e.shared && !this.noSharedTooltip || e.hide();
              f.series.forEach(function (b) {
                b.setState("", !0);
              });
            };

            d.prototype.setState = function (b, f) {
              var e = this,
                  a = e.options,
                  c = e.graph,
                  d = a.inactiveOtherPoints,
                  h = a.states,
                  p = O(h[b || "normal"] && h[b || "normal"].animation, e.chart.options.chart.animation),
                  n = a.lineWidth,
                  k = 0,
                  u = a.opacity;
              b = b || "";

              if (e.state !== b && ([e.group, e.markerGroup, e.dataLabelsGroup].forEach(function (f) {
                f && (e.state && f.removeClass("highcharts-series-" + e.state), b && f.addClass("highcharts-series-" + b));
              }), e.state = b, !e.chart.styledMode)) {
                if (h[b] && !1 === h[b].enabled) return;
                b && (n = h[b].lineWidth || n + (h[b].lineWidthPlus || 0), u = O(h[b].opacity, u));
                if (c && !c.dashstyle) for (a = {
                  "stroke-width": n
                }, c.animate(a, p); e["zone-graph-" + k];) {
                  e["zone-graph-" + k].animate(a, p), k += 1;
                }
                d || [e.group, e.markerGroup, e.dataLabelsGroup, e.labelBySeries].forEach(function (b) {
                  b && b.animate({
                    opacity: u
                  }, p);
                });
              }

              f && d && e.points && e.setAllPointsToState(b || void 0);
            };

            d.prototype.setAllPointsToState = function (b) {
              this.points.forEach(function (f) {
                f.setState && f.setState(b);
              });
            };

            d.prototype.setVisible = function (b, f) {
              var e = this,
                  a = e.chart,
                  c = e.legendItem,
                  d = a.options.chart.ignoreHiddenSeries,
                  h = e.visible,
                  p = (e.visible = b = e.options.visible = e.userOptions.visible = "undefined" === typeof b ? !h : b) ? "show" : "hide";
              ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
                if (e[b]) e[b][p]();
              });
              if (a.hoverSeries === e || (a.hoverPoint && a.hoverPoint.series) === e) e.onMouseOut();
              c && a.legend.colorizeItem(e, b);
              e.isDirty = !0;
              e.options.stacking && a.series.forEach(function (b) {
                b.options.stacking && b.visible && (b.isDirty = !0);
              });
              e.linkedSeries.forEach(function (f) {
                f.setVisible(b, !1);
              });
              d && (a.isDirtyBox = !0);
              D(e, p);
              !1 !== f && a.redraw();
            };

            d.prototype.show = function () {
              this.setVisible(!0);
            };

            d.prototype.hide = function () {
              this.setVisible(!1);
            };

            d.prototype.select = function (b) {
              this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
              this.checkbox && (this.checkbox.checked = b);
              D(this, b ? "select" : "unselect");
            };

            d.prototype.shouldShowTooltip = function (b, f, e) {
              void 0 === e && (e = {});
              e.series = this;
              e.visiblePlotOnly = !0;
              return this.chart.isInsidePlot(b, f, e);
            };

            d.defaultOptions = I;
            return d;
          }();

          f(d.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: x.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: G,
            requireSorting: !0,
            sorted: !0
          });
          A.series = d;
          "";
          "";
          return d;
        });
        P(g, "Extensions/ScrollablePlotArea.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Series/Series.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G) {
          var C = d.stop,
              A = G.addEvent,
              t = G.createElement,
              q = G.defined,
              c = G.merge,
              l = G.pick;
          A(B, "afterSetChartSize", function (a) {
            var d = this.options.chart.scrollablePlotArea,
                l = d && d.minWidth;
            d = d && d.minHeight;

            if (!this.renderer.forExport) {
              if (l) {
                if (this.scrollablePixelsX = l = Math.max(0, l - this.chartWidth)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox);
                  this.plotBox.width = this.plotWidth += l;
                  this.inverted ? this.clipBox.height += l : this.clipBox.width += l;
                  var m = {
                    1: {
                      name: "right",
                      value: l
                    }
                  };
                }
              } else d && (this.scrollablePixelsY = l = Math.max(0, d - this.chartHeight), q(l) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.height = this.plotHeight += l, this.inverted ? this.clipBox.width += l : this.clipBox.height += l, m = {
                2: {
                  name: "bottom",
                  value: l
                }
              }));

              m && !a.skipAxes && this.axes.forEach(function (a) {
                m[a.side] ? a.getPlotLinePath = function () {
                  var c = m[a.side].name,
                      d = this[c];
                  this[c] = d - m[a.side].value;
                  var k = g.prototype.getPlotLinePath.apply(this, arguments);
                  this[c] = d;
                  return k;
                } : (a.setAxisSize(), a.setAxisTranslation());
              });
            }
          });
          A(B, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });

          B.prototype.setUpScrolling = function () {
            var a = this,
                c = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            this.scrollablePixelsX && (c.overflowX = "auto");
            this.scrollablePixelsY && (c.overflowY = "auto");
            this.scrollingParent = t("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = t("div", {
              className: "highcharts-scrolling"
            }, c, this.scrollingParent);
            A(this.scrollingContainer, "scroll", function () {
              a.pointer && delete a.pointer.chartPosition;
            });
            this.innerContainer = t("div", {
              className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };

          B.prototype.moveFixedElements = function () {
            var a = this.container,
                c = this.fixedRenderer,
                d = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
                m;
            this.scrollablePixelsX && !this.inverted ? m = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? m = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? m = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (m = ".highcharts-yaxis");
            m && d.push("" + m + ":not(.highcharts-radial-axis)", "" + m + "-labels:not(.highcharts-radial-axis-labels)");
            d.forEach(function (d) {
              [].forEach.call(a.querySelectorAll(d), function (a) {
                (a.namespaceURI === c.SVG_NS ? c.box : c.box.parentNode).appendChild(a);
                a.style.pointerEvents = "auto";
              });
            });
          };

          B.prototype.applyFixed = function () {
            var a = !this.fixedDiv,
                c = this.options.chart,
                d = c.scrollablePlotArea,
                m = x.getRendererType();
            a ? (this.fixedDiv = t("div", {
              className: "highcharts-fixed"
            }, {
              position: "absolute",
              overflow: "hidden",
              pointerEvents: "none",
              zIndex: (c.style && c.style.zIndex || 0) + 2,
              top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = c = new m(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({
              fill: this.options.chart.backgroundColor || "#fff",
              "fill-opacity": l(d.opacity, .85),
              zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), A(this, "afterShowResetZoom", this.moveFixedElements), A(this, "afterApplyDrilldown", this.moveFixedElements), A(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
            c = this.chartWidth + (this.scrollablePixelsX || 0);
            m = this.chartHeight + (this.scrollablePixelsY || 0);
            C(this.container);
            this.container.style.width = c + "px";
            this.container.style.height = m + "px";
            this.renderer.boxWrapper.attr({
              width: c,
              height: m,
              viewBox: [0, 0, c, m].join(" ")
            });
            this.chartBackground.attr({
              width: c,
              height: m
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            a && (d.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * d.scrollPositionX), d.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * d.scrollPositionY));
            m = this.axisOffset;
            a = this.plotTop - m[0] - 1;
            d = this.plotLeft - m[3] - 1;
            c = this.plotTop + this.plotHeight + m[2] + 1;
            m = this.plotLeft + this.plotWidth + m[1] + 1;
            var g = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                q = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, c], ["L", 0, c], ["Z"], ["M", g, a], ["L", this.chartWidth, a], ["L", this.chartWidth, c], ["L", g, c], ["Z"]] : this.scrollablePixelsY ? [["M", d, 0], ["L", d, this.plotTop - 1], ["L", m, this.plotTop - 1], ["L", m, 0], ["Z"], ["M", d, q], ["L", d, this.chartHeight], ["L", m, this.chartHeight], ["L", m, q], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
              d: a
            });
          };

          A(g, "afterInit", function () {
            this.chart.scrollableDirty = !0;
          });
          A(E, "show", function () {
            this.chart.scrollableDirty = !0;
          });
          "";
        });
        P(g, "Core/Axis/StackingAxis.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = d.getDeferredAnimation,
              x = B.addEvent,
              G = B.destroyObjectProperties,
              I = B.fireEvent,
              A = B.isNumber,
              t = B.objectEach,
              q;

          (function (c) {
            function d() {
              var a = this.stacking;

              if (a) {
                var c = a.stacks;
                t(c, function (a, d) {
                  G(a);
                  c[d] = null;
                });
                a && a.stackTotalGroup && a.stackTotalGroup.destroy();
              }
            }

            function a() {
              this.stacking || (this.stacking = new g(this));
            }

            var k = [];

            c.compose = function (c) {
              -1 === k.indexOf(c) && (k.push(c), x(c, "init", a), x(c, "destroy", d));
              return c;
            };

            var g = function () {
              function a(a) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = a;
              }

              a.prototype.buildStacks = function () {
                var a = this.axis,
                    c = a.series,
                    d = a.options.reversedStacks,
                    k = c.length,
                    m;

                if (!a.isXAxis) {
                  this.usePercentage = !1;

                  for (m = k; m--;) {
                    var l = c[d ? m : k - m - 1];
                    l.setStackedPoints();
                    l.setGroupedPoints();
                  }

                  for (m = 0; m < k; m++) {
                    c[m].modifyStacks();
                  }

                  I(a, "afterBuildStacks");
                }
              };

              a.prototype.cleanStacks = function () {
                if (!this.axis.isXAxis) {
                  if (this.oldStacks) var a = this.stacks = this.oldStacks;
                  t(a, function (a) {
                    t(a, function (a) {
                      a.cumulative = a.total;
                    });
                  });
                }
              };

              a.prototype.resetStacks = function () {
                var a = this,
                    c = a.stacks;
                a.axis.isXAxis || t(c, function (c) {
                  t(c, function (d, k) {
                    A(d.touched) && d.touched < a.stacksTouched ? (d.destroy(), delete c[k]) : (d.total = null, d.cumulative = null);
                  });
                });
              };

              a.prototype.renderStackTotals = function () {
                var a = this.axis,
                    c = a.chart,
                    d = c.renderer,
                    k = this.stacks;
                a = C(c, a.options.stackLabels && a.options.stackLabels.animation || !1);
                var m = this.stackTotalGroup = this.stackTotalGroup || d.g("stack-labels").attr({
                  zIndex: 6,
                  opacity: 0
                }).add();
                m.translate(c.plotLeft, c.plotTop);
                t(k, function (a) {
                  t(a, function (a) {
                    a.render(m);
                  });
                });
                m.animate({
                  opacity: 1
                }, a);
              };

              return a;
            }();

            c.Additions = g;
          })(q || (q = {}));

          return q;
        });
        P(g, "Extensions/Stacking.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Series/Series.js"], g["Core/Axis/StackingAxis.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I) {
          var A = B.format,
              t = I.correctFloat,
              q = I.defined,
              c = I.destroyObjectProperties,
              l = I.isArray,
              a = I.isNumber,
              k = I.objectEach,
              v = I.pick,
              m = function () {
            function d(a, c, d, k, m) {
              var l = a.chart.inverted;
              this.axis = a;
              this.isNegative = d;
              this.options = c = c || {};
              this.x = k;
              this.total = null;
              this.points = {};
              this.hasValidPoints = !1;
              this.stack = m;
              this.rightCliff = this.leftCliff = 0;
              this.alignOptions = {
                align: c.align || (l ? d ? "left" : "right" : "center"),
                verticalAlign: c.verticalAlign || (l ? "middle" : d ? "bottom" : "top"),
                y: c.y,
                x: c.x
              };
              this.textAlign = c.textAlign || (l ? d ? "right" : "left" : "center");
            }

            d.prototype.destroy = function () {
              c(this, this.axis);
            };

            d.prototype.render = function (a) {
              var c = this.axis.chart,
                  d = this.options,
                  k = d.format;
              k = k ? A(k, this, c) : d.formatter.call(this);
              this.label ? this.label.attr({
                text: k,
                visibility: "hidden"
              }) : (this.label = c.renderer.label(k, null, null, d.shape, null, null, d.useHTML, !1, "stack-labels"), k = {
                r: d.borderRadius || 0,
                text: k,
                rotation: d.rotation,
                padding: v(d.padding, 5),
                visibility: "hidden"
              }, c.styledMode || (k.fill = d.backgroundColor, k.stroke = d.borderColor, k["stroke-width"] = d.borderWidth, this.label.css(d.style)), this.label.attr(k), this.label.added || this.label.add(a));
              this.label.labelrank = c.plotSizeY;
            };

            d.prototype.setOffset = function (c, d, k, m, l) {
              var g = this.axis,
                  e = g.chart;
              m = g.translate(g.stacking.usePercentage ? 100 : m ? m : this.total, 0, 0, 0, 1);
              k = g.translate(k ? k : 0);
              k = q(m) && Math.abs(m - k);
              c = v(l, e.xAxis[0].translate(this.x)) + c;
              g = q(m) && this.getStackBox(e, this, c, m, d, k, g);
              d = this.label;
              k = this.isNegative;
              c = "justify" === v(this.options.overflow, "justify");
              var r = this.textAlign;
              d && g && (l = d.getBBox(), m = d.padding, r = "left" === r ? e.inverted ? -m : m : "right" === r ? l.width : e.inverted && "center" === r ? l.width / 2 : e.inverted ? k ? l.width + m : -m : l.width / 2, k = e.inverted ? l.height / 2 : k ? -m : l.height, this.alignOptions.x = v(this.options.x, 0), this.alignOptions.y = v(this.options.y, 0), g.x -= r, g.y -= k, d.align(this.alignOptions, null, g), e.isInsidePlot(d.alignAttr.x + r - this.alignOptions.x, d.alignAttr.y + k - this.alignOptions.y) ? d.show() : (d.hide(), c = !1), c && x.prototype.justifyDataLabel.call(this.axis, d, this.alignOptions, d.alignAttr, l, g), d.attr({
                x: d.alignAttr.x,
                y: d.alignAttr.y
              }), v(!c && this.options.crop, !0) && ((e = a(d.x) && a(d.y) && e.isInsidePlot(d.x - m + d.width, d.y) && e.isInsidePlot(d.x + m, d.y)) || d.hide()));
            };

            d.prototype.getStackBox = function (a, c, d, k, m, l, e) {
              var r = c.axis.reversed,
                  h = a.inverted,
                  n = e.height + e.pos - (h ? a.plotLeft : a.plotTop);
              c = c.isNegative && !r || !c.isNegative && r;
              return {
                x: h ? c ? k - e.right : k - l + e.pos - a.plotLeft : d + a.xAxis[0].transB - a.plotLeft,
                y: h ? e.height - d - m : c ? n - k - l : n - k,
                width: h ? l : m,
                height: h ? m : l
              };
            };

            return d;
          }();

          g.prototype.getStacks = function () {
            var a = this,
                c = a.inverted;
            a.yAxis.forEach(function (a) {
              a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
            });
            a.series.forEach(function (d) {
              var k = d.xAxis && d.xAxis.options || {};
              !d.options.stacking || !0 !== d.visible && !1 !== a.options.chart.ignoreHiddenSeries || (d.stackKey = [d.type, v(d.options.stack, ""), c ? k.top : k.left, c ? k.height : k.width].join());
            });
          };

          G.compose(d);

          x.prototype.setGroupedPoints = function () {
            var a = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? x.prototype.setStackedPoints.call(this, "group") : a && k(a.stacks, function (c, d) {
              "group" === d.slice(-5) && (k(c, function (a) {
                return a.destroy();
              }), delete a.stacks[d]);
            });
          };

          x.prototype.setStackedPoints = function (a) {
            var c = a || this.options.stacking;

            if (c && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
              var d = this.processedXData,
                  k = this.processedYData,
                  g = [],
                  z = k.length,
                  w = this.options,
                  e = w.threshold,
                  r = v(w.startFromThreshold && e, 0);
              w = w.stack;
              a = a ? "" + this.type + ",".concat(c) : this.stackKey;
              var h = "-" + a,
                  n = this.negStacks,
                  f = this.yAxis,
                  b = f.stacking.stacks,
                  D = f.stacking.oldStacks,
                  H,
                  p;
              f.stacking.stacksTouched += 1;

              for (p = 0; p < z; p++) {
                var u = d[p];
                var K = k[p];
                var x = this.getStackIndicator(x, u, this.index);
                var M = x.key;
                var O = (H = n && K < (r ? 0 : e)) ? h : a;
                b[O] || (b[O] = {});
                b[O][u] || (D[O] && D[O][u] ? (b[O][u] = D[O][u], b[O][u].total = null) : b[O][u] = new m(f, f.options.stackLabels, H, u, w));
                O = b[O][u];
                null !== K ? (O.points[M] = O.points[this.index] = [v(O.cumulative, r)], q(O.cumulative) || (O.base = M), O.touched = f.stacking.stacksTouched, 0 < x.index && !1 === this.singleStacks && (O.points[M][0] = O.points[this.index + "," + u + ",0"][0])) : O.points[M] = O.points[this.index] = null;
                "percent" === c ? (H = H ? a : h, n && b[H] && b[H][u] ? (H = b[H][u], O.total = H.total = Math.max(H.total, O.total) + Math.abs(K) || 0) : O.total = t(O.total + (Math.abs(K) || 0))) : "group" === c ? (l(K) && (K = K[0]), null !== K && (O.total = (O.total || 0) + 1)) : O.total = t(O.total + (K || 0));
                O.cumulative = "group" === c ? (O.total || 1) - 1 : v(O.cumulative, r) + (K || 0);
                null !== K && (O.points[M].push(O.cumulative), g[p] = O.cumulative, O.hasValidPoints = !0);
              }

              "percent" === c && (f.stacking.usePercentage = !0);
              "group" !== c && (this.stackedYData = g);
              f.stacking.oldStacks = {};
            }
          };

          x.prototype.modifyStacks = function () {
            var a = this,
                c = a.stackKey,
                d = a.yAxis.stacking.stacks,
                k = a.processedXData,
                m,
                l = a.options.stacking;
            a[l + "Stacker"] && [c, "-" + c].forEach(function (c) {
              for (var e = k.length, r, h; e--;) {
                if (r = k[e], m = a.getStackIndicator(m, r, a.index, c), h = (r = d[c] && d[c][r]) && r.points[m.key]) a[l + "Stacker"](h, r, e);
              }
            });
          };

          x.prototype.percentStacker = function (a, c, d) {
            c = c.total ? 100 / c.total : 0;
            a[0] = t(a[0] * c);
            a[1] = t(a[1] * c);
            this.stackedYData[d] = a[1];
          };

          x.prototype.getStackIndicator = function (a, c, d, k) {
            !q(a) || a.x !== c || k && a.stackKey !== k ? a = {
              x: c,
              index: 0,
              key: k,
              stackKey: k
            } : a.index++;
            a.key = [d, c, a.index].join();
            return a;
          };

          E.StackItem = m;
          "";
          return E.StackItem;
        });
        P(g, "Series/Line/LineSeries.js", [g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = this && this.__extends || function () {
            var _d2 = function d(g, t) {
              _d2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, c) {
                d.__proto__ = c;
              } || function (d, c) {
                for (var l in c) {
                  c.hasOwnProperty(l) && (d[l] = c[l]);
                }
              };

              return _d2(g, t);
            };

            return function (g, t) {
              function q() {
                this.constructor = g;
              }

              _d2(g, t);

              g.prototype = null === t ? Object.create(t) : (q.prototype = t.prototype, new q());
            };
          }(),
              x = B.defined,
              G = B.merge;

          B = function (g) {
            function A() {
              var d = null !== g && g.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            C(A, g);

            A.prototype.drawGraph = function () {
              var d = this,
                  g = this.options,
                  c = (this.gappedPath || this.getGraphPath).call(this),
                  l = this.chart.styledMode,
                  a = [["graph", "highcharts-graph"]];
              l || a[0].push(g.lineColor || this.color || "#cccccc", g.dashStyle);
              a = d.getZonesGraphs(a);
              a.forEach(function (a, q) {
                var k = a[0],
                    t = d[k],
                    v = t ? "animate" : "attr";
                t ? (t.endX = d.preventGraphAnimation ? null : c.xMap, t.animate({
                  d: c
                })) : c.length && (d[k] = t = d.chart.renderer.path(c).addClass(a[1]).attr({
                  zIndex: 1
                }).add(d.group));
                t && !l && (k = {
                  stroke: a[2],
                  "stroke-width": g.lineWidth,
                  fill: d.fillGraph && d.color || "none"
                }, a[3] ? k.dashstyle = a[3] : "square" !== g.linecap && (k["stroke-linecap"] = k["stroke-linejoin"] = "round"), t[v](k).shadow(2 > q && g.shadow));
                t && (t.startX = c.xMap, t.isArea = c.isArea);
              });
            };

            A.prototype.getGraphPath = function (d, g, c) {
              var l = this,
                  a = l.options,
                  k = [],
                  q = [],
                  m,
                  t = a.step;
              d = d || l.points;
              var F = d.reversed;
              F && d.reverse();
              (t = {
                right: 1,
                center: 2
              }[t] || t && 3) && F && (t = 4 - t);
              d = this.getValidPoints(d, !1, !(a.connectNulls && !g && !c));
              d.forEach(function (v, F) {
                var y = v.plotX,
                    z = v.plotY,
                    w = d[F - 1];
                (v.leftCliff || w && w.rightCliff) && !c && (m = !0);
                v.isNull && !x(g) && 0 < F ? m = !a.connectNulls : v.isNull && !g ? m = !0 : (0 === F || m ? F = [["M", v.plotX, v.plotY]] : l.getPointSpline ? F = [l.getPointSpline(d, v, F)] : t ? (F = 1 === t ? [["L", w.plotX, z]] : 2 === t ? [["L", (w.plotX + y) / 2, w.plotY], ["L", (w.plotX + y) / 2, z]] : [["L", y, w.plotY]], F.push(["L", y, z])) : F = [["L", y, z]], q.push(v.x), t && (q.push(v.x), 2 === t && q.push(v.x)), k.push.apply(k, F), m = !1);
              });
              k.xMap = q;
              return l.graphPath = k;
            };

            A.prototype.getZonesGraphs = function (d) {
              this.zones.forEach(function (g, c) {
                c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (g.className || "")];
                this.chart.styledMode || c.push(g.color || this.color, g.dashStyle || this.options.dashStyle);
                d.push(c);
              }, this);
              return d;
            };

            A.defaultOptions = G(d.defaultOptions, {});
            return A;
          }(d);

          g.registerSeriesType("line", B);
          "";
          return B;
        });
        P(g, "Series/Area/AreaSeries.js", [g["Core/Color/Color.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B, E) {
          var x = this && this.__extends || function () {
            var _c = function c(d, a) {
              _c = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _c(d, a);
            };

            return function (d, a) {
              function k() {
                this.constructor = d;
              }

              _c(d, a);

              d.prototype = null === a ? Object.create(a) : (k.prototype = a.prototype, new k());
            };
          }(),
              C = d.parse,
              I = B.seriesTypes.line;

          d = E.extend;
          var A = E.merge,
              t = E.objectEach,
              q = E.pick;

          E = function (c) {
            function d() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            x(d, c);

            d.prototype.drawGraph = function () {
              this.areaPath = [];
              c.prototype.drawGraph.apply(this);
              var a = this,
                  d = this.areaPath,
                  l = this.options,
                  m = [["area", "highcharts-area", this.color, l.fillColor]];
              this.zones.forEach(function (c, d) {
                m.push(["zone-area-" + d, "highcharts-area highcharts-zone-area-" + d + " " + c.className, c.color || a.color, c.fillColor || l.fillColor]);
              });
              m.forEach(function (c) {
                var k = c[0],
                    m = {},
                    g = a[k],
                    t = g ? "animate" : "attr";
                g ? (g.endX = a.preventGraphAnimation ? null : d.xMap, g.animate({
                  d: d
                })) : (m.zIndex = 0, g = a[k] = a.chart.renderer.path(d).addClass(c[1]).add(a.group), g.isArea = !0);
                a.chart.styledMode || (m.fill = q(c[3], C(c[2]).setOpacity(q(l.fillOpacity, .75)).get()));
                g[t](m);
                g.startX = d.xMap;
                g.shiftUnit = l.step ? 2 : 1;
              });
            };

            d.prototype.getGraphPath = function (a) {
              var c = I.prototype.getGraphPath,
                  d = this.options,
                  m = d.stacking,
                  l = this.yAxis,
                  g = [],
                  t = [],
                  x = this.index,
                  y = l.stacking.stacks[this.stackKey],
                  z = d.threshold,
                  w = Math.round(l.getThreshold(d.threshold));
              d = q(d.connectNulls, "percent" === m);

              var e = function e(b, _e, c) {
                var d = a[b];
                b = m && y[d.x].points[x];
                var h = d[c + "Null"] || 0;
                c = d[c + "Cliff"] || 0;
                d = !0;

                if (c || h) {
                  var p = (h ? b[0] : b[1]) + c;
                  var n = b[0] + c;
                  d = !!h;
                } else !m && a[_e] && a[_e].isNull && (p = n = z);

                "undefined" !== typeof p && (t.push({
                  plotX: f,
                  plotY: null === p ? w : l.getThreshold(p),
                  isNull: d,
                  isCliff: !0
                }), g.push({
                  plotX: f,
                  plotY: null === n ? w : l.getThreshold(n),
                  doCurve: !1
                }));
              };

              a = a || this.points;
              m && (a = this.getStackPoints(a));

              for (var r = 0, h = a.length; r < h; ++r) {
                m || (a[r].leftCliff = a[r].rightCliff = a[r].leftNull = a[r].rightNull = void 0);
                var n = a[r].isNull;
                var f = q(a[r].rectPlotX, a[r].plotX);
                var b = m ? q(a[r].yBottom, w) : w;
                if (!n || d) d || e(r, r - 1, "left"), n && !m && d || (t.push(a[r]), g.push({
                  x: r,
                  plotX: f,
                  plotY: b
                })), d || e(r, r + 1, "right");
              }

              e = c.call(this, t, !0, !0);
              g.reversed = !0;
              n = c.call(this, g, !0, !0);
              (b = n[0]) && "M" === b[0] && (n[0] = ["L", b[1], b[2]]);
              n = e.concat(n);
              n.length && n.push(["Z"]);
              c = c.call(this, t, !1, d);
              n.xMap = e.xMap;
              this.areaPath = n;
              return c;
            };

            d.prototype.getStackPoints = function (a) {
              var c = this,
                  d = [],
                  m = [],
                  l = this.xAxis,
                  g = this.yAxis,
                  x = g.stacking.stacks[this.stackKey],
                  J = {},
                  y = g.series,
                  z = y.length,
                  w = g.options.reversedStacks ? 1 : -1,
                  e = y.indexOf(c);
              a = a || this.points;

              if (this.options.stacking) {
                for (var r = 0; r < a.length; r++) {
                  a[r].leftNull = a[r].rightNull = void 0, J[a[r].x] = a[r];
                }

                t(x, function (e, f) {
                  null !== e.total && m.push(f);
                });
                m.sort(function (e, f) {
                  return e - f;
                });
                var h = y.map(function (e) {
                  return e.visible;
                });
                m.forEach(function (a, f) {
                  var b = 0,
                      n,
                      k;
                  if (J[a] && !J[a].isNull) d.push(J[a]), [-1, 1].forEach(function (b) {
                    var d = 1 === b ? "rightNull" : "leftNull",
                        p = x[m[f + b]],
                        u = 0;
                    if (p) for (var l = e; 0 <= l && l < z;) {
                      var r = y[l].index;
                      n = p.points[r];
                      n || (r === c.index ? J[a][d] = !0 : h[l] && (k = x[a].points[r]) && (u -= k[1] - k[0]));
                      l += w;
                    }
                    J[a][1 === b ? "rightCliff" : "leftCliff"] = u;
                  });else {
                    for (var p = e; 0 <= p && p < z;) {
                      if (n = x[a].points[y[p].index]) {
                        b = n[1];
                        break;
                      }

                      p += w;
                    }

                    b = q(b, 0);
                    b = g.translate(b, 0, 1, 0, 1);
                    d.push({
                      isNull: !0,
                      plotX: l.translate(a, 0, 0, 0, 1),
                      x: a,
                      plotY: b,
                      yBottom: b
                    });
                  }
                });
              }

              return d;
            };

            d.defaultOptions = A(I.defaultOptions, {
              threshold: 0
            });
            return d;
          }(I);

          d(E.prototype, {
            singleStacks: !1,
            drawLegendSymbol: g.drawRectangle
          });
          B.registerSeriesType("area", E);
          "";
          return E;
        });
        P(g, "Series/Spline/SplineSeries.js", [g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g) {
          var C = this && this.__extends || function () {
            var _d3 = function d(g, t) {
              _d3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, c) {
                d.__proto__ = c;
              } || function (d, c) {
                for (var l in c) {
                  c.hasOwnProperty(l) && (d[l] = c[l]);
                }
              };

              return _d3(g, t);
            };

            return function (g, t) {
              function q() {
                this.constructor = g;
              }

              _d3(g, t);

              g.prototype = null === t ? Object.create(t) : (q.prototype = t.prototype, new q());
            };
          }(),
              E = d.seriesTypes.line,
              x = g.merge,
              G = g.pick;

          g = function (d) {
            function g() {
              var g = null !== d && d.apply(this, arguments) || this;
              g.data = void 0;
              g.options = void 0;
              g.points = void 0;
              return g;
            }

            C(g, d);

            g.prototype.getPointSpline = function (d, g, c) {
              var l = g.plotX || 0,
                  a = g.plotY || 0,
                  k = d[c - 1];
              c = d[c + 1];

              if (k && !k.isNull && !1 !== k.doCurve && !g.isCliff && c && !c.isNull && !1 !== c.doCurve && !g.isCliff) {
                d = k.plotY || 0;
                var q = c.plotX || 0;
                c = c.plotY || 0;
                var m = 0;
                var t = (1.5 * l + (k.plotX || 0)) / 2.5;
                var x = (1.5 * a + d) / 2.5;
                q = (1.5 * l + q) / 2.5;
                var A = (1.5 * a + c) / 2.5;
                q !== t && (m = (A - x) * (q - l) / (q - t) + a - A);
                x += m;
                A += m;
                x > d && x > a ? (x = Math.max(d, a), A = 2 * a - x) : x < d && x < a && (x = Math.min(d, a), A = 2 * a - x);
                A > c && A > a ? (A = Math.max(c, a), x = 2 * a - A) : A < c && A < a && (A = Math.min(c, a), x = 2 * a - A);
                g.rightContX = q;
                g.rightContY = A;
              }

              g = ["C", G(k.rightContX, k.plotX, 0), G(k.rightContY, k.plotY, 0), G(t, l, 0), G(x, a, 0), l, a];
              k.rightContX = k.rightContY = void 0;
              return g;
            };

            g.defaultOptions = x(E.defaultOptions);
            return g;
          }(E);

          d.registerSeriesType("spline", g);
          "";
          return g;
        });
        P(g, "Series/AreaSpline/AreaSplineSeries.js", [g["Series/Spline/SplineSeries.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B, E) {
          var x = this && this.__extends || function () {
            var _d4 = function d(c, g) {
              _d4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _d4(c, g);
            };

            return function (c, g) {
              function a() {
                this.constructor = c;
              }

              _d4(c, g);

              c.prototype = null === g ? Object.create(g) : (a.prototype = g.prototype, new a());
            };
          }(),
              C = B.seriesTypes,
              I = C.area;

          C = C.area.prototype;
          var A = E.extend,
              t = E.merge;

          E = function (g) {
            function c() {
              var c = null !== g && g.apply(this, arguments) || this;
              c.data = void 0;
              c.points = void 0;
              c.options = void 0;
              return c;
            }

            x(c, g);
            c.defaultOptions = t(d.defaultOptions, I.defaultOptions);
            return c;
          }(d);

          A(E.prototype, {
            getGraphPath: C.getGraphPath,
            getStackPoints: C.getStackPoints,
            drawGraph: C.drawGraph,
            drawLegendSymbol: g.drawRectangle
          });
          B.registerSeriesType("areaspline", E);
          "";
          return E;
        });
        P(g, "Series/Column/ColumnSeries.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I) {
          var A = this && this.__extends || function () {
            var _a4 = function a(c, e) {
              _a4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, a) {
                e.__proto__ = a;
              } || function (e, a) {
                for (var c in a) {
                  a.hasOwnProperty(c) && (e[c] = a[c]);
                }
              };

              return _a4(c, e);
            };

            return function (c, e) {
              function d() {
                this.constructor = c;
              }

              _a4(c, e);

              c.prototype = null === e ? Object.create(e) : (d.prototype = e.prototype, new d());
            };
          }(),
              t = d.animObject,
              q = g.parse,
              c = B.hasTouch;

          d = B.noop;
          var l = I.clamp,
              a = I.css,
              k = I.defined,
              v = I.extend,
              m = I.fireEvent,
              C = I.isArray,
              F = I.isNumber,
              L = I.merge,
              J = I.pick,
              y = I.objectEach;

          I = function (d) {
            function g() {
              var e = null !== d && d.apply(this, arguments) || this;
              e.borderWidth = void 0;
              e.data = void 0;
              e.group = void 0;
              e.options = void 0;
              e.points = void 0;
              return e;
            }

            A(g, d);

            g.prototype.animate = function (e) {
              var a = this,
                  c = this.yAxis,
                  d = a.options,
                  f = this.chart.inverted,
                  b = {},
                  k = f ? "translateX" : "translateY";
              if (e) b.scaleY = .001, e = l(c.toPixels(d.threshold), c.pos, c.pos + c.len), f ? b.translateX = e - c.len : b.translateY = e, a.clipBox && a.setClip(), a.group.attr(b);else {
                var g = Number(a.group.attr(k));
                a.group.animate({
                  scaleY: 1
                }, v(t(a.options.animation), {
                  step: function step(f, e) {
                    a.group && (b[k] = g + e.pos * (c.pos - g), a.group.attr(b));
                  }
                }));
              }
            };

            g.prototype.init = function (e, a) {
              d.prototype.init.apply(this, arguments);
              var c = this;
              e = c.chart;
              e.hasRendered && e.series.forEach(function (e) {
                e.type === c.type && (e.isDirty = !0);
              });
            };

            g.prototype.getColumnMetrics = function () {
              var e = this,
                  a = e.options,
                  c = e.xAxis,
                  d = e.yAxis,
                  f = c.options.reversedStacks;
              f = c.reversed && !f || !c.reversed && f;
              var b = {},
                  k,
                  g = 0;
              !1 === a.grouping ? g = 1 : e.chart.series.forEach(function (f) {
                var a = f.yAxis,
                    c = f.options;

                if (f.type === e.type && (f.visible || !e.chart.options.chart.ignoreHiddenSeries) && d.len === a.len && d.pos === a.pos) {
                  if (c.stacking && "group" !== c.stacking) {
                    k = f.stackKey;
                    "undefined" === typeof b[k] && (b[k] = g++);
                    var h = b[k];
                  } else !1 !== c.grouping && (h = g++);

                  f.columnIndex = h;
                }
              });
              var p = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || a.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
                  u = p * a.groupPadding,
                  m = (p - 2 * u) / (g || 1);
              a = Math.min(a.maxPointWidth || c.len, J(a.pointWidth, m * (1 - 2 * a.pointPadding)));
              e.columnMetrics = {
                width: a,
                offset: (m - a) / 2 + (u + ((e.columnIndex || 0) + (f ? 1 : 0)) * m - p / 2) * (f ? -1 : 1),
                paddedWidth: m,
                columnCount: g
              };
              return e.columnMetrics;
            };

            g.prototype.crispCol = function (e, a, c, d) {
              var f = this.chart,
                  b = this.borderWidth,
                  h = -(b % 2 ? .5 : 0);
              b = b % 2 ? .5 : 1;
              f.inverted && f.renderer.isVML && (b += 1);
              this.options.crisp && (c = Math.round(e + c) + h, e = Math.round(e) + h, c -= e);
              d = Math.round(a + d) + b;
              h = .5 >= Math.abs(a) && .5 < d;
              a = Math.round(a) + b;
              d -= a;
              h && d && (--a, d += 1);
              return {
                x: e,
                y: a,
                width: c,
                height: d
              };
            };

            g.prototype.adjustForMissingColumns = function (e, a, c, d) {
              var f = this,
                  b = this.options.stacking;

              if (!c.isNull && 1 < d.columnCount) {
                var h = this.yAxis.options.reversedStacks,
                    n = 0,
                    p = h ? 0 : -d.columnCount;
                y(this.yAxis.stacking && this.yAxis.stacking.stacks, function (e) {
                  if ("number" === typeof c.x && (e = e[c.x.toString()])) {
                    var a = e.points[f.index],
                        d = e.total;
                    b ? (a && (n = p), e.hasValidPoints && (h ? p++ : p--)) : C(a) && (n = a[1], p = d || 0);
                  }
                });
                e = (c.plotX || 0) + ((p - 1) * d.paddedWidth + a) / 2 - a - n * d.paddedWidth;
              }

              return e;
            };

            g.prototype.translate = function () {
              var e = this,
                  a = e.chart,
                  c = e.options,
                  d = e.dense = 2 > e.closestPointRange * e.xAxis.transA;
              d = e.borderWidth = J(c.borderWidth, d ? 0 : 1);
              var f = e.xAxis,
                  b = e.yAxis,
                  g = c.threshold,
                  m = e.translatedThreshold = b.getThreshold(g),
                  p = J(c.minPointLength, 5),
                  u = e.getColumnMetrics(),
                  q = u.width,
                  w = e.pointXOffset = u.offset,
                  t = e.dataMin,
                  y = e.dataMax,
                  z = e.barW = Math.max(q, 1 + 2 * d);
              a.inverted && (m -= .5);
              c.pointPadding && (z = Math.ceil(z));
              x.prototype.translate.apply(e);
              e.points.forEach(function (d) {
                var h = J(d.yBottom, m),
                    n = 999 + Math.abs(h),
                    r = d.plotX || 0;
                n = l(d.plotY, -n, b.len + n);
                var H = Math.min(n, h),
                    D = Math.max(n, h) - H,
                    K = q,
                    v = r + w,
                    x = z;
                p && Math.abs(D) < p && (D = p, r = !b.reversed && !d.negative || b.reversed && d.negative, F(g) && F(y) && d.y === g && y <= g && (b.min || 0) < g && (t !== y || (b.max || 0) <= g) && (r = !r), H = Math.abs(H - m) > p ? h - p : m - (r ? p : 0));
                k(d.options.pointWidth) && (K = x = Math.ceil(d.options.pointWidth), v -= Math.round((K - q) / 2));
                c.centerInCategory && (v = e.adjustForMissingColumns(v, K, d, u));
                d.barX = v;
                d.pointWidth = K;
                d.tooltipPos = a.inverted ? [l(b.len + b.pos - a.plotLeft - n, b.pos - a.plotLeft, b.len + b.pos - a.plotLeft), f.len + f.pos - a.plotTop - v - x / 2, D] : [f.left - a.plotLeft + v + x / 2, l(n + b.pos - a.plotTop, b.pos - a.plotTop, b.len + b.pos - a.plotTop), D];
                d.shapeType = e.pointClass.prototype.shapeType || "rect";
                d.shapeArgs = e.crispCol.apply(e, d.isNull ? [v, m, x, 0] : [v, H, x, D]);
              });
            };

            g.prototype.drawGraph = function () {
              this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };

            g.prototype.pointAttribs = function (e, a) {
              var c = this.options,
                  d = this.pointAttrToOptions || {},
                  f = d.stroke || "borderColor",
                  b = d["stroke-width"] || "borderWidth",
                  k = e && e.color || this.color,
                  g = e && e[f] || c[f] || k;
              d = e && e.options.dashStyle || c.dashStyle;
              var p = e && e[b] || c[b] || this[b] || 0,
                  u = J(e && e.opacity, c.opacity, 1);

              if (e && this.zones.length) {
                var m = e.getZone();
                k = e.options.color || m && (m.color || e.nonZonedColor) || this.color;
                m && (g = m.borderColor || g, d = m.dashStyle || d, p = m.borderWidth || p);
              }

              a && e && (e = L(c.states[a], e.options.states && e.options.states[a] || {}), a = e.brightness, k = e.color || "undefined" !== typeof a && q(k).brighten(e.brightness).get() || k, g = e[f] || g, p = e[b] || p, d = e.dashStyle || d, u = J(e.opacity, u));
              f = {
                fill: k,
                stroke: g,
                "stroke-width": p,
                opacity: u
              };
              d && (f.dashstyle = d);
              return f;
            };

            g.prototype.drawPoints = function () {
              var e = this,
                  a = this.chart,
                  c = e.options,
                  d = a.renderer,
                  f = c.animationLimit || 250,
                  b;
              e.points.forEach(function (h) {
                var n = h.graphic,
                    p = !!n,
                    k = n && a.pointCount < f ? "animate" : "attr";

                if (F(h.plotY) && null !== h.y) {
                  b = h.shapeArgs;
                  n && h.hasNewShapeType() && (n = n.destroy());
                  e.enabledDataSorting && (h.startXPos = e.xAxis.reversed ? -(b ? b.width || 0 : 0) : e.xAxis.width);
                  n || (h.graphic = n = d[h.shapeType](b).add(h.group || e.group)) && e.enabledDataSorting && a.hasRendered && a.pointCount < f && (n.attr({
                    x: h.startXPos
                  }), p = !0, k = "animate");
                  if (n && p) n[k](L(b));
                  if (c.borderRadius) n[k]({
                    r: c.borderRadius
                  });
                  a.styledMode || n[k](e.pointAttribs(h, h.selected && "select")).shadow(!1 !== h.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);
                  n && (n.addClass(h.getClassName(), !0), n.attr({
                    visibility: h.visible ? "inherit" : "hidden"
                  }));
                } else n && (h.graphic = n.destroy());
              });
            };

            g.prototype.drawTracker = function () {
              var e = this,
                  d = e.chart,
                  h = d.pointer,
                  n = function n(b) {
                var f = h.getPointFromEvent(b);
                "undefined" !== typeof f && (h.isDirectTouch = !0, f.onMouseOver(b));
              },
                  f;

              e.points.forEach(function (b) {
                f = C(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
                b.graphic && (b.graphic.element.point = b);
                f.forEach(function (f) {
                  f.div ? f.div.point = b : f.element.point = b;
                });
              });
              e._hasTracking || (e.trackerGroups.forEach(function (b) {
                if (e[b]) {
                  e[b].addClass("highcharts-tracker").on("mouseover", n).on("mouseout", function (b) {
                    h.onTrackerMouseOut(b);
                  });
                  if (c) e[b].on("touchstart", n);
                  !d.styledMode && e.options.cursor && e[b].css(a).css({
                    cursor: e.options.cursor
                  });
                }
              }), e._hasTracking = !0);
              m(this, "afterDrawTracker");
            };

            g.prototype.remove = function () {
              var e = this,
                  a = e.chart;
              a.hasRendered && a.series.forEach(function (a) {
                a.type === e.type && (a.isDirty = !0);
              });
              x.prototype.remove.apply(e, arguments);
            };

            g.defaultOptions = L(x.defaultOptions, {
              borderRadius: 0,
              centerInCategory: !1,
              groupPadding: .2,
              marker: null,
              pointPadding: .1,
              minPointLength: 0,
              cropThreshold: 50,
              pointRange: null,
              states: {
                hover: {
                  halo: !1,
                  brightness: .1
                },
                select: {
                  color: "#cccccc",
                  borderColor: "#000000"
                }
              },
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
              },
              startFromThreshold: !0,
              stickyTracking: !1,
              tooltip: {
                distance: 6
              },
              threshold: 0,
              borderColor: "#ffffff"
            });
            return g;
          }(x);

          v(I.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: E.drawRectangle,
            getSymbol: d,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          G.registerSeriesType("column", I);
          "";
          "";
          return I;
        });
        P(g, "Core/Series/DataLabel.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/FormatUtilities.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = d.getDeferredAnimation,
              x = g.format,
              G = B.defined,
              I = B.extend,
              A = B.fireEvent,
              t = B.isArray,
              q = B.merge,
              c = B.objectEach,
              l = B.pick,
              a = B.splat,
              k;

          (function (d) {
            function k(a, e, c, d, n) {
              var f = this,
                  b = this.chart,
                  h = this.isCartesian && b.inverted,
                  k = this.enabledDataSorting,
                  p = l(a.dlBox && a.dlBox.centerX, a.plotX),
                  g = a.plotY,
                  m = c.rotation,
                  r = c.align,
                  q = G(p) && G(g) && b.isInsidePlot(p, Math.round(g), {
                inverted: h,
                paneCoordinates: !0,
                series: f
              }),
                  w = function w(b) {
                k && f.xAxis && !t && f.setDataLabelStartPos(a, e, n, q, b);
              },
                  t = "justify" === l(c.overflow, k ? "none" : "justify"),
                  y = this.visible && !1 !== a.visible && (a.series.forceDL || k && !t || q || l(c.inside, !!this.options.stacking) && d && b.isInsidePlot(p, h ? d.x + 1 : d.y + d.height - 1, {
                inverted: h,
                paneCoordinates: !0,
                series: f
              }));

              if (y && G(p) && G(g)) {
                m && e.attr({
                  align: r
                });
                r = e.getBBox(!0);
                var z = [0, 0];
                var v = b.renderer.fontMetrics(b.styledMode ? void 0 : c.style.fontSize, e).b;
                d = I({
                  x: h ? this.yAxis.len - g : p,
                  y: Math.round(h ? this.xAxis.len - p : g),
                  width: 0,
                  height: 0
                }, d);
                I(c, {
                  width: r.width,
                  height: r.height
                });
                m ? (t = !1, z = b.renderer.rotCorr(v, m), p = {
                  x: d.x + (c.x || 0) + d.width / 2 + z.x,
                  y: d.y + (c.y || 0) + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                  }[c.verticalAlign] * d.height
                }, z = [r.x - Number(e.attr("x")), r.y - Number(e.attr("y"))], w(p), e[n ? "attr" : "animate"](p)) : (w(d), e.align(c, void 0, d), p = e.alignAttr);
                t && 0 <= d.height ? this.justifyDataLabel(e, c, p, r, d, n) : l(c.crop, !0) && (d = p.x, w = p.y, d += z[0], w += z[1], y = b.isInsidePlot(d, w, {
                  paneCoordinates: !0,
                  series: f
                }) && b.isInsidePlot(d + r.width, w + r.height, {
                  paneCoordinates: !0,
                  series: f
                }));
                if (c.shape && !m) e[n ? "attr" : "animate"]({
                  anchorX: h ? b.plotWidth - a.plotY : a.plotX,
                  anchorY: h ? b.plotHeight - a.plotX : a.plotY
                });
              }

              n && k && (e.placed = !1);
              y || k && !t ? e.show() : (e.hide(), e.placed = !1);
            }

            function g(a, e) {
              var c = e.filter;
              return c ? (e = c.operator, a = a[c.property], c = c.value, ">" === e && a > c || "<" === e && a < c || ">=" === e && a >= c || "<=" === e && a <= c || "==" === e && a == c || "===" === e && a === c ? !0 : !1) : !0;
            }

            function v() {
              var d = this,
                  e = d.chart,
                  k = d.options,
                  h = d.points,
                  n = d.hasRendered || 0,
                  f = e.renderer,
                  b = k.dataLabels,
                  m,
                  q = b.animation;
              q = b.defer ? C(e, q, d) : {
                defer: 0,
                duration: 0
              };
              b = J(J(e.options.plotOptions && e.options.plotOptions.series && e.options.plotOptions.series.dataLabels, e.options.plotOptions && e.options.plotOptions[d.type] && e.options.plotOptions[d.type].dataLabels), b);
              A(this, "drawDataLabels");

              if (t(b) || b.enabled || d._hasPointLabels) {
                var p = d.plotGroup("dataLabelsGroup", "data-labels", n ? "inherit" : "hidden", b.zIndex || 6);
                p.attr({
                  opacity: +n
                });
                !n && (n = d.dataLabelsGroup) && (d.visible && p.show(), n[k.animation ? "animate" : "attr"]({
                  opacity: 1
                }, q));
                h.forEach(function (h) {
                  m = a(J(b, h.dlOptions || h.options && h.options.dataLabels));
                  m.forEach(function (b, a) {
                    var n = b.enabled && (!h.isNull || h.dataLabelOnNull) && g(h, b),
                        m = h.connectors ? h.connectors[a] : h.connector,
                        u = h.dataLabels ? h.dataLabels[a] : h.dataLabel,
                        r = !u,
                        q = l(b.distance, h.labelDistance);

                    if (n) {
                      var w = h.getLabelConfig();
                      var t = l(b[h.formatPrefix + "Format"], b.format);
                      w = G(t) ? x(t, w, e) : (b[h.formatPrefix + "Formatter"] || b.formatter).call(w, b);
                      t = b.style;
                      var H = b.rotation;
                      e.styledMode || (t.color = l(b.color, t.color, d.color, "#000000"), "contrast" === t.color ? (h.contrastColor = f.getContrast(h.color || d.color), t.color = !G(q) && b.inside || 0 > q || k.stacking ? h.contrastColor : "#000000") : delete h.contrastColor, k.cursor && (t.cursor = k.cursor));
                      var D = {
                        r: b.borderRadius || 0,
                        rotation: H,
                        padding: b.padding,
                        zIndex: 1
                      };
                      e.styledMode || (D.fill = b.backgroundColor, D.stroke = b.borderColor, D["stroke-width"] = b.borderWidth);
                      c(D, function (b, f) {
                        "undefined" === typeof b && delete D[f];
                      });
                    }

                    !u || n && G(w) && !!u.div === !!b.useHTML && (u.rotation && b.rotation || u.rotation === b.rotation) || (r = !0, h.dataLabel = u = h.dataLabel && h.dataLabel.destroy(), h.dataLabels && (1 === h.dataLabels.length ? delete h.dataLabels : delete h.dataLabels[a]), a || delete h.dataLabel, m && (h.connector = h.connector.destroy(), h.connectors && (1 === h.connectors.length ? delete h.connectors : delete h.connectors[a])));
                    n && G(w) ? (u ? D.text = w : (h.dataLabels = h.dataLabels || [], u = h.dataLabels[a] = H ? f.text(w, 0, 0, b.useHTML).addClass("highcharts-data-label") : f.label(w, 0, 0, b.shape, null, null, b.useHTML, null, "data-label"), a || (h.dataLabel = u), u.addClass(" highcharts-data-label-color-" + h.colorIndex + " " + (b.className || "") + (b.useHTML ? " highcharts-tracker" : ""))), u.options = b, u.attr(D), e.styledMode || u.css(t).shadow(b.shadow), u.added || u.add(p), b.textPath && !b.useHTML && (u.setTextPath(h.getDataLabelPath && h.getDataLabelPath(u) || h.graphic, b.textPath), h.dataLabelPath && !b.textPath.enabled && (h.dataLabelPath = h.dataLabelPath.destroy())), d.alignDataLabel(h, u, b, null, r)) : u && u.hide();
                  });
                });
              }

              A(this, "afterDrawDataLabels");
            }

            function L(a, e, c, d, n, f) {
              var b = this.chart,
                  h = e.align,
                  k = e.verticalAlign,
                  p = a.box ? 0 : a.padding || 0,
                  g = e.x;
              g = void 0 === g ? 0 : g;
              var m = e.y;
              m = void 0 === m ? 0 : m;
              var l = (c.x || 0) + p;

              if (0 > l) {
                "right" === h && 0 <= g ? (e.align = "left", e.inside = !0) : g -= l;
                var r = !0;
              }

              l = (c.x || 0) + d.width - p;
              l > b.plotWidth && ("left" === h && 0 >= g ? (e.align = "right", e.inside = !0) : g += b.plotWidth - l, r = !0);
              l = c.y + p;
              0 > l && ("bottom" === k && 0 <= m ? (e.verticalAlign = "top", e.inside = !0) : m -= l, r = !0);
              l = (c.y || 0) + d.height - p;
              l > b.plotHeight && ("top" === k && 0 >= m ? (e.verticalAlign = "bottom", e.inside = !0) : m += b.plotHeight - l, r = !0);
              r && (e.x = g, e.y = m, a.placed = !f, a.align(e, void 0, n));
              return r;
            }

            function J(a, e) {
              var c = [],
                  d;
              if (t(a) && !t(e)) c = a.map(function (a) {
                return q(a, e);
              });else if (t(e) && !t(a)) c = e.map(function (e) {
                return q(a, e);
              });else if (t(a) || t(e)) for (d = Math.max(a.length, e.length); d--;) {
                c[d] = q(a[d], e[d]);
              } else c = q(a, e);
              return c;
            }

            function y(a, e, c, d, n) {
              var f = this.chart,
                  b = f.inverted,
                  h = this.xAxis,
                  k = h.reversed,
                  p = b ? e.height / 2 : e.width / 2;
              a = (a = a.pointWidth) ? a / 2 : 0;
              e.startXPos = b ? n.x : k ? -p - a : h.width - p + a;
              e.startYPos = b ? k ? this.yAxis.height - p + a : -p - a : n.y;
              d ? "hidden" === e.visibility && (e.show(), e.attr({
                opacity: 0
              }).animate({
                opacity: 1
              })) : e.attr({
                opacity: 1
              }).animate({
                opacity: 0
              }, void 0, e.hide);
              f.hasRendered && (c && e.attr({
                x: e.startXPos,
                y: e.startYPos
              }), e.placed = !0);
            }

            var z = [];

            d.compose = function (a) {
              if (-1 === z.indexOf(a)) {
                var e = a.prototype;
                z.push(a);
                e.alignDataLabel = k;
                e.drawDataLabels = v;
                e.justifyDataLabel = L;
                e.setDataLabelStartPos = y;
              }
            };
          })(k || (k = {}));

          "";
          return k;
        });
        P(g, "Series/Column/ColumnDataLabel.js", [g["Core/Series/DataLabel.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = g.series,
              x = B.merge,
              G = B.pick,
              I;

          (function (g) {
            function t(c, d, a, k, g) {
              var m = this.chart.inverted,
                  l = c.series,
                  q = (l.xAxis ? l.xAxis.len : this.chart.plotSizeX) || 0;
              l = (l.yAxis ? l.yAxis.len : this.chart.plotSizeY) || 0;
              var t = c.dlBox || c.shapeArgs,
                  v = G(c.below, c.plotY > G(this.translatedThreshold, l)),
                  y = G(a.inside, !!this.options.stacking);
              t && (k = x(t), 0 > k.y && (k.height += k.y, k.y = 0), t = k.y + k.height - l, 0 < t && t < k.height && (k.height -= t), m && (k = {
                x: l - k.y - k.height,
                y: q - k.x - k.width,
                width: k.height,
                height: k.width
              }), y || (m ? (k.x += v ? 0 : k.width, k.width = 0) : (k.y += v ? k.height : 0, k.height = 0)));
              a.align = G(a.align, !m || y ? "center" : v ? "right" : "left");
              a.verticalAlign = G(a.verticalAlign, m || y ? "middle" : v ? "top" : "bottom");
              C.prototype.alignDataLabel.call(this, c, d, a, k, g);
              a.inside && c.contrastColor && d.css({
                color: c.contrastColor
              });
            }

            var q = [];

            g.compose = function (c) {
              d.compose(C);
              -1 === q.indexOf(c) && (q.push(c), c.prototype.alignDataLabel = t);
            };
          })(I || (I = {}));

          return I;
        });
        P(g, "Series/Bar/BarSeries.js", [g["Series/Column/ColumnSeries.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = this && this.__extends || function () {
            var _d5 = function d(g, t) {
              _d5 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, c) {
                d.__proto__ = c;
              } || function (d, c) {
                for (var g in c) {
                  c.hasOwnProperty(g) && (d[g] = c[g]);
                }
              };

              return _d5(g, t);
            };

            return function (g, t) {
              function q() {
                this.constructor = g;
              }

              _d5(g, t);

              g.prototype = null === t ? Object.create(t) : (q.prototype = t.prototype, new q());
            };
          }(),
              x = B.extend,
              G = B.merge;

          B = function (g) {
            function x() {
              var d = null !== g && g.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            C(x, g);
            x.defaultOptions = G(d.defaultOptions, {});
            return x;
          }(d);

          x(B.prototype, {
            inverted: !0
          });
          g.registerSeriesType("bar", B);
          "";
          return B;
        });
        P(g, "Series/Scatter/ScatterSeries.js", [g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g) {
          var C = this && this.__extends || function () {
            var _d6 = function d(g, c) {
              _d6 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, a) {
                c.__proto__ = a;
              } || function (c, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (c[d] = a[d]);
                }
              };

              return _d6(g, c);
            };

            return function (g, c) {
              function l() {
                this.constructor = g;
              }

              _d6(g, c);

              g.prototype = null === c ? Object.create(c) : (l.prototype = c.prototype, new l());
            };
          }(),
              E = d.seriesTypes,
              x = E.column,
              G = E.line;

          E = g.addEvent;
          var I = g.extend,
              A = g.merge;

          g = function (d) {
            function g() {
              var c = null !== d && d.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            C(g, d);

            g.prototype.applyJitter = function () {
              var c = this,
                  d = this.options.jitter,
                  a = this.points.length;
              d && this.points.forEach(function (k, g) {
                ["x", "y"].forEach(function (m, l) {
                  var q = "plot" + m.toUpperCase();

                  if (d[m] && !k.isNull) {
                    var t = c[m + "Axis"];
                    var v = d[m] * t.transA;

                    if (t && !t.isLog) {
                      var y = Math.max(0, k[q] - v);
                      t = Math.min(t.len, k[q] + v);
                      l = 1E4 * Math.sin(g + l * a);
                      k[q] = y + (t - y) * (l - Math.floor(l));
                      "x" === m && (k.clientX = k.plotX);
                    }
                  }
                });
              });
            };

            g.prototype.drawGraph = function () {
              this.options.lineWidth ? d.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };

            g.defaultOptions = A(G.defaultOptions, {
              lineWidth: 0,
              findNearestPointBy: "xy",
              jitter: {
                x: 0,
                y: 0
              },
              marker: {
                enabled: !0
              },
              tooltip: {
                headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
              }
            });
            return g;
          }(G);

          I(g.prototype, {
            drawTracker: x.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
          });
          E(g, "afterTranslate", function () {
            this.applyJitter();
          });
          d.registerSeriesType("scatter", g);
          "";
          return g;
        });
        P(g, "Series/CenteredUtilities.js", [g["Core/Globals.js"], g["Core/Series/Series.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = d.deg2rad,
              x = B.fireEvent,
              G = B.isNumber,
              I = B.pick,
              A = B.relativeLength,
              t;

          (function (d) {
            d.getCenter = function () {
              var c = this.options,
                  d = this.chart,
                  a = 2 * (c.slicedOffset || 0),
                  k = d.plotWidth - 2 * a,
                  q = d.plotHeight - 2 * a,
                  m = c.center,
                  t = Math.min(k, q),
                  F = c.thickness,
                  C = c.size,
                  J = c.innerSize || 0;
              "string" === typeof C && (C = parseFloat(C));
              "string" === typeof J && (J = parseFloat(J));
              c = [I(m[0], "50%"), I(m[1], "50%"), I(C && 0 > C ? void 0 : c.size, "100%"), I(J && 0 > J ? void 0 : c.innerSize || 0, "0%")];
              !d.angular || this instanceof g || (c[3] = 0);

              for (m = 0; 4 > m; ++m) {
                C = c[m], d = 2 > m || 2 === m && /%$/.test(C), c[m] = A(C, [k, q, t, c[2]][m]) + (d ? a : 0);
              }

              c[3] > c[2] && (c[3] = c[2]);
              G(F) && 2 * F < c[2] && 0 < F && (c[3] = c[2] - 2 * F);
              x(this, "afterGetCenter", {
                positions: c
              });
              return c;
            };

            d.getStartAndEndRadians = function (c, d) {
              c = G(c) ? c : 0;
              d = G(d) && d > c && 360 > d - c ? d : c + 360;
              return {
                start: C * (c + -90),
                end: C * (d + -90)
              };
            };
          })(t || (t = {}));

          "";
          return t;
        });
        P(g, "Series/Pie/PiePoint.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = this && this.__extends || function () {
            var _c2 = function c(d, a) {
              _c2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _c2(d, a);
            };

            return function (d, a) {
              function k() {
                this.constructor = d;
              }

              _c2(d, a);

              d.prototype = null === a ? Object.create(a) : (k.prototype = a.prototype, new k());
            };
          }(),
              x = d.setAnimation,
              G = B.addEvent,
              I = B.defined;

          d = B.extend;
          var A = B.isNumber,
              t = B.pick,
              q = B.relativeLength;

          g = function (c) {
            function d() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.labelDistance = void 0;
              a.options = void 0;
              a.series = void 0;
              return a;
            }

            C(d, c);

            d.prototype.getConnectorPath = function () {
              var a = this.labelPosition,
                  c = this.series.options.dataLabels,
                  d = this.connectorShapes,
                  g = c.connectorShape;
              d[g] && (g = d[g]);
              return g.call(this, {
                x: a["final"].x,
                y: a["final"].y,
                alignment: a.alignment
              }, a.connectorPosition, c);
            };

            d.prototype.getTranslate = function () {
              return this.sliced ? this.slicedTranslation : {
                translateX: 0,
                translateY: 0
              };
            };

            d.prototype.haloPath = function (a) {
              var c = this.shapeArgs;
              return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
                innerR: c.r - 1,
                start: c.start,
                end: c.end
              });
            };

            d.prototype.init = function () {
              var a = this;
              c.prototype.init.apply(this, arguments);
              this.name = t(this.name, "Slice");

              var d = function d(c) {
                a.slice("select" === c.type);
              };

              G(this, "select", d);
              G(this, "unselect", d);
              return this;
            };

            d.prototype.isValid = function () {
              return A(this.y) && 0 <= this.y;
            };

            d.prototype.setVisible = function (a, c) {
              var d = this,
                  g = this.series,
                  k = g.chart,
                  l = g.options.ignoreHiddenPoint;
              c = t(c, l);
              a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, g.options.data[g.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (c) {
                if (d[c]) d[c][a ? "show" : "hide"](a);
              }), this.legendItem && k.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), l && (g.isDirty = !0), c && k.redraw());
            };

            d.prototype.slice = function (a, c, d) {
              var g = this.series;
              x(d, g.chart);
              t(c, !0);
              this.sliced = this.options.sliced = I(a) ? a : !this.sliced;
              g.options.data[g.data.indexOf(this)] = this.options;
              this.graphic && this.graphic.animate(this.getTranslate());
              this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };

            return d;
          }(g);

          d(g.prototype, {
            connectorShapes: {
              fixedOffset: function fixedOffset(c, d, a) {
                var g = d.breakAt;
                d = d.touchingSliceAt;
                return [["M", c.x, c.y], a.softConnector ? ["C", c.x + ("left" === c.alignment ? -5 : 5), c.y, 2 * g.x - d.x, 2 * g.y - d.y, g.x, g.y] : ["L", g.x, g.y], ["L", d.x, d.y]];
              },
              straight: function straight(c, d) {
                d = d.touchingSliceAt;
                return [["M", c.x, c.y], ["L", d.x, d.y]];
              },
              crookedLine: function crookedLine(c, d, a) {
                d = d.touchingSliceAt;
                var g = this.series,
                    l = g.center[0],
                    m = g.chart.plotWidth,
                    t = g.chart.plotLeft;
                g = c.alignment;
                var x = this.shapeArgs.r;
                a = q(a.crookDistance, 1);
                m = "left" === g ? l + x + (m + t - l - x) * (1 - a) : t + (l - x) * a;
                a = ["L", m, c.y];
                l = !0;
                if ("left" === g ? m > c.x || m < d.x : m < c.x || m > d.x) l = !1;
                c = [["M", c.x, c.y]];
                l && c.push(a);
                c.push(["L", d.x, d.y]);
                return c;
              }
            }
          });
          return g;
        });
        P(g, "Series/Pie/PieSeries.js", [g["Series/CenteredUtilities.js"], g["Series/Column/ColumnSeries.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Series/Pie/PiePoint.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/Symbols.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I, A, t) {
          var q = this && this.__extends || function () {
            var _a5 = function a(c, d) {
              _a5 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _a5(c, d);
            };

            return function (c, d) {
              function g() {
                this.constructor = c;
              }

              _a5(c, d);

              c.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }(),
              c = d.getStartAndEndRadians;

          B = B.noop;
          var l = t.clamp,
              a = t.extend,
              k = t.fireEvent,
              v = t.merge,
              m = t.pick,
              C = t.relativeLength;

          t = function (a) {
            function d() {
              var c = null !== a && a.apply(this, arguments) || this;
              c.center = void 0;
              c.data = void 0;
              c.maxLabelDistance = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            q(d, a);

            d.prototype.animate = function (a) {
              var c = this,
                  d = c.points,
                  g = c.startAngleRad;
              a || d.forEach(function (a) {
                var e = a.graphic,
                    d = a.shapeArgs;
                e && d && (e.attr({
                  r: m(a.startR, c.center && c.center[3] / 2),
                  start: g,
                  end: g
                }), e.animate({
                  r: d.r,
                  start: d.start,
                  end: d.end
                }, c.options.animation));
              });
            };

            d.prototype.drawEmpty = function () {
              var a = this.startAngleRad,
                  c = this.endAngleRad,
                  d = this.options;

              if (0 === this.total && this.center) {
                var g = this.center[0];
                var e = this.center[1];
                this.graph || (this.graph = this.chart.renderer.arc(g, e, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
                this.graph.attr({
                  d: A.arc(g, e, this.center[2] / 2, 0, {
                    start: a,
                    end: c,
                    innerR: this.center[3] / 2
                  })
                });
                this.chart.styledMode || this.graph.attr({
                  "stroke-width": d.borderWidth,
                  fill: d.fillColor || "none",
                  stroke: d.color || "#cccccc"
                });
              } else this.graph && (this.graph = this.graph.destroy());
            };

            d.prototype.drawPoints = function () {
              var a = this.chart.renderer;
              this.points.forEach(function (c) {
                c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
                c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
              });
            };

            d.prototype.generatePoints = function () {
              a.prototype.generatePoints.call(this);
              this.updateTotals();
            };

            d.prototype.getX = function (a, c, d) {
              var g = this.center,
                  e = this.radii ? this.radii[d.index] || 0 : g[2] / 2;
              a = Math.asin(l((a - g[1]) / (e + d.labelDistance), -1, 1));
              return g[0] + (c ? -1 : 1) * Math.cos(a) * (e + d.labelDistance) + (0 < d.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
            };

            d.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            d.prototype.redrawPoints = function () {
              var a = this,
                  c = a.chart,
                  d = c.renderer,
                  g = a.options.shadow,
                  e,
                  k,
                  h,
                  n;
              this.drawEmpty();
              !g || a.shadowGroup || c.styledMode || (a.shadowGroup = d.g("shadow").attr({
                zIndex: -1
              }).add(a.group));
              a.points.forEach(function (f) {
                var b = {};
                k = f.graphic;

                if (!f.isNull && k) {
                  var m = void 0;
                  n = f.shapeArgs;
                  e = f.getTranslate();
                  c.styledMode || (m = f.shadowGroup, g && !m && (m = f.shadowGroup = d.g("shadow").add(a.shadowGroup)), m && m.attr(e), h = a.pointAttribs(f, f.selected && "select"));
                  f.delayedRendering ? (k.setRadialReference(a.center).attr(n).attr(e), c.styledMode || k.attr(h).attr({
                    "stroke-linejoin": "round"
                  }).shadow(g, m), f.delayedRendering = !1) : (k.setRadialReference(a.center), c.styledMode || v(!0, b, h), v(!0, b, n, e), k.animate(b));
                  k.attr({
                    visibility: f.visible ? "inherit" : "hidden"
                  });
                  k.addClass(f.getClassName(), !0);
                } else k && (f.graphic = k.destroy());
              });
            };

            d.prototype.sortByAngle = function (a, c) {
              a.sort(function (a, d) {
                return "undefined" !== typeof a.angle && (d.angle - a.angle) * c;
              });
            };

            d.prototype.translate = function (a) {
              k(this, "translate");
              this.generatePoints();
              var d = this.options,
                  g = d.slicedOffset,
                  l = g + (d.borderWidth || 0),
                  e = c(d.startAngle, d.endAngle),
                  r = this.startAngleRad = e.start;
              e = (this.endAngleRad = e.end) - r;
              var h = this.points,
                  n = d.dataLabels.distance;
              d = d.ignoreHiddenPoint;
              var f = h.length,
                  b,
                  q = 0;
              a || (this.center = a = this.getCenter());

              for (b = 0; b < f; b++) {
                var t = h[b];
                var p = r + q * e;
                !t.isValid() || d && !t.visible || (q += t.percentage / 100);
                var u = r + q * e;
                var v = {
                  x: a[0],
                  y: a[1],
                  r: a[2] / 2,
                  innerR: a[3] / 2,
                  start: Math.round(1E3 * p) / 1E3,
                  end: Math.round(1E3 * u) / 1E3
                };
                t.shapeType = "arc";
                t.shapeArgs = v;
                t.labelDistance = m(t.options.dataLabels && t.options.dataLabels.distance, n);
                t.labelDistance = C(t.labelDistance, v.r);
                this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, t.labelDistance);
                u = (u + p) / 2;
                u > 1.5 * Math.PI ? u -= 2 * Math.PI : u < -Math.PI / 2 && (u += 2 * Math.PI);
                t.slicedTranslation = {
                  translateX: Math.round(Math.cos(u) * g),
                  translateY: Math.round(Math.sin(u) * g)
                };
                v = Math.cos(u) * a[2] / 2;
                var x = Math.sin(u) * a[2] / 2;
                t.tooltipPos = [a[0] + .7 * v, a[1] + .7 * x];
                t.half = u < -Math.PI / 2 || u > Math.PI / 2 ? 1 : 0;
                t.angle = u;
                p = Math.min(l, t.labelDistance / 5);
                t.labelPosition = {
                  natural: {
                    x: a[0] + v + Math.cos(u) * t.labelDistance,
                    y: a[1] + x + Math.sin(u) * t.labelDistance
                  },
                  "final": {},
                  alignment: 0 > t.labelDistance ? "center" : t.half ? "right" : "left",
                  connectorPosition: {
                    breakAt: {
                      x: a[0] + v + Math.cos(u) * p,
                      y: a[1] + x + Math.sin(u) * p
                    },
                    touchingSliceAt: {
                      x: a[0] + v,
                      y: a[1] + x
                    }
                  }
                };
              }

              k(this, "afterTranslate");
            };

            d.prototype.updateTotals = function () {
              var a = this.points,
                  c = a.length,
                  d = this.options.ignoreHiddenPoint,
                  g,
                  e = 0;

              for (g = 0; g < c; g++) {
                var k = a[g];
                !k.isValid() || d && !k.visible || (e += k.y);
              }

              this.total = e;

              for (g = 0; g < c; g++) {
                k = a[g], k.percentage = 0 < e && (k.visible || !d) ? k.y / e * 100 : 0, k.total = e;
              }
            };

            d.defaultOptions = v(G.defaultOptions, {
              center: [null, null],
              clip: !1,
              colorByPoint: !0,
              dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0
              },
              fillColor: void 0,
              ignoreHiddenPoint: !0,
              inactiveOtherPoints: !0,
              legendType: "point",
              marker: null,
              size: null,
              showInLegend: !1,
              slicedOffset: 10,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0
              },
              borderColor: "#ffffff",
              borderWidth: 1,
              lineWidth: void 0,
              states: {
                hover: {
                  brightness: .1
                }
              }
            });
            return d;
          }(G);

          a(t.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: E.drawRectangle,
            drawTracker: g.prototype.drawTracker,
            getCenter: d.getCenter,
            getSymbol: B,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: g.prototype.pointAttribs,
            pointClass: x,
            requireSorting: !1,
            searchPoint: B,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          I.registerSeriesType("pie", t);
          "";
          return t;
        });
        P(g, "Series/Pie/PieDataLabel.js", [g["Core/Series/DataLabel.js"], g["Core/Globals.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B, E, x) {
          var C = g.noop,
              I = B.distribute,
              A = E.series,
              t = x.arrayMax,
              q = x.clamp,
              c = x.defined,
              l = x.merge,
              a = x.pick,
              k = x.relativeLength,
              v;

          (function (g) {
            function m() {
              var d = this,
                  g = d.data,
                  e = d.chart,
                  k = d.options.dataLabels || {},
                  h = k.connectorPadding,
                  n = e.plotWidth,
                  f = e.plotHeight,
                  b = e.plotLeft,
                  m = Math.round(e.chartWidth / 3),
                  q = d.center,
                  p = q[2] / 2,
                  u = q[1],
                  v = [[], []],
                  y = [0, 0, 0, 0],
                  x = d.dataLabelPositioners,
                  O,
                  F,
                  C,
                  B,
                  N,
                  J,
                  E,
                  G,
                  L,
                  P,
                  V,
                  R;
              d.visible && (k.enabled || d._hasPointLabels) && (g.forEach(function (b) {
                b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({
                  width: "auto"
                }).css({
                  width: "auto",
                  textOverflow: "clip"
                }), b.dataLabel.shortened = !1);
              }), A.prototype.drawDataLabels.apply(d), g.forEach(function (b) {
                b.dataLabel && (b.visible ? (v[b.half].push(b), b.dataLabel._pos = null, !c(k.style.width) && !c(b.options.dataLabels && b.options.dataLabels.style && b.options.dataLabels.style.width) && b.dataLabel.getBBox().width > m && (b.dataLabel.css({
                  width: Math.round(.7 * m) + "px"
                }), b.dataLabel.shortened = !0)) : (b.dataLabel = b.dataLabel.destroy(), b.dataLabels && 1 === b.dataLabels.length && delete b.dataLabels));
              }), v.forEach(function (g, m) {
                var l = g.length,
                    r = [],
                    t;

                if (l) {
                  d.sortByAngle(g, m - .5);

                  if (0 < d.maxLabelDistance) {
                    var w = Math.max(0, u - p - d.maxLabelDistance);
                    var D = Math.min(u + p + d.maxLabelDistance, e.plotHeight);
                    g.forEach(function (b) {
                      0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, u - p - b.labelDistance), b.bottom = Math.min(u + p + b.labelDistance, e.plotHeight), t = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                        target: b.labelPosition.natural.y - b.top + t / 2,
                        size: t,
                        rank: b.y
                      }, r.push(b.distributeBox));
                    });
                    w = D + t - w;
                    I(r, w, w / 5);
                  }

                  for (V = 0; V < l; V++) {
                    O = g[V];
                    J = O.labelPosition;
                    B = O.dataLabel;
                    P = !1 === O.visible ? "hidden" : "inherit";
                    L = w = J.natural.y;
                    r && c(O.distributeBox) && ("undefined" === typeof O.distributeBox.pos ? P = "hidden" : (E = O.distributeBox.size, L = x.radialDistributionY(O)));
                    delete O.positionIndex;
                    if (k.justify) G = x.justify(O, p, q);else switch (k.alignTo) {
                      case "connectors":
                        G = x.alignToConnectors(g, m, n, b);
                        break;

                      case "plotEdges":
                        G = x.alignToPlotEdges(B, m, n, b);
                        break;

                      default:
                        G = x.radialDistributionX(d, O, L, w);
                    }
                    B._attr = {
                      visibility: P,
                      align: J.alignment
                    };
                    R = O.options.dataLabels || {};
                    B._pos = {
                      x: G + a(R.x, k.x) + ({
                        left: h,
                        right: -h
                      }[J.alignment] || 0),
                      y: L + a(R.y, k.y) - 10
                    };
                    J["final"].x = G;
                    J["final"].y = L;
                    a(k.crop, !0) && (N = B.getBBox().width, w = null, G - N < h && 1 === m ? (w = Math.round(N - G + h), y[3] = Math.max(w, y[3])) : G + N > n - h && 0 === m && (w = Math.round(G + N - n + h), y[1] = Math.max(w, y[1])), 0 > L - E / 2 ? y[0] = Math.max(Math.round(-L + E / 2), y[0]) : L + E / 2 > f && (y[2] = Math.max(Math.round(L + E / 2 - f), y[2])), B.sideOverflow = w);
                  }
                }
              }), 0 === t(y) || this.verifyDataLabelOverflow(y)) && (this.placeDataLabels(), this.points.forEach(function (b) {
                R = l(k, b.options.dataLabels);

                if (F = a(R.connectorWidth, 1)) {
                  var f;
                  C = b.connector;

                  if ((B = b.dataLabel) && B._pos && b.visible && 0 < b.labelDistance) {
                    P = B._attr.visibility;
                    if (f = !C) b.connector = C = e.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b.colorIndex + (b.className ? " " + b.className : "")).add(d.dataLabelsGroup), e.styledMode || C.attr({
                      "stroke-width": F,
                      stroke: R.connectorColor || b.color || "#666666"
                    });
                    C[f ? "attr" : "animate"]({
                      d: b.getConnectorPath()
                    });
                    C.attr("visibility", P);
                  } else C && (b.connector = C.destroy());
                }
              }));
            }

            function v() {
              this.points.forEach(function (a) {
                var c = a.dataLabel,
                    e;
                c && a.visible && ((e = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
                  width: c._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](e), c.moved = !0) : c && c.attr({
                  y: -9999
                }));
                delete a.distributeBox;
              }, this);
            }

            function x(a) {
              var c = this.center,
                  e = this.options,
                  d = e.center,
                  h = e.minSize || 80,
                  g = null !== e.size;

              if (!g) {
                if (null !== d[0]) var f = Math.max(c[2] - Math.max(a[1], a[3]), h);else f = Math.max(c[2] - a[1] - a[3], h), c[0] += (a[3] - a[1]) / 2;
                null !== d[1] ? f = q(f, h, c[2] - Math.max(a[0], a[2])) : (f = q(f, h, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
                f < c[2] ? (c[2] = f, c[3] = Math.min(e.thickness ? Math.max(0, f - 2 * e.thickness) : Math.max(0, k(e.innerSize || 0, f)), f), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : g = !0;
              }

              return g;
            }

            var B = [],
                y = {
              radialDistributionY: function radialDistributionY(a) {
                return a.top + a.distributeBox.pos;
              },
              radialDistributionX: function radialDistributionX(a, c, e, d) {
                return a.getX(e < c.top + 2 || e > c.bottom - 2 ? d : e, c.half, c);
              },
              justify: function justify(a, c, e) {
                return e[0] + (a.half ? -1 : 1) * (c + a.labelDistance);
              },
              alignToPlotEdges: function alignToPlotEdges(a, c, e, d) {
                a = a.getBBox().width;
                return c ? a + d : e - a - d;
              },
              alignToConnectors: function alignToConnectors(a, c, e, d) {
                var h = 0,
                    g;
                a.forEach(function (f) {
                  g = f.dataLabel.getBBox().width;
                  g > h && (h = g);
                });
                return c ? h + d : e - h - d;
              }
            };

            g.compose = function (a) {
              d.compose(A);
              -1 === B.indexOf(a) && (B.push(a), a = a.prototype, a.dataLabelPositioners = y, a.alignDataLabel = C, a.drawDataLabels = m, a.placeDataLabels = v, a.verifyDataLabelOverflow = x);
            };
          })(v || (v = {}));

          return v;
        });
        P(g, "Extensions/OverlappingDataLabels.js", [g["Core/Chart/Chart.js"], g["Core/Utilities.js"]], function (d, g) {
          function C(d, c) {
            var g = !1;

            if (d) {
              var a = d.newOpacity;
              d.oldOpacity !== a && (d.alignAttr && d.placed ? (d[a ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), g = !0, d.alignAttr.opacity = a, d[d.isOld ? "animate" : "attr"](d.alignAttr, null, function () {
                c.styledMode || d.css({
                  pointerEvents: a ? "auto" : "none"
                });
              }), x(c, "afterHideOverlappingLabel")) : d.attr({
                opacity: a
              }));
              d.isOld = !0;
            }

            return g;
          }

          var E = g.addEvent,
              x = g.fireEvent,
              G = g.isArray,
              I = g.isNumber,
              A = g.objectEach,
              t = g.pick;
          E(d, "render", function () {
            var d = this,
                c = [];
            (this.labelCollectors || []).forEach(function (d) {
              c = c.concat(d());
            });
            (this.yAxis || []).forEach(function (d) {
              d.stacking && d.options.stackLabels && !d.options.stackLabels.allowOverlap && A(d.stacking.stacks, function (a) {
                A(a, function (a) {
                  a.label && c.push(a.label);
                });
              });
            });
            (this.series || []).forEach(function (g) {
              var a = g.options.dataLabels;
              g.visible && (!1 !== a.enabled || g._hasPointLabels) && (a = function a(_a6) {
                return _a6.forEach(function (a) {
                  a.visible && (G(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : []).forEach(function (g) {
                    var k = g.options;
                    g.labelrank = t(k.labelrank, a.labelrank, a.shapeArgs && a.shapeArgs.height);
                    k.allowOverlap ? (g.oldOpacity = g.opacity, g.newOpacity = 1, C(g, d)) : c.push(g);
                  });
                });
              }, a(g.nodes || []), a(g.points));
            });
            this.hideOverlappingLabels(c);
          });

          d.prototype.hideOverlappingLabels = function (d) {
            var c = this,
                g = d.length,
                a = c.renderer,
                k,
                q,
                m,
                t = !1;

            var F = function F(c) {
              var d,
                  g = c.box ? 0 : c.padding || 0,
                  e = d = 0,
                  k;

              if (c && (!c.alignAttr || c.placed)) {
                var h = c.alignAttr || {
                  x: c.attr("x"),
                  y: c.attr("y")
                };
                var n = c.parentGroup;
                c.width || (d = c.getBBox(), c.width = d.width, c.height = d.height, d = a.fontMetrics(null, c.element).h);
                var f = c.width - 2 * g;
                (k = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[c.alignValue]) ? e = +k * f : I(c.x) && Math.round(c.x) !== c.translateX && (e = c.x - c.translateX);
                return {
                  x: h.x + (n.translateX || 0) + g - (e || 0),
                  y: h.y + (n.translateY || 0) + g - d,
                  width: c.width - 2 * g,
                  height: c.height - 2 * g
                };
              }
            };

            for (q = 0; q < g; q++) {
              if (k = d[q]) k.oldOpacity = k.opacity, k.newOpacity = 1, k.absoluteBox = F(k);
            }

            d.sort(function (a, c) {
              return (c.labelrank || 0) - (a.labelrank || 0);
            });

            for (q = 0; q < g; q++) {
              var A = (F = d[q]) && F.absoluteBox;

              for (k = q + 1; k < g; ++k) {
                var B = (m = d[k]) && m.absoluteBox;
                !A || !B || F === m || 0 === F.newOpacity || 0 === m.newOpacity || "hidden" === F.visibility || "hidden" === m.visibility || B.x >= A.x + A.width || B.x + B.width <= A.x || B.y >= A.y + A.height || B.y + B.height <= A.y || ((F.labelrank < m.labelrank ? F : m).newOpacity = 0);
              }
            }

            d.forEach(function (a) {
              C(a, c) && (t = !0);
            });
            t && x(c, "afterHideAllOverlappingLabels");
          };
        });
        P(g, "Core/Responsive.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.extend,
              B = d.find,
              E = d.isArray,
              x = d.isObject,
              G = d.merge,
              I = d.objectEach,
              A = d.pick,
              t = d.splat,
              q = d.uniqueKey,
              c;

          (function (c) {
            var a = [];

            c.compose = function (c) {
              -1 === a.indexOf(c) && (a.push(c), g(c.prototype, d.prototype));
              return c;
            };

            var d = function () {
              function a() {}

              a.prototype.currentOptions = function (a) {
                function c(a, g, k, m) {
                  var e;
                  I(a, function (a, h) {
                    if (!m && -1 < d.collectionsWithUpdate.indexOf(h) && g[h]) for (a = t(a), k[h] = [], e = 0; e < Math.max(a.length, g[h].length); e++) {
                      g[h][e] && (void 0 === a[e] ? k[h][e] = g[h][e] : (k[h][e] = {}, c(a[e], g[h][e], k[h][e], m + 1)));
                    } else x(a) ? (k[h] = E(a) ? [] : {}, c(a, g[h] || {}, k[h], m + 1)) : k[h] = "undefined" === typeof g[h] ? null : g[h];
                  });
                }

                var d = this,
                    g = {};
                c(a, this.options, g, 0);
                return g;
              };

              a.prototype.matchResponsiveRule = function (a, c) {
                var d = a.condition;
                (d.callback || function () {
                  return this.chartWidth <= A(d.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(d.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(d.minWidth, 0) && this.chartHeight >= A(d.minHeight, 0);
                }).call(this) && c.push(a._id);
              };

              a.prototype.setResponsive = function (a, c) {
                var d = this,
                    g = this.options.responsive,
                    k = this.currentResponsive,
                    m = [];
                !c && g && g.rules && g.rules.forEach(function (a) {
                  "undefined" === typeof a._id && (a._id = q());
                  d.matchResponsiveRule(a, m);
                }, this);
                c = G.apply(void 0, m.map(function (a) {
                  return B((g || {}).rules || [], function (c) {
                    return c._id === a;
                  });
                }).map(function (a) {
                  return a && a.chartOptions;
                }));
                c.isResponsiveOptions = !0;
                m = m.toString() || void 0;
                m !== (k && k.ruleIds) && (k && this.update(k.undoOptions, a, !0), m ? (k = this.currentOptions(c), k.isResponsiveOptions = !0, this.currentResponsive = {
                  ruleIds: m,
                  mergedOptions: c,
                  undoOptions: k
                }, this.update(c, a, !0)) : this.currentResponsive = void 0);
              };

              return a;
            }();
          })(c || (c = {}));

          "";
          "";
          return c;
        });
        P(g, "masters/highcharts.src.js", [g["Core/Globals.js"], g["Core/Utilities.js"], g["Core/DefaultOptions.js"], g["Core/Animation/Fx.js"], g["Core/Animation/AnimationUtilities.js"], g["Core/Renderer/HTML/AST.js"], g["Core/FormatUtilities.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Renderer/HTML/HTMLElement.js"], g["Core/Renderer/HTML/HTMLRenderer.js"], g["Core/Axis/Axis.js"], g["Core/Axis/DateTimeAxis.js"], g["Core/Axis/LogarithmicAxis.js"], g["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], g["Core/Axis/Tick.js"], g["Core/Tooltip.js"], g["Core/Series/Point.js"], g["Core/Pointer.js"], g["Core/MSPointer.js"], g["Core/Legend/Legend.js"], g["Core/Chart/Chart.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Series/Column/ColumnSeries.js"], g["Series/Column/ColumnDataLabel.js"], g["Series/Pie/PieSeries.js"], g["Series/Pie/PieDataLabel.js"], g["Core/Series/DataLabel.js"], g["Core/Responsive.js"], g["Core/Color/Color.js"], g["Core/Time.js"]], function (d, g, B, E, x, G, I, A, t, q, c, l, a, k, v, m, N, F, L, J, y, z, w, e, r, h, n, f, b, D, H, p, u) {
          d.animate = x.animate;
          d.animObject = x.animObject;
          d.getDeferredAnimation = x.getDeferredAnimation;
          d.setAnimation = x.setAnimation;
          d.stop = x.stop;
          d.timers = E.timers;
          d.AST = G;
          d.Axis = a;
          d.Chart = w;
          d.chart = w.chart;
          d.Fx = E;
          d.Legend = z;
          d.PlotLineOrBand = m;
          d.Point = L;
          d.Pointer = y.isRequired() ? y : J;
          d.Series = e;
          d.SVGElement = t;
          d.SVGRenderer = q;
          d.Tick = N;
          d.Time = u;
          d.Tooltip = F;
          d.Color = p;
          d.color = p.parse;
          l.compose(q);
          c.compose(t);
          d.defaultOptions = B.defaultOptions;
          d.getOptions = B.getOptions;
          d.time = B.defaultTime;
          d.setOptions = B.setOptions;
          d.dateFormat = I.dateFormat;
          d.format = I.format;
          d.numberFormat = I.numberFormat;
          d.addEvent = g.addEvent;
          d.arrayMax = g.arrayMax;
          d.arrayMin = g.arrayMin;
          d.attr = g.attr;
          d.clearTimeout = g.clearTimeout;
          d.correctFloat = g.correctFloat;
          d.createElement = g.createElement;
          d.css = g.css;
          d.defined = g.defined;
          d.destroyObjectProperties = g.destroyObjectProperties;
          d.discardElement = g.discardElement;
          d.distribute = A.distribute;
          d.erase = g.erase;
          d.error = g.error;
          d.extend = g.extend;
          d.extendClass = g.extendClass;
          d.find = g.find;
          d.fireEvent = g.fireEvent;
          d.getMagnitude = g.getMagnitude;
          d.getStyle = g.getStyle;
          d.inArray = g.inArray;
          d.isArray = g.isArray;
          d.isClass = g.isClass;
          d.isDOMElement = g.isDOMElement;
          d.isFunction = g.isFunction;
          d.isNumber = g.isNumber;
          d.isObject = g.isObject;
          d.isString = g.isString;
          d.keys = g.keys;
          d.merge = g.merge;
          d.normalizeTickInterval = g.normalizeTickInterval;
          d.objectEach = g.objectEach;
          d.offset = g.offset;
          d.pad = g.pad;
          d.pick = g.pick;
          d.pInt = g.pInt;
          d.relativeLength = g.relativeLength;
          d.removeEvent = g.removeEvent;
          d.seriesType = r.seriesType;
          d.splat = g.splat;
          d.stableSort = g.stableSort;
          d.syncTimeout = g.syncTimeout;
          d.timeUnits = g.timeUnits;
          d.uniqueKey = g.uniqueKey;
          d.useSerialIds = g.useSerialIds;
          d.wrap = g.wrap;
          n.compose(h);
          D.compose(e);
          k.compose(a);
          v.compose(a);
          b.compose(f);
          m.compose(a);
          H.compose(w);
          return d;
        });
        P(g, "Core/Axis/OrdinalAxis.js", [g["Core/Axis/Axis.js"], g["Core/Globals.js"], g["Core/Series/Series.js"], g["Core/Utilities.js"]], function (d, g, B, E) {
          var x = E.addEvent,
              C = E.correctFloat,
              I = E.css,
              A = E.defined,
              t = E.error,
              q = E.pick,
              c = E.timeUnits,
              l = [],
              a;

          (function (a) {
            function d(a, f, b, e, d, h, g) {
              void 0 === d && (d = []);
              void 0 === h && (h = 0);
              var p = {},
                  n = this.options.tickPixelInterval,
                  k = this.chart.time,
                  m = [],
                  u,
                  l,
                  r = 0,
                  q = [],
                  D = -Number.MAX_VALUE;
              if (!this.options.ordinal && !this.options.breaks || !d || 3 > d.length || "undefined" === typeof f) return k.getTimeTicks.apply(k, arguments);
              var H = d.length;

              for (u = 0; u < H; u++) {
                var w = u && d[u - 1] > b;
                d[u] < f && (r = u);

                if (u === H - 1 || d[u + 1] - d[u] > 5 * h || w) {
                  if (d[u] > D) {
                    for (l = k.getTimeTicks(a, d[r], d[u], e); l.length && l[0] <= D;) {
                      l.shift();
                    }

                    l.length && (D = l[l.length - 1]);
                    m.push(q.length);
                    q = q.concat(l);
                  }

                  r = u + 1;
                }

                if (w) break;
              }

              if (l) {
                l = l.info;

                if (g && l.unitRange <= c.hour) {
                  u = q.length - 1;

                  for (r = 1; r < u; r++) {
                    if (k.dateFormat("%d", q[r]) !== k.dateFormat("%d", q[r - 1])) {
                      p[q[r]] = "day";
                      var v = !0;
                    }
                  }

                  v && (p[q[0]] = "day");
                  l.higherRanks = p;
                }

                l.segmentStarts = m;
                q.info = l;
              } else t(12, !1, this.chart);

              if (g && A(n)) {
                l = q.length;
                k = [];
                r = [];
                u = void 0;

                for (v = l; v--;) {
                  m = this.translate(q[v]), u && (r[v] = u - m), k[v] = u = m;
                }

                r.sort();
                r = r[Math.floor(r.length / 2)];
                r < .6 * n && (r = null);
                v = q[l - 1] > b ? l - 1 : l;

                for (u = void 0; v--;) {
                  m = k[v], l = Math.abs(u - m), u && l < .8 * n && (null === r || l < .8 * r) ? (p[q[v]] && !p[q[v + 1]] ? (l = v + 1, u = m) : l = v, q.splice(l, 1)) : u = m;
                }
              }

              return q;
            }

            function k(a) {
              var f = this.ordinal.positions;
              if (!f) return a;
              var b = f.length - 1;
              if (0 > a) a = f[0];else if (a > b) a = f[b];else {
                b = Math.floor(a);
                var e = a - b;
              }
              return "undefined" !== typeof e && "undefined" !== typeof f[b] ? f[b] + (e ? e * (f[b + 1] - f[b]) : 0) : a;
            }

            function G(a) {
              var f = this.ordinal,
                  b = f.positions;
              if (!b) return a;
              var e = (a - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding;
              0 < e && e < this.left + this.len || (f.extendedOrdinalPositions || (f.extendedOrdinalPositions = f.getExtendedPositions()), b = f.extendedOrdinalPositions);

              if (b && b.length) {
                a = f.getIndexOfPoint(e, b);
                f = C(a % 1);
                if (0 <= a && a < b.length - 1) return b[Math.floor(a)] + f * (b[Math.ceil(a)] - b[Math.floor(a)]);
                f = b.length;
                e = b[0];
                b = b[f - 1];
                var c = (b - e) / (f - 1);
                return 0 > a ? e + c * a : b + c * (a - f);
              }

              return a;
            }

            function F(e, f) {
              var b = a.Additions.findIndexOf(e, f, !0);
              return e[b] === f ? b : b + (f - e[b]) / (e[b + 1] - e[b]);
            }

            function E() {
              this.ordinal || (this.ordinal = new a.Additions(this));
            }

            function J() {
              this.isXAxis && A(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && "navigator" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && A(this.userMin) && (this.min += this.options.overscroll));
            }

            function y() {
              this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
            }

            function z() {
              this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
            }

            function w(a) {
              var f = this.xAxis[0],
                  b = f.options.overscroll,
                  e = a.originalEvent.chartX,
                  c = this.options.chart.panning,
                  d = !1;

              if (c && "y" !== c.type && f.options.ordinal && f.series.length) {
                var h = this.mouseDownX,
                    g = f.getExtremes(),
                    k = g.dataMax,
                    n = g.min,
                    m = g.max,
                    l = this.hoverPoints,
                    r = f.closestPointRange || f.ordinal && f.ordinal.overscrollPointsRange;
                h = (h - e) / (f.translationSlope * (f.ordinal.slope || r));
                r = f.ordinal.getExtendedPositions();
                r = {
                  ordinal: {
                    positions: r,
                    extendedOrdinalPositions: r
                  }
                };
                var q = f.index2val,
                    t = f.val2lin,
                    w = void 0,
                    v = w = void 0,
                    y = void 0;
                r.ordinal.positions ? 1 < Math.abs(h) && (l && l.forEach(function (b) {
                  b.setState();
                }), 0 > h ? (v = r, y = f.ordinal.positions ? f : r) : (v = f.ordinal.positions ? f : r, y = r), w = y.ordinal.positions, k > w[w.length - 1] && w.push(k), this.fixedRange = m - n, w = f.navigatorAxis.toFixedRange(void 0, void 0, q.apply(v, [t.apply(v, [n, !0]) + h]), q.apply(y, [t.apply(y, [m, !0]) + h])), w.min >= Math.min(g.dataMin, n) && w.max <= Math.max(k, m) + b && f.setExtremes(w.min, w.max, !0, !1, {
                  trigger: "pan"
                }), this.mouseDownX = e, I(this.container, {
                  cursor: "move"
                })) : d = !0;
              } else d = !0;

              d || c && /y/.test(c.type) ? b && (f.max = f.dataMax + b) : a.preventDefault();
            }

            function e() {
              var a = this.xAxis;
              a && a.options.ordinal && (delete a.ordinal.index, delete a.ordinal.extendedOrdinalPositions);
            }

            function r(a, f) {
              var b = this.ordinal,
                  e = b.positions,
                  c = b.slope,
                  d = b.extendedOrdinalPositions;
              if (!e) return a;
              var h = e.length;
              if (e[0] <= a && e[h - 1] >= a) a = F(e, a);else {
                d || (d = b.getExtendedPositions && b.getExtendedPositions(), b.extendedOrdinalPositions = d);
                if (!d || !d.length) return a;
                h = d.length;
                c || (c = (d[h - 1] - d[0]) / h);
                e = F(d, e[0]);
                a >= d[0] && a <= d[h - 1] ? a = F(d, a) - e : a < d[0] ? (a = d[0] - a, a = -e - a / c) : (a -= d[h - 1], a = a / c + h - e);
              }
              return f ? a : c * (a || 0) + b.offset;
            }

            a.compose = function (a, f, b) {
              if (-1 === l.indexOf(a)) {
                l.push(a);
                var c = a.prototype;
                c.getTimeTicks = d;
                c.index2val = k;
                c.lin2val = G;
                c.val2lin = r;
                c.ordinal2lin = c.val2lin;
                x(a, "afterInit", E);
                x(a, "foundExtremes", J);
                x(a, "afterSetScale", y);
                x(a, "initialAxisTranslation", z);
              }

              -1 === l.indexOf(b) && (l.push(b), x(b, "pan", w));
              -1 === l.indexOf(f) && (l.push(f), x(f, "updatedData", e));
              return a;
            };

            var h = function () {
              function a(a) {
                this.index = {};
                this.axis = a;
              }

              a.prototype.beforeSetTickPositions = function () {
                var a = this.axis,
                    b = a.ordinal,
                    e = a.getExtremes(),
                    c = e.min,
                    d = e.max,
                    h = a.isXAxis && !!a.options.breaks;
                e = a.options.ordinal;
                var g = a.chart.options.chart.ignoreHiddenSeries,
                    k,
                    n,
                    m = [],
                    l = Number.MAX_VALUE,
                    r = !1,
                    t = !1,
                    w = !1;

                if (e || h) {
                  var v = 0;
                  a.series.forEach(function (b, a) {
                    k = [];
                    0 < a && "highcharts-navigator-series" !== b.options.id && (t = v !== b.processedXData[1] - b.processedXData[0]);
                    v = b.processedXData[1] - b.processedXData[0];
                    b.isSeriesBoosting && (w = b.isSeriesBoosting);

                    if (!(g && !1 === b.visible || !1 === b.takeOrdinalPosition && !h) && (m = m.concat(b.processedXData), y = m.length, m.sort(function (b, a) {
                      return b - a;
                    }), l = Math.min(l, q(b.closestPointRange, l)), y)) {
                      for (a = 0; a < y - 1;) {
                        m[a] !== m[a + 1] && k.push(m[a + 1]), a++;
                      }

                      k[0] !== m[0] && k.unshift(m[0]);
                      m = k;
                    }
                  });
                  t && w && (m.pop(), m.shift());
                  var y = m.length;

                  if (2 < y) {
                    var z = m[1] - m[0];

                    for (n = y - 1; n-- && !r;) {
                      m[n + 1] - m[n] !== z && (r = !0);
                    }

                    !a.options.keepOrdinalPadding && (m[0] - c > z || d - m[m.length - 1] > z) && (r = !0);
                  } else a.options.overscroll && (2 === y ? l = m[1] - m[0] : 1 === y ? (l = a.options.overscroll, m = [m[0], m[0] + l]) : l = b.overscrollPointsRange);

                  r || a.forceOrdinal ? (a.options.overscroll && (b.overscrollPointsRange = l, m = m.concat(b.getOverscrollPositions())), b.positions = m, z = a.ordinal2lin(Math.max(c, m[0]), !0), n = Math.max(a.ordinal2lin(Math.min(d, m[m.length - 1]), !0), 1), b.slope = d = (d - c) / (n - z), b.offset = c - z * d) : (b.overscrollPointsRange = q(a.closestPointRange, b.overscrollPointsRange), b.positions = a.ordinal.slope = b.offset = void 0);
                }

                a.isOrdinal = e && r;
                b.groupIntervalFactor = null;
              };

              a.findIndexOf = function (a, b, e) {
                for (var f = 0, c = a.length - 1, d; f < c;) {
                  d = Math.ceil((f + c) / 2), a[d] <= b ? f = d : c = d - 1;
                }

                return a[f] === b ? f : e ? f : -1;
              };

              a.prototype.getExtendedPositions = function () {
                var a = this,
                    b = a.axis,
                    e = b.constructor.prototype,
                    c = b.chart,
                    d = b.series[0].currentDataGrouping,
                    h = d ? d.count + d.unitName : "raw",
                    k = b.options.overscroll,
                    n = b.getExtremes(),
                    m = void 0,
                    l = a.index;
                l || (l = a.index = {});

                if (!l[h]) {
                  var r = {
                    series: [],
                    chart: c,
                    forceOrdinal: !1,
                    getExtremes: function getExtremes() {
                      return {
                        min: n.dataMin,
                        max: n.dataMax + k
                      };
                    },
                    getGroupPixelWidth: e.getGroupPixelWidth,
                    getTimeTicks: e.getTimeTicks,
                    options: {
                      ordinal: !0
                    },
                    ordinal: {
                      getGroupIntervalFactor: this.getGroupIntervalFactor
                    },
                    ordinal2lin: e.ordinal2lin,
                    getIndexOfPoint: e.getIndexOfPoint,
                    val2lin: e.val2lin
                  };
                  r.ordinal.axis = r;
                  b.series.forEach(function (b) {
                    m = {
                      xAxis: r,
                      xData: b.xData.slice(),
                      chart: c,
                      destroyGroupedData: g.noop,
                      getProcessedData: B.prototype.getProcessedData,
                      applyGrouping: B.prototype.applyGrouping
                    };
                    m.xData = m.xData.concat(a.getOverscrollPositions());
                    m.options = {
                      dataGrouping: d ? {
                        firstAnchor: "firstPoint",
                        anchor: "middle",
                        lastAnchor: "lastPoint",
                        enabled: !0,
                        forced: !0,
                        approximation: "open",
                        units: [[d.unitName, [d.count]]]
                      } : {
                        enabled: !1
                      }
                    };
                    r.series.push(m);
                    b.processData.apply(m);
                  });
                  m.closestPointRange !== m.basePointRange && m.currentDataGrouping && (r.forceOrdinal = !0);
                  b.ordinal.beforeSetTickPositions.apply({
                    axis: r
                  });
                  l[h] = r.ordinal.positions;
                }

                return l[h];
              };

              a.prototype.getGroupIntervalFactor = function (a, b, e) {
                e = e.processedXData;
                var f = e.length,
                    c = [];
                var d = this.groupIntervalFactor;

                if (!d) {
                  for (d = 0; d < f - 1; d++) {
                    c[d] = e[d + 1] - e[d];
                  }

                  c.sort(function (b, a) {
                    return b - a;
                  });
                  c = c[Math.floor(f / 2)];
                  a = Math.max(a, e[0]);
                  b = Math.min(b, e[f - 1]);
                  this.groupIntervalFactor = d = f * c / (b - a);
                }

                return d;
              };

              a.prototype.getIndexOfPoint = function (f, b) {
                var e = this.axis,
                    c = this.positions ? this.positions[0] : 0,
                    d = e.series[0].points && e.series[0].points[0] && e.series[0].points[0].plotX || e.minPixelPadding;
                1 < e.series.length && e.series.forEach(function (b) {
                  b.points && A(b.points[0]) && A(b.points[0].plotX) && b.points[0].plotX < d && (d = b.points[0].plotX);
                });
                f = (f - d) / (e.translationSlope * (this.slope || e.closestPointRange || this.overscrollPointsRange));
                return a.findIndexOf(b, c) + f;
              };

              a.prototype.getOverscrollPositions = function () {
                var a = this.axis,
                    b = a.options.overscroll,
                    e = this.overscrollPointsRange,
                    c = [],
                    d = a.dataMax;
                if (A(e)) for (; d <= a.dataMax + b;) {
                  d += e, c.push(d);
                }
                return c;
              };

              a.prototype.postProcessTickInterval = function (a) {
                var b = this.axis,
                    f = this.slope;
                return f ? b.options.breaks ? b.closestPointRange || a : a / (f / b.closestPointRange) : a;
              };

              return a;
            }();

            a.Additions = h;
          })(a || (a = {}));

          return a;
        });
        P(g, "Series/DataModifyComposition.js", [g["Core/Axis/Axis.js"], g["Core/Series/Point.js"], g["Core/Series/Series.js"], g["Core/Utilities.js"]], function (d, g, B, E) {
          var x = g.prototype.tooltipFormatter,
              C = E.addEvent,
              I = E.arrayMax,
              A = E.arrayMin,
              t = E.correctFloat,
              q = E.defined,
              c = E.isArray,
              l = E.isNumber,
              a = E.isString,
              k = E.pick,
              v;

          (function (d) {
            function g(f, b, e) {
              this.isXAxis || (this.series.forEach(function (e) {
                "compare" === f && "boolean" !== typeof b ? e.setCompare(b, !1) : "cumulative" !== f || a(b) || e.setCumulative(b, !1);
              }), k(e, !0) && this.chart.redraw());
            }

            function m(a) {
              var b = this,
                  f = b.series.chart.numberFormatter,
                  e = function e(_e2) {
                a = a.replace("{point." + _e2 + "}", (0 < b[_e2] && "change" === _e2 ? "+" : "") + f(b[_e2], k(b.series.tooltipOptions.changeDecimals, 2)));
              };

              q(b.change) && e("change");
              q(b.cumulativeSum) && e("cumulativeSum");
              return x.apply(this, [a]);
            }

            function v() {
              var a = this.options.compare;

              if ("percent" === a || "value" === a || this.options.cumulative) {
                var b = new n(this);
                "percent" === a || "value" === a ? b.initCompare(a) : b.initCumulative();
              }

              this.dataModify = b;
            }

            function B(a) {
              a = a.dataExtremes;
              var b = a.activeYData;

              if (this.dataModify && a) {
                var f = void 0;
                this.options.compare ? f = [this.dataModify.modifyValue(a.dataMin), this.dataModify.modifyValue(a.dataMax)] : this.options.cumulative && c(b) && 2 <= b.length && (f = n.getCumulativeExtremes(b));
                f && (a.dataMin = A(f), a.dataMax = I(f));
              }
            }

            function y(a, b) {
              this.options.compare = this.userOptions.compare = a;
              this.update({}, k(b, !0));
              !this.dataModify || "value" !== a && "percent" !== a ? this.points.forEach(function (b) {
                delete b.change;
              }) : this.dataModify.initCompare(a);
            }

            function z() {
              if (this.xAxis && this.processedYData && this.dataModify) {
                var a = this.processedXData,
                    b = this.processedYData,
                    e = b.length,
                    c = !0 === this.options.compareStart ? 0 : 1,
                    d = -1,
                    h;
                this.pointArrayMap && (d = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || "y"));

                for (h = 0; h < e - c; h++) {
                  var g = b[h] && -1 < d ? b[h][d] : b[h];

                  if (l(g) && 0 !== g && a[h + c] >= (this.xAxis.min || 0)) {
                    this.dataModify.compareValue = g;
                    break;
                  }
                }
              }
            }

            function w(a, b) {
              this.setModifier("compare", a, b);
            }

            function e(a, b) {
              a = k(a, !1);
              this.options.cumulative = this.userOptions.cumulative = a;
              this.update({}, k(b, !0));
              this.dataModify ? this.dataModify.initCumulative() : this.points.forEach(function (b) {
                delete b.cumulativeSum;
              });
            }

            function r(a, b) {
              this.setModifier("cumulative", a, b);
            }

            var h = [];

            d.compose = function (a, b, c) {
              if (-1 === h.indexOf(a)) {
                h.push(a);
                var f = a.prototype;
                f.setCompare = y;
                f.setCumulative = e;
                C(a, "afterInit", v);
                C(a, "afterGetExtremes", B);
                C(a, "afterProcessData", z);
              }

              -1 === h.indexOf(b) && (h.push(b), b = b.prototype, b.setCompare = w, b.setModifier = g, b.setCumulative = r);
              -1 === h.indexOf(c) && (h.push(c), c.prototype.tooltipFormatter = m);
              return a;
            };

            var n = function () {
              function a(b) {
                this.series = b;
              }

              a.prototype.modifyValue = function () {
                return 0;
              };

              a.getCumulativeExtremes = function (b) {
                var a = Infinity,
                    f = -Infinity;
                b.reduce(function (b, e) {
                  e = b + e;
                  a = Math.min(a, e, b);
                  f = Math.max(f, e, b);
                  return e;
                });
                return [a, f];
              };

              a.prototype.initCompare = function (b) {
                this.modifyValue = function (a, f) {
                  null === a && (a = 0);
                  var e = this.compareValue;
                  return "undefined" !== typeof a && "undefined" !== typeof e ? (a = "value" === b ? a - e : a / e * 100 - (100 === this.series.options.compareBase ? 0 : 100), "undefined" !== typeof f && (f = this.series.points[f]) && (f.change = a), a) : 0;
                };
              };

              a.prototype.initCumulative = function () {
                this.modifyValue = function (b, a) {
                  null === b && (b = 0);

                  if (void 0 !== b && void 0 !== a) {
                    var f = 0 < a ? this.series.points[a - 1] : null;
                    f && f.cumulativeSum && (b = t(f.cumulativeSum + b));
                    if (a = this.series.points[a]) a.cumulativeSum = b;
                    return b;
                  }

                  return 0;
                };
              };

              return a;
            }();

            d.Additions = n;
          })(v || (v = {}));

          "";
          return v;
        });
        P(g, "Core/Axis/BrokenAxis.js", [g["Extensions/Stacking.js"], g["Core/Utilities.js"]], function (d, g) {
          var B = g.addEvent,
              C = g.find,
              x = g.fireEvent,
              G = g.isArray,
              I = g.isNumber,
              A = g.pick,
              t;

          (function (g) {
            function c() {
              "undefined" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);
            }

            function l() {
              this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);
            }

            function a() {
              var a = this.brokenAxis;

              if (a && a.hasBreaks) {
                for (var c = this.tickPositions, d = this.tickPositions.info, e = [], g = 0; g < c.length; g++) {
                  a.isInAnyBreak(c[g]) || e.push(c[g]);
                }

                this.tickPositions = e;
                this.tickPositions.info = d;
              }
            }

            function k() {
              this.brokenAxis || (this.brokenAxis = new J(this));
            }

            function q() {
              var a = this.options.connectNulls,
                  c = this.points,
                  d = this.xAxis,
                  e = this.yAxis;
              if (this.isDirty) for (var g = c.length; g--;) {
                var h = c[g],
                    k = !(null === h.y && !1 === a) && (d && d.brokenAxis && d.brokenAxis.isInAnyBreak(h.x, !0) || e && e.brokenAxis && e.brokenAxis.isInAnyBreak(h.y, !0));
                h.visible = k ? !1 : !1 !== h.options.visible;
              }
            }

            function m() {
              this.drawBreaks(this.xAxis, ["x"]);
              this.drawBreaks(this.yAxis, A(this.pointArrayMap, ["y"]));
            }

            function t(a, c) {
              var d = this,
                  e = d.points,
                  g,
                  h,
                  k,
                  f;

              if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {
                var b = a.brokenAxis;
                c.forEach(function (c) {
                  g = b && b.breakArray || [];
                  h = a.isXAxis ? a.min : A(d.options.threshold, a.min);
                  e.forEach(function (b) {
                    f = A(b["stack" + c.toUpperCase()], b[c]);
                    g.forEach(function (e) {
                      if (I(h) && I(f)) {
                        k = !1;
                        if (h < e.from && f > e.to || h > e.from && f < e.from) k = "pointBreak";else if (h < e.from && f > e.from && f < e.to || h > e.from && f > e.to && f < e.from) k = "pointInBreak";
                        k && x(a, k, {
                          point: b,
                          brk: e
                        });
                      }
                    });
                  });
                });
              }
            }

            function F() {
              var a = this.currentDataGrouping,
                  c = a && a.gapSize;
              a = this.points.slice();
              var g = this.yAxis,
                  e = this.options.gapSize,
                  k = a.length - 1,
                  h;
              if (e && 0 < k) for ("value" !== this.options.gapUnit && (e *= this.basePointRange), c && c > e && c >= this.basePointRange && (e = c), h = void 0; k--;) {
                h && !1 !== h.visible || (h = a[k + 1]), c = a[k], !1 !== h.visible && !1 !== c.visible && (h.x - c.x > e && (h = (c.x + h.x) / 2, a.splice(k + 1, 0, {
                  isNull: !0,
                  x: h
                }), g.stacking && this.options.stacking && (h = g.stacking.stacks[this.stackKey][h] = new d(g, g.options.stackLabels, !1, h, this.stack), h.total = 0)), h = c);
              }
              return this.getGraphPath(a);
            }

            var E = [];

            g.compose = function (d, g) {
              -1 === E.indexOf(d) && (E.push(d), d.keepProps.push("brokenAxis"), B(d, "init", k), B(d, "afterInit", c), B(d, "afterSetTickPositions", a), B(d, "afterSetOptions", l));

              if (-1 === E.indexOf(g)) {
                E.push(g);
                var w = g.prototype;
                w.drawBreaks = t;
                w.gappedPath = F;
                B(g, "afterGeneratePoints", q);
                B(g, "afterRender", m);
              }

              return d;
            };

            var J = function () {
              function a(a) {
                this.hasBreaks = !1;
                this.axis = a;
              }

              a.isInBreak = function (a, c) {
                var e = a.repeat || Infinity,
                    d = a.from,
                    h = a.to - a.from;
                c = c >= d ? (c - d) % e : e - (d - c) % e;
                return a.inclusive ? c <= h : c < h && 0 !== c;
              };

              a.lin2Val = function (c) {
                var d = this.brokenAxis;
                d = d && d.breakArray;
                if (!d || !I(c)) return c;
                var e;

                for (e = 0; e < d.length; e++) {
                  var g = d[e];
                  if (g.from >= c) break;else g.to < c ? c += g.len : a.isInBreak(g, c) && (c += g.len);
                }

                return c;
              };

              a.val2Lin = function (c) {
                var d = this.brokenAxis;
                d = d && d.breakArray;
                if (!d || !I(c)) return c;
                var e = c,
                    g;

                for (g = 0; g < d.length; g++) {
                  var h = d[g];
                  if (h.to <= c) e -= h.len;else if (h.from >= c) break;else if (a.isInBreak(h, c)) {
                    e -= c - h.from;
                    break;
                  }
                }

                return e;
              };

              a.prototype.findBreakAt = function (a, c) {
                return C(c, function (e) {
                  return e.from < a && a < e.to;
                });
              };

              a.prototype.isInAnyBreak = function (c, d) {
                var e = this.axis,
                    g = e.options.breaks || [],
                    h = g.length,
                    k;

                if (h && I(c)) {
                  for (; h--;) {
                    if (a.isInBreak(g[h], c)) {
                      var f = !0;
                      k || (k = A(g[h].showPoints, !e.isXAxis));
                    }
                  }

                  var b = f && d ? f && !k : f;
                }

                return b;
              };

              a.prototype.setBreaks = function (c, d) {
                var e = this,
                    g = e.axis,
                    h = G(c) && !!c.length;
                g.isDirty = e.hasBreaks !== h;
                e.hasBreaks = h;
                g.options.breaks = g.userOptions.breaks = c;
                g.forceRedraw = !0;
                g.series.forEach(function (a) {
                  a.isDirty = !0;
                });
                h || g.val2lin !== a.val2Lin || (delete g.val2lin, delete g.lin2val);
                h && (g.userOptions.ordinal = !1, g.lin2val = a.lin2Val, g.val2lin = a.val2Lin, g.setExtremes = function (a, c, b, d, h) {
                  if (e.hasBreaks) {
                    for (var f = this.options.breaks || [], k; k = e.findBreakAt(a, f);) {
                      a = k.to;
                    }

                    for (; k = e.findBreakAt(c, f);) {
                      c = k.from;
                    }

                    c < a && (c = a);
                  }

                  g.constructor.prototype.setExtremes.call(this, a, c, b, d, h);
                }, g.setAxisTranslation = function () {
                  g.constructor.prototype.setAxisTranslation.call(this);
                  e.unitLength = void 0;

                  if (e.hasBreaks) {
                    var c = g.options.breaks || [],
                        f = [],
                        b = [],
                        d = A(g.pointRangePadding, 0),
                        h = 0,
                        p,
                        k = g.userMin || g.min,
                        m = g.userMax || g.max,
                        l;
                    c.forEach(function (b) {
                      p = b.repeat || Infinity;
                      I(k) && I(m) && (a.isInBreak(b, k) && (k += b.to % p - k % p), a.isInBreak(b, m) && (m -= m % p - b.from % p));
                    });
                    c.forEach(function (b) {
                      r = b.from;
                      p = b.repeat || Infinity;

                      if (I(k) && I(m)) {
                        for (; r - p > k;) {
                          r -= p;
                        }

                        for (; r < k;) {
                          r += p;
                        }

                        for (l = r; l < m; l += p) {
                          f.push({
                            value: l,
                            move: "in"
                          }), f.push({
                            value: l + b.to - b.from,
                            move: "out",
                            size: b.breakSize
                          });
                        }
                      }
                    });
                    f.sort(function (b, a) {
                      return b.value === a.value ? ("in" === b.move ? 0 : 1) - ("in" === a.move ? 0 : 1) : b.value - a.value;
                    });
                    var q = 0;
                    var r = k;
                    f.forEach(function (a) {
                      q += "in" === a.move ? 1 : -1;
                      1 === q && "in" === a.move && (r = a.value);
                      0 === q && I(r) && (b.push({
                        from: r,
                        to: a.value,
                        len: a.value - r - (a.size || 0)
                      }), h += a.value - r - (a.size || 0));
                    });
                    e.breakArray = b;
                    I(k) && I(m) && I(g.min) && (e.unitLength = m - k - h + d, x(g, "afterBreaks"), g.staticScale ? g.transA = g.staticScale : e.unitLength && (g.transA *= (m - g.min + d) / e.unitLength), d && (g.minPixelPadding = g.transA * (g.minPointOffset || 0)), g.min = k, g.max = m);
                  }
                });
                A(d, !0) && g.chart.redraw();
              };

              return a;
            }();

            g.Additions = J;
          })(t || (t = {}));

          return t;
        });
        P(g, "masters/modules/broken-axis.src.js", [g["Core/Globals.js"], g["Core/Axis/BrokenAxis.js"]], function (d, g) {
          g.compose(d.Axis, d.Series);
        });
        P(g, "Extensions/DataGrouping.js", [g["Core/Axis/Axis.js"], g["Core/Axis/DateTimeAxis.js"], g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Series/Point.js"], g["Core/Series/Series.js"], g["Core/Tooltip.js"], g["Core/DefaultOptions.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I, A, t) {
          var q = B.format,
              c = G.prototype;
          B = t.addEvent;
          var l = t.arrayMax,
              a = t.arrayMin,
              k = t.correctFloat,
              v = t.defined,
              m = t.error,
              C = t.extend,
              F = t.isNumber,
              L = t.merge,
              J = t.pick;
          "";
          var y = E.approximations = {
            sum: function sum(a) {
              var c = a.length;
              if (!c && a.hasNulls) var b = null;else if (c) for (b = 0; c--;) {
                b += a[c];
              }
              return b;
            },
            average: function average(a) {
              var c = a.length;
              a = y.sum(a);
              F(a) && c && (a = k(a / c));
              return a;
            },
            averages: function averages() {
              var a = [];
              [].forEach.call(arguments, function (c) {
                a.push(y.average(c));
              });
              return "undefined" === typeof a[0] ? void 0 : a;
            },
            open: function open(a) {
              return a.length ? a[0] : a.hasNulls ? null : void 0;
            },
            high: function high(a) {
              return a.length ? l(a) : a.hasNulls ? null : void 0;
            },
            low: function low(c) {
              return c.length ? a(c) : c.hasNulls ? null : void 0;
            },
            close: function close(a) {
              return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;
            },
            hlc: function hlc(a, c, b) {
              a = y.high(a);
              c = y.low(c);
              b = y.close(b);
              if (F(a) || F(c) || F(b)) return [a, c, b];
            },
            ohlc: function ohlc(a, c, b, e) {
              a = y.open(a);
              c = y.high(c);
              b = y.low(b);
              e = y.close(e);
              if (F(a) || F(c) || F(b) || F(e)) return [a, c, b, e];
            },
            range: function range(a, c) {
              a = y.low(a);
              c = y.high(c);
              if (F(a) || F(c)) return [a, c];
              if (null === a && null === c) return null;
            }
          };

          t = function t(a, c, b, e) {
            var f = this,
                d = f.data,
                h = f.options && f.options.data,
                g = [],
                k = [],
                m = [],
                n = a.length,
                l = !!c,
                q = [],
                r = f.pointArrayMap,
                t = r && r.length,
                w = ["x"].concat(r || ["y"]),
                D = this.options.dataGrouping && this.options.dataGrouping.groupAll,
                x = 0,
                z = 0,
                A;
            e = "function" === typeof e ? e : y[e] ? y[e] : y[f.getDGApproximation && f.getDGApproximation() || "average"];
            t ? r.forEach(function () {
              q.push([]);
            }) : q.push([]);
            var B = t || 1;

            for (A = 0; A <= n && !(a[A] >= b[0]); A++) {
              ;
            }

            for (A; A <= n; A++) {
              for (; "undefined" !== typeof b[x + 1] && a[A] >= b[x + 1] || A === n;) {
                var C = b[x];
                f.dataGroupInfo = {
                  start: D ? z : f.cropStart + z,
                  length: q[0].length
                };
                var E = e.apply(f, q);
                f.pointClass && !v(f.dataGroupInfo.options) && (f.dataGroupInfo.options = L(f.pointClass.prototype.optionsToObject.call({
                  series: f
                }, f.options.data[f.cropStart + z])), w.forEach(function (b) {
                  delete f.dataGroupInfo.options[b];
                }));
                "undefined" !== typeof E && (g.push(C), k.push(E), m.push(f.dataGroupInfo));
                z = A;

                for (C = 0; C < B; C++) {
                  q[C].length = 0, q[C].hasNulls = !1;
                }

                x += 1;
                if (A === n) break;
              }

              if (A === n) break;

              if (r) {
                C = f.options.dataGrouping && f.options.dataGrouping.groupAll ? A : f.cropStart + A;
                E = d && d[C] || f.pointClass.prototype.applyOptions.apply({
                  series: f
                }, [h[C]]);
                var G = void 0;

                for (C = 0; C < t; C++) {
                  G = E[r[C]], F(G) ? q[C].push(G) : null === G && (q[C].hasNulls = !0);
                }
              } else C = l ? c[A] : null, F(C) ? q[0].push(C) : null === C && (q[0].hasNulls = !0);
            }

            return {
              groupedXData: g,
              groupedYData: k,
              groupMap: m
            };
          };

          var z = {
            approximations: y,
            groupData: t
          },
              w = c.generatePoints,
              e = {
            groupPixelWidth: 2,
            dateTimeLabelFormats: {
              millisecond: ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"],
              second: ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"],
              minute: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
              hour: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
              day: ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
              week: ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
              month: ["%B %Y", "%B", "-%B %Y"],
              year: ["%Y", "%Y", "-%Y"]
            }
          },
              r = {
            line: {},
            spline: {},
            area: {},
            areaspline: {},
            arearange: {},
            column: {
              groupPixelWidth: 10
            },
            columnrange: {
              groupPixelWidth: 10
            },
            candlestick: {
              groupPixelWidth: 10
            },
            ohlc: {
              groupPixelWidth: 5
            },
            hlc: {
              groupPixelWidth: 5
            },
            heikinashi: {
              groupPixelWidth: 10
            }
          },
              h = E.defaultDataGroupingUnits = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]];

          c.getDGApproximation = function () {
            return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") ? "sum" : "average";
          };

          c.groupData = t;

          c.applyGrouping = function (a) {
            var e = this.chart,
                b = this.options.dataGrouping,
                d = !1 !== this.allowDG && b && J(b.enabled, e.options.isStock),
                k = this.visible || !e.options.chart.ignoreHiddenSeries,
                p,
                n = this.currentDataGrouping,
                l = !1;
            d && !this.requireSorting && (this.requireSorting = l = !0);
            a = !1 === !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !a) || !d;
            l && (this.requireSorting = !1);

            if (!a) {
              this.destroyGroupedData();
              d = b.groupAll ? this.xData : this.processedXData;
              var q = b.groupAll ? this.yData : this.processedYData;
              a = e.plotSizeX;
              l = this.xAxis;
              var r = l.options.ordinal,
                  t = this.groupPixelWidth;

              if (t && d && d.length) {
                this.isDirty = p = !0;
                this.points = null;
                var w = l.getExtremes();
                var y = w.min;
                w = w.max;
                r = r && l.ordinal && l.ordinal.getGroupIntervalFactor(y, w, this) || 1;
                a = l.getTimeTicks(g.Additions.prototype.normalizeTimeTickInterval(t * (w - y) / a * r, b.units || h), Math.min(y, d[0]), Math.max(w, d[d.length - 1]), l.options.startOfWeek, d, this.closestPointRange);
                t = c.groupData.apply(this, [d, q, a, b.approximation]);
                d = t.groupedXData;
                q = t.groupedYData;
                r = 0;
                b && b.smoothed && d.length && (b.firstAnchor = "firstPoint", b.anchor = "middle", b.lastAnchor = "lastPoint", m(32, !1, e, {
                  "dataGrouping.smoothed": "use dataGrouping.anchor"
                }));
                e = d;
                var x = this.options.dataGrouping;
                y = this.currentDataGrouping && this.currentDataGrouping.gapSize;

                if (x && this.xData && y && this.groupMap) {
                  var z = e.length - 1;
                  var A = x.anchor;
                  var B = J(x.firstAnchor, A);
                  x = J(x.lastAnchor, A);

                  if (A && "start" !== A) {
                    var C = y * {
                      middle: .5,
                      end: 1
                    }[A];

                    for (A = e.length - 1; A-- && 0 < A;) {
                      e[A] += C;
                    }
                  }

                  if (B && "start" !== B && this.xData[0] >= e[0]) {
                    A = this.groupMap[0].start;
                    C = this.groupMap[0].length;
                    var E = void 0;
                    F(A) && F(C) && (E = A + (C - 1));
                    e[0] = {
                      middle: e[0] + .5 * y,
                      end: e[0] + y,
                      firstPoint: this.xData[0],
                      lastPoint: E && this.xData[E]
                    }[B];
                  }

                  x && "start" !== x && y && e[z] >= w - y && (w = this.groupMap[this.groupMap.length - 1].start, e[z] = {
                    middle: e[z] + .5 * y,
                    end: e[z] + y,
                    firstPoint: w && this.xData[w],
                    lastPoint: this.xData[this.xData.length - 1]
                  }[x]);
                }

                for (w = 1; w < a.length; w++) {
                  a.info.segmentStarts && -1 !== a.info.segmentStarts.indexOf(w) || (r = Math.max(a[w] - a[w - 1], r));
                }

                w = a.info;
                w.gapSize = r;
                this.closestPointRange = a.info.totalRange;
                this.groupMap = t.groupMap;

                if (k) {
                  k = d;

                  if (v(k[0]) && F(l.min) && F(l.dataMin) && k[0] < l.min) {
                    if (!v(l.options.min) && l.min <= l.dataMin || l.min === l.dataMin) l.min = Math.min(k[0], l.min);
                    l.dataMin = Math.min(k[0], l.dataMin);
                  }

                  if (v(k[k.length - 1]) && F(l.max) && F(l.dataMax) && k[k.length - 1] > l.max) {
                    if (!v(l.options.max) && F(l.dataMax) && l.max >= l.dataMax || l.max === l.dataMax) l.max = Math.max(k[k.length - 1], l.max);
                    l.dataMax = Math.max(k[k.length - 1], l.dataMax);
                  }
                }

                b.groupAll && (this.allGroupedData = q, b = this.cropData(d, q, l.min, l.max, 1), d = b.xData, q = b.yData, this.cropStart = b.start);
                this.processedXData = d;
                this.processedYData = q;
              } else this.groupMap = null;

              this.hasGroupedData = p;
              this.currentDataGrouping = w;
              this.preventGraphAnimation = (n && n.totalRange) !== (w && w.totalRange);
            }
          };

          c.destroyGroupedData = function () {
            this.groupedData && (this.groupedData.forEach(function (a, c) {
              a && (this.groupedData[c] = a.destroy ? a.destroy() : null);
            }, this), this.groupedData.length = 0);
          };

          c.generatePoints = function () {
            w.apply(this);
            this.destroyGroupedData();
            this.groupedData = this.hasGroupedData ? this.points : null;
          };

          d.prototype.applyGrouping = function (a) {
            var c = this,
                b = c.series;
            b.forEach(function (b) {
              b.groupPixelWidth = void 0;
            });
            b.forEach(function (b) {
              b.groupPixelWidth = c.getGroupPixelWidth && c.getGroupPixelWidth();
              b.groupPixelWidth && (b.hasProcessed = !0);
              b.applyGrouping(!!a.hasExtemesChanged);
            });
          };

          d.prototype.getGroupPixelWidth = function () {
            var a = this.series,
                c = a.length,
                b,
                d = 0,
                h = !1,
                g;

            for (b = c; b--;) {
              (g = a[b].options.dataGrouping) && (d = Math.max(d, J(g.groupPixelWidth, e.groupPixelWidth)));
            }

            for (b = c; b--;) {
              if (g = a[b].options.dataGrouping) if (c = (a[b].processedXData || a[b].data).length, a[b].groupPixelWidth || c > this.chart.plotSizeX / d || c && g.forced) h = !0;
            }

            return h ? d : 0;
          };

          d.prototype.setDataGrouping = function (a, c) {
            var b;
            c = J(c, !0);
            a || (a = {
              forced: !1,
              units: null
            });
            if (this instanceof d) for (b = this.series.length; b--;) {
              this.series[b].update({
                dataGrouping: a
              }, !1);
            } else this.chart.options.series.forEach(function (b) {
              b.dataGrouping = "boolean" === typeof a ? a : L(a, b.dataGrouping);
            });
            this.ordinal && (this.ordinal.slope = void 0);
            c && this.chart.redraw();
          };

          B(d, "postProcessData", d.prototype.applyGrouping);
          B(x, "update", function () {
            if (this.dataGroup) return m(24, !1, this.series.chart), !1;
          });
          B(I, "headerFormatter", function (a) {
            var c = this.chart,
                b = c.time,
                d = a.labelConfig,
                h = d.series,
                g = h.tooltipOptions,
                k = h.options.dataGrouping,
                m = g.xDateFormat,
                l = h.xAxis,
                n = g[a.isFooter ? "footerFormat" : "headerFormat"];

            if (l && "datetime" === l.options.type && k && F(d.key)) {
              var r = h.currentDataGrouping;
              k = k.dateTimeLabelFormats || e.dateTimeLabelFormats;
              if (r) {
                if (g = k[r.unitName], 1 === r.count) m = g[0];else {
                  m = g[1];
                  var t = g[2];
                }
              } else !m && k && l.dateTime && (m = l.dateTime.getXDateFormat(d.x, g.dateTimeLabelFormats));
              m = b.dateFormat(m, d.key);
              t && (m += b.dateFormat(t, d.key + r.totalRange - 1));
              h.chart.styledMode && (n = this.styledModeFormat(n));
              a.text = q(n, {
                point: C(d.point, {
                  key: m
                }),
                series: h
              }, c);
              a.preventDefault();
            }
          });
          B(G, "destroy", c.destroyGroupedData);
          B(G, "afterSetOptions", function (a) {
            a = a.options;
            var c = this.type,
                b = this.chart.options.plotOptions,
                d = A.defaultOptions.plotOptions[c].dataGrouping,
                h = this.useCommonDataGrouping && e;

            if (b && (r[c] || h)) {
              d || (d = L(e, r[c]));
              var g = this.chart.rangeSelector;
              a.dataGrouping = L(h, d, b.series && b.series.dataGrouping, b[c].dataGrouping, this.userOptions.dataGrouping, !a.isInternal && g && F(g.selected) && g.buttonOptions[g.selected].dataGrouping);
            }
          });
          B(d, "afterSetScale", function () {
            this.series.forEach(function (a) {
              a.hasProcessed = !1;
            });
          });
          E.dataGrouping = z;
          "";
          return z;
        });
        P(g, "Series/HLC/HLCPoint.js", [g["Core/Series/SeriesRegistry.js"]], function (d) {
          var g = this && this.__extends || function () {
            var _d7 = function d(g, x) {
              _d7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, g) {
                d.__proto__ = g;
              } || function (d, g) {
                for (var x in g) {
                  g.hasOwnProperty(x) && (d[x] = g[x]);
                }
              };

              return _d7(g, x);
            };

            return function (g, x) {
              function B() {
                this.constructor = g;
              }

              _d7(g, x);

              g.prototype = null === x ? Object.create(x) : (B.prototype = x.prototype, new B());
            };
          }();

          return function (d) {
            function B() {
              var g = null !== d && d.apply(this, arguments) || this;
              g.close = void 0;
              g.high = void 0;
              g.low = void 0;
              g.options = void 0;
              g.plotClose = void 0;
              g.series = void 0;
              return g;
            }

            g(B, d);
            return B;
          }(d.seriesTypes.column.prototype.pointClass);
        });
        P(g, "Series/HLC/HLCSeries.js", [g["Series/HLC/HLCPoint.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = this && this.__extends || function () {
            var _d8 = function d(g, q) {
              _d8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, d) {
                c.__proto__ = d;
              } || function (c, d) {
                for (var a in d) {
                  d.hasOwnProperty(a) && (c[a] = d[a]);
                }
              };

              return _d8(g, q);
            };

            return function (g, q) {
              function c() {
                this.constructor = g;
              }

              _d8(g, q);

              g.prototype = null === q ? Object.create(q) : (c.prototype = q.prototype, new c());
            };
          }(),
              x = g.seriesTypes.column,
              G = B.extend,
              I = B.merge;

          B = function (d) {
            function g() {
              var g = null !== d && d.apply(this, arguments) || this;
              g.data = void 0;
              g.options = void 0;
              g.points = void 0;
              g.yData = void 0;
              return g;
            }

            C(g, d);

            g.prototype.extendStem = function (d, c, g) {
              var a = d[0];
              d = d[1];
              "number" === typeof a[2] && (a[2] = Math.max(g + c, a[2]));
              "number" === typeof d[2] && (d[2] = Math.min(g - c, d[2]));
            };

            g.prototype.getPointPath = function (d, c) {
              c = c.strokeWidth();
              var g = d.series,
                  a = c % 2 / 2,
                  k = Math.round(d.plotX) - a,
                  q = Math.round(d.shapeArgs.width / 2);
              var m = [["M", k, Math.round(d.yBottom)], ["L", k, Math.round(d.plotHigh)]];
              null !== d.close && (d = Math.round(d.plotClose) + a, m.push(["M", k, d], ["L", k + q, d]), g.extendStem(m, c / 2, d));
              return m;
            };

            g.prototype.drawSinglePoint = function (d) {
              var c = d.series,
                  g = c.chart,
                  a = d.graphic,
                  k = !a;
              "undefined" !== typeof d.plotY && (a || (d.graphic = a = g.renderer.path().add(c.group)), g.styledMode || a.attr(c.pointAttribs(d, d.selected && "select")), c = c.getPointPath(d, a), a[k ? "attr" : "animate"]({
                d: c
              }).addClass(d.getClassName(), !0));
            };

            g.prototype.drawPoints = function () {
              this.points.forEach(this.drawSinglePoint);
            };

            g.prototype.init = function () {
              d.prototype.init.apply(this, arguments);
              this.options.stacking = void 0;
            };

            g.prototype.pointAttribs = function (g, c) {
              g = d.prototype.pointAttribs.call(this, g, c);
              delete g.fill;
              return g;
            };

            g.prototype.toYData = function (d) {
              return [d.high, d.low, d.close];
            };

            g.prototype.translate = function () {
              var g = this,
                  c = g.yAxis,
                  l = this.pointArrayMap && this.pointArrayMap.slice() || [],
                  a = l.map(function (a) {
                return "plot".concat(a.charAt(0).toUpperCase() + a.slice(1));
              });
              a.push("yBottom");
              l.push("low");
              d.prototype.translate.apply(g);
              g.points.forEach(function (d) {
                l.forEach(function (k, m) {
                  k = d[k];
                  null !== k && (g.dataModify && (k = g.dataModify.modifyValue(k)), d[a[m]] = c.toPixels(k, !0));
                });
                d.tooltipPos[1] = d.plotHigh + c.pos - g.chart.plotTop;
              });
            };

            g.defaultOptions = I(x.defaultOptions, {
              lineWidth: 1,
              tooltip: {
                pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>"
              },
              threshold: null,
              states: {
                hover: {
                  lineWidth: 3
                }
              },
              stickyTracking: !0
            });
            return g;
          }(x);

          G(B.prototype, {
            animate: null,
            directTouch: !1,
            pointArrayMap: ["high", "low", "close"],
            pointAttrToOptions: {
              stroke: "color",
              "stroke-width": "lineWidth"
            },
            pointValKey: "close"
          });
          B.prototype.pointClass = d;
          g.registerSeriesType("hlc", B);
          "";
          return B;
        });
        P(g, "Series/OHLC/OHLCPoint.js", [g["Core/Series/SeriesRegistry.js"]], function (d) {
          var g = this && this.__extends || function () {
            var _d9 = function d(g, x) {
              _d9 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, g) {
                d.__proto__ = g;
              } || function (d, g) {
                for (var x in g) {
                  g.hasOwnProperty(x) && (d[x] = g[x]);
                }
              };

              return _d9(g, x);
            };

            return function (g, x) {
              function B() {
                this.constructor = g;
              }

              _d9(g, x);

              g.prototype = null === x ? Object.create(x) : (B.prototype = x.prototype, new B());
            };
          }();

          return function (d) {
            function B() {
              var g = null !== d && d.apply(this, arguments) || this;
              g.open = void 0;
              g.options = void 0;
              g.plotOpen = void 0;
              g.series = void 0;
              return g;
            }

            g(B, d);

            B.prototype.getClassName = function () {
              return d.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
            };

            B.prototype.resolveUpColor = function () {
              this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
            };

            B.prototype.resolveColor = function () {
              d.prototype.resolveColor.call(this);
              this.resolveUpColor();
            };

            B.prototype.getZone = function () {
              var g = d.prototype.getZone.call(this);
              this.resolveUpColor();
              return g;
            };

            B.prototype.applyOptions = function () {
              d.prototype.applyOptions.apply(this, arguments);
              this.resolveColor && this.resolveColor();
              return this;
            };

            return B;
          }(d.seriesTypes.hlc.prototype.pointClass);
        });
        P(g, "Series/OHLC/OHLCSeries.js", [g["Series/OHLC/OHLCPoint.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = this && this.__extends || function () {
            var _c3 = function c(d, a) {
              _c3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _c3(d, a);
            };

            return function (d, a) {
              function g() {
                this.constructor = d;
              }

              _c3(d, a);

              d.prototype = null === a ? Object.create(a) : (g.prototype = a.prototype, new g());
            };
          }(),
              x = g.series,
              G = g.seriesTypes.hlc,
              I = B.addEvent,
              A = B.extend,
              t = B.merge,
              q = function (c) {
            function d() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            C(d, c);

            d.prototype.getPointPath = function (a, d) {
              var g = c.prototype.getPointPath.call(this, a, d);
              d = d.strokeWidth();
              var k = d % 2 / 2,
                  l = Math.round(a.plotX) - k,
                  q = Math.round(a.shapeArgs.width / 2);
              null !== a.open && (a = Math.round(a.plotOpen) + k, g.push(["M", l, a], ["L", l - q, a]), c.prototype.extendStem.call(this, g, d / 2, a));
              return g;
            };

            d.prototype.pointAttribs = function (a, d) {
              d = c.prototype.pointAttribs.call(this, a, d);
              var g = this.options;
              delete d.fill;
              !a.options.color && g.upColor && a.open < a.close && (d.stroke = g.upColor);
              return d;
            };

            d.prototype.toYData = function (a) {
              return [a.open, a.high, a.low, a.close];
            };

            d.defaultOptions = t(G.defaultOptions, {
              tooltip: {
                pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>"
              }
            });
            return d;
          }(G);

          A(q.prototype, {
            pointArrayMap: ["open", "high", "low", "close"]
          });
          q.prototype.pointClass = d;
          g.registerSeriesType("ohlc", q);
          I(x, "init", function (c) {
            c = c.options;
            c.useOhlcData && "highcharts-navigator-series" !== c.id && A(this, {
              pointValKey: q.prototype.pointValKey,
              pointArrayMap: q.prototype.pointArrayMap,
              toYData: q.prototype.toYData
            });
          });
          I(x, "afterSetOptions", function (c) {
            c = c.options;
            var d = c.dataGrouping;
            d && c.useOhlcData && "highcharts-navigator-series" !== c.id && (d.approximation = "ohlc");
          });
          "";
          return q;
        });
        P(g, "Series/Candlestick/CandlestickSeries.js", [g["Core/DefaultOptions.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = this && this.__extends || function () {
            var _d10 = function d(g, c) {
              _d10 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, a) {
                c.__proto__ = a;
              } || function (c, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (c[d] = a[d]);
                }
              };

              return _d10(g, c);
            };

            return function (g, c) {
              function l() {
                this.constructor = g;
              }

              _d10(g, c);

              g.prototype = null === c ? Object.create(c) : (l.prototype = c.prototype, new l());
            };
          }(),
              x = d.defaultOptions;

          d = g.seriesTypes;
          var G = d.column,
              I = d.ohlc,
              A = B.merge;

          B = function (d) {
            function g() {
              var c = null !== d && d.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            C(g, d);

            g.prototype.pointAttribs = function (c, d) {
              var a = G.prototype.pointAttribs.call(this, c, d),
                  g = this.options,
                  l = c.open < c.close,
                  m = g.lineColor || this.color,
                  q = c.color || this.color;
              a["stroke-width"] = g.lineWidth;
              a.fill = c.options.color || (l ? g.upColor || q : q);
              a.stroke = c.options.lineColor || (l ? g.upLineColor || m : m);
              d && (c = g.states[d], a.fill = c.color || a.fill, a.stroke = c.lineColor || a.stroke, a["stroke-width"] = c.lineWidth || a["stroke-width"]);
              return a;
            };

            g.prototype.drawPoints = function () {
              var c = this,
                  d = c.chart,
                  a = c.yAxis.reversed;
              c.points.forEach(function (g) {
                var k = g.graphic,
                    m = !k;

                if ("undefined" !== typeof g.plotY) {
                  k || (g.graphic = k = d.renderer.path().add(c.group));
                  c.chart.styledMode || k.attr(c.pointAttribs(g, g.selected && "select")).shadow(c.options.shadow);
                  var l = k.strokeWidth() % 2 / 2;
                  var q = Math.round(g.plotX) - l;
                  var t = g.plotOpen;
                  var x = g.plotClose;
                  var y = Math.min(t, x);
                  t = Math.max(t, x);
                  var z = Math.round(g.shapeArgs.width / 2);
                  x = a ? t !== g.yBottom : Math.round(y) !== Math.round(g.plotHigh);
                  var w = a ? Math.round(y) !== Math.round(g.plotHigh) : t !== g.yBottom;
                  y = Math.round(y) + l;
                  t = Math.round(t) + l;
                  l = [];
                  l.push(["M", q - z, t], ["L", q - z, y], ["L", q + z, y], ["L", q + z, t], ["Z"], ["M", q, y], ["L", q, x ? Math.round(a ? g.yBottom : g.plotHigh) : y], ["M", q, t], ["L", q, w ? Math.round(a ? g.plotHigh : g.yBottom) : t]);
                  k[m ? "attr" : "animate"]({
                    d: l
                  }).addClass(g.getClassName(), !0);
                }
              });
            };

            g.defaultOptions = A(I.defaultOptions, x.plotOptions, {
              states: {
                hover: {
                  lineWidth: 2
                }
              },
              tooltip: x.plotOptions.ohlc.tooltip,
              threshold: null,
              lineColor: "#000000",
              lineWidth: 1,
              upColor: "#ffffff",
              stickyTracking: !0
            });
            return g;
          }(I);

          g.registerSeriesType("candlestick", B);
          "";
          return B;
        });
        P(g, "Series/Flags/FlagsPoint.js", [g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g) {
          var B = this && this.__extends || function () {
            var _d11 = function d(g, x) {
              _d11 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, g) {
                d.__proto__ = g;
              } || function (d, g) {
                for (var q in g) {
                  g.hasOwnProperty(q) && (d[q] = g[q]);
                }
              };

              return _d11(g, x);
            };

            return function (g, x) {
              function A() {
                this.constructor = g;
              }

              _d11(g, x);

              g.prototype = null === x ? Object.create(x) : (A.prototype = x.prototype, new A());
            };
          }(),
              C = g.isNumber;

          return function (d) {
            function g() {
              var g = null !== d && d.apply(this, arguments) || this;
              g.options = void 0;
              g.series = void 0;
              g.ttBelow = !1;
              return g;
            }

            B(g, d);

            g.prototype.isValid = function () {
              return C(this.y) || "undefined" === typeof this.y;
            };

            g.prototype.hasNewShapeType = function () {
              var d = this.options.shape || this.series.options.shape;
              return this.graphic && d && d !== this.graphic.symbolKey;
            };

            return g;
          }(d.seriesTypes.column.prototype.pointClass);
        });
        P(g, "Series/OnSeriesComposition.js", [g["Series/Column/ColumnSeries.js"], g["Core/Series/Series.js"], g["Core/Utilities.js"]], function (d, g, B) {
          var C = d.prototype,
              x = g.prototype,
              G = B.defined,
              I = B.stableSort,
              A;

          (function (d) {
            function g() {
              return x.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);
            }

            function c() {
              C.translate.apply(this);
              var a = this,
                  c = a.options,
                  d = a.chart,
                  g = a.points,
                  l = c.onSeries,
                  q = (l = l && d.get(l)) && l.options.step,
                  t = l && l.points,
                  x = d.inverted,
                  y = a.xAxis,
                  z = a.yAxis;
              d = g.length - 1;
              var w;
              c = c.onKey || "y";
              var e = t && t.length,
                  r = 0,
                  h;

              if (l && l.visible && e) {
                r = (l.pointXOffset || 0) + (l.barW || 0) / 2;
                var n = l.currentDataGrouping;
                var f = t[e - 1].x + (n ? n.totalRange : 0);
                I(g, function (b, a) {
                  return b.x - a.x;
                });

                for (c = "plot" + c[0].toUpperCase() + c.substr(1); e-- && g[d];) {
                  var b = t[e];
                  n = g[d];
                  n.y = b.y;

                  if (b.x <= n.x && "undefined" !== typeof b[c]) {
                    if (n.x <= f && (n.plotY = b[c], b.x < n.x && !q && (h = t[e + 1]) && "undefined" !== typeof h[c])) {
                      var D = (n.x - b.x) / (h.x - b.x);
                      n.plotY += D * (h[c] - b[c]);
                      n.y += D * (h.y - b.y);
                    }

                    d--;
                    e++;
                    if (0 > d) break;
                  }
                }
              }

              g.forEach(function (b, c) {
                b.plotX += r;
                if ("undefined" === typeof b.plotY || x) 0 <= b.plotX && b.plotX <= y.len ? x ? (b.plotY = y.translate(b.x, 0, 1, 0, 1), b.plotX = G(b.y) ? z.translate(b.y, 0, 0, 0, 1) : 0) : b.plotY = (y.opposite ? 0 : a.yAxis.len) + y.offset : b.shapeArgs = {};

                if ((w = g[c - 1]) && w.plotX === b.plotX) {
                  "undefined" === typeof w.stackIndex && (w.stackIndex = 0);
                  var e = w.stackIndex + 1;
                }

                b.stackIndex = e;
              });
              this.onSeries = l;
            }

            var l = [];

            d.compose = function (a) {
              if (-1 === l.indexOf(a)) {
                l.push(a);
                var d = a.prototype;
                d.getPlotBox = g;
                d.translate = c;
              }

              return a;
            };

            d.getPlotBox = g;
            d.translate = c;
          })(A || (A = {}));

          return A;
        });
        P(g, "Series/Flags/FlagsSymbols.js", [g["Core/Renderer/RendererRegistry.js"], g["Core/Renderer/SVG/SVGRenderer.js"]], function (d, g) {
          function B(d) {
            C[d + "pin"] = function (g, x, A, t, q) {
              var c = q && q.anchorX;
              q = q && q.anchorY;
              "circle" === d && t > A && (g -= Math.round((t - A) / 2), A = t);
              var l = C[d](g, x, A, t);

              if (c && q) {
                var a = c;
                "circle" === d ? a = g + A / 2 : (g = l[0], A = l[1], "M" === g[0] && "L" === A[0] && (a = (g[1] + A[1]) / 2));
                l.push(["M", a, x > q ? x : x + t], ["L", c, q]);
                l = l.concat(C.circle(c - 1, q - 1, 2, 2));
              }

              return l;
            };
          }

          var C = g.prototype.symbols;

          C.flag = function (d, g, B, A, t) {
            var q = t && t.anchorX || d;
            t = t && t.anchorY || g;
            var c = C.circle(q - 1, t - 1, 2, 2);
            c.push(["M", q, t], ["L", d, g + A], ["L", d, g], ["L", d + B, g], ["L", d + B, g + A], ["L", d, g + A], ["Z"]);
            return c;
          };

          B("circle");
          B("square");
          d = d.getRendererType();
          d !== g && (d.prototype.symbols.circlepin = C.circlepin, d.prototype.symbols.flag = C.flag, d.prototype.symbols.squarepin = C.squarepin);
          return C;
        });
        P(g, "Series/Flags/FlagsSeries.js", [g["Series/Flags/FlagsPoint.js"], g["Core/Globals.js"], g["Series/OnSeriesComposition.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I) {
          var A = this && this.__extends || function () {
            var _a7 = function a(c, d) {
              _a7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _a7(c, d);
            };

            return function (c, d) {
              function g() {
                this.constructor = c;
              }

              _a7(c, d);

              c.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }();

          g = g.noop;
          var t = E.distribute,
              q = x.series,
              c = x.seriesTypes.column,
              l = I.addEvent,
              a = I.defined;
          E = I.extend;
          var k = I.merge,
              v = I.objectEach,
              m = I.wrap;

          I = function (d) {
            function g() {
              var a = null !== d && d.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            A(g, d);

            g.prototype.animate = function (a) {
              a && this.setClip();
            };

            g.prototype.drawPoints = function () {
              var c = this.points,
                  d = this.chart,
                  g = d.renderer,
                  l = d.inverted,
                  q = this.options,
                  e = q.y,
                  r,
                  h = this.yAxis,
                  n = {},
                  f = [];

              for (r = c.length; r--;) {
                var b = c[r];
                var x = (l ? b.plotY : b.plotX) > this.xAxis.len;
                var H = b.plotX;
                var p = b.stackIndex;
                var u = b.options.shape || q.shape;
                var K = b.plotY;
                "undefined" !== typeof K && (K = b.plotY + e - ("undefined" !== typeof p && p * q.stackDistance));
                b.anchorX = p ? void 0 : b.plotX;
                var A = p ? void 0 : b.plotY;
                var B = "flag" !== u;
                p = b.graphic;
                "undefined" !== typeof K && 0 <= H && !x ? (p && b.hasNewShapeType() && (p = p.destroy()), p || (p = b.graphic = g.label("", null, null, u, null, null, q.useHTML).addClass("highcharts-point").add(this.markerGroup), b.graphic.div && (b.graphic.div.point = b), p.isNew = !0), p.attr({
                  align: B ? "center" : "left",
                  width: q.width,
                  height: q.height,
                  "text-align": q.textAlign
                }), d.styledMode || p.attr(this.pointAttribs(b)).css(k(q.style, b.style)).shadow(q.shadow), 0 < H && (H -= p.strokeWidth() % 2), u = {
                  y: K,
                  anchorY: A
                }, q.allowOverlapX && (u.x = H, u.anchorX = b.anchorX), p.attr({
                  text: b.options.title || q.title || "A"
                })[p.isNew ? "attr" : "animate"](u), q.allowOverlapX || (n[b.plotX] ? n[b.plotX].size = Math.max(n[b.plotX].size, p.width) : n[b.plotX] = {
                  align: B ? .5 : 0,
                  size: p.width,
                  target: H,
                  anchorX: H
                }), b.tooltipPos = [H, K + h.pos - d.plotTop]) : p && (b.graphic = p.destroy());
              }

              if (!q.allowOverlapX) {
                var C = 100;
                v(n, function (b) {
                  b.plotX = b.anchorX;
                  f.push(b);
                  C = Math.max(b.size, C);
                });
                t(f, l ? h.len : this.xAxis.len, C);
                c.forEach(function (b) {
                  var c = b.plotX,
                      e = b.graphic;
                  (c = e && n[c]) && e && (a(c.pos) ? e[e.isNew ? "attr" : "animate"]({
                    x: c.pos + (c.align || 0) * c.size,
                    anchorX: b.anchorX
                  }).show().isNew = !1 : e.hide().isNew = !0);
                });
              }

              q.useHTML && m(this.markerGroup, "on", function (b) {
                return G.prototype.on.apply(b.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
              });
            };

            g.prototype.drawTracker = function () {
              var a = this.points;
              d.prototype.drawTracker.call(this);
              a.forEach(function (c) {
                var d = c.graphic;
                d && (c.unbindMouseOver && c.unbindMouseOver(), c.unbindMouseOver = l(d.element, "mouseover", function () {
                  0 < c.stackIndex && !c.raised && (c._y = d.y, d.attr({
                    y: c._y - 8
                  }), c.raised = !0);
                  a.forEach(function (a) {
                    a !== c && a.raised && a.graphic && (a.graphic.attr({
                      y: a._y
                    }), a.raised = !1);
                  });
                }));
              });
            };

            g.prototype.pointAttribs = function (a, c) {
              var d = this.options,
                  g = a && a.color || this.color,
                  k = d.lineColor,
                  e = a && a.lineWidth;
              a = a && a.fillColor || d.fillColor;
              c && (a = d.states[c].fillColor, k = d.states[c].lineColor, e = d.states[c].lineWidth);
              return {
                fill: a || g,
                stroke: k || g,
                "stroke-width": e || d.lineWidth || 0
              };
            };

            g.prototype.setClip = function () {
              q.prototype.setClip.apply(this, arguments);
              !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
            };

            g.defaultOptions = k(c.defaultOptions, {
              pointRange: 0,
              allowOverlapX: !1,
              shape: "flag",
              stackDistance: 12,
              textAlign: "center",
              tooltip: {
                pointFormat: "{point.text}"
              },
              threshold: null,
              y: -30,
              fillColor: "#ffffff",
              lineWidth: 1,
              states: {
                hover: {
                  lineColor: "#000000",
                  fillColor: "#ccd6eb"
                }
              },
              style: {
                fontSize: "11px",
                fontWeight: "bold"
              }
            });
            return g;
          }(c);

          B.compose(I);
          E(I.prototype, {
            allowDG: !1,
            forceCrop: !0,
            invertible: !1,
            noSharedTooltip: !0,
            pointClass: d,
            sorted: !1,
            takeOrdinalPosition: !1,
            trackerGroups: ["markerGroup"],
            buildKDTree: g,
            init: q.prototype.init,
            invertGroups: g
          });
          x.registerSeriesType("flags", I);
          "";
          "";
          return I;
        });
        P(g, "Core/Axis/ScrollbarAxis.js", [g["Core/Utilities.js"]], function (d) {
          var g = d.addEvent,
              B = d.defined,
              E = d.pick;
          return function () {
            function d() {}

            d.compose = function (x, C) {
              if (-1 === d.composed.indexOf(x)) d.composed.push(x);else return x;

              var A = function A(d) {
                var g = E(d.options && d.options.min, d.min),
                    c = E(d.options && d.options.max, d.max);
                return {
                  axisMin: g,
                  axisMax: c,
                  scrollMin: B(d.dataMin) ? Math.min(g, d.min, d.dataMin, E(d.threshold, Infinity)) : g,
                  scrollMax: B(d.dataMax) ? Math.max(c, d.max, d.dataMax, E(d.threshold, -Infinity)) : c
                };
              };

              g(x, "afterInit", function () {
                var d = this;
                d.options && d.options.scrollbar && d.options.scrollbar.enabled && (d.options.scrollbar.vertical = !d.horiz, d.options.startOnTick = d.options.endOnTick = !1, d.scrollbar = new C(d.chart.renderer, d.options.scrollbar, d.chart), g(d.scrollbar, "changed", function (g) {
                  var c = A(d),
                      l = c.axisMax,
                      a = c.scrollMin,
                      k = c.scrollMax - a;
                  B(c.axisMin) && B(l) && (d.horiz && !d.reversed || !d.horiz && d.reversed ? (c = a + k * this.to, a += k * this.from) : (c = a + k * (1 - this.from), a += k * (1 - this.to)), this.shouldUpdateExtremes(g.DOMType) ? d.setExtremes(a, c, !0, "mousemove" !== g.DOMType && "touchmove" !== g.DOMType, g) : this.setRange(this.from, this.to));
                }));
              });
              g(x, "afterRender", function () {
                var d = A(this),
                    g = d.scrollMin,
                    c = d.scrollMax;
                d = this.scrollbar;
                var l = this.axisTitleMargin + (this.titleOffset || 0),
                    a = this.chart.scrollbarsOffsets,
                    k = this.options.margin || 0;
                d && (this.horiz ? (this.opposite || (a[1] += l), d.position(this.left, this.top + this.height + 2 + a[1] - (this.opposite ? k : 0), this.width, this.height), this.opposite || (a[1] += k), l = 1) : (this.opposite && (a[0] += l), d.position(d.options.opposite ? this.left + this.width + 2 + a[0] - (this.opposite ? 0 : k) : this.opposite ? 0 : k, this.top, this.width, this.height), this.opposite && (a[0] += k), l = 0), a[l] += d.size + d.options.margin, isNaN(g) || isNaN(c) || !B(this.min) || !B(this.max) || this.min === this.max ? d.setRange(0, 1) : (a = (this.min - g) / (c - g), g = (this.max - g) / (c - g), this.horiz && !this.reversed || !this.horiz && this.reversed ? d.setRange(a, g) : d.setRange(1 - g, 1 - a)));
              });
              g(x, "afterGetOffset", function () {
                var d = this.scrollbar && !this.scrollbar.options.opposite;
                d = this.horiz ? 2 : d ? 3 : 1;
                var g = this.scrollbar;
                g && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[d] += g.size + g.options.margin);
              });
              return x;
            };

            d.composed = [];
            return d;
          }();
        });
        P(g, "Core/ScrollbarDefaults.js", [g["Core/Globals.js"]], function (d) {
          return {
            height: d.isTouchDevice ? 20 : 14,
            barBorderRadius: 0,
            buttonBorderRadius: 0,
            liveRedraw: void 0,
            margin: 10,
            minWidth: 6,
            opposite: !0,
            step: .2,
            zIndex: 3,
            barBackgroundColor: "#cccccc",
            barBorderWidth: 1,
            barBorderColor: "#cccccc",
            buttonArrowColor: "#333333",
            buttonBackgroundColor: "#e6e6e6",
            buttonBorderColor: "#cccccc",
            buttonBorderWidth: 1,
            rifleColor: "#333333",
            trackBackgroundColor: "#f2f2f2",
            trackBorderColor: "#f2f2f2",
            trackBorderWidth: 1
          };
        });
        P(g, "Core/Scrollbar.js", [g["Core/DefaultOptions.js"], g["Core/Globals.js"], g["Core/Axis/ScrollbarAxis.js"], g["Core/ScrollbarDefaults.js"], g["Core/Utilities.js"]], function (d, g, B, E, x) {
          var C = d.defaultOptions,
              I = x.addEvent,
              A = x.correctFloat,
              t = x.defined,
              q = x.destroyObjectProperties,
              c = x.fireEvent,
              l = x.merge,
              a = x.pick,
              k = x.removeEvent;

          d = function () {
            function d(a, c, d) {
              this._events = [];
              this.chart = void 0;
              this.from = this.chartY = this.chartX = 0;
              this.scrollbar = this.renderer = this.options = this.group = void 0;
              this.scrollbarButtons = [];
              this.scrollbarGroup = void 0;
              this.scrollbarLeft = 0;
              this.scrollbarRifles = void 0;
              this.scrollbarStrokeWidth = 1;
              this.to = this.size = this.scrollbarTop = 0;
              this.track = void 0;
              this.trackBorderWidth = 1;
              this.userOptions = void 0;
              this.y = this.x = 0;
              this.init(a, c, d);
            }

            d.compose = function (a) {
              B.compose(a, d);
            };

            d.swapXY = function (a, c) {
              c && a.forEach(function (a) {
                for (var c = a.length, d, g = 0; g < c; g += 2) {
                  d = a[g + 1], "number" === typeof d && (a[g + 1] = a[g + 2], a[g + 2] = d);
                }
              });
              return a;
            };

            d.prototype.addEvents = function () {
              var a = this.options.inverted ? [1, 0] : [0, 1],
                  c = this.scrollbarButtons,
                  d = this.scrollbarGroup.element,
                  k = this.track.element,
                  l = this.mouseDownHandler.bind(this),
                  q = this.mouseMoveHandler.bind(this),
                  t = this.mouseUpHandler.bind(this);
              a = [[c[a[0]].element, "click", this.buttonToMinClick.bind(this)], [c[a[1]].element, "click", this.buttonToMaxClick.bind(this)], [k, "click", this.trackClick.bind(this)], [d, "mousedown", l], [d.ownerDocument, "mousemove", q], [d.ownerDocument, "mouseup", t]];
              g.hasTouch && a.push([d, "touchstart", l], [d.ownerDocument, "touchmove", q], [d.ownerDocument, "touchend", t]);
              a.forEach(function (a) {
                I.apply(null, a);
              });
              this._events = a;
            };

            d.prototype.buttonToMaxClick = function (d) {
              var g = (this.to - this.from) * a(this.options.step, .2);
              this.updatePosition(this.from + g, this.to + g);
              c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: d
              });
            };

            d.prototype.buttonToMinClick = function (d) {
              var g = A(this.to - this.from) * a(this.options.step, .2);
              this.updatePosition(A(this.from - g), A(this.to - g));
              c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: d
              });
            };

            d.prototype.cursorToScrollbarPosition = function (a) {
              var c = this.options;
              c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;
              return {
                chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - c),
                chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - c)
              };
            };

            d.prototype.destroy = function () {
              var a = this,
                  c = a.chart.scroller;
              a.removeEvents();
              ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (c) {
                a[c] && a[c].destroy && (a[c] = a[c].destroy());
              });
              c && a === c.scrollbar && (c.scrollbar = null, q(c.scrollbarButtons));
            };

            d.prototype.drawScrollbarButton = function (a) {
              var c = this.renderer,
                  g = this.scrollbarButtons,
                  k = this.options,
                  m = this.size,
                  l = c.g().add(this.group);
              g.push(l);
              l = c.rect().addClass("highcharts-scrollbar-button").add(l);
              this.chart.styledMode || l.attr({
                stroke: k.buttonBorderColor,
                "stroke-width": k.buttonBorderWidth,
                fill: k.buttonBackgroundColor
              });
              l.attr(l.crisp({
                x: -.5,
                y: -.5,
                width: m + 1,
                height: m + 1,
                r: k.buttonBorderRadius
              }, l.strokeWidth()));
              l = c.path(d.swapXY([["M", m / 2 + (a ? -1 : 1), m / 2 - 3], ["L", m / 2 + (a ? -1 : 1), m / 2 + 3], ["L", m / 2 + (a ? 2 : -2), m / 2]], k.vertical)).addClass("highcharts-scrollbar-arrow").add(g[a]);
              this.chart.styledMode || l.attr({
                fill: k.buttonArrowColor
              });
            };

            d.prototype.init = function (c, d, g) {
              this.scrollbarButtons = [];
              this.renderer = c;
              this.userOptions = d;
              this.options = l(E, C.scrollbar, d);
              this.chart = g;
              this.size = a(this.options.size, this.options.height);
              d.enabled && (this.render(), this.addEvents());
            };

            d.prototype.mouseDownHandler = function (a) {
              a = this.chart.pointer.normalize(a);
              a = this.cursorToScrollbarPosition(a);
              this.chartX = a.chartX;
              this.chartY = a.chartY;
              this.initPositions = [this.from, this.to];
              this.grabbedCenter = !0;
            };

            d.prototype.mouseMoveHandler = function (a) {
              var d = this.chart.pointer.normalize(a),
                  g = this.options.vertical ? "chartY" : "chartX",
                  k = this.initPositions || [];
              !this.grabbedCenter || a.touches && 0 === a.touches[0][g] || (d = this.cursorToScrollbarPosition(d)[g], g = this[g], g = d - g, this.hasDragged = !0, this.updatePosition(k[0] + g, k[1] + g), this.hasDragged && c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: a.type,
                DOMEvent: a
              }));
            };

            d.prototype.mouseUpHandler = function (a) {
              this.hasDragged && c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: a.type,
                DOMEvent: a
              });
              this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
            };

            d.prototype.position = function (a, c, d, g) {
              var k = this.options.vertical,
                  m = this.rendered ? "animate" : "attr",
                  l = g,
                  q = 0;
              this.group.show();
              this.x = a;
              this.y = c + this.trackBorderWidth;
              this.width = d;
              this.height = g;
              this.xOffset = l;
              this.yOffset = q;
              k ? (this.width = this.yOffset = d = q = this.size, this.xOffset = l = 0, this.barWidth = g - 2 * d, this.x = a += this.options.margin) : (this.height = this.xOffset = g = l = this.size, this.barWidth = d - 2 * g, this.y += this.options.margin);
              this.group[m]({
                translateX: a,
                translateY: this.y
              });
              this.track[m]({
                width: d,
                height: g
              });
              this.scrollbarButtons[1][m]({
                translateX: k ? 0 : d - l,
                translateY: k ? g - q : 0
              });
            };

            d.prototype.removeEvents = function () {
              this._events.forEach(function (a) {
                k.apply(null, a);
              });

              this._events.length = 0;
            };

            d.prototype.render = function () {
              var a = this.renderer,
                  c = this.options,
                  g = this.size,
                  k = this.chart.styledMode,
                  l = a.g("scrollbar").attr({
                zIndex: c.zIndex
              }).hide().add();
              this.group = l;
              this.track = a.rect().addClass("highcharts-scrollbar-track").attr({
                x: 0,
                r: c.trackBorderRadius || 0,
                height: g,
                width: g
              }).add(l);
              k || this.track.attr({
                fill: c.trackBackgroundColor,
                stroke: c.trackBorderColor,
                "stroke-width": c.trackBorderWidth
              });
              this.trackBorderWidth = this.track.strokeWidth();
              this.track.attr({
                y: -this.trackBorderWidth % 2 / 2
              });
              this.scrollbarGroup = a.g().add(l);
              this.scrollbar = a.rect().addClass("highcharts-scrollbar-thumb").attr({
                height: g,
                width: g,
                r: c.barBorderRadius || 0
              }).add(this.scrollbarGroup);
              this.scrollbarRifles = a.path(d.swapXY([["M", -3, g / 4], ["L", -3, 2 * g / 3], ["M", 0, g / 4], ["L", 0, 2 * g / 3], ["M", 3, g / 4], ["L", 3, 2 * g / 3]], c.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
              k || (this.scrollbar.attr({
                fill: c.barBackgroundColor,
                stroke: c.barBorderColor,
                "stroke-width": c.barBorderWidth
              }), this.scrollbarRifles.attr({
                stroke: c.rifleColor,
                "stroke-width": 1
              }));
              this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
              this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
              this.drawScrollbarButton(0);
              this.drawScrollbarButton(1);
            };

            d.prototype.setRange = function (a, c) {
              var d = this.options,
                  g = d.vertical,
                  k = d.minWidth,
                  l = this.barWidth,
                  m = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";

              if (t(l)) {
                var q = l * Math.min(c, 1);
                a = Math.max(a, 0);
                var e = Math.ceil(l * a);
                this.calculatedWidth = q = A(q - e);
                q < k && (e = (l - k + q) * a, q = k);
                k = Math.floor(e + this.xOffset + this.yOffset);
                l = q / 2 - .5;
                this.from = a;
                this.to = c;
                g ? (this.scrollbarGroup[m]({
                  translateY: k
                }), this.scrollbar[m]({
                  height: q
                }), this.scrollbarRifles[m]({
                  translateY: l
                }), this.scrollbarTop = k, this.scrollbarLeft = 0) : (this.scrollbarGroup[m]({
                  translateX: k
                }), this.scrollbar[m]({
                  width: q
                }), this.scrollbarRifles[m]({
                  translateX: l
                }), this.scrollbarLeft = k, this.scrollbarTop = 0);
                12 >= q ? this.scrollbarRifles.hide() : this.scrollbarRifles.show();
                !1 === d.showFull && (0 >= a && 1 <= c ? this.group.hide() : this.group.show());
                this.rendered = !0;
              }
            };

            d.prototype.shouldUpdateExtremes = function (c) {
              return a(this.options.liveRedraw, g.svg && !g.isTouchDevice && !this.chart.isBoosting) || "mouseup" === c || "touchend" === c || !t(c);
            };

            d.prototype.trackClick = function (a) {
              var d = this.chart.pointer.normalize(a),
                  g = this.to - this.from,
                  k = this.y + this.scrollbarTop,
                  l = this.x + this.scrollbarLeft;
              this.options.vertical && d.chartY > k || !this.options.vertical && d.chartX > l ? this.updatePosition(this.from + g, this.to + g) : this.updatePosition(this.from - g, this.to - g);
              c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: a
              });
            };

            d.prototype.update = function (a) {
              this.destroy();
              this.init(this.chart.renderer, l(!0, this.options, a), this.chart);
            };

            d.prototype.updatePosition = function (a, c) {
              1 < c && (a = A(1 - A(c - a)), c = 1);
              0 > a && (c = A(c - a), a = 0);
              this.from = a;
              this.to = c;
            };

            d.defaultOptions = E;
            return d;
          }();

          C.scrollbar = l(!0, d.defaultOptions, C.scrollbar);
          return d;
        });
        P(g, "Core/Axis/NavigatorAxis.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (d, g) {
          var B = d.isTouchDevice,
              C = g.addEvent,
              x = g.correctFloat,
              G = g.defined,
              I = g.isNumber,
              A = g.pick,
              t = function () {
            function d(c) {
              this.axis = c;
            }

            d.prototype.destroy = function () {
              this.axis = void 0;
            };

            d.prototype.toFixedRange = function (c, d, a, g) {
              var k = this.axis,
                  l = k.chart;
              l = l && l.fixedRange;
              var q = (k.pointRange || 0) / 2;
              c = A(a, k.translate(c, !0, !k.horiz));
              d = A(g, k.translate(d, !0, !k.horiz));
              k = l && (d - c) / l;
              G(a) || (c = x(c + q));
              G(g) || (d = x(d - q));
              .7 < k && 1.3 > k && (g ? c = d - l : d = c + l);
              I(c) && I(d) || (c = d = void 0);
              return {
                min: c,
                max: d
              };
            };

            return d;
          }();

          return function () {
            function d() {}

            d.compose = function (c) {
              c.keepProps.push("navigatorAxis");
              C(c, "init", function () {
                this.navigatorAxis || (this.navigatorAxis = new t(this));
              });
              C(c, "zoom", function (c) {
                var a = this.chart.options,
                    d = a.navigator,
                    g = this.navigatorAxis,
                    l = a.chart.pinchType,
                    q = a.rangeSelector;
                a = a.chart.zoomType;
                this.isXAxis && (d && d.enabled || q && q.enabled) && ("y" === a ? c.zoomed = !1 : (!B && "xy" === a || B && "xy" === l) && this.options.range && (d = g.previousZoom, G(c.newMin) ? g.previousZoom = [this.min, this.max] : d && (c.newMin = d[0], c.newMax = d[1], g.previousZoom = void 0)));
                "undefined" !== typeof c.zoomed && c.preventDefault();
              });
            };

            d.AdditionsClass = t;
            return d;
          }();
        });
        P(g, "Core/Navigator.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Axis/NavigatorAxis.js"], g["Core/DefaultOptions.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Scrollbar.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I, A, t, q, c) {
          B = B.parse;

          var l = E.hasTouch,
              a = E.isTouchDevice,
              k = G.defaultOptions,
              v = c.addEvent,
              m = c.clamp,
              C = c.correctFloat,
              F = c.defined,
              L = c.destroyObjectProperties,
              J = c.erase,
              y = c.extend,
              z = c.find,
              w = c.isArray,
              e = c.isNumber,
              r = c.merge,
              h = c.pick,
              n = c.removeEvent,
              f = c.splat,
              b = function b(_b) {
            for (var a = [], c = 1; c < arguments.length; c++) {
              a[c - 1] = arguments[c];
            }

            a = [].filter.call(a, e);
            if (a.length) return Math[_b].apply(0, a);
          };

          G = "undefined" === typeof q.seriesTypes.areaspline ? "line" : "areaspline";
          y(k, {
            navigator: {
              height: 40,
              margin: 25,
              maskInside: !0,
              handles: {
                width: 7,
                height: 15,
                symbols: ["navigator-handle", "navigator-handle"],
                enabled: !0,
                lineWidth: 1,
                backgroundColor: "#f2f2f2",
                borderColor: "#999999"
              },
              maskFill: B("#6685c2").setOpacity(.3).get(),
              outlineColor: "#cccccc",
              outlineWidth: 1,
              series: {
                type: G,
                fillOpacity: .05,
                lineWidth: 1,
                compare: null,
                dataGrouping: {
                  approximation: "average",
                  enabled: !0,
                  groupPixelWidth: 2,
                  firstAnchor: "firstPoint",
                  anchor: "middle",
                  lastAnchor: "lastPoint",
                  units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
                },
                dataLabels: {
                  enabled: !1,
                  zIndex: 2
                },
                id: "highcharts-navigator-series",
                className: "highcharts-navigator-series",
                lineColor: null,
                marker: {
                  enabled: !1
                },
                threshold: null
              },
              xAxis: {
                overscroll: 0,
                className: "highcharts-navigator-xaxis",
                tickLength: 0,
                lineWidth: 0,
                gridLineColor: "#e6e6e6",
                gridLineWidth: 1,
                tickPixelInterval: 200,
                labels: {
                  align: "left",
                  style: {
                    color: "#999999"
                  },
                  x: 3,
                  y: -4
                },
                crosshair: !1
              },
              yAxis: {
                className: "highcharts-navigator-yaxis",
                gridLineWidth: 0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: .1,
                maxPadding: .1,
                labels: {
                  enabled: !1
                },
                crosshair: !1,
                title: {
                  text: null
                },
                tickLength: 0,
                tickWidth: 0
              }
            }
          });

          I.getRendererType().prototype.symbols["navigator-handle"] = function (b, a, c, d, e) {
            b = (e && e.width || 0) / 2;
            a = Math.round(b / 3) + .5;
            e = e && e.height || 0;
            return [["M", -b - 1, .5], ["L", b, .5], ["L", b, e + .5], ["L", -b - 1, e + .5], ["L", -b - 1, .5], ["M", -a, 4], ["L", -a, e - 3], ["M", a - 1, 4], ["L", a - 1, e - 3]];
          };

          var D = function () {
            function c(b) {
              this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;
              this.init(b);
            }

            c.prototype.drawHandle = function (b, a, c, d) {
              var e = this.navigatorOptions.handles.height;
              this.handles[a][d](c ? {
                translateX: Math.round(this.left + this.height / 2),
                translateY: Math.round(this.top + parseInt(b, 10) + .5 - e)
              } : {
                translateX: Math.round(this.left + parseInt(b, 10)),
                translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)
              });
            };

            c.prototype.drawOutline = function (b, a, c, d) {
              var e = this.navigatorOptions.maskInside,
                  f = this.outline.strokeWidth(),
                  g = f / 2,
                  h = f % 2 / 2;
              f = this.outlineHeight;
              var k = this.scrollbarHeight || 0,
                  p = this.size,
                  l = this.left - k,
                  m = this.top;
              c ? (l -= g, c = m + a + h, a = m + b + h, h = [["M", l + f, m - k - h], ["L", l + f, c], ["L", l, c], ["L", l, a], ["L", l + f, a], ["L", l + f, m + p + k]], e && h.push(["M", l + f, c - g], ["L", l + f, a + g])) : (b += l + k - h, a += l + k - h, m += g, h = [["M", l, m], ["L", b, m], ["L", b, m + f], ["L", a, m + f], ["L", a, m], ["L", l + p + 2 * k, m]], e && h.push(["M", b - g, m], ["L", a + g, m]));
              this.outline[d]({
                d: h
              });
            };

            c.prototype.drawMasks = function (b, a, c, d) {
              var e = this.left,
                  f = this.top,
                  g = this.height;

              if (c) {
                var h = [e, e, e];
                var k = [f, f + b, f + a];
                var p = [g, g, g];
                var l = [b, a - b, this.size - a];
              } else h = [e, e + b, e + a], k = [f, f, f], p = [b, a - b, this.size - a], l = [g, g, g];

              this.shades.forEach(function (b, a) {
                b[d]({
                  x: h[a],
                  y: k[a],
                  width: p[a],
                  height: l[a]
                });
              });
            };

            c.prototype.renderElements = function () {
              var b = this,
                  a = b.navigatorOptions,
                  c = a.maskInside,
                  d = b.chart,
                  e = d.renderer,
                  f,
                  g = {
                cursor: d.inverted ? "ns-resize" : "ew-resize"
              };
              b.navigatorGroup = f = e.g("navigator").attr({
                zIndex: 8,
                visibility: "hidden"
              }).add();
              [!c, c, !c].forEach(function (c, h) {
                var k = e.rect().addClass("highcharts-navigator-mask" + (1 === h ? "-inside" : "-outside")).add(f);
                d.styledMode || (k.attr({
                  fill: c ? a.maskFill : "rgba(0,0,0,0)"
                }), 1 === h && k.css(g));
                b.shades[h] = k;
              });
              b.outline = e.path().addClass("highcharts-navigator-outline").add(f);
              d.styledMode || b.outline.attr({
                "stroke-width": a.outlineWidth,
                stroke: a.outlineColor
              });
              a.handles.enabled && [0, 1].forEach(function (c) {
                a.handles.inverted = d.inverted;
                b.handles[c] = e.symbol(a.handles.symbols[c], -a.handles.width / 2 - 1, 0, a.handles.width, a.handles.height, a.handles);
                b.handles[c].attr({
                  zIndex: 7 - c
                }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][c]).add(f);

                if (!d.styledMode) {
                  var h = a.handles;
                  b.handles[c].attr({
                    fill: h.backgroundColor,
                    stroke: h.borderColor,
                    "stroke-width": h.lineWidth
                  }).css(g);
                }
              });
            };

            c.prototype.update = function (b) {
              (this.series || []).forEach(function (b) {
                b.baseSeries && delete b.baseSeries.navigatorSeries;
              });
              this.destroy();
              r(!0, this.chart.options.navigator, this.options, b);
              this.init(this.chart);
            };

            c.prototype.render = function (b, a, c, d) {
              var f = this.chart,
                  g = this.scrollbarHeight,
                  k,
                  p = this.xAxis,
                  l = p.pointRange || 0;
              var n = p.navigatorAxis.fake ? f.xAxis[0] : p;
              var u = this.navigatorEnabled,
                  r,
                  q = this.rendered;
              var t = f.inverted;
              var w = f.xAxis[0].minRange,
                  v = f.xAxis[0].options.maxRange;

              if (!this.hasDragged || F(c)) {
                b = C(b - l / 2);
                a = C(a + l / 2);
                if (!e(b) || !e(a)) if (q) c = 0, d = h(p.width, n.width);else return;
                this.left = h(p.left, f.plotLeft + g + (t ? f.plotWidth : 0));
                this.size = r = k = h(p.len, (t ? f.plotHeight : f.plotWidth) - 2 * g);
                f = t ? g : k + 2 * g;
                c = h(c, p.toPixels(b, !0));
                d = h(d, p.toPixels(a, !0));
                e(c) && Infinity !== Math.abs(c) || (c = 0, d = f);
                b = p.toValue(c, !0);
                a = p.toValue(d, !0);
                var x = Math.abs(C(a - b));
                x < w ? this.grabbedLeft ? c = p.toPixels(a - w - l, !0) : this.grabbedRight && (d = p.toPixels(b + w + l, !0)) : F(v) && C(x - l) > v && (this.grabbedLeft ? c = p.toPixels(a - v - l, !0) : this.grabbedRight && (d = p.toPixels(b + v + l, !0)));
                this.zoomedMax = m(Math.max(c, d), 0, r);
                this.zoomedMin = m(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, d), 0, r);
                this.range = this.zoomedMax - this.zoomedMin;
                r = Math.round(this.zoomedMax);
                c = Math.round(this.zoomedMin);
                u && (this.navigatorGroup.attr({
                  visibility: "inherit"
                }), q = q && !this.hasDragged ? "animate" : "attr", this.drawMasks(c, r, t, q), this.drawOutline(c, r, t, q), this.navigatorOptions.handles.enabled && (this.drawHandle(c, 0, t, q), this.drawHandle(r, 1, t, q)));
                this.scrollbar && (t ? (t = this.top - g, n = this.left - g + (u || !n.opposite ? 0 : (n.titleOffset || 0) + n.axisTitleMargin), g = k + 2 * g) : (t = this.top + (u ? this.height : -g), n = this.left - g), this.scrollbar.position(n, t, f, g), this.scrollbar.setRange(this.zoomedMin / (k || 1), this.zoomedMax / (k || 1)));
                this.rendered = !0;
              }
            };

            c.prototype.addMouseEvents = function () {
              var b = this,
                  a = b.chart,
                  c = a.container,
                  d = [],
                  e,
                  f;

              b.mouseMoveHandler = e = function e(a) {
                b.onMouseMove(a);
              };

              b.mouseUpHandler = f = function f(a) {
                b.onMouseUp(a);
              };

              d = b.getPartsEvents("mousedown");
              d.push(v(a.renderTo, "mousemove", e), v(c.ownerDocument, "mouseup", f));
              l && (d.push(v(a.renderTo, "touchmove", e), v(c.ownerDocument, "touchend", f)), d.concat(b.getPartsEvents("touchstart")));
              b.eventsToUnbind = d;
              b.series && b.series[0] && d.push(v(b.series[0].xAxis, "foundExtremes", function () {
                a.navigator.modifyNavigatorAxisExtremes();
              }));
            };

            c.prototype.getPartsEvents = function (b) {
              var a = this,
                  c = [];
              ["shades", "handles"].forEach(function (d) {
                a[d].forEach(function (e, f) {
                  c.push(v(e.element, b, function (b) {
                    a[d + "Mousedown"](b, f);
                  }));
                });
              });
              return c;
            };

            c.prototype.shadesMousedown = function (b, a) {
              b = this.chart.pointer.normalize(b);
              var c = this.chart,
                  d = this.xAxis,
                  e = this.zoomedMin,
                  f = this.left,
                  g = this.size,
                  h = this.range,
                  k = b.chartX;
              c.inverted && (k = b.chartY, f = this.top);
              if (1 === a) this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e;else {
                b = k - f - h / 2;
                if (0 === a) b = Math.max(0, b);else if (2 === a && b + h >= g) if (b = g - h, this.reversedExtremes) {
                  b -= h;
                  var p = this.getUnionExtremes().dataMin;
                } else var l = this.getUnionExtremes().dataMax;
                b !== e && (this.fixedWidth = h, a = d.navigatorAxis.toFixedRange(b, b + h, p, l), F(a.min) && c.xAxis[0].setExtremes(Math.min(a.min, a.max), Math.max(a.min, a.max), !0, null, {
                  trigger: "navigator"
                }));
              }
            };

            c.prototype.handlesMousedown = function (b, a) {
              this.chart.pointer.normalize(b);
              b = this.chart;
              var c = b.xAxis[0],
                  d = this.reversedExtremes;
              0 === a ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);
              b.fixedRange = null;
            };

            c.prototype.onMouseMove = function (b) {
              var c = this,
                  d = c.chart,
                  e = c.left,
                  f = c.navigatorSize,
                  g = c.range,
                  k = c.dragOffset,
                  p = d.inverted;
              b.touches && 0 === b.touches[0].pageX || (b = d.pointer.normalize(b), d = b.chartX, p && (e = c.top, d = b.chartY), c.grabbedLeft ? (c.hasDragged = !0, c.render(0, 0, d - e, c.otherHandlePos)) : c.grabbedRight ? (c.hasDragged = !0, c.render(0, 0, c.otherHandlePos, d - e)) : c.grabbedCenter && (c.hasDragged = !0, d < k ? d = k : d > f + k - g && (d = f + k - g), c.render(0, 0, d - k, d - k + g)), c.hasDragged && c.scrollbar && h(c.scrollbar.options.liveRedraw, E.svg && !a && !this.chart.isBoosting) && (b.DOMType = b.type, setTimeout(function () {
                c.onMouseUp(b);
              }, 0)));
            };

            c.prototype.onMouseUp = function (b) {
              var a = this.chart,
                  c = this.xAxis,
                  d = this.scrollbar,
                  f = b.DOMEvent || b,
                  g = a.inverted,
                  h = this.rendered && !this.hasDragged ? "animate" : "attr";

              if (this.hasDragged && (!d || !d.hasDragged) || "scrollbar" === b.trigger) {
                d = this.getUnionExtremes();
                if (this.zoomedMin === this.otherHandlePos) var k = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var p = this.fixedExtreme;
                this.zoomedMax === this.size && (p = this.reversedExtremes ? d.dataMin : d.dataMax);
                0 === this.zoomedMin && (k = this.reversedExtremes ? d.dataMax : d.dataMin);
                c = c.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, k, p);
                F(c.min) && a.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {
                  trigger: "navigator",
                  triggerOp: "navigator-drag",
                  DOMEvent: f
                });
              }

              "mousemove" !== b.DOMType && "touchmove" !== b.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
              this.navigatorEnabled && e(this.zoomedMin) && e(this.zoomedMax) && (a = Math.round(this.zoomedMin), b = Math.round(this.zoomedMax), this.shades && this.drawMasks(a, b, g, h), this.outline && this.drawOutline(a, b, g, h), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(a, 0, g, h), this.drawHandle(b, 1, g, h)));
            };

            c.prototype.removeEvents = function () {
              this.eventsToUnbind && (this.eventsToUnbind.forEach(function (b) {
                b();
              }), this.eventsToUnbind = void 0);
              this.removeBaseSeriesEvents();
            };

            c.prototype.removeBaseSeriesEvents = function () {
              var b = this.baseSeries || [];
              this.navigatorEnabled && b[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && b.forEach(function (b) {
                n(b, "updatedData", this.updatedDataHandler);
              }, this), b[0].xAxis && n(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
            };

            c.prototype.init = function (a) {
              var c = a.options,
                  e = c.navigator,
                  f = e.enabled,
                  g = c.scrollbar,
                  k = g.enabled;
              c = f ? e.height : 0;
              var p = k ? g.height : 0;
              this.handles = [];
              this.shades = [];
              this.chart = a;
              this.setBaseSeries();
              this.height = c;
              this.scrollbarHeight = p;
              this.scrollbarEnabled = k;
              this.navigatorEnabled = f;
              this.navigatorOptions = e;
              this.scrollbarOptions = g;
              this.outlineHeight = c + p;
              this.opposite = h(e.opposite, !(f || !a.inverted));
              var l = this;
              f = l.baseSeries;
              g = a.xAxis.length;
              k = a.yAxis.length;
              var m = f && f[0] && f[0].xAxis || a.xAxis[0] || {
                options: {}
              };
              a.isDirtyBox = !0;
              l.navigatorEnabled ? (l.xAxis = new d(a, r({
                breaks: m.options.breaks,
                ordinal: m.options.ordinal
              }, e.xAxis, {
                id: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                isX: !0,
                type: "datetime",
                index: g,
                isInternal: !0,
                offset: 0,
                keepOrdinalPadding: !0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: 0,
                maxPadding: 0,
                zoomEnabled: !1
              }, a.inverted ? {
                offsets: [p, 0, -p, 0],
                width: c
              } : {
                offsets: [0, -p, 0, p],
                height: c
              })), l.yAxis = new d(a, r(e.yAxis, {
                id: "navigator-y-axis",
                alignTicks: !1,
                offset: 0,
                index: k,
                isInternal: !0,
                reversed: h(e.yAxis && e.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),
                zoomEnabled: !1
              }, a.inverted ? {
                width: c
              } : {
                height: c
              })), f || e.series.data ? l.updateNavigatorSeries(!1) : 0 === a.series.length && (l.unbindRedraw = v(a, "beforeRedraw", function () {
                0 < a.series.length && !l.series && (l.setBaseSeries(), l.unbindRedraw());
              })), l.reversedExtremes = a.inverted && !l.xAxis.reversed || !a.inverted && l.xAxis.reversed, l.renderElements(), l.addMouseEvents()) : (l.xAxis = {
                chart: a,
                navigatorAxis: {
                  fake: !0
                },
                translate: function translate(c, d) {
                  var e = a.xAxis[0],
                      f = e.getExtremes(),
                      g = e.len - 2 * p,
                      h = b("min", e.options.min, f.dataMin);
                  e = b("max", e.options.max, f.dataMax) - h;
                  return d ? c * e / g + h : g * (c - h) / e;
                },
                toPixels: function toPixels(b) {
                  return this.translate(b);
                },
                toValue: function toValue(b) {
                  return this.translate(b, !0);
                }
              }, l.xAxis.navigatorAxis.axis = l.xAxis, l.xAxis.navigatorAxis.toFixedRange = x.AdditionsClass.prototype.toFixedRange.bind(l.xAxis.navigatorAxis));
              a.options.scrollbar.enabled && (a.scrollbar = l.scrollbar = new A(a.renderer, r(a.options.scrollbar, {
                margin: l.navigatorEnabled ? 0 : 10,
                vertical: a.inverted
              }), a), v(l.scrollbar, "changed", function (b) {
                var a = l.size,
                    c = a * this.to;
                a *= this.from;
                l.hasDragged = l.scrollbar.hasDragged;
                l.render(0, 0, a, c);
                this.shouldUpdateExtremes(b.DOMType) && setTimeout(function () {
                  l.onMouseUp(b);
                });
              }));
              l.addBaseSeriesEvents();
              l.addChartEvents();
            };

            c.prototype.getUnionExtremes = function (a) {
              var c = this.chart.xAxis[0],
                  d = this.xAxis,
                  e = d.options,
                  f = c.options,
                  g;
              a && null === c.dataMin || (g = {
                dataMin: h(e && e.min, b("min", f.min, c.dataMin, d.dataMin, d.min)),
                dataMax: h(e && e.max, b("max", f.max, c.dataMax, d.dataMax, d.max))
              });
              return g;
            };

            c.prototype.setBaseSeries = function (b, a) {
              var c = this.chart,
                  d = this.baseSeries = [];
              b = b || c.options && c.options.navigator.baseSeries || (c.series.length ? z(c.series, function (b) {
                return !b.options.isInternal;
              }).index : 0);
              (c.series || []).forEach(function (a, c) {
                a.options.isInternal || !a.options.showInNavigator && (c !== b && a.options.id !== b || !1 === a.options.showInNavigator) || d.push(a);
              });
              this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, a);
            };

            c.prototype.updateNavigatorSeries = function (b, a) {
              var c = this,
                  d = c.chart,
                  e = c.baseSeries,
                  g,
                  p,
                  l = c.navigatorOptions.series,
                  m,
                  q = {
                enableMouseTracking: !1,
                index: null,
                linkedTo: null,
                group: "nav",
                padXAxis: !1,
                xAxis: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                showInLegend: !1,
                stacking: void 0,
                isInternal: !0,
                states: {
                  inactive: {
                    opacity: 1
                  }
                }
              },
                  u = c.series = (c.series || []).filter(function (b) {
                var a = b.baseSeries;
                return 0 > e.indexOf(a) ? (a && (n(a, "updatedData", c.updatedDataHandler), delete a.navigatorSeries), b.chart && b.destroy(), !1) : !0;
              });
              e && e.length && e.forEach(function (b) {
                var n = b.navigatorSeries,
                    t = y({
                  color: b.color,
                  visible: b.visible
                }, w(l) ? k.navigator.series : l);
                n && !1 === c.navigatorOptions.adaptToUpdatedData || (q.name = "Navigator " + e.length, g = b.options || {}, m = g.navigatorOptions || {}, t.dataLabels = f(t.dataLabels), p = r(g, q, t, m), p.pointRange = h(t.pointRange, m.pointRange, k.plotOptions[p.type || "line"].pointRange), t = m.data || t.data, c.hasNavigatorData = c.hasNavigatorData || !!t, p.data = t || g.data && g.data.slice(0), n && n.options ? n.update(p, a) : (b.navigatorSeries = d.initSeries(p), b.navigatorSeries.baseSeries = b, u.push(b.navigatorSeries)));
              });
              if (l.data && (!e || !e.length) || w(l)) c.hasNavigatorData = !1, l = f(l), l.forEach(function (b, a) {
                q.name = "Navigator " + (u.length + 1);
                p = r(k.navigator.series, {
                  color: d.series[a] && !d.series[a].options.isInternal && d.series[a].color || d.options.colors[a] || d.options.colors[0]
                }, q, b);
                p.data = b.data;
                p.data && (c.hasNavigatorData = !0, u.push(d.initSeries(p)));
              });
              b && this.addBaseSeriesEvents();
            };

            c.prototype.addBaseSeriesEvents = function () {
              var b = this,
                  a = b.baseSeries || [];
              a[0] && a[0].xAxis && a[0].eventsToUnbind.push(v(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
              a.forEach(function (a) {
                a.eventsToUnbind.push(v(a, "show", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);
                }));
                a.eventsToUnbind.push(v(a, "hide", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);
                }));
                !1 !== this.navigatorOptions.adaptToUpdatedData && a.xAxis && a.eventsToUnbind.push(v(a, "updatedData", this.updatedDataHandler));
                a.eventsToUnbind.push(v(a, "remove", function () {
                  this.navigatorSeries && (J(b.series, this.navigatorSeries), F(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);
                }));
              }, this);
            };

            c.prototype.getBaseSeriesMin = function (b) {
              return this.baseSeries.reduce(function (b, a) {
                return Math.min(b, a.xData && a.xData.length ? a.xData[0] : b);
              }, b);
            };

            c.prototype.modifyNavigatorAxisExtremes = function () {
              var b = this.xAxis,
                  a;
              "undefined" !== typeof b.getExtremes && (!(a = this.getUnionExtremes(!0)) || a.dataMin === b.min && a.dataMax === b.max || (b.min = a.dataMin, b.max = a.dataMax));
            };

            c.prototype.modifyBaseAxisExtremes = function () {
              var b = this.chart.navigator,
                  a = this.getExtremes(),
                  c = a.dataMin,
                  d = a.dataMax;
              a = a.max - a.min;
              var f = b.stickToMin,
                  g = b.stickToMax,
                  k = h(this.options.overscroll, 0),
                  l = b.series && b.series[0],
                  m = !!this.setExtremes;

              if (!this.eventArgs || "rangeSelectorButton" !== this.eventArgs.trigger) {
                if (f) {
                  var n = c;
                  var r = n + a;
                }

                g && (r = d + k, f || (n = Math.max(c, r - a, b.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE))));
                m && (f || g) && e(n) && (this.min = this.userMin = n, this.max = this.userMax = r);
              }

              b.stickToMin = b.stickToMax = null;
            };

            c.prototype.updatedDataHandler = function () {
              var b = this.chart.navigator,
                  a = this.navigatorSeries;
              b.stickToMax = b.reversedExtremes ? 0 === Math.round(b.zoomedMin) : Math.round(b.zoomedMax) >= Math.round(b.size);
              b.stickToMin = b.shouldStickToMin(this, b);
              a && !b.hasNavigatorData && (a.options.pointStart = this.xData[0], a.setData(this.options.data, !1, null, !1));
            };

            c.prototype.shouldStickToMin = function (b, a) {
              a = a.getBaseSeriesMin(b.xData[0]);
              var c = b.xAxis;
              b = c.max;
              var d = c.min;
              c = c.options.range;
              return e(b) && e(d) ? c && 0 < b - a ? b - a < c : d <= a : !1;
            };

            c.prototype.addChartEvents = function () {
              this.eventsToUnbind || (this.eventsToUnbind = []);
              this.eventsToUnbind.push(v(this.chart, "redraw", function () {
                var b = this.navigator,
                    a = b && (b.baseSeries && b.baseSeries[0] && b.baseSeries[0].xAxis || this.xAxis[0]);
                a && b.render(a.min, a.max);
              }), v(this.chart, "getMargins", function () {
                var b = this.navigator,
                    a = b.opposite ? "plotTop" : "marginBottom";
                this.inverted && (a = b.opposite ? "marginRight" : "plotLeft");
                this[a] = (this[a] || 0) + (b.navigatorEnabled || !this.inverted ? b.outlineHeight : 0) + b.navigatorOptions.margin;
              }));
            };

            c.prototype.destroy = function () {
              this.removeEvents();
              this.xAxis && (J(this.chart.xAxis, this.xAxis), J(this.chart.axes, this.xAxis));
              this.yAxis && (J(this.chart.yAxis, this.yAxis), J(this.chart.axes, this.yAxis));
              (this.series || []).forEach(function (b) {
                b.destroy && b.destroy();
              });
              "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach(function (b) {
                this[b] && this[b].destroy && this[b].destroy();
                this[b] = null;
              }, this);
              [this.handles].forEach(function (b) {
                L(b);
              }, this);
            };

            return c;
          }();

          E.Navigator || (E.Navigator = D, x.compose(d), v(g, "beforeShowResetZoom", function () {
            var b = this.options,
                c = b.navigator,
                d = b.rangeSelector;
            if ((c && c.enabled || d && d.enabled) && (!a && "x" === b.chart.zoomType || a && "x" === b.chart.pinchType)) return !1;
          }), v(g, "beforeRender", function () {
            var b = this.options;
            if (b.navigator.enabled || b.scrollbar.enabled) this.scroller = this.navigator = new D(this);
          }), v(g, "afterSetChartSize", function () {
            var b = this.legend,
                a = this.navigator;

            if (a) {
              var c = b && b.options;
              var d = a.xAxis;
              var e = a.yAxis;
              var f = a.scrollbarHeight;
              this.inverted ? (a.left = a.opposite ? this.chartWidth - f - a.height : this.spacing[3] + f, a.top = this.plotTop + f) : (a.left = h(d.left, this.plotLeft + f), a.top = a.navigatorOptions.top || this.chartHeight - a.height - f - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && "bottom" === c.verticalAlign && "proximate" !== c.layout && c.enabled && !c.floating ? b.legendHeight + h(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));
              d && e && (this.inverted ? d.options.left = e.options.left = a.left : d.options.top = e.options.top = a.top, d.setAxisSize(), e.setAxisSize());
            }
          }), v(g, "update", function (b) {
            var a = b.options.navigator || {},
                c = b.options.scrollbar || {};
            this.navigator || this.scroller || !a.enabled && !c.enabled || (r(!0, this.options.navigator, a), r(!0, this.options.scrollbar, c), delete b.options.navigator, delete b.options.scrollbar);
          }), v(g, "afterUpdate", function (b) {
            this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new D(this), h(b.redraw, !0) && this.redraw(b.animation));
          }), v(g, "afterAddSeries", function () {
            this.navigator && this.navigator.setBaseSeries(null, !1);
          }), v(t, "afterUpdate", function () {
            this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);
          }), g.prototype.callbacks.push(function (b) {
            var a = b.navigator;
            a && b.xAxis[0] && (b = b.xAxis[0].getExtremes(), a.render(b.min, b.max));
          }));
          E.Navigator = D;
          return E.Navigator;
        });
        P(g, "Extensions/RangeSelector.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Globals.js"], g["Core/DefaultOptions.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G) {
          function C(a) {
            if (-1 !== a.indexOf("%L")) return "text";
            var b = "aAdewbBmoyY".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            }),
                c = "HkIlMS".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            });
            return b && c ? "datetime-local" : b ? "date" : c ? "time" : "text";
          }

          var A = E.defaultOptions,
              t = G.addEvent,
              q = G.createElement,
              c = G.css,
              l = G.defined,
              a = G.destroyObjectProperties,
              k = G.discardElement,
              v = G.extend,
              m = G.find,
              N = G.fireEvent,
              F = G.isNumber,
              L = G.merge,
              J = G.objectEach,
              y = G.pad,
              z = G.pick,
              w = G.pInt,
              e = G.splat;
          v(A, {
            rangeSelector: {
              allButtonsEnabled: !1,
              buttons: void 0,
              buttonSpacing: 5,
              dropdown: "responsive",
              enabled: void 0,
              verticalAlign: "top",
              buttonTheme: {
                width: 28,
                height: 18,
                padding: 2,
                zIndex: 7
              },
              floating: !1,
              x: 0,
              y: 0,
              height: void 0,
              inputBoxBorderColor: "none",
              inputBoxHeight: 17,
              inputBoxWidth: void 0,
              inputDateFormat: "%b %e, %Y",
              inputDateParser: void 0,
              inputEditDateFormat: "%Y-%m-%d",
              inputEnabled: !0,
              inputPosition: {
                align: "right",
                x: 0,
                y: 0
              },
              inputSpacing: 5,
              selected: void 0,
              buttonPosition: {
                align: "left",
                x: 0,
                y: 0
              },
              inputStyle: {
                color: "#335cad",
                cursor: "pointer"
              },
              labelStyle: {
                color: "#666666"
              }
            }
          });
          v(A.lang, {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "\u2192"
          });

          var r = function () {
            function f(b) {
              this.buttons = void 0;
              this.buttonOptions = f.prototype.defaultButtons;
              this.initialButtonGroupWidth = 0;
              this.options = void 0;
              this.chart = b;
              this.init(b);
            }

            f.prototype.clickButton = function (b, a) {
              var c = this.chart,
                  f = this.buttonOptions[b],
                  g = c.xAxis[0],
                  h = c.scroller && c.scroller.getUnionExtremes() || g || {},
                  k = h.dataMin,
                  m = h.dataMax,
                  n = g && Math.round(Math.min(g.max, z(m, g.max))),
                  r = f.type;
              h = f._range;
              var q,
                  w = f.dataGrouping;
              var v = !0;

              if (null !== k && null !== m) {
                c.fixedRange = h;
                this.setSelected(b);
                w && (this.forcedDataGrouping = !0, d.prototype.setDataGrouping.call(g || {
                  chart: this.chart
                }, w, !1), this.frozenStates = f.preserveDataGrouping);
                if ("month" === r || "year" === r) {
                  if (g) {
                    v = {
                      range: f,
                      max: n,
                      chart: c,
                      dataMin: k,
                      dataMax: m
                    };
                    var x = g.minFromRange.call(v);
                    F(v.newMax) && (n = v.newMax);
                    v = !1;
                  } else h = f;
                } else if (h) x = Math.max(n - h, k), n = Math.min(x + h, m), v = !1;else if ("ytd" === r) {
                  if (g) {
                    if ("undefined" === typeof m || "undefined" === typeof k) k = Number.MAX_VALUE, m = Number.MIN_VALUE, c.series.forEach(function (b) {
                      if (b = b.xData) k = Math.min(b[0], k), m = Math.max(b[b.length - 1], m);
                    }), a = !1;
                    n = this.getYTDExtremes(m, k, c.time.useUTC);
                    x = q = n.min;
                    n = n.max;
                  } else {
                    this.deferredYTDClick = b;
                    return;
                  }
                } else "all" === r && g && (c.navigator && c.navigator.baseSeries[0] && (c.navigator.baseSeries[0].xAxis.options.range = void 0), x = k, n = m);
                v && f._offsetMin && l(x) && (x += f._offsetMin);
                f._offsetMax && l(n) && (n += f._offsetMax);
                this.dropdown && (this.dropdown.selectedIndex = b + 1);
                if (g) g.setExtremes(x, n, z(a, !0), void 0, {
                  trigger: "rangeSelectorButton",
                  rangeSelectorButton: f
                });else {
                  var y = e(c.options.xAxis)[0];
                  var D = y.range;
                  y.range = h;
                  var A = y.min;
                  y.min = q;
                  t(c, "load", function () {
                    y.range = D;
                    y.min = A;
                  });
                }
                N(this, "afterBtnClick");
              }
            };

            f.prototype.setSelected = function (b) {
              this.selected = this.options.selected = b;
            };

            f.prototype.init = function (b) {
              var a = this,
                  c = b.options.rangeSelector,
                  d = c.buttons || a.defaultButtons.slice(),
                  e = c.selected,
                  f = function f() {
                var b = a.minInput,
                    c = a.maxInput;
                b && b.blur && N(b, "blur");
                c && c.blur && N(c, "blur");
              };

              a.chart = b;
              a.options = c;
              a.buttons = [];
              a.buttonOptions = d;
              this.eventsToUnbind = [];
              this.eventsToUnbind.push(t(b.container, "mousedown", f));
              this.eventsToUnbind.push(t(b, "resize", f));
              d.forEach(a.computeButtonRange);
              "undefined" !== typeof e && d[e] && this.clickButton(e, !1);
              this.eventsToUnbind.push(t(b, "load", function () {
                b.xAxis && b.xAxis[0] && t(b.xAxis[0], "setExtremes", function (c) {
                  this.max - this.min !== b.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && a.forcedDataGrouping && !a.frozenStates && this.setDataGrouping(!1, !1);
                });
              }));
            };

            f.prototype.updateButtonStates = function () {
              var b = this,
                  a = this.chart,
                  c = this.dropdown,
                  d = a.xAxis[0],
                  e = Math.round(d.max - d.min),
                  f = !d.hasVisibleSeries,
                  g = a.scroller && a.scroller.getUnionExtremes() || d,
                  h = g.dataMin,
                  k = g.dataMax;
              a = b.getYTDExtremes(k, h, a.time.useUTC);
              var l = a.min,
                  m = a.max,
                  n = b.selected,
                  r = F(n),
                  q = b.options.allButtonsEnabled,
                  t = b.buttons;
              b.buttonOptions.forEach(function (a, g) {
                var p = a._range,
                    u = a.type,
                    w = a.count || 1,
                    v = t[g],
                    x = 0,
                    y = a._offsetMax - a._offsetMin;
                a = g === n;
                var D = p > k - h,
                    z = p < d.minRange,
                    A = !1,
                    H = !1;
                p = p === e;
                ("month" === u || "year" === u) && e + 36E5 >= 864E5 * {
                  month: 28,
                  year: 365
                }[u] * w - y && e - 36E5 <= 864E5 * {
                  month: 31,
                  year: 366
                }[u] * w + y ? p = !0 : "ytd" === u ? (p = m - l + y === e, A = !a) : "all" === u && (p = d.max - d.min >= k - h, H = !a && r && p);
                u = !q && (D || z || H || f);
                w = a && p || p && !r && !A || a && b.frozenStates;
                u ? x = 3 : w && (r = !0, x = 2);
                v.state !== x && (v.setState(x), c && (c.options[g + 1].disabled = u, 2 === x && (c.selectedIndex = g + 1)), 0 === x && n === g && b.setSelected());
              });
            };

            f.prototype.computeButtonRange = function (b) {
              var a = b.type,
                  c = b.count || 1,
                  d = {
                millisecond: 1,
                second: 1E3,
                minute: 6E4,
                hour: 36E5,
                day: 864E5,
                week: 6048E5
              };
              if (d[a]) b._range = d[a] * c;else if ("month" === a || "year" === a) b._range = 864E5 * {
                month: 30,
                year: 365
              }[a] * c;
              b._offsetMin = z(b.offsetMin, 0);
              b._offsetMax = z(b.offsetMax, 0);
              b._range += b._offsetMax - b._offsetMin;
            };

            f.prototype.getInputValue = function (b) {
              b = "min" === b ? this.minInput : this.maxInput;
              var a = this.chart.options.rangeSelector,
                  c = this.chart.time;
              return b ? ("text" === b.type && a.inputDateParser || this.defaultInputDateParser)(b.value, c.useUTC, c) : 0;
            };

            f.prototype.setInputValue = function (b, a) {
              var c = this.options,
                  d = this.chart.time,
                  e = "min" === b ? this.minInput : this.maxInput;
              b = "min" === b ? this.minDateBox : this.maxDateBox;

              if (e) {
                var f = e.getAttribute("data-hc-time");
                f = l(f) ? Number(f) : void 0;
                l(a) && (l(f) && e.setAttribute("data-hc-time-previous", f), e.setAttribute("data-hc-time", a), f = a);
                e.value = d.dateFormat(this.inputTypeFormats[e.type] || c.inputEditDateFormat, f);
                b && b.attr({
                  text: d.dateFormat(c.inputDateFormat, f)
                });
              }
            };

            f.prototype.setInputExtremes = function (b, a, c) {
              if (b = "min" === b ? this.minInput : this.maxInput) {
                var d = this.inputTypeFormats[b.type],
                    e = this.chart.time;
                d && (a = e.dateFormat(d, a), b.min !== a && (b.min = a), c = e.dateFormat(d, c), b.max !== c && (b.max = c));
              }
            };

            f.prototype.showInput = function (b) {
              var a = "min" === b ? this.minDateBox : this.maxDateBox;

              if ((b = "min" === b ? this.minInput : this.maxInput) && a && this.inputGroup) {
                var d = "text" === b.type,
                    e = this.inputGroup,
                    f = e.translateX;
                e = e.translateY;
                var g = this.options.inputBoxWidth;
                c(b, {
                  width: d ? a.width + (g ? -2 : 20) + "px" : "auto",
                  height: d ? a.height - 2 + "px" : "auto",
                  border: "2px solid silver"
                });
                d && g ? c(b, {
                  left: f + a.x + "px",
                  top: e + "px"
                }) : c(b, {
                  left: Math.min(Math.round(a.x + f - (b.offsetWidth - a.width) / 2), this.chart.chartWidth - b.offsetWidth) + "px",
                  top: e - (b.offsetHeight - a.height) / 2 + "px"
                });
              }
            };

            f.prototype.hideInput = function (b) {
              (b = "min" === b ? this.minInput : this.maxInput) && c(b, {
                top: "-9999em",
                border: 0,
                width: "1px",
                height: "1px"
              });
            };

            f.prototype.defaultInputDateParser = function (b, a, c) {
              var d = b.split("/").join("-").split(" ").join("T");
              -1 === d.indexOf("T") && (d += "T00:00");
              if (a) d += "Z";else {
                var e;
                if (e = B.isSafari) e = d, e = !(6 < e.length && (e.lastIndexOf("-") === e.length - 6 || e.lastIndexOf("+") === e.length - 6));
                e && (e = new Date(d).getTimezoneOffset() / 60, d += 0 >= e ? "+".concat(y(-e), ":00") : "-".concat(y(e), ":00"));
              }
              d = Date.parse(d);
              F(d) || (b = b.split("-"), d = Date.UTC(w(b[0]), w(b[1]) - 1, w(b[2])));
              c && a && F(d) && (d += c.getTimezoneOffset(d));
              return d;
            };

            f.prototype.drawInput = function (b) {
              function a() {
                var a = g.getInputValue(b),
                    c = d.xAxis[0],
                    e = d.scroller && d.scroller.xAxis ? d.scroller.xAxis : c,
                    f = e.dataMin;
                e = e.dataMax;
                var h = g.maxInput,
                    k = g.minInput;
                a !== Number(r.getAttribute("data-hc-time-previous")) && F(a) && (r.setAttribute("data-hc-time-previous", a), m && h && F(f) ? a > Number(h.getAttribute("data-hc-time")) ? a = void 0 : a < f && (a = f) : k && F(e) && (a < Number(k.getAttribute("data-hc-time")) ? a = void 0 : a > e && (a = e)), "undefined" !== typeof a && c.setExtremes(m ? a : c.min, m ? c.max : a, void 0, void 0, {
                  trigger: "rangeSelectorInput"
                }));
              }

              var d = this.chart,
                  e = this.div,
                  f = this.inputGroup,
                  g = this,
                  h = d.renderer.style || {},
                  k = d.renderer,
                  l = d.options.rangeSelector,
                  m = "min" === b,
                  n = A.lang[m ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
              n = k.label(n, 0).addClass("highcharts-range-label").attr({
                padding: n ? 2 : 0,
                height: n ? l.inputBoxHeight : 0
              }).add(f);
              k = k.label("", 0).addClass("highcharts-range-input").attr({
                padding: 2,
                width: l.inputBoxWidth,
                height: l.inputBoxHeight,
                "text-align": "center"
              }).on("click", function () {
                g.showInput(b);
                g[b + "Input"].focus();
              });
              d.styledMode || k.attr({
                stroke: l.inputBoxBorderColor,
                "stroke-width": 1
              });
              k.add(f);
              var r = q("input", {
                name: b,
                className: "highcharts-range-selector"
              }, void 0, e);
              r.setAttribute("type", C(l.inputDateFormat || "%b %e, %Y"));
              d.styledMode || (n.css(L(h, l.labelStyle)), k.css(L({
                color: "#333333"
              }, h, l.inputStyle)), c(r, v({
                position: "absolute",
                border: 0,
                boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                width: "1px",
                height: "1px",
                padding: 0,
                textAlign: "center",
                fontSize: h.fontSize,
                fontFamily: h.fontFamily,
                top: "-9999em"
              }, l.inputStyle)));

              r.onfocus = function () {
                g.showInput(b);
              };

              r.onblur = function () {
                r === B.doc.activeElement && a();
                g.hideInput(b);
                g.setInputValue(b);
                r.blur();
              };

              var t = !1;

              r.onchange = function () {
                t || (a(), g.hideInput(b), r.blur());
              };

              r.onkeypress = function (b) {
                13 === b.keyCode && a();
              };

              r.onkeydown = function (b) {
                t = !0;
                38 !== b.keyCode && 40 !== b.keyCode || a();
              };

              r.onkeyup = function () {
                t = !1;
              };

              return {
                dateBox: k,
                input: r,
                label: n
              };
            };

            f.prototype.getPosition = function () {
              var b = this.chart,
                  a = b.options.rangeSelector;
              b = "top" === a.verticalAlign ? b.plotTop - b.axisOffset[0] : 0;
              return {
                buttonTop: b + a.buttonPosition.y,
                inputTop: b + a.inputPosition.y - 10
              };
            };

            f.prototype.getYTDExtremes = function (b, a, c) {
              var d = this.chart.time,
                  e = new d.Date(b),
                  f = d.get("FullYear", e);
              c = c ? d.Date.UTC(f, 0, 1) : +new d.Date(f, 0, 1);
              a = Math.max(a, c);
              e = e.getTime();
              return {
                max: Math.min(b || e, e),
                min: a
              };
            };

            f.prototype.render = function (b, a) {
              var c = this.chart,
                  d = c.renderer,
                  e = c.container,
                  f = c.options,
                  g = f.rangeSelector,
                  h = z(f.chart.style && f.chart.style.zIndex, 0) + 1;
              f = g.inputEnabled;

              if (!1 !== g.enabled) {
                this.rendered || (this.group = d.g("range-selector-group").attr({
                  zIndex: 7
                }).add(), this.div = q("div", void 0, {
                  position: "relative",
                  height: 0,
                  zIndex: h
                }), this.buttonOptions.length && this.renderButtons(), e.parentNode && e.parentNode.insertBefore(this.div, e), f && (this.inputGroup = d.g("input-group").add(this.group), d = this.drawInput("min"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput("max"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));

                if (f && (this.setInputValue("min", b), this.setInputValue("max", a), b = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, l(b.dataMin) && l(b.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes("min", b.dataMin, Math.min(b.dataMax, this.getInputValue("max")) - c), this.setInputExtremes("max", Math.max(b.dataMin, this.getInputValue("min")) + c, b.dataMax)), this.inputGroup)) {
                  var k = 0;
                  [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (b) {
                    if (b) {
                      var a = b.getBBox().width;
                      a && (b.attr({
                        x: k
                      }), k += a + g.inputSpacing);
                    }
                  });
                }

                this.alignElements();
                this.rendered = !0;
              }
            };

            f.prototype.renderButtons = function () {
              var b = this,
                  a = this.buttons,
                  c = this.options,
                  d = A.lang,
                  e = this.chart.renderer,
                  f = L(c.buttonTheme),
                  g = f && f.states,
                  h = f.width || 28;
              delete f.width;
              delete f.states;
              this.buttonGroup = e.g("range-selector-buttons").add(this.group);
              var k = this.dropdown = q("select", void 0, {
                position: "absolute",
                width: "1px",
                height: "1px",
                padding: 0,
                border: 0,
                top: "-9999em",
                cursor: "pointer",
                opacity: .0001
              }, this.div);
              t(k, "touchstart", function () {
                k.style.fontSize = "16px";
              });
              [[B.isMS ? "mouseover" : "mouseenter"], [B.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(function (c) {
                var d = c[0],
                    e = c[1];
                t(k, d, function () {
                  var c = a[b.currentButtonIndex()];
                  c && N(c.element, e || d);
                });
              });
              this.zoomText = e.label(d && d.rangeSelectorZoom || "", 0).attr({
                padding: c.buttonTheme.padding,
                height: c.buttonTheme.height,
                paddingLeft: 0,
                paddingRight: 0
              }).add(this.buttonGroup);
              this.chart.styledMode || (this.zoomText.css(c.labelStyle), f["stroke-width"] = z(f["stroke-width"], 0));
              q("option", {
                textContent: this.zoomText.textStr,
                disabled: !0
              }, void 0, k);
              this.buttonOptions.forEach(function (c, d) {
                q("option", {
                  textContent: c.title || c.text
                }, void 0, k);
                a[d] = e.button(c.text, 0, 0, function (a) {
                  var e = c.events && c.events.click,
                      f;
                  e && (f = e.call(c, a));
                  !1 !== f && b.clickButton(d);
                  b.isActive = !0;
                }, f, g && g.hover, g && g.select, g && g.disabled).attr({
                  "text-align": "center",
                  width: h
                }).add(b.buttonGroup);
                c.title && a[d].attr("title", c.title);
              });
            };

            f.prototype.alignElements = function () {
              var a = this,
                  c = this.buttonGroup,
                  d = this.buttons,
                  e = this.chart,
                  f = this.group,
                  g = this.inputGroup,
                  h = this.options,
                  k = this.zoomText,
                  l = e.options,
                  m = l.exporting && !1 !== l.exporting.enabled && l.navigation && l.navigation.buttonOptions;
              l = h.buttonPosition;

              var n = h.inputPosition,
                  r = h.verticalAlign,
                  q = function q(b, c) {
                return m && a.titleCollision(e) && "top" === r && "right" === c.align && c.y - b.getBBox().height - 12 < (m.y || 0) + (m.height || 0) + e.spacing[0] ? -40 : 0;
              },
                  t = e.plotLeft;

              if (f && l && n) {
                var w = l.x - e.spacing[3];

                if (c) {
                  this.positionButtons();

                  if (!this.initialButtonGroupWidth) {
                    var v = 0;
                    k && (v += k.getBBox().width + 5);
                    d.forEach(function (a, b) {
                      v += a.width;
                      b !== d.length - 1 && (v += h.buttonSpacing);
                    });
                    this.initialButtonGroupWidth = v;
                  }

                  t -= e.spacing[3];
                  this.updateButtonStates();
                  k = q(c, l);
                  this.alignButtonGroup(k);
                  f.placed = c.placed = e.hasLoaded;
                }

                c = 0;
                g && (c = q(g, n), "left" === n.align ? w = t : "right" === n.align && (w = -Math.max(e.axisOffset[1], -c)), g.align({
                  y: n.y,
                  width: g.getBBox().width,
                  align: n.align,
                  x: n.x + w - 2
                }, !0, e.spacingBox), g.placed = e.hasLoaded);
                this.handleCollision(c);
                f.align({
                  verticalAlign: r
                }, !0, e.spacingBox);
                g = f.alignAttr.translateY;
                c = f.getBBox().height + 20;
                q = 0;
                "bottom" === r && (q = (q = e.legend && e.legend.options) && "bottom" === q.verticalAlign && q.enabled && !q.floating ? e.legend.legendHeight + z(q.margin, 10) : 0, c = c + q - 20, q = g - c - (h.floating ? 0 : h.y) - (e.titleOffset ? e.titleOffset[2] : 0) - 10);
                if ("top" === r) h.floating && (q = 0), e.titleOffset && e.titleOffset[0] && (q = e.titleOffset[0]), q += e.margin[0] - e.spacing[0] || 0;else if ("middle" === r) if (n.y === l.y) q = g;else if (n.y || l.y) q = 0 > n.y || 0 > l.y ? q - Math.min(n.y, l.y) : g - c;
                f.translate(h.x, h.y + Math.floor(q));
                l = this.minInput;
                n = this.maxInput;
                g = this.dropdown;
                h.inputEnabled && l && n && (l.style.marginTop = f.translateY + "px", n.style.marginTop = f.translateY + "px");
                g && (g.style.marginTop = f.translateY + "px");
              }
            };

            f.prototype.alignButtonGroup = function (a, c) {
              var b = this.chart,
                  d = this.buttonGroup,
                  e = this.options.buttonPosition,
                  f = b.plotLeft - b.spacing[3],
                  g = e.x - b.spacing[3];
              "right" === e.align ? g += a - f : "center" === e.align && (g -= f / 2);
              d && d.align({
                y: e.y,
                width: z(c, this.initialButtonGroupWidth),
                align: e.align,
                x: g
              }, !0, b.spacingBox);
            };

            f.prototype.positionButtons = function () {
              var a = this.buttons,
                  c = this.chart,
                  d = this.options,
                  e = this.zoomText,
                  f = c.hasLoaded ? "animate" : "attr",
                  g = d.buttonPosition,
                  h = c.plotLeft,
                  k = h;
              e && "hidden" !== e.visibility && (e[f]({
                x: z(h + g.x, h)
              }), k += g.x + e.getBBox().width + 5);
              this.buttonOptions.forEach(function (b, c) {
                if ("hidden" !== a[c].visibility) a[c][f]({
                  x: k
                }), k += a[c].width + d.buttonSpacing;else a[c][f]({
                  x: h
                });
              });
            };

            f.prototype.handleCollision = function (a) {
              var b = this,
                  c = this.chart,
                  d = this.buttonGroup,
                  e = this.inputGroup,
                  f = this.options,
                  g = f.buttonPosition,
                  h = f.dropdown,
                  k = f.inputPosition;

              f = function f() {
                var a = 0;
                b.buttons.forEach(function (b) {
                  b = b.getBBox();
                  b.width > a && (a = b.width);
                });
                return a;
              };

              var l = function l(b) {
                if (e && d) {
                  var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,
                      f = e.alignOptions.width,
                      h = d.alignAttr.translateX + d.getBBox().x;
                  return h + b > c && c + f > h && g.y < k.y + e.getBBox().height;
                }

                return !1;
              },
                  m = function m() {
                e && d && e.attr({
                  translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),
                  translateY: e.alignAttr.translateY + d.getBBox().height + 10
                });
              };

              if (d) {
                if ("always" === h) {
                  this.collapseButtons(a);
                  l(f()) && m();
                  return;
                }

                "never" === h && this.expandButtons();
              }

              e && d ? k.align === g.align || l(this.initialButtonGroupWidth + 20) ? "responsive" === h ? (this.collapseButtons(a), l(f()) && m()) : m() : "responsive" === h && this.expandButtons() : d && "responsive" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());
            };

            f.prototype.collapseButtons = function (a) {
              var b = this.buttons,
                  c = this.buttonOptions,
                  d = this.chart,
                  e = this.dropdown,
                  f = this.options,
                  g = this.zoomText,
                  h = d.userOptions.rangeSelector && d.userOptions.rangeSelector.buttonTheme || {},
                  k = function k(a) {
                return {
                  text: a ? "" + a + " \u25BE" : "\u25BE",
                  width: "auto",
                  paddingLeft: z(f.buttonTheme.paddingLeft, h.padding, 8),
                  paddingRight: z(f.buttonTheme.paddingRight, h.padding, 8)
                };
              };

              g && g.hide();
              var l = !1;
              c.forEach(function (a, c) {
                c = b[c];
                2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), l = !0);
              });
              l || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));
              c = f.buttonPosition.align;
              this.positionButtons();
              "right" !== c && "center" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);
              this.showDropdown();
            };

            f.prototype.expandButtons = function () {
              var a = this.buttons,
                  c = this.buttonOptions,
                  d = this.options,
                  e = this.zoomText;
              this.hideDropdown();
              e && e.show();
              c.forEach(function (b, c) {
                c = a[c];
                c.show();
                c.attr({
                  text: b.text,
                  width: d.buttonTheme.width || 28,
                  paddingLeft: z(d.buttonTheme.paddingLeft, "unset"),
                  paddingRight: z(d.buttonTheme.paddingRight, "unset")
                });
                2 > c.state && c.setState(0);
              });
              this.positionButtons();
            };

            f.prototype.currentButtonIndex = function () {
              var a = this.dropdown;
              return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;
            };

            f.prototype.showDropdown = function () {
              var a = this.buttonGroup,
                  d = this.buttons,
                  e = this.chart,
                  f = this.dropdown;

              if (a && f) {
                var g = a.translateX;
                a = a.translateY;
                d = d[this.currentButtonIndex()].getBBox();
                c(f, {
                  left: e.plotLeft + g + "px",
                  top: a + .5 + "px",
                  width: d.width + "px",
                  height: d.height + "px"
                });
                this.hasVisibleDropdown = !0;
              }
            };

            f.prototype.hideDropdown = function () {
              var a = this.dropdown;
              a && (c(a, {
                top: "-9999em",
                width: "1px",
                height: "1px"
              }), this.hasVisibleDropdown = !1);
            };

            f.prototype.getHeight = function () {
              var a = this.options,
                  c = this.group,
                  d = a.y,
                  e = a.buttonPosition.y,
                  f = a.inputPosition.y;
              if (a.height) return a.height;
              this.alignElements();
              a = c ? c.getBBox(!0).height + 13 + d : 0;
              c = Math.min(f, e);
              if (0 > f && 0 > e || 0 < f && 0 < e) a += Math.abs(c);
              return a;
            };

            f.prototype.titleCollision = function (a) {
              return !(a.options.title.text || a.options.subtitle.text);
            };

            f.prototype.update = function (a) {
              var b = this.chart;
              L(!0, b.options.rangeSelector, a);
              this.destroy();
              this.init(b);
              this.render();
            };

            f.prototype.destroy = function () {
              var b = this,
                  c = b.minInput,
                  d = b.maxInput;
              b.eventsToUnbind && (b.eventsToUnbind.forEach(function (a) {
                return a();
              }), b.eventsToUnbind = void 0);
              a(b.buttons);
              c && (c.onfocus = c.onblur = c.onchange = null);
              d && (d.onfocus = d.onblur = d.onchange = null);
              J(b, function (a, c) {
                a && "chart" !== c && (a instanceof x ? a.destroy() : a instanceof U.HTMLElement && k(a));
                a !== f.prototype[c] && (b[c] = null);
              }, this);
            };

            return f;
          }();

          r.prototype.defaultButtons = [{
            type: "month",
            count: 1,
            text: "1m",
            title: "View 1 month"
          }, {
            type: "month",
            count: 3,
            text: "3m",
            title: "View 3 months"
          }, {
            type: "month",
            count: 6,
            text: "6m",
            title: "View 6 months"
          }, {
            type: "ytd",
            text: "YTD",
            title: "View year to date"
          }, {
            type: "year",
            count: 1,
            text: "1y",
            title: "View 1 year"
          }, {
            type: "all",
            text: "All",
            title: "View all"
          }];
          r.prototype.inputTypeFormats = {
            "datetime-local": "%Y-%m-%dT%H:%M:%S",
            date: "%Y-%m-%d",
            time: "%H:%M:%S"
          };

          d.prototype.minFromRange = function () {
            var a = this.range,
                b = a.type,
                c = this.max,
                d = this.chart.time,
                e = function e(a, c) {
              var e = "year" === b ? "FullYear" : "Month",
                  f = new d.Date(a),
                  g = d.get(e, f);
              d.set(e, f, g + c);
              g === d.get(e, f) && d.set("Date", f, 0);
              return f.getTime() - a;
            };

            if (F(a)) {
              var g = c - a;
              var h = a;
            } else a && (g = c + e(c, -(a.count || 1)), this.chart && (this.chart.fixedRange = c - g));

            var k = z(this.dataMin, Number.MIN_VALUE);
            F(g) || (g = k);
            g <= k && (g = k, "undefined" === typeof h && (h = e(g, a.count)), this.newMax = Math.min(g + h, z(this.dataMax, Number.MAX_VALUE)));
            F(c) ? !F(a) && a && a._offsetMin && (g += a._offsetMin) : g = void 0;
            return g;
          };

          if (!B.RangeSelector) {
            var h = [],
                n = function n(a) {
              function b() {
                d && (c = a.xAxis[0].getExtremes(), e = a.legend, g = d && d.options.verticalAlign, F(c.min) && d.render(c.min, c.max), e.display && "top" === g && g === e.options.verticalAlign && (f = L(a.spacingBox), f.y = "vertical" === e.options.layout ? a.plotTop : f.y + d.getHeight(), e.group.placed = !1, e.align(f)));
              }

              var c,
                  d = a.rangeSelector,
                  e,
                  f,
                  g;
              d && (m(h, function (b) {
                return b[0] === a;
              }) || h.push([a, [t(a.xAxis[0], "afterSetExtremes", function (a) {
                d && d.render(a.min, a.max);
              }), t(a, "redraw", b)]]), b());
            };

            t(g, "afterGetContainer", function () {
              this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new r(this));
            });
            t(g, "beforeRender", function () {
              var a = this.axes,
                  b = this.rangeSelector;
              b && (F(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {
                a.updateNames();
                a.setScale();
              }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || ("bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0)));
            });
            t(g, "update", function (a) {
              var b = a.options.rangeSelector;
              a = this.rangeSelector;
              var c = this.extraBottomMargin,
                  d = this.extraTopMargin;
              b && b.enabled && !l(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new r(this));
              this.extraTopMargin = this.extraBottomMargin = !1;
              a && (n(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || ("bottom" === b ? this.extraBottomMargin = !0 : "middle" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== c || this.extraTopMargin !== d) && (this.isDirtyBox = !0);
            });
            t(g, "render", function () {
              var a = this.rangeSelector;
              a && !a.options.floating && (a.render(), a = a.options.verticalAlign, "bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0));
            });
            t(g, "getMargins", function () {
              var a = this.rangeSelector;
              a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));
            });
            g.prototype.callbacks.push(n);
            t(g, "destroy", function () {
              for (var a = 0; a < h.length; a++) {
                var b = h[a];

                if (b[0] === this) {
                  b[1].forEach(function (a) {
                    return a();
                  });
                  h.splice(a, 1);
                  break;
                }
              }
            });
            B.RangeSelector = r;
          }

          return r;
        });
        P(g, "Core/Chart/StockChart.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/FormatUtilities.js"], g["Core/DefaultOptions.js"], g["Core/Series/Series.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Utilities.js"]], function (d, g, B, E, x, G, I, A) {
          function t(a, c) {
            return "xAxis" === a ? {
              minPadding: 0,
              maxPadding: 0,
              overscroll: 0,
              ordinal: !0,
              title: {
                text: null
              },
              labels: {
                overflow: "justify"
              },
              showLastLabel: !0
            } : "yAxis" === a ? {
              labels: {
                y: -2
              },
              opposite: y(c.opposite, !0),
              showLastLabel: !(!c.categories && "category" !== c.type),
              title: {
                text: null
              }
            } : {};
          }

          function q(c, d) {
            if ("xAxis" === c) {
              c = a();
              var e = {
                type: "datetime",
                categories: void 0
              };
              y(d.navigator && d.navigator.enabled, c.navigator.enabled, !0) && (e.startOnTick = !1, e.endOnTick = !1);
              return e;
            }

            return {};
          }

          var c = this && this.__extends || function () {
            var _a8 = function a(c, d) {
              _a8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _a8(c, d);
            };

            return function (c, d) {
              function e() {
                this.constructor = c;
              }

              _a8(c, d);

              c.prototype = null === d ? Object.create(d) : (e.prototype = d.prototype, new e());
            };
          }(),
              l = E.format,
              a = x.getOptions;

          d = A.addEvent;
          var k = A.clamp,
              v = A.defined,
              m = A.extend,
              C = A.find,
              F = A.isNumber,
              L = A.isString,
              J = A.merge,
              y = A.pick,
              z = A.splat;

          A = function (d) {
            function e() {
              return null !== d && d.apply(this, arguments) || this;
            }

            c(e, d);

            e.prototype.init = function (c, e) {
              var g = a(),
                  f = c.xAxis,
                  b = c.yAxis,
                  h = y(c.navigator && c.navigator.enabled, g.navigator.enabled, !0);
              c.xAxis = c.yAxis = void 0;
              h = J({
                chart: {
                  panning: {
                    enabled: !0,
                    type: "x"
                  },
                  pinchType: "x"
                },
                navigator: {
                  enabled: h
                },
                scrollbar: {
                  enabled: y(g.scrollbar && g.scrollbar.enabled, !0)
                },
                rangeSelector: {
                  enabled: y(g.rangeSelector.enabled, !0)
                },
                title: {
                  text: null
                },
                tooltip: {
                  split: y(g.tooltip.split, !0),
                  crosshairs: !0
                },
                legend: {
                  enabled: !1
                }
              }, c, {
                isStock: !0
              });
              c.xAxis = f;
              c.yAxis = b;
              h.xAxis = z(c.xAxis || {}).map(function (a, b) {
                return J(t("xAxis", a), g.xAxis, g.xAxis && g.xAxis[b], a, q("xAxis", c));
              });
              h.yAxis = z(c.yAxis || {}).map(function (a, b) {
                return J(t("yAxis", a), g.yAxis, g.yAxis && g.yAxis[b], a);
              });
              d.prototype.init.call(this, h, e);
            };

            e.prototype.createAxis = function (a, c) {
              c.axis = J(t(a, c.axis), c.axis, q(a, this.userOptions));
              return d.prototype.createAxis.call(this, a, c);
            };

            return e;
          }(B);

          (function (a) {
            a.stockChart = function (c, d, g) {
              return new a(c, d, g);
            };
          })(A || (A = {}));

          d(G, "setOptions", function (a) {
            var c;
            this.chart.options.isStock && (this.is("column") || this.is("columnrange") ? c = {
              borderWidth: 0,
              shadow: !1
            } : this.is("scatter") || this.is("sma") || (c = {
              marker: {
                enabled: !1,
                radius: 2
              }
            }), c && (a.plotOptions[this.type] = J(a.plotOptions[this.type], c)));
          });
          d(g, "autoLabelAlign", function (a) {
            var c = this.chart,
                d = this.options;
            c = c._labelPanes = c._labelPanes || {};
            var g = this.options.labels;
            this.chart.options.isStock && "yAxis" === this.coll && (d = d.top + "," + d.height, !c[d] && g.enabled && (15 === g.x && (g.x = 0), "undefined" === typeof g.align && (g.align = "right"), c[d] = this, a.align = "right", a.preventDefault()));
          });
          d(g, "destroy", function () {
            var a = this.chart,
                c = this.options && this.options.top + "," + this.options.height;
            c && a._labelPanes && a._labelPanes[c] === this && delete a._labelPanes[c];
          });
          d(g, "getPlotLinePath", function (a) {
            function c(a) {
              var b = "xAxis" === a ? "yAxis" : "xAxis";
              a = d.options[b];
              return F(a) ? [l[b][a]] : L(a) ? [l.get(a)] : g.map(function (a) {
                return a[b];
              });
            }

            var d = this,
                g = this.isLinked && !this.series ? this.linkedParent.series : this.series,
                l = d.chart,
                f = l.renderer,
                b = d.left,
                m = d.top,
                q,
                p,
                t,
                w,
                x = [],
                z = [],
                A = a.translatedValue,
                B = a.value,
                E = a.force;

            if (l.options.isStock && !1 !== a.acrossPanes && "xAxis" === d.coll || "yAxis" === d.coll) {
              a.preventDefault();
              z = c(d.coll);
              var G = d.isXAxis ? l.yAxis : l.xAxis;
              G.forEach(function (a) {
                if (v(a.options.id) ? -1 === a.options.id.indexOf("navigator") : 1) {
                  var b = a.isXAxis ? "yAxis" : "xAxis";
                  b = v(a.options[b]) ? l[b][a.options[b]] : l[b][0];
                  d === b && z.push(a);
                }
              });
              var I = z.length ? [] : [d.isXAxis ? l.yAxis[0] : l.xAxis[0]];
              z.forEach(function (a) {
                -1 !== I.indexOf(a) || C(I, function (b) {
                  return b.pos === a.pos && b.len === a.len;
                }) || I.push(a);
              });
              var J = y(A, d.translate(B, void 0, void 0, a.old));
              F(J) && (d.horiz ? I.forEach(function (a) {
                var c;
                p = a.pos;
                w = p + a.len;
                q = t = Math.round(J + d.transB);
                "pass" !== E && (q < b || q > b + d.width) && (E ? q = t = k(q, b, b + d.width) : c = !0);
                c || x.push(["M", q, p], ["L", t, w]);
              }) : I.forEach(function (a) {
                var b;
                q = a.pos;
                t = q + a.len;
                p = w = Math.round(m + d.height - J);
                "pass" !== E && (p < m || p > m + d.height) && (E ? p = w = k(p, m, m + d.height) : b = !0);
                b || x.push(["M", q, p], ["L", t, w]);
              }));
              a.path = 0 < x.length ? f.crispPolyLine(x, a.lineWidth || 1) : null;
            }
          });

          I.prototype.crispPolyLine = function (a, c) {
            for (var d = 0; d < a.length; d += 2) {
              var e = a[d],
                  g = a[d + 1];
              e[1] === g[1] && (e[1] = g[1] = Math.round(e[1]) - c % 2 / 2);
              e[2] === g[2] && (e[2] = g[2] = Math.round(e[2]) + c % 2 / 2);
            }

            return a;
          };

          d(g, "afterHideCrosshair", function () {
            this.crossLabel && (this.crossLabel = this.crossLabel.hide());
          });
          d(g, "afterDrawCrosshair", function (a) {
            var c, d;

            if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && F(this.min) && F(this.max)) {
              var g = this.chart,
                  k = this.logarithmic,
                  f = this.crosshair.label,
                  b = this.horiz,
                  q = this.opposite,
                  t = this.left,
                  p = this.top,
                  u = this.crossLabel,
                  v = f.format,
                  w = "",
                  x = "inside" === this.options.tickPosition,
                  z = !1 !== this.crosshair.snap,
                  A = 0,
                  B = a.e || this.cross && this.cross.e;
              a = a.point;
              var C = this.min,
                  E = this.max;
              k && (C = k.lin2log(C), E = k.lin2log(E));
              k = b ? "center" : q ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
              u || (u = this.crossLabel = g.renderer.label("", 0, void 0, f.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (a ? a.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
                align: f.align || k,
                padding: y(f.padding, 8),
                r: y(f.borderRadius, 3),
                zIndex: 2
              }).add(this.labelGroup), g.styledMode || u.attr({
                fill: f.backgroundColor || a && a.series && a.series.color || "#666666",
                stroke: f.borderColor || "",
                "stroke-width": f.borderWidth || 0
              }).css(m({
                color: "#ffffff",
                fontWeight: "normal",
                fontSize: "11px",
                textAlign: "center"
              }, f.style || {})));
              b ? (k = z ? (a.plotX || 0) + t : B.chartX, p += q ? 0 : this.height) : (k = q ? this.width + t : 0, p = z ? (a.plotY || 0) + p : B.chartY);
              v || f.formatter || (this.dateTime && (w = "%b %d, %Y"), v = "{value" + (w ? ":" + w : "") + "}");
              w = z ? this.isXAxis ? a.x : a.y : this.toValue(b ? B.chartX : B.chartY);
              z = a ? a.series.isPointInside(a) : F(w) && w > C && w < E;
              B = "";
              v ? B = l(v, {
                value: w
              }, g) : f.formatter && F(w) && (B = f.formatter.call(this, w));
              u.attr({
                text: B,
                x: k,
                y: p,
                visibility: z ? "inherit" : "hidden"
              });
              f = u.getBBox();
              if (F(u.y)) if (b) {
                if (x && !q || !x && q) p = u.y - f.height;
              } else p = u.y - f.height / 2;
              b ? (c = t - f.x, d = t + this.width - f.x) : (c = "left" === this.labelAlign ? t : 0, d = "right" === this.labelAlign ? t + this.width : g.chartWidth);
              u.translateX < c && (A = c - u.translateX);
              u.translateX + f.width >= d && (A = -(u.translateX + f.width - d));
              u.attr({
                x: k + A,
                y: p,
                anchorX: b ? k : this.opposite ? 0 : g.chartWidth,
                anchorY: b ? this.opposite ? g.chartHeight : 0 : p + f.height / 2
              });
            }
          });

          G.prototype.forceCropping = function () {
            var a = this.chart,
                c = this.options.dataGrouping;
            return !1 !== this.allowDG && c && y(c.enabled, a.options.isStock);
          };

          d(B, "update", function (a) {
            a = a.options;
            "scrollbar" in a && this.navigator && (J(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);
          });
          return A;
        });
        P(g, "masters/modules/stock.src.js", [g["Core/Globals.js"], g["Core/Axis/OrdinalAxis.js"], g["Series/DataModifyComposition.js"], g["Core/Scrollbar.js"], g["Core/Chart/StockChart.js"]], function (d, g, B, E, x) {
          d.Scrollbar = E;
          d.StockChart = d.stockChart = x.stockChart;
          E.compose(d.Axis);
          g.compose(d.Axis, d.Series, d.Chart);
          B.compose(d.Series, d.Axis, d.Point);
        });
        P(g, "masters/highstock.src.js", [g["masters/highcharts.src.js"]], function (d) {
          d.product = "Highstock";
          return d;
        });
        g["masters/highstock.src.js"]._modules = g;
        return g["masters/highstock.src.js"];
      }); //# sourceMappingURL=highstock.js.map

      /***/

    },

    /***/
    "ZivX":
    /*!*****************************************************!*\
      !*** ./node_modules/highcharts/highcharts-gantt.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function ZivX(module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*
      Highcharts Gantt JS v10.2.0 (2022-07-05)
      (c) 2017-2021 Lars Cabrera, Torstein Honsi, Jon Arild Nygard & Oystein Moseng
      License: www.highcharts.com/license
      */


      (function (U, N) {
        true && module.exports ? (N["default"] = N, module.exports = U.document ? N(U) : N) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return N(U);
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
      })("undefined" !== typeof window ? window : this, function (U) {
        function N(G, n, e, H) {
          G.hasOwnProperty(n) || (G[n] = H.apply(null, e), "function" === typeof CustomEvent && U.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
            detail: {
              path: n,
              module: G[n]
            }
          })));
        }

        var e = {};
        N(e, "Core/Globals.js", [], function () {
          var G;

          (function (n) {
            n.SVG_NS = "http://www.w3.org/2000/svg";
            n.product = "Highcharts";
            n.version = "10.2.0";
            n.win = "undefined" !== typeof U ? U : {};
            n.doc = n.win.document;
            n.svg = n.doc && n.doc.createElementNS && !!n.doc.createElementNS(n.SVG_NS, "svg").createSVGRect;
            n.userAgent = n.win.navigator && n.win.navigator.userAgent || "";
            n.isChrome = -1 !== n.userAgent.indexOf("Chrome");
            n.isFirefox = -1 !== n.userAgent.indexOf("Firefox");
            n.isMS = /(edge|msie|trident)/i.test(n.userAgent) && !n.win.opera;
            n.isSafari = !n.isChrome && -1 !== n.userAgent.indexOf("Safari");
            n.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(n.userAgent);
            n.isWebKit = -1 !== n.userAgent.indexOf("AppleWebKit");
            n.deg2rad = 2 * Math.PI / 360;
            n.hasBidiBug = n.isFirefox && 4 > parseInt(n.userAgent.split("Firefox/")[1], 10);
            n.hasTouch = !!n.win.TouchEvent;
            n.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];

            n.noop = function () {};

            n.supportsPassiveEvents = function () {
              var G = !1;

              if (!n.isMS) {
                var e = Object.defineProperty({}, "passive", {
                  get: function get() {
                    G = !0;
                  }
                });
                n.win.addEventListener && n.win.removeEventListener && (n.win.addEventListener("testPassive", n.noop, e), n.win.removeEventListener("testPassive", n.noop, e));
              }

              return G;
            }();

            n.charts = [];
            n.dateFormats = {};
            n.seriesTypes = {};
            n.symbolSizes = {};
            n.chartCount = 0;
          })(G || (G = {}));

          "";
          return G;
        });
        N(e, "Core/Utilities.js", [e["Core/Globals.js"]], function (G) {
          function n(k, h, d, m) {
            var u = h ? "Highcharts error" : "Highcharts warning";
            32 === k && (k = "" + u + ": Deprecated member");
            var A = q(k),
                O = A ? "" + u + " #" + k + ": www.highcharts.com/errors/" + k + "/" : k.toString();

            if ("undefined" !== typeof m) {
              var b = "";
              A && (O += "?");
              C(m, function (v, h) {
                b += "\n - ".concat(h, ": ").concat(v);
                A && (O += encodeURI(h) + "=" + encodeURI(v));
              });
              O += b;
            }

            p(G, "displayError", {
              chart: d,
              code: k,
              message: O,
              params: m
            }, function () {
              if (h) throw Error(O);
              a.console && -1 === n.messages.indexOf(O) && console.warn(O);
            });
            n.messages.push(O);
          }

          function e(k, h) {
            var a = {};
            C(k, function (d, u) {
              if (I(k[u], !0) && !k.nodeType && h[u]) d = e(k[u], h[u]), Object.keys(d).length && (a[u] = d);else if (I(k[u]) || k[u] !== h[u] || u in k && !(u in h)) a[u] = k[u];
            });
            return a;
          }

          function H(k, h) {
            return parseInt(k, h || 10);
          }

          function B(k) {
            return "string" === typeof k;
          }

          function E(k) {
            k = Object.prototype.toString.call(k);
            return "[object Array]" === k || "[object Array Iterator]" === k;
          }

          function I(k, h) {
            return !!k && "object" === typeof k && (!h || !E(k));
          }

          function y(k) {
            return I(k) && "number" === typeof k.nodeType;
          }

          function r(k) {
            var h = k && k.constructor;
            return !(!I(k, !0) || y(k) || !h || !h.name || "Object" === h.name);
          }

          function q(k) {
            return "number" === typeof k && !isNaN(k) && Infinity > k && -Infinity < k;
          }

          function c(k) {
            return "undefined" !== typeof k && null !== k;
          }

          function g(k, h, a) {
            var d = B(h) && !c(a),
                u,
                m = function m(h, a) {
              c(h) ? k.setAttribute(a, h) : d ? (u = k.getAttribute(a)) || "class" !== a || (u = k.getAttribute(a + "Name")) : k.removeAttribute(a);
            };

            B(h) ? m(a, h) : C(h, m);
            return u;
          }

          function l(k, h) {
            var a;
            k || (k = {});

            for (a in h) {
              k[a] = h[a];
            }

            return k;
          }

          function x() {
            for (var k = arguments, h = k.length, a = 0; a < h; a++) {
              var d = k[a];
              if ("undefined" !== typeof d && null !== d) return d;
            }
          }

          function f(k, h) {
            G.isMS && !G.svg && h && c(h.opacity) && (h.filter = "alpha(opacity=".concat(100 * h.opacity, ")"));
            l(k.style, h);
          }

          function b(k) {
            return Math.pow(10, Math.floor(Math.log(k) / Math.LN10));
          }

          function w(k, h) {
            return 1E14 < k ? k : parseFloat(k.toPrecision(h || 14));
          }

          function J(k, h, d) {
            var m = G.getStyle || J;
            if ("width" === h) return h = Math.min(k.offsetWidth, k.scrollWidth), d = k.getBoundingClientRect && k.getBoundingClientRect().width, d < h && d >= h - 1 && (h = Math.floor(d)), Math.max(0, h - (m(k, "padding-left", !0) || 0) - (m(k, "padding-right", !0) || 0));
            if ("height" === h) return Math.max(0, Math.min(k.offsetHeight, k.scrollHeight) - (m(k, "padding-top", !0) || 0) - (m(k, "padding-bottom", !0) || 0));
            a.getComputedStyle || n(27, !0);

            if (k = a.getComputedStyle(k, void 0)) {
              var u = k.getPropertyValue(h);
              x(d, "opacity" !== h) && (u = H(u));
            }

            return u;
          }

          function C(k, h, a) {
            for (var d in k) {
              Object.hasOwnProperty.call(k, d) && h.call(a || k[d], k[d], d, k);
            }
          }

          function K(a, h, d) {
            function k(h, v) {
              var k = a.removeEventListener || G.removeEventListenerPolyfill;
              k && k.call(a, h, v, !1);
            }

            function u(d) {
              var v;

              if (a.nodeName) {
                if (h) {
                  var M = {};
                  M[h] = !0;
                } else M = d;

                C(M, function (h, a) {
                  if (d[a]) for (v = d[a].length; v--;) {
                    k(a, d[a][v].fn);
                  }
                });
              }
            }

            var m = "function" === typeof a && a.prototype || a;

            if (Object.hasOwnProperty.call(m, "hcEvents")) {
              var O = m.hcEvents;
              h ? (m = O[h] || [], d ? (O[h] = m.filter(function (h) {
                return d !== h.fn;
              }), k(h, d)) : (u(O), O[h] = [])) : (u(O), delete m.hcEvents);
            }
          }

          function p(a, h, d, m) {
            d = d || {};

            if (t.createEvent && (a.dispatchEvent || a.fireEvent && a !== G)) {
              var k = t.createEvent("Events");
              k.initEvent(h, !0, !0);
              d = l(k, d);
              a.dispatchEvent ? a.dispatchEvent(d) : a.fireEvent(h, d);
            } else if (a.hcEvents) {
              d.target || l(d, {
                preventDefault: function preventDefault() {
                  d.defaultPrevented = !0;
                },
                target: a,
                type: h
              });
              k = [];

              for (var A = a, O = !1; A.hcEvents;) {
                Object.hasOwnProperty.call(A, "hcEvents") && A.hcEvents[h] && (k.length && (O = !0), k.unshift.apply(k, A.hcEvents[h])), A = Object.getPrototypeOf(A);
              }

              O && k.sort(function (h, v) {
                return h.order - v.order;
              });
              k.forEach(function (h) {
                !1 === h.fn.call(a, d) && d.preventDefault();
              });
            }

            m && !d.defaultPrevented && m.call(a, d);
          }

          var m = G.charts,
              t = G.doc,
              a = G.win;
          (n || (n = {})).messages = [];

          Math.easeInOutSine = function (a) {
            return -.5 * (Math.cos(Math.PI * a) - 1);
          };

          var z = Array.prototype.find ? function (a, h) {
            return a.find(h);
          } : function (a, h) {
            var k,
                d = a.length;

            for (k = 0; k < d; k++) {
              if (h(a[k], k)) return a[k];
            }
          };
          C({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function (a, h) {
            G[h] = function (k) {
              var d;
              n(32, !1, void 0, (d = {}, d["Highcharts.".concat(h)] = "use Array.".concat(a), d));
              return Array.prototype[a].apply(k, [].slice.call(arguments, 1));
            };
          });

          var d,
              F = function () {
            var a = Math.random().toString(36).substring(2, 9) + "-",
                h = 0;
            return function () {
              return "highcharts-" + (d ? "" : a) + h++;
            };
          }();

          a.jQuery && (a.jQuery.fn.highcharts = function () {
            var a = [].slice.call(arguments);
            if (this[0]) return a[0] ? (new G[B(a[0]) ? a.shift() : "Chart"](this[0], a[0], a[1]), this) : m[g(this[0], "data-highcharts-chart")];
          });
          z = {
            addEvent: function addEvent(a, h, d, m) {
              void 0 === m && (m = {});
              var k = "function" === typeof a && a.prototype || a;
              Object.hasOwnProperty.call(k, "hcEvents") || (k.hcEvents = {});
              k = k.hcEvents;
              G.Point && a instanceof G.Point && a.series && a.series.chart && (a.series.chart.runTrackerClick = !0);
              var A = a.addEventListener || G.addEventListenerPolyfill;
              A && A.call(a, h, d, G.supportsPassiveEvents ? {
                passive: void 0 === m.passive ? -1 !== h.indexOf("touch") : m.passive,
                capture: !1
              } : !1);
              k[h] || (k[h] = []);
              k[h].push({
                fn: d,
                order: "number" === typeof m.order ? m.order : Infinity
              });
              k[h].sort(function (a, h) {
                return a.order - h.order;
              });
              return function () {
                K(a, h, d);
              };
            },
            arrayMax: function arrayMax(a) {
              for (var h = a.length, k = a[0]; h--;) {
                a[h] > k && (k = a[h]);
              }

              return k;
            },
            arrayMin: function arrayMin(a) {
              for (var h = a.length, k = a[0]; h--;) {
                a[h] < k && (k = a[h]);
              }

              return k;
            },
            attr: g,
            clamp: function clamp(a, h, d) {
              return a > h ? a < d ? a : d : h;
            },
            cleanRecursively: e,
            clearTimeout: function (_clearTimeout2) {
              function clearTimeout(_x2) {
                return _clearTimeout2.apply(this, arguments);
              }

              clearTimeout.toString = function () {
                return _clearTimeout2.toString();
              };

              return clearTimeout;
            }(function (a) {
              c(a) && clearTimeout(a);
            }),
            correctFloat: w,
            createElement: function createElement(a, h, d, m, u) {
              a = t.createElement(a);
              h && l(a, h);
              u && f(a, {
                padding: "0",
                border: "none",
                margin: "0"
              });
              d && f(a, d);
              m && m.appendChild(a);
              return a;
            },
            css: f,
            defined: c,
            destroyObjectProperties: function destroyObjectProperties(a, h) {
              C(a, function (d, k) {
                d && d !== h && d.destroy && d.destroy();
                delete a[k];
              });
            },
            discardElement: function discardElement(a) {
              a && a.parentElement && a.parentElement.removeChild(a);
            },
            erase: function erase(a, h) {
              for (var d = a.length; d--;) {
                if (a[d] === h) {
                  a.splice(d, 1);
                  break;
                }
              }
            },
            error: n,
            extend: l,
            extendClass: function extendClass(a, h) {
              var d = function d() {};

              d.prototype = new a();
              l(d.prototype, h);
              return d;
            },
            find: z,
            fireEvent: p,
            getMagnitude: b,
            getNestedProperty: function getNestedProperty(d, h) {
              for (d = d.split("."); d.length && c(h);) {
                var k = d.shift();
                if ("undefined" === typeof k || "__proto__" === k) return;
                h = h[k];
                if (!c(h) || "function" === typeof h || "number" === typeof h.nodeType || h === a) return;
              }

              return h;
            },
            getStyle: J,
            inArray: function inArray(a, h, d) {
              n(32, !1, void 0, {
                "Highcharts.inArray": "use Array.indexOf"
              });
              return h.indexOf(a, d);
            },
            isArray: E,
            isClass: r,
            isDOMElement: y,
            isFunction: function isFunction(a) {
              return "function" === typeof a;
            },
            isNumber: q,
            isObject: I,
            isString: B,
            keys: function keys(a) {
              n(32, !1, void 0, {
                "Highcharts.keys": "use Object.keys"
              });
              return Object.keys(a);
            },
            merge: function merge() {
              var a,
                  h = arguments,
                  d = {},
                  m = function m(a, h) {
                "object" !== typeof a && (a = {});
                C(h, function (d, v) {
                  "__proto__" !== v && "constructor" !== v && (!I(d, !0) || r(d) || y(d) ? a[v] = h[v] : a[v] = m(a[v] || {}, d));
                });
                return a;
              };

              !0 === h[0] && (d = h[1], h = Array.prototype.slice.call(h, 2));
              var u = h.length;

              for (a = 0; a < u; a++) {
                d = m(d, h[a]);
              }

              return d;
            },
            normalizeTickInterval: function normalizeTickInterval(a, h, d, m, u) {
              var k = a;
              d = x(d, b(a));
              var O = a / d;
              h || (h = u ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === m && (1 === d ? h = h.filter(function (a) {
                return 0 === a % 1;
              }) : .1 >= d && (h = [1 / d])));

              for (m = 0; m < h.length && !(k = h[m], u && k * d >= a || !u && O <= (h[m] + (h[m + 1] || h[m])) / 2); m++) {
                ;
              }

              return k = w(k * d, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: C,
            offset: function offset(d) {
              var h = t.documentElement;
              d = d.parentElement || d.parentNode ? d.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
              };
              return {
                top: d.top + (a.pageYOffset || h.scrollTop) - (h.clientTop || 0),
                left: d.left + (a.pageXOffset || h.scrollLeft) - (h.clientLeft || 0),
                width: d.width,
                height: d.height
              };
            },
            pad: function pad(a, h, d) {
              return Array((h || 2) + 1 - String(a).replace("-", "").length).join(d || "0") + a;
            },
            pick: x,
            pInt: H,
            relativeLength: function relativeLength(a, h, d) {
              return /%$/.test(a) ? h * parseFloat(a) / 100 + (d || 0) : parseFloat(a);
            },
            removeEvent: K,
            splat: function splat(a) {
              return E(a) ? a : [a];
            },
            stableSort: function stableSort(a, h) {
              var d = a.length,
                  k,
                  m;

              for (m = 0; m < d; m++) {
                a[m].safeI = m;
              }

              a.sort(function (a, d) {
                k = h(a, d);
                return 0 === k ? a.safeI - d.safeI : k;
              });

              for (m = 0; m < d; m++) {
                delete a[m].safeI;
              }
            },
            syncTimeout: function syncTimeout(a, d, m) {
              if (0 < d) return setTimeout(a, d, m);
              a.call(0, m);
              return -1;
            },
            timeUnits: {
              millisecond: 1,
              second: 1E3,
              minute: 6E4,
              hour: 36E5,
              day: 864E5,
              week: 6048E5,
              month: 24192E5,
              year: 314496E5
            },
            uniqueKey: F,
            useSerialIds: function useSerialIds(a) {
              return d = x(a, d);
            },
            wrap: function wrap(a, d, m) {
              var h = a[d];

              a[d] = function () {
                var a = Array.prototype.slice.call(arguments),
                    d = arguments,
                    k = this;

                k.proceed = function () {
                  h.apply(k, arguments.length ? arguments : d);
                };

                a.unshift(h);
                a = m.apply(this, a);
                k.proceed = null;
                return a;
              };
            }
          };
          "";
          return z;
        });
        N(e, "Core/Chart/ChartDefaults.js", [], function () {
          return {
            alignThresholds: !1,
            panning: {
              enabled: !1,
              type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            allowMutatingData: !0,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: "#335cad",
            backgroundColor: "#ffffff",
            plotBorderColor: "#cccccc"
          };
        });
        N(e, "Core/Color/Color.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (G, n) {
          var e = n.isNumber,
              H = n.merge,
              B = n.pInt;

          n = function () {
            function n(e) {
              this.rgba = [NaN, NaN, NaN, NaN];
              this.input = e;
              var y = G.Color;
              if (y && y !== n) return new y(e);
              if (!(this instanceof n)) return new n(e);
              this.init(e);
            }

            n.parse = function (e) {
              return e ? new n(e) : n.None;
            };

            n.prototype.init = function (e) {
              var y;
              if ("object" === typeof e && "undefined" !== typeof e.stops) this.stops = e.stops.map(function (c) {
                return new n(c[1]);
              });else if ("string" === typeof e) {
                this.input = e = n.names[e.toLowerCase()] || e;

                if ("#" === e.charAt(0)) {
                  var r = e.length;
                  var q = parseInt(e.substr(1), 16);
                  7 === r ? y = [(q & 16711680) >> 16, (q & 65280) >> 8, q & 255, 1] : 4 === r && (y = [(q & 3840) >> 4 | (q & 3840) >> 8, (q & 240) >> 4 | q & 240, (q & 15) << 4 | q & 15, 1]);
                }

                if (!y) for (q = n.parsers.length; q-- && !y;) {
                  var c = n.parsers[q];
                  (r = c.regex.exec(e)) && (y = c.parse(r));
                }
              }
              y && (this.rgba = y);
            };

            n.prototype.get = function (n) {
              var y = this.input,
                  r = this.rgba;

              if ("object" === typeof y && "undefined" !== typeof this.stops) {
                var q = H(y);
                q.stops = [].slice.call(q.stops);
                this.stops.forEach(function (c, g) {
                  q.stops[g] = [q.stops[g][0], c.get(n)];
                });
                return q;
              }

              return r && e(r[0]) ? "rgb" === n || !n && 1 === r[3] ? "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")" : "a" === n ? "".concat(r[3]) : "rgba(" + r.join(",") + ")" : y;
            };

            n.prototype.brighten = function (n) {
              var y = this.rgba;
              if (this.stops) this.stops.forEach(function (q) {
                q.brighten(n);
              });else if (e(n) && 0 !== n) for (var r = 0; 3 > r; r++) {
                y[r] += B(255 * n), 0 > y[r] && (y[r] = 0), 255 < y[r] && (y[r] = 255);
              }
              return this;
            };

            n.prototype.setOpacity = function (n) {
              this.rgba[3] = n;
              return this;
            };

            n.prototype.tweenTo = function (n, y) {
              var r = this.rgba,
                  q = n.rgba;
              if (!e(r[0]) || !e(q[0])) return n.input || "none";
              n = 1 !== q[3] || 1 !== r[3];
              return (n ? "rgba(" : "rgb(") + Math.round(q[0] + (r[0] - q[0]) * (1 - y)) + "," + Math.round(q[1] + (r[1] - q[1]) * (1 - y)) + "," + Math.round(q[2] + (r[2] - q[2]) * (1 - y)) + (n ? "," + (q[3] + (r[3] - q[3]) * (1 - y)) : "") + ")";
            };

            n.names = {
              white: "#ffffff",
              black: "#000000"
            };
            n.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(n) {
                return [B(n[1]), B(n[2]), B(n[3]), parseFloat(n[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(n) {
                return [B(n[1]), B(n[2]), B(n[3]), 1];
              }
            }];
            n.None = new n("");
            return n;
          }();

          "";
          return n;
        });
        N(e, "Core/Color/Palettes.js", [], function () {
          return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
          };
        });
        N(e, "Core/Time.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n) {
          var G = e.win,
              H = n.defined,
              B = n.error,
              E = n.extend,
              I = n.isObject,
              y = n.merge,
              r = n.objectEach,
              q = n.pad,
              c = n.pick,
              g = n.splat,
              l = n.timeUnits,
              x = e.isSafari && G.Intl && G.Intl.DateTimeFormat.prototype.formatRange,
              f = e.isSafari && G.Intl && !G.Intl.DateTimeFormat.prototype.formatRange;

          n = function () {
            function b(b) {
              this.options = {};
              this.variableTimezone = this.useUTC = !1;
              this.Date = G.Date;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.update(b);
            }

            b.prototype.get = function (b, f) {
              if (this.variableTimezone || this.timezoneOffset) {
                var w = f.getTime(),
                    J = w - this.getTimezoneOffset(f);
                f.setTime(J);
                b = f["getUTC" + b]();
                f.setTime(w);
                return b;
              }

              return this.useUTC ? f["getUTC" + b]() : f["get" + b]();
            };

            b.prototype.set = function (b, f, c) {
              if (this.variableTimezone || this.timezoneOffset) {
                if ("Milliseconds" === b || "Seconds" === b || "Minutes" === b && 0 === this.getTimezoneOffset(f) % 36E5) return f["setUTC" + b](c);
                var w = this.getTimezoneOffset(f);
                w = f.getTime() - w;
                f.setTime(w);
                f["setUTC" + b](c);
                b = this.getTimezoneOffset(f);
                w = f.getTime() + b;
                return f.setTime(w);
              }

              return this.useUTC || x && "FullYear" === b ? f["setUTC" + b](c) : f["set" + b](c);
            };

            b.prototype.update = function (b) {
              var w = c(b && b.useUTC, !0);
              this.options = b = y(!0, this.options || {}, b);
              this.Date = b.Date || G.Date || Date;
              this.timezoneOffset = (this.useUTC = w) && b.timezoneOffset || void 0;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.variableTimezone = w && !(!b.getTimezoneOffset && !b.timezone);
            };

            b.prototype.makeTime = function (b, g, l, x, p, m) {
              if (this.useUTC) {
                var t = this.Date.UTC.apply(0, arguments);
                var a = this.getTimezoneOffset(t);
                t += a;
                var z = this.getTimezoneOffset(t);
                a !== z ? t += z - a : a - 36E5 !== this.getTimezoneOffset(t - 36E5) || f || (t -= 36E5);
              } else t = new this.Date(b, g, c(l, 1), c(x, 0), c(p, 0), c(m, 0)).getTime();

              return t;
            };

            b.prototype.timezoneOffsetFunction = function () {
              var b = this,
                  f = this.options,
                  c = f.getTimezoneOffset,
                  g = f.moment || G.moment;
              if (!this.useUTC) return function (b) {
                return 6E4 * new Date(b.toString()).getTimezoneOffset();
              };

              if (f.timezone) {
                if (g) return function (b) {
                  return 6E4 * -g.tz(b, f.timezone).utcOffset();
                };
                B(25);
              }

              return this.useUTC && c ? function (b) {
                return 6E4 * c(b.valueOf());
              } : function () {
                return 6E4 * (b.timezoneOffset || 0);
              };
            };

            b.prototype.dateFormat = function (b, f, g) {
              if (!H(f) || isNaN(f)) return e.defaultOptions.lang && e.defaultOptions.lang.invalidDate || "";
              b = c(b, "%Y-%m-%d %H:%M:%S");
              var w = this,
                  p = new this.Date(f),
                  m = this.get("Hours", p),
                  t = this.get("Day", p),
                  a = this.get("Date", p),
                  z = this.get("Month", p),
                  d = this.get("FullYear", p),
                  F = e.defaultOptions.lang,
                  k = F && F.weekdays,
                  h = F && F.shortWeekdays;
              p = E({
                a: h ? h[t] : k[t].substr(0, 3),
                A: k[t],
                d: q(a),
                e: q(a, 2, " "),
                w: t,
                b: F.shortMonths[z],
                B: F.months[z],
                m: q(z + 1),
                o: z + 1,
                y: d.toString().substr(2, 2),
                Y: d,
                H: q(m),
                k: m,
                I: q(m % 12 || 12),
                l: m % 12 || 12,
                M: q(this.get("Minutes", p)),
                p: 12 > m ? "AM" : "PM",
                P: 12 > m ? "am" : "pm",
                S: q(p.getSeconds()),
                L: q(Math.floor(f % 1E3), 3)
              }, e.dateFormats);
              r(p, function (a, d) {
                for (; -1 !== b.indexOf("%" + d);) {
                  b = b.replace("%" + d, "function" === typeof a ? a.call(w, f) : a);
                }
              });
              return g ? b.substr(0, 1).toUpperCase() + b.substr(1) : b;
            };

            b.prototype.resolveDTLFormat = function (b) {
              return I(b, !0) ? b : (b = g(b), {
                main: b[0],
                from: b[1],
                to: b[2]
              });
            };

            b.prototype.getTimeTicks = function (b, f, g, x) {
              var p = this,
                  m = [],
                  t = {},
                  a = new p.Date(f),
                  z = b.unitRange,
                  d = b.count || 1,
                  w;
              x = c(x, 1);

              if (H(f)) {
                p.set("Milliseconds", a, z >= l.second ? 0 : d * Math.floor(p.get("Milliseconds", a) / d));
                z >= l.second && p.set("Seconds", a, z >= l.minute ? 0 : d * Math.floor(p.get("Seconds", a) / d));
                z >= l.minute && p.set("Minutes", a, z >= l.hour ? 0 : d * Math.floor(p.get("Minutes", a) / d));
                z >= l.hour && p.set("Hours", a, z >= l.day ? 0 : d * Math.floor(p.get("Hours", a) / d));
                z >= l.day && p.set("Date", a, z >= l.month ? 1 : Math.max(1, d * Math.floor(p.get("Date", a) / d)));

                if (z >= l.month) {
                  p.set("Month", a, z >= l.year ? 0 : d * Math.floor(p.get("Month", a) / d));
                  var k = p.get("FullYear", a);
                }

                z >= l.year && p.set("FullYear", a, k - k % d);
                z === l.week && (k = p.get("Day", a), p.set("Date", a, p.get("Date", a) - k + x + (k < x ? -7 : 0)));
                k = p.get("FullYear", a);
                x = p.get("Month", a);
                var h = p.get("Date", a),
                    L = p.get("Hours", a);
                f = a.getTime();
                !p.variableTimezone && p.useUTC || !H(g) || (w = g - f > 4 * l.month || p.getTimezoneOffset(f) !== p.getTimezoneOffset(g));
                f = a.getTime();

                for (a = 1; f < g;) {
                  m.push(f), f = z === l.year ? p.makeTime(k + a * d, 0) : z === l.month ? p.makeTime(k, x + a * d) : !w || z !== l.day && z !== l.week ? w && z === l.hour && 1 < d ? p.makeTime(k, x, h, L + a * d) : f + z * d : p.makeTime(k, x, h + a * d * (z === l.day ? 1 : 7)), a++;
                }

                m.push(f);
                z <= l.hour && 1E4 > m.length && m.forEach(function (a) {
                  0 === a % 18E5 && "000000000" === p.dateFormat("%H%M%S%L", a) && (t[a] = "day");
                });
              }

              m.info = E(b, {
                higherRanks: t,
                totalRange: z * d
              });
              return m;
            };

            b.prototype.getDateFormat = function (b, f, c, g) {
              var p = this.dateFormat("%m-%d %H:%M:%S.%L", f),
                  m = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
              },
                  t = "millisecond";

              for (a in l) {
                if (b === l.week && +this.dateFormat("%w", f) === c && "00:00:00.000" === p.substr(6)) {
                  var a = "week";
                  break;
                }

                if (l[a] > b) {
                  a = t;
                  break;
                }

                if (m[a] && p.substr(m[a]) !== "01-01 00:00:00.000".substr(m[a])) break;
                "week" !== a && (t = a);
              }

              return this.resolveDTLFormat(g[a]).main;
            };

            return b;
          }();

          "";
          return n;
        });
        N(e, "Core/DefaultOptions.js", [e["Core/Chart/ChartDefaults.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Color/Palettes.js"], e["Core/Time.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E) {
          n = n.parse;
          var G = E.merge,
              y = {
            colors: H.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
              loading: "Loading...",
              months: "January February March April May June July August September October November December".split(" "),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
              weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
              decimalPoint: ".",
              numericSymbols: "kMGTPE".split(""),
              resetZoom: "Reset zoom",
              resetZoomTitle: "Reset zoom level 1:1",
              thousandsSep: " "
            },
            global: {},
            time: {
              Date: void 0,
              getTimezoneOffset: void 0,
              timezone: void 0,
              timezoneOffset: 0,
              useUTC: !0
            },
            chart: e,
            title: {
              text: "Chart title",
              align: "center",
              margin: 15,
              widthAdjust: -44
            },
            subtitle: {
              text: "",
              align: "center",
              widthAdjust: -44
            },
            caption: {
              margin: 15,
              text: "",
              align: "left",
              verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
              style: {
                position: "absolute",
                color: "#333333"
              }
            },
            legend: {
              enabled: !0,
              align: "center",
              alignColumns: !0,
              className: "highcharts-no-tooltip",
              layout: "horizontal",
              labelFormatter: function labelFormatter() {
                return this.name;
              },
              borderColor: "#999999",
              borderRadius: 0,
              navigation: {
                activeColor: "#003399",
                inactiveColor: "#cccccc"
              },
              itemStyle: {
                color: "#333333",
                cursor: "pointer",
                fontSize: "12px",
                fontWeight: "bold",
                textOverflow: "ellipsis"
              },
              itemHoverStyle: {
                color: "#000000"
              },
              itemHiddenStyle: {
                color: "#cccccc"
              },
              shadow: !1,
              itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
              },
              squareSymbol: !0,
              symbolPadding: 5,
              verticalAlign: "bottom",
              x: 0,
              y: 0,
              title: {
                style: {
                  fontWeight: "bold"
                }
              }
            },
            loading: {
              labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
              },
              style: {
                position: "absolute",
                backgroundColor: "#ffffff",
                opacity: .5,
                textAlign: "center"
              }
            },
            tooltip: {
              enabled: !0,
              animation: D.svg,
              borderRadius: 3,
              dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
              },
              footerFormat: "",
              headerShape: "callout",
              hideDelay: 500,
              padding: 8,
              shape: "callout",
              shared: !1,
              snap: D.isTouchDevice ? 25 : 10,
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
              backgroundColor: n("#f7f7f7").setOpacity(.85).get(),
              borderWidth: 1,
              shadow: !0,
              stickOnContact: !1,
              style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                whiteSpace: "nowrap"
              },
              useHTML: !1
            },
            credits: {
              enabled: !0,
              href: "https://www.highcharts.com?credits",
              position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
              },
              style: {
                cursor: "pointer",
                color: "#999999",
                fontSize: "9px"
              },
              text: "Highcharts.com"
            }
          };
          y.chart.styledMode = !1;
          "";
          var r = new B(G(y.global, y.time));
          e = {
            defaultOptions: y,
            defaultTime: r,
            getOptions: function getOptions() {
              return y;
            },
            setOptions: function setOptions(q) {
              G(!0, y, q);
              if (q.time || q.global) D.time ? D.time.update(G(y.global, y.time, q.global, q.time)) : D.time = r;
              return y;
            }
          };
          "";
          return e;
        });
        N(e, "Core/Animation/Fx.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = e.parse,
              B = n.win,
              E = D.isNumber,
              I = D.objectEach;
          return function () {
            function y(r, q, c) {
              this.pos = NaN;
              this.options = q;
              this.elem = r;
              this.prop = c;
            }

            y.prototype.dSetter = function () {
              var r = this.paths,
                  q = r && r[0];
              r = r && r[1];
              var c = this.now || 0,
                  g = [];
              if (1 !== c && q && r) {
                if (q.length === r.length && 1 > c) for (var l = 0; l < r.length; l++) {
                  for (var x = q[l], f = r[l], b = [], w = 0; w < f.length; w++) {
                    var J = x[w],
                        C = f[w];
                    E(J) && E(C) && ("A" !== f[0] || 4 !== w && 5 !== w) ? b[w] = J + c * (C - J) : b[w] = C;
                  }

                  g.push(b);
                } else g = r;
              } else g = this.toD || [];
              this.elem.attr("d", g, void 0, !0);
            };

            y.prototype.update = function () {
              var r = this.elem,
                  q = this.prop,
                  c = this.now,
                  g = this.options.step;
              if (this[q + "Setter"]) this[q + "Setter"]();else r.attr ? r.element && r.attr(q, c, null, !0) : r.style[q] = c + this.unit;
              g && g.call(r, c, this);
            };

            y.prototype.run = function (r, q, c) {
              var g = this,
                  l = g.options,
                  x = function x(b) {
                return x.stopped ? !1 : g.step(b);
              },
                  f = B.requestAnimationFrame || function (b) {
                setTimeout(b, 13);
              },
                  b = function b() {
                for (var w = 0; w < y.timers.length; w++) {
                  y.timers[w]() || y.timers.splice(w--, 1);
                }

                y.timers.length && f(b);
              };

              r !== q || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = r, this.end = q, this.unit = c, this.now = this.start, this.pos = 0, x.elem = this.elem, x.prop = this.prop, x() && 1 === y.timers.push(x) && f(b)) : (delete l.curAnim[this.prop], l.complete && 0 === Object.keys(l.curAnim).length && l.complete.call(this.elem));
            };

            y.prototype.step = function (r) {
              var q = +new Date(),
                  c = this.options,
                  g = this.elem,
                  l = c.complete,
                  x = c.duration,
                  f = c.curAnim;
              if (g.attr && !g.element) r = !1;else if (r || q >= x + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                var b = f[this.prop] = !0;
                I(f, function (f) {
                  !0 !== f && (b = !1);
                });
                b && l && l.call(g);
                r = !1;
              } else this.pos = c.easing((q - this.startTime) / x), this.now = this.start + (this.end - this.start) * this.pos, this.update(), r = !0;
              return r;
            };

            y.prototype.initPath = function (r, q, c) {
              function g(p, m) {
                for (; p.length < K;) {
                  var t = p[0],
                      a = m[K - p.length];
                  a && "M" === t[0] && (p[0] = "C" === a[0] ? ["C", t[1], t[2], t[1], t[2], t[1], t[2]] : ["L", t[1], t[2]]);
                  p.unshift(t);
                  b && (t = p.pop(), p.push(p[p.length - 1], t));
                }
              }

              function l(p, m) {
                for (; p.length < K;) {
                  if (m = p[Math.floor(p.length / w) - 1].slice(), "C" === m[0] && (m[1] = m[5], m[2] = m[6]), b) {
                    var t = p[Math.floor(p.length / w)].slice();
                    p.splice(p.length / 2, 0, m, t);
                  } else p.push(m);
                }
              }

              var x = r.startX,
                  f = r.endX;
              c = c.slice();
              var b = r.isArea,
                  w = b ? 2 : 1;
              q = q && q.slice();
              if (!q) return [c, c];

              if (x && f && f.length) {
                for (r = 0; r < x.length; r++) {
                  if (x[r] === f[0]) {
                    var J = r;
                    break;
                  } else if (x[0] === f[f.length - x.length + r]) {
                    J = r;
                    var C = !0;
                    break;
                  } else if (x[x.length - 1] === f[f.length - x.length + r]) {
                    J = x.length - r;
                    break;
                  }
                }

                "undefined" === typeof J && (q = []);
              }

              if (q.length && E(J)) {
                var K = c.length + J * w;
                C ? (g(q, c), l(c, q)) : (g(c, q), l(q, c));
              }

              return [q, c];
            };

            y.prototype.fillSetter = function () {
              y.prototype.strokeSetter.apply(this, arguments);
            };

            y.prototype.strokeSetter = function () {
              this.elem.attr(this.prop, G(this.start).tweenTo(G(this.end), this.pos), void 0, !0);
            };

            y.timers = [];
            return y;
          }();
        });
        N(e, "Core/Animation/AnimationUtilities.js", [e["Core/Animation/Fx.js"], e["Core/Utilities.js"]], function (e, n) {
          function G(c) {
            return r(c) ? q({
              duration: 500,
              defer: 0
            }, c) : {
              duration: c ? 500 : 0,
              defer: 0
            };
          }

          function H(c, g) {
            for (var f = e.timers.length; f--;) {
              e.timers[f].elem !== c || g && g !== e.timers[f].prop || (e.timers[f].stopped = !0);
            }
          }

          var B = n.defined,
              E = n.getStyle,
              I = n.isArray,
              y = n.isNumber,
              r = n.isObject,
              q = n.merge,
              c = n.objectEach,
              g = n.pick;
          return {
            animate: function animate(g, x, f) {
              var b,
                  w = "",
                  l,
                  C;

              if (!r(f)) {
                var K = arguments;
                f = {
                  duration: K[2],
                  easing: K[3],
                  complete: K[4]
                };
              }

              y(f.duration) || (f.duration = 400);
              f.easing = "function" === typeof f.easing ? f.easing : Math[f.easing] || Math.easeInOutSine;
              f.curAnim = q(x);
              c(x, function (p, m) {
                H(g, m);
                C = new e(g, f, m);
                l = void 0;
                "d" === m && I(x.d) ? (C.paths = C.initPath(g, g.pathArray, x.d), C.toD = x.d, b = 0, l = 1) : g.attr ? b = g.attr(m) : (b = parseFloat(E(g, m)) || 0, "opacity" !== m && (w = "px"));
                l || (l = p);
                "string" === typeof l && l.match("px") && (l = l.replace(/px/g, ""));
                C.run(b, l, w);
              });
            },
            animObject: G,
            getDeferredAnimation: function getDeferredAnimation(c, g, f) {
              var b = G(g),
                  w = 0,
                  l = 0;
              (f ? [f] : c.series).forEach(function (f) {
                f = G(f.options.animation);
                w = g && B(g.defer) ? b.defer : Math.max(w, f.duration + f.defer);
                l = Math.min(b.duration, f.duration);
              });
              c.renderer.forExport && (w = 0);
              return {
                defer: Math.max(0, w - l),
                duration: Math.min(w, l)
              };
            },
            setAnimation: function setAnimation(c, x) {
              x.renderer.globalAnimation = g(c, x.options.chart.animation, !0);
            },
            stop: H
          };
        });
        N(e, "Core/Renderer/HTML/AST.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n) {
          var G = e.SVG_NS,
              H = n.attr,
              B = n.createElement,
              E = n.css,
              I = n.error,
              y = n.isFunction,
              r = n.isString,
              q = n.objectEach,
              c = n.splat,
              g = (n = e.win.trustedTypes) && y(n.createPolicy) && n.createPolicy("highcharts", {
            createHTML: function createHTML(f) {
              return f;
            }
          }),
              l = g ? g.createHTML("") : "";

          try {
            var x = !!new DOMParser().parseFromString(l, "text/html");
          } catch (f) {
            x = !1;
          }

          y = function () {
            function f(b) {
              this.nodes = "string" === typeof b ? this.parseMarkup(b) : b;
            }

            f.filterUserAttributes = function (b) {
              q(b, function (w, c) {
                var g = !0;
                -1 === f.allowedAttributes.indexOf(c) && (g = !1);
                -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(c) && (g = r(w) && f.allowedReferences.some(function (b) {
                  return 0 === w.indexOf(b);
                }));
                g || (I(33, !1, void 0, {
                  "Invalid attribute in config": "".concat(c)
                }), delete b[c]);
              });
              return b;
            };

            f.parseStyle = function (b) {
              return b.split(";").reduce(function (b, f) {
                f = f.split(":").map(function (b) {
                  return b.trim();
                });
                var w = f.shift();
                w && f.length && (b[w.replace(/-([a-z])/g, function (b) {
                  return b[1].toUpperCase();
                })] = f.join(":"));
                return b;
              }, {});
            };

            f.setElementHTML = function (b, w) {
              b.innerHTML = f.emptyHTML;
              w && new f(w).addToDOM(b);
            };

            f.prototype.addToDOM = function (b) {
              function w(b, g) {
                var l;
                c(b).forEach(function (b) {
                  var m = b.tagName,
                      t = b.textContent ? e.doc.createTextNode(b.textContent) : void 0,
                      a = f.bypassHTMLFiltering;
                  if (m) if ("#text" === m) var p = t;else if (-1 !== f.allowedTags.indexOf(m) || a) {
                    m = e.doc.createElementNS("svg" === m ? G : g.namespaceURI || G, m);
                    var d = b.attributes || {};
                    q(b, function (a, k) {
                      "tagName" !== k && "attributes" !== k && "children" !== k && "style" !== k && "textContent" !== k && (d[k] = a);
                    });
                    H(m, a ? d : f.filterUserAttributes(d));
                    b.style && E(m, b.style);
                    t && m.appendChild(t);
                    w(b.children || [], m);
                    p = m;
                  } else I(33, !1, void 0, {
                    "Invalid tagName in config": m
                  });
                  p && g.appendChild(p);
                  l = p;
                });
                return l;
              }

              return w(this.nodes, b);
            };

            f.prototype.parseMarkup = function (b) {
              var w = [];
              b = b.trim().replace(/ style="/g, ' data-style="');
              if (x) b = new DOMParser().parseFromString(g ? g.createHTML(b) : b, "text/html");else {
                var c = B("div");
                c.innerHTML = b;
                b = {
                  body: c
                };
              }

              var l = function l(b, p) {
                var m = b.nodeName.toLowerCase(),
                    t = {
                  tagName: m
                };
                "#text" === m && (t.textContent = b.textContent || "");

                if (m = b.attributes) {
                  var a = {};
                  [].forEach.call(m, function (d) {
                    "data-style" === d.name ? t.style = f.parseStyle(d.value) : a[d.name] = d.value;
                  });
                  t.attributes = a;
                }

                if (b.childNodes.length) {
                  var z = [];
                  [].forEach.call(b.childNodes, function (a) {
                    l(a, z);
                  });
                  z.length && (t.children = z);
                }

                p.push(t);
              };

              [].forEach.call(b.body.childNodes, function (b) {
                return l(b, w);
              });
              return w;
            };

            f.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            f.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            f.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            f.emptyHTML = l;
            f.bypassHTMLFiltering = !1;
            return f;
          }();

          "";
          return y;
        });
        N(e, "Core/FormatUtilities.js", [e["Core/DefaultOptions.js"], e["Core/Utilities.js"]], function (e, n) {
          function G(q, c, g, l) {
            q = +q || 0;
            c = +c;
            var x = H.lang,
                f = (q.toString().split(".")[1] || "").split("e")[0].length,
                b = q.toString().split("e"),
                w = c;
            if (-1 === c) c = Math.min(f, 20);else if (!I(c)) c = 2;else if (c && b[1] && 0 > b[1]) {
              var J = c + +b[1];
              0 <= J ? (b[0] = (+b[0]).toExponential(J).split("e")[0], c = J) : (b[0] = b[0].split(".")[0] || 0, q = 20 > c ? (b[0] * Math.pow(10, b[1])).toFixed(c) : 0, b[1] = 0);
            }
            J = (Math.abs(b[1] ? b[0] : q) + Math.pow(10, -Math.max(c, f) - 1)).toFixed(c);
            f = String(r(J));
            var C = 3 < f.length ? f.length % 3 : 0;
            g = y(g, x.decimalPoint);
            l = y(l, x.thousandsSep);
            q = (0 > q ? "-" : "") + (C ? f.substr(0, C) + l : "");
            q = 0 > +b[1] && !w ? "0" : q + f.substr(C).replace(/(\d{3})(?=\d)/g, "$1" + l);
            c && (q += g + J.slice(-c));
            b[1] && 0 !== +q && (q += "e" + b[1]);
            return q;
          }

          var H = e.defaultOptions,
              B = e.defaultTime,
              E = n.getNestedProperty,
              I = n.isNumber,
              y = n.pick,
              r = n.pInt;
          return {
            dateFormat: function dateFormat(q, c, g) {
              return B.dateFormat(q, c, g);
            },
            format: function format(q, c, g) {
              var l = "{",
                  x = !1,
                  f = /f$/,
                  b = /\.([0-9])/,
                  w = H.lang,
                  J = g && g.time || B;
              g = g && g.numberFormatter || G;

              for (var C = []; q;) {
                var K = q.indexOf(l);
                if (-1 === K) break;
                var p = q.slice(0, K);

                if (x) {
                  p = p.split(":");
                  l = E(p.shift() || "", c);
                  if (p.length && "number" === typeof l) if (p = p.join(":"), f.test(p)) {
                    var m = parseInt((p.match(b) || ["", "-1"])[1], 10);
                    null !== l && (l = g(l, m, w.decimalPoint, -1 < p.indexOf(",") ? w.thousandsSep : ""));
                  } else l = J.dateFormat(p, l);
                  C.push(l);
                } else C.push(p);

                q = q.slice(K + 1);
                l = (x = !x) ? "}" : "{";
              }

              C.push(q);
              return C.join("");
            },
            numberFormat: G
          };
        });
        N(e, "Core/Renderer/RendererUtilities.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.clamp,
              G = e.pick,
              H = e.stableSort,
              B;

          (function (e) {
            function I(y, r, q) {
              var c = y,
                  g = c.reducedLen || r,
                  l = function l(b, f) {
                return (f.rank || 0) - (b.rank || 0);
              },
                  x = function x(b, f) {
                return b.target - f.target;
              },
                  f,
                  b = !0,
                  w = [],
                  J = 0;

              for (f = y.length; f--;) {
                J += y[f].size;
              }

              if (J > g) {
                H(y, l);

                for (J = f = 0; J <= g;) {
                  J += y[f].size, f++;
                }

                w = y.splice(f - 1, y.length);
              }

              H(y, x);

              for (y = y.map(function (b) {
                return {
                  size: b.size,
                  targets: [b.target],
                  align: G(b.align, .5)
                };
              }); b;) {
                for (f = y.length; f--;) {
                  g = y[f], l = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, g.pos = n(l - g.size * g.align, 0, r - g.size);
                }

                f = y.length;

                for (b = !1; f--;) {
                  0 < f && y[f - 1].pos + y[f - 1].size > y[f].pos && (y[f - 1].size += y[f].size, y[f - 1].targets = y[f - 1].targets.concat(y[f].targets), y[f - 1].align = .5, y[f - 1].pos + y[f - 1].size > r && (y[f - 1].pos = r - y[f - 1].size), y.splice(f, 1), b = !0);
                }
              }

              c.push.apply(c, w);
              f = 0;
              y.some(function (b) {
                var w = 0;
                return (b.targets || []).some(function () {
                  c[f].pos = b.pos + w;
                  if ("undefined" !== typeof q && Math.abs(c[f].pos - c[f].target) > q) return c.slice(0, f + 1).forEach(function (b) {
                    return delete b.pos;
                  }), c.reducedLen = (c.reducedLen || r) - .1 * r, c.reducedLen > .1 * r && I(c, r, q), !0;
                  w += c[f].size;
                  f++;
                  return !1;
                });
              });
              H(c, x);
              return c;
            }

            e.distribute = I;
          })(B || (B = {}));

          return B;
        });
        N(e, "Core/Renderer/SVG/SVGElement.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n, D, H, B) {
          var G = e.animate,
              I = e.animObject,
              y = e.stop,
              r = H.deg2rad,
              q = H.doc,
              c = H.noop,
              g = H.svg,
              l = H.SVG_NS,
              x = H.win,
              f = B.addEvent,
              b = B.attr,
              w = B.createElement,
              J = B.css,
              C = B.defined,
              K = B.erase,
              p = B.extend,
              m = B.fireEvent,
              t = B.isArray,
              a = B.isFunction,
              z = B.isNumber,
              d = B.isString,
              F = B.merge,
              k = B.objectEach,
              h = B.pick,
              L = B.pInt,
              P = B.syncTimeout,
              u = B.uniqueKey;

          e = function () {
            function A() {
              this.element = void 0;
              this.onEvents = {};
              this.opacity = 1;
              this.renderer = void 0;
              this.SVG_NS = l;
              this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }

            A.prototype._defaultGetter = function (a) {
              a = h(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0);
              /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
              return a;
            };

            A.prototype._defaultSetter = function (a, d, v) {
              v.setAttribute(d, a);
            };

            A.prototype.add = function (a) {
              var d = this.renderer,
                  v = this.element;
              a && (this.parentGroup = a);
              this.parentInverted = a && a.inverted;
              "undefined" !== typeof this.textStr && "text" === this.element.nodeName && d.buildText(this);
              this.added = !0;
              if (!a || a.handleZ || this.zIndex) var h = this.zIndexSetter();
              h || (a ? a.element : d.box).appendChild(v);
              if (this.onAdd) this.onAdd();
              return this;
            };

            A.prototype.addClass = function (a, d) {
              var v = d ? "" : this.attr("class") || "";
              a = (a || "").split(/ /g).reduce(function (a, d) {
                -1 === v.indexOf(d) && a.push(d);
                return a;
              }, v ? [v] : []).join(" ");
              a !== v && this.attr("class", a);
              return this;
            };

            A.prototype.afterSetters = function () {
              this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };

            A.prototype.align = function (a, b, v) {
              var M = {},
                  k = this.renderer,
                  m = k.alignedObjects,
                  u,
                  t,
                  p;

              if (a) {
                if (this.alignOptions = a, this.alignByTranslate = b, !v || d(v)) this.alignTo = u = v || "renderer", K(m, this), m.push(this), v = void 0;
              } else a = this.alignOptions, b = this.alignByTranslate, u = this.alignTo;

              v = h(v, k[u], "scrollablePlotBox" === u ? k.plotBox : void 0, k);
              u = a.align;
              var A = a.verticalAlign;
              k = (v.x || 0) + (a.x || 0);
              m = (v.y || 0) + (a.y || 0);
              "right" === u ? t = 1 : "center" === u && (t = 2);
              t && (k += (v.width - (a.width || 0)) / t);
              M[b ? "translateX" : "x"] = Math.round(k);
              "bottom" === A ? p = 1 : "middle" === A && (p = 2);
              p && (m += (v.height - (a.height || 0)) / p);
              M[b ? "translateY" : "y"] = Math.round(m);
              this[this.placed ? "animate" : "attr"](M);
              this.placed = !0;
              this.alignAttr = M;
              return this;
            };

            A.prototype.alignSetter = function (a) {
              var d = {
                left: "start",
                center: "middle",
                right: "end"
              };
              d[a] && (this.alignValue = a, this.element.setAttribute("text-anchor", d[a]));
            };

            A.prototype.animate = function (a, d, v) {
              var M = this,
                  b = I(h(d, this.renderer.globalAnimation, !0));
              d = b.defer;
              h(q.hidden, q.msHidden, q.webkitHidden, !1) && (b.duration = 0);
              0 !== b.duration ? (v && (b.complete = v), P(function () {
                M.element && G(M, a, b);
              }, d)) : (this.attr(a, void 0, v || b.complete), k(a, function (a, v) {
                b.step && b.step.call(this, a, {
                  prop: v,
                  pos: 1,
                  elem: this
                });
              }, this));
              return this;
            };

            A.prototype.applyTextOutline = function (a) {
              var d = this.element;
              -1 !== a.indexOf("contrast") && (a = a.replace(/contrast/g, this.renderer.getContrast(d.style.fill)));
              var v = a.split(" ");
              a = v[v.length - 1];

              if ((v = v[0]) && "none" !== v && H.svg) {
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                v = v.replace(/(^[\d\.]+)(.*?)$/g, function (a, d, v) {
                  return 2 * Number(d) + v;
                });
                this.removeTextOutline();
                var h = q.createElementNS(l, "tspan");
                b(h, {
                  "class": "highcharts-text-outline",
                  fill: a,
                  stroke: a,
                  "stroke-width": v,
                  "stroke-linejoin": "round"
                });
                [].forEach.call(d.childNodes, function (a) {
                  var d = a.cloneNode(!0);
                  d.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (a) {
                    return d.removeAttribute(a);
                  });
                  h.appendChild(d);
                });
                var k = q.createElementNS(l, "tspan");
                k.textContent = "\u200B";
                ["x", "y"].forEach(function (a) {
                  var v = d.getAttribute(a);
                  v && k.setAttribute(a, v);
                });
                h.appendChild(k);
                d.insertBefore(h, d.firstChild);
              }
            };

            A.prototype.attr = function (a, d, v, h) {
              var M = this.element,
                  b = this.symbolCustomAttribs,
                  m,
                  u = this,
                  t,
                  p;

              if ("string" === typeof a && "undefined" !== typeof d) {
                var A = a;
                a = {};
                a[A] = d;
              }

              "string" === typeof a ? u = (this[a + "Getter"] || this._defaultGetter).call(this, a, M) : (k(a, function (d, v) {
                t = !1;
                h || y(this, v);
                this.symbolName && -1 !== b.indexOf(v) && (m || (this.symbolAttr(a), m = !0), t = !0);
                !this.rotation || "x" !== v && "y" !== v || (this.doTransform = !0);
                t || (p = this[v + "Setter"] || this._defaultSetter, p.call(this, d, v, M), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(v) && this.updateShadows(v, d, p));
              }, this), this.afterSetters());
              v && v.call(this);
              return u;
            };

            A.prototype.clip = function (a) {
              return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
            };

            A.prototype.crisp = function (a, d) {
              d = d || a.strokeWidth || 0;
              var v = Math.round(d) % 2 / 2;
              a.x = Math.floor(a.x || this.x || 0) + v;
              a.y = Math.floor(a.y || this.y || 0) + v;
              a.width = Math.floor((a.width || this.width || 0) - 2 * v);
              a.height = Math.floor((a.height || this.height || 0) - 2 * v);
              C(a.strokeWidth) && (a.strokeWidth = d);
              return a;
            };

            A.prototype.complexColor = function (a, d, v) {
              var h = this.renderer,
                  b,
                  p,
                  A,
                  f,
                  Q,
                  z,
                  w,
                  O,
                  c,
                  g,
                  l = [],
                  L;
              m(this.renderer, "complexColor", {
                args: arguments
              }, function () {
                a.radialGradient ? p = "radialGradient" : a.linearGradient && (p = "linearGradient");

                if (p) {
                  A = a[p];
                  Q = h.gradients;
                  z = a.stops;
                  c = v.radialReference;
                  t(A) && (a[p] = A = {
                    x1: A[0],
                    y1: A[1],
                    x2: A[2],
                    y2: A[3],
                    gradientUnits: "userSpaceOnUse"
                  });
                  "radialGradient" === p && c && !C(A.gradientUnits) && (f = A, A = F(A, h.getRadialAttr(c, f), {
                    gradientUnits: "userSpaceOnUse"
                  }));
                  k(A, function (a, d) {
                    "id" !== d && l.push(d, a);
                  });
                  k(z, function (a) {
                    l.push(a);
                  });
                  l = l.join(",");
                  if (Q[l]) g = Q[l].attr("id");else {
                    A.id = g = u();
                    var M = Q[l] = h.createElement(p).attr(A).add(h.defs);
                    M.radAttr = f;
                    M.stops = [];
                    z.forEach(function (a) {
                      0 === a[1].indexOf("rgba") ? (b = D.parse(a[1]), w = b.get("rgb"), O = b.get("a")) : (w = a[1], O = 1);
                      a = h.createElement("stop").attr({
                        offset: a[0],
                        "stop-color": w,
                        "stop-opacity": O
                      }).add(M);
                      M.stops.push(a);
                    });
                  }
                  L = "url(" + h.url + "#" + g + ")";
                  v.setAttribute(d, L);
                  v.gradient = l;

                  a.toString = function () {
                    return L;
                  };
                }
              });
            };

            A.prototype.css = function (a) {
              var d = this.styles,
                  v = {},
                  h = this.element,
                  b = !d;
              a.color && (a.fill = a.color);
              d && k(a, function (a, h) {
                d && d[h] !== a && (v[h] = a, b = !0);
              });

              if (b) {
                d && (a = p(d, v));
                if (null === a.width || "auto" === a.width) delete this.textWidth;else if ("text" === h.nodeName.toLowerCase() && a.width) var m = this.textWidth = L(a.width);
                this.styles = a;
                m && !g && this.renderer.forExport && delete a.width;
                var u = F(a);
                h.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach(function (a) {
                  return u && delete u[a];
                });
                J(h, u);
                this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), a.textOutline && this.applyTextOutline(a.textOutline));
              }

              return this;
            };

            A.prototype.dashstyleSetter = function (a) {
              var d = this["stroke-width"];
              "inherit" === d && (d = 1);

              if (a = a && a.toLowerCase()) {
                var v = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

                for (a = v.length; a--;) {
                  v[a] = "" + L(v[a]) * h(d, NaN);
                }

                a = v.join(",").replace(/NaN/g, "none");
                this.element.setAttribute("stroke-dasharray", a);
              }
            };

            A.prototype.destroy = function () {
              var a = this,
                  d = a.element || {},
                  v = a.renderer,
                  h = d.ownerSVGElement,
                  b = v.isSVG && "SPAN" === d.nodeName && a.parentGroup || void 0;
              d.onclick = d.onmouseout = d.onmouseover = d.onmousemove = d.point = null;
              y(a);

              if (a.clipPath && h) {
                var m = a.clipPath;
                [].forEach.call(h.querySelectorAll("[clip-path],[CLIP-PATH]"), function (a) {
                  -1 < a.getAttribute("clip-path").indexOf(m.element.id) && a.removeAttribute("clip-path");
                });
                a.clipPath = m.destroy();
              }

              if (a.stops) {
                for (h = 0; h < a.stops.length; h++) {
                  a.stops[h].destroy();
                }

                a.stops.length = 0;
                a.stops = void 0;
              }

              a.safeRemoveChild(d);

              for (v.styledMode || a.destroyShadows(); b && b.div && 0 === b.div.childNodes.length;) {
                d = b.parentGroup, a.safeRemoveChild(b.div), delete b.div, b = d;
              }

              a.alignTo && K(v.alignedObjects, a);
              k(a, function (d, v) {
                a[v] && a[v].parentGroup === a && a[v].destroy && a[v].destroy();
                delete a[v];
              });
            };

            A.prototype.destroyShadows = function () {
              (this.shadows || []).forEach(function (a) {
                this.safeRemoveChild(a);
              }, this);
              this.shadows = void 0;
            };

            A.prototype.destroyTextPath = function (a, d) {
              var v = a.getElementsByTagName("text")[0];

              if (v) {
                if (v.removeAttribute("dx"), v.removeAttribute("dy"), d.element.setAttribute("id", ""), this.textPathWrapper && v.getElementsByTagName("textPath").length) {
                  for (a = this.textPathWrapper.element.childNodes; a.length;) {
                    v.appendChild(a[0]);
                  }

                  v.removeChild(this.textPathWrapper.element);
                }
              } else if (a.getAttribute("dx") || a.getAttribute("dy")) a.removeAttribute("dx"), a.removeAttribute("dy");

              this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };

            A.prototype.dSetter = function (a, d, v) {
              t(a) && ("string" === typeof a[0] && (a = this.renderer.pathToSegments(a)), this.pathArray = a, a = a.reduce(function (a, d, v) {
                return d && d.join ? (v ? a + " " : "") + d.join(" ") : (d || "").toString();
              }, ""));
              /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
              this[d] !== a && (v.setAttribute(d, a), this[d] = a);
            };

            A.prototype.fadeOut = function (a) {
              var d = this;
              d.animate({
                opacity: 0
              }, {
                duration: h(a, 150),
                complete: function complete() {
                  d.hide();
                }
              });
            };

            A.prototype.fillSetter = function (a, d, v) {
              "string" === typeof a ? v.setAttribute(d, a) : a && this.complexColor(a, d, v);
            };

            A.prototype.getBBox = function (d, b) {
              var v = this.alignValue,
                  M = this.element,
                  k = this.renderer,
                  m = this.styles,
                  u = this.textStr,
                  t = k.cache,
                  f = k.cacheKeys,
                  z = M.namespaceURI === this.SVG_NS;
              b = h(b, this.rotation, 0);
              var w = k.styledMode ? M && A.prototype.getStyle.call(M, "font-size") : m && m.fontSize,
                  c;

              if (C(u)) {
                var g = u.toString();
                -1 === g.indexOf("<") && (g = g.replace(/[0-9]/g, "0"));
                g += ["", b, w, this.textWidth, v, m && m.textOverflow, m && m.fontWeight].join();
              }

              g && !d && (c = t[g]);

              if (!c) {
                if (z || k.forExport) {
                  try {
                    var l = this.fakeTS && function (a) {
                      var d = M.querySelector(".highcharts-text-outline");
                      d && J(d, {
                        display: a
                      });
                    };

                    a(l) && l("none");
                    c = M.getBBox ? p({}, M.getBBox()) : {
                      width: M.offsetWidth,
                      height: M.offsetHeight
                    };
                    a(l) && l("");
                  } catch (fa) {
                    "";
                  }

                  if (!c || 0 > c.width) c = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                } else c = this.htmlGetBBox();

                if (k.isSVG && (k = c.width, d = c.height, z && (c.height = d = {
                  "11px,17": 14,
                  "13px,20": 16
                }["" + (w || "") + ",".concat(Math.round(d))] || d), b)) {
                  z = Number(M.getAttribute("y") || 0) - c.y;
                  v = {
                    right: 1,
                    center: .5
                  }[v || 0] || 0;
                  m = b * r;
                  w = (b - 90) * r;
                  var F = k * Math.cos(m);
                  b = k * Math.sin(m);
                  l = Math.cos(w);
                  m = Math.sin(w);
                  k = c.x + v * (k - F) + z * l;
                  w = k + F;
                  l = w - d * l;
                  F = l - F;
                  z = c.y + z - v * b + z * m;
                  v = z + b;
                  d = v - d * m;
                  b = d - b;
                  c.x = Math.min(k, w, l, F);
                  c.y = Math.min(z, v, d, b);
                  c.width = Math.max(k, w, l, F) - c.x;
                  c.height = Math.max(z, v, d, b) - c.y;
                }

                if (g && ("" === u || 0 < c.height)) {
                  for (; 250 < f.length;) {
                    delete t[f.shift()];
                  }

                  t[g] || f.push(g);
                  t[g] = c;
                }
              }

              return c;
            };

            A.prototype.getStyle = function (a) {
              return x.getComputedStyle(this.element || this, "").getPropertyValue(a);
            };

            A.prototype.hasClass = function (a) {
              return -1 !== ("" + this.attr("class")).split(" ").indexOf(a);
            };

            A.prototype.hide = function () {
              return this.attr({
                visibility: "hidden"
              });
            };

            A.prototype.htmlGetBBox = function () {
              return {
                height: 0,
                width: 0,
                x: 0,
                y: 0
              };
            };

            A.prototype.init = function (a, d) {
              this.element = "span" === d ? w(d) : q.createElementNS(this.SVG_NS, d);
              this.renderer = a;
              m(this, "afterInit");
            };

            A.prototype.invert = function (a) {
              this.inverted = a;
              this.updateTransform();
              return this;
            };

            A.prototype.on = function (a, d) {
              var v = this.onEvents;
              if (v[a]) v[a]();
              v[a] = f(this.element, a, d);
              return this;
            };

            A.prototype.opacitySetter = function (a, d, v) {
              this.opacity = a = Number(Number(a).toFixed(3));
              v.setAttribute(d, a);
            };

            A.prototype.removeClass = function (a) {
              return this.attr("class", ("" + this.attr("class")).replace(d(a) ? new RegExp("(^| )".concat(a, "( |$)")) : a, " ").replace(/ +/g, " ").trim());
            };

            A.prototype.removeTextOutline = function () {
              var a = this.element.querySelector("tspan.highcharts-text-outline");
              a && this.safeRemoveChild(a);
            };

            A.prototype.safeRemoveChild = function (a) {
              var d = a.parentNode;
              d && d.removeChild(a);
            };

            A.prototype.setRadialReference = function (a) {
              var d = this.element.gradient && this.renderer.gradients[this.element.gradient];
              this.element.radialReference = a;
              d && d.radAttr && d.animate(this.renderer.getRadialAttr(a, d.radAttr));
              return this;
            };

            A.prototype.setTextPath = function (a, d) {
              var v = this.element,
                  h = this.text ? this.text.element : v,
                  b = {
                textAnchor: "text-anchor"
              },
                  m = !1,
                  t = this.textPathWrapper,
                  A = !t;
              d = F(!0, {
                enabled: !0,
                attributes: {
                  dy: -5,
                  startOffset: "50%",
                  textAnchor: "middle"
                }
              }, d);
              var p = n.filterUserAttributes(d.attributes);

              if (a && d && d.enabled) {
                t && null === t.element.parentNode ? (A = !0, t = t.destroy()) : t && this.removeTextOutline.call(t.parentGroup);
                this.options && this.options.padding && (p.dx = -this.options.padding);
                t || (this.textPathWrapper = t = this.renderer.createElement("textPath"), m = !0);
                var f = t.element;
                (d = a.element.getAttribute("id")) || a.element.setAttribute("id", d = u());
                if (A) for (h.setAttribute("y", 0), z(p.dx) && h.setAttribute("x", -p.dx), a = [].slice.call(h.childNodes), A = 0; A < a.length; A++) {
                  var w = a[A];
                  w.nodeType !== x.Node.TEXT_NODE && "tspan" !== w.nodeName || f.appendChild(w);
                }
                m && t && t.add({
                  element: h
                });
                f.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + d);
                C(p.dy) && (f.parentNode.setAttribute("dy", p.dy), delete p.dy);
                C(p.dx) && (f.parentNode.setAttribute("dx", p.dx), delete p.dx);
                k(p, function (a, d) {
                  f.setAttribute(b[d] || d, a);
                });
                v.removeAttribute("transform");
                this.removeTextOutline.call(t);
                this.text && !this.renderer.styledMode && this.attr({
                  fill: "none",
                  "stroke-width": 0
                });
                this.applyTextOutline = this.updateTransform = c;
              } else t && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(v, a), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

              return this;
            };

            A.prototype.shadow = function (a, d, v) {
              var h = [],
                  m = this.element,
                  u = this.oldShadowOptions,
                  t = {
                color: "#000000",
                offsetX: this.parentInverted ? -1 : 1,
                offsetY: this.parentInverted ? -1 : 1,
                opacity: .15,
                width: 3
              },
                  A = !1,
                  f;
              !0 === a ? f = t : "object" === typeof a && (f = p(t, a));
              f && (f && u && k(f, function (a, d) {
                a !== u[d] && (A = !0);
              }), A && this.destroyShadows(), this.oldShadowOptions = f);
              if (!f) this.destroyShadows();else if (!this.shadows) {
                var z = f.opacity / f.width;
                var w = this.parentInverted ? "translate(".concat(f.offsetY, ", ").concat(f.offsetX, ")") : "translate(".concat(f.offsetX, ", ").concat(f.offsetY, ")");

                for (t = 1; t <= f.width; t++) {
                  var c = m.cloneNode(!1);
                  var g = 2 * f.width + 1 - 2 * t;
                  b(c, {
                    stroke: a.color || "#000000",
                    "stroke-opacity": z * t,
                    "stroke-width": g,
                    transform: w,
                    fill: "none"
                  });
                  c.setAttribute("class", (c.getAttribute("class") || "") + " highcharts-shadow");
                  v && (b(c, "height", Math.max(b(c, "height") - g, 0)), c.cutHeight = g);
                  d ? d.element.appendChild(c) : m.parentNode && m.parentNode.insertBefore(c, m);
                  h.push(c);
                }

                this.shadows = h;
              }
              return this;
            };

            A.prototype.show = function (a) {
              void 0 === a && (a = !0);
              return this.attr({
                visibility: a ? "inherit" : "visible"
              });
            };

            A.prototype.strokeSetter = function (a, d, v) {
              this[d] = a;
              this.stroke && this["stroke-width"] ? (A.prototype.fillSetter.call(this, this.stroke, "stroke", v), v.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === d && 0 === a && this.hasStroke ? (v.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (v.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
            };

            A.prototype.strokeWidth = function () {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              var a = this.getStyle("stroke-width"),
                  d = 0;
              if (a.indexOf("px") === a.length - 2) d = L(a);else if ("" !== a) {
                var v = q.createElementNS(l, "rect");
                b(v, {
                  width: a,
                  "stroke-width": 0
                });
                this.element.parentNode.appendChild(v);
                d = v.getBBox().width;
                v.parentNode.removeChild(v);
              }
              return d;
            };

            A.prototype.symbolAttr = function (a) {
              var d = this;
              "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (v) {
                d[v] = h(a[v], d[v]);
              });
              d.attr({
                d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)
              });
            };

            A.prototype.textSetter = function (a) {
              a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));
            };

            A.prototype.titleSetter = function (a) {
              var d = this.element,
                  v = d.getElementsByTagName("title")[0] || q.createElementNS(this.SVG_NS, "title");
              d.insertBefore ? d.insertBefore(v, d.firstChild) : d.appendChild(v);
              v.textContent = String(h(a, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };

            A.prototype.toFront = function () {
              var a = this.element;
              a.parentNode.appendChild(a);
              return this;
            };

            A.prototype.translate = function (a, d) {
              return this.attr({
                translateX: a,
                translateY: d
              });
            };

            A.prototype.updateShadows = function (a, d, v) {
              var h = this.shadows;
              if (h) for (var b = h.length; b--;) {
                v.call(h[b], "height" === a ? Math.max(d - (h[b].cutHeight || 0), 0) : "d" === a ? this.d : d, a, h[b]);
              }
            };

            A.prototype.updateTransform = function () {
              var a = this.scaleX,
                  d = this.scaleY,
                  v = this.inverted,
                  b = this.rotation,
                  k = this.matrix,
                  m = this.element,
                  u = this.translateX || 0,
                  t = this.translateY || 0;
              v && (u += this.width, t += this.height);
              u = ["translate(" + u + "," + t + ")"];
              C(k) && u.push("matrix(" + k.join(",") + ")");
              v ? u.push("rotate(90) scale(-1,1)") : b && u.push("rotate(" + b + " " + h(this.rotationOriginX, m.getAttribute("x"), 0) + " " + h(this.rotationOriginY, m.getAttribute("y") || 0) + ")");
              (C(a) || C(d)) && u.push("scale(" + h(a, 1) + " " + h(d, 1) + ")");
              u.length && m.setAttribute("transform", u.join(" "));
            };

            A.prototype.visibilitySetter = function (a, d, v) {
              "inherit" === a ? v.removeAttribute(d) : this[d] !== a && v.setAttribute(d, a);
              this[d] = a;
            };

            A.prototype.xGetter = function (a) {
              "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
              return this._defaultGetter(a);
            };

            A.prototype.zIndexSetter = function (a, d) {
              var v = this.renderer,
                  h = this.parentGroup,
                  b = (h || v).element || v.box,
                  k = this.element;
              v = b === v.box;
              var m = !1;
              var u = this.added;
              var t;
              C(a) ? (k.setAttribute("data-z-index", a), a = +a, this[d] === a && (u = !1)) : C(this[d]) && k.removeAttribute("data-z-index");
              this[d] = a;

              if (u) {
                (a = this.zIndex) && h && (h.handleZ = !0);
                d = b.childNodes;

                for (t = d.length - 1; 0 <= t && !m; t--) {
                  h = d[t];
                  u = h.getAttribute("data-z-index");
                  var A = !C(u);
                  if (h !== k) if (0 > a && A && !v && !t) b.insertBefore(k, d[t]), m = !0;else if (L(u) <= a || A && (!C(a) || 0 <= a)) b.insertBefore(k, d[t + 1] || null), m = !0;
                }

                m || (b.insertBefore(k, d[v ? 3 : 0] || null), m = !0);
              }

              return m;
            };

            return A;
          }();

          e.prototype["stroke-widthSetter"] = e.prototype.strokeSetter;
          e.prototype.yGetter = e.prototype.xGetter;

          e.prototype.matrixSetter = e.prototype.rotationOriginXSetter = e.prototype.rotationOriginYSetter = e.prototype.rotationSetter = e.prototype.scaleXSetter = e.prototype.scaleYSetter = e.prototype.translateXSetter = e.prototype.translateYSetter = e.prototype.verticalAlignSetter = function (a, d) {
            this[d] = a;
            this.doTransform = !0;
          };

          "";
          return e;
        });
        N(e, "Core/Renderer/RendererRegistry.js", [e["Core/Globals.js"]], function (e) {
          var n;

          (function (n) {
            n.rendererTypes = {};
            var G;

            n.getRendererType = function (e) {
              void 0 === e && (e = G);
              return n.rendererTypes[e] || n.rendererTypes[G];
            };

            n.registerRendererType = function (B, E, I) {
              n.rendererTypes[B] = E;
              if (!G || I) G = B, e.Renderer = E;
            };
          })(n || (n = {}));

          return n;
        });
        N(e, "Core/Renderer/SVG/SVGLabel.js", [e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (e, n) {
          var G = this && this.__extends || function () {
            var _q2 = function q(c, g) {
              _q2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, g) {
                c.__proto__ = g;
              } || function (c, g) {
                for (var f in g) {
                  g.hasOwnProperty(f) && (c[f] = g[f]);
                }
              };

              return _q2(c, g);
            };

            return function (c, g) {
              function l() {
                this.constructor = c;
              }

              _q2(c, g);

              c.prototype = null === g ? Object.create(g) : (l.prototype = g.prototype, new l());
            };
          }(),
              H = n.defined,
              B = n.extend,
              E = n.isNumber,
              I = n.merge,
              y = n.pick,
              r = n.removeEvent;

          return function (q) {
            function c(g, l, x, f, b, w, J, C, K, p) {
              var m = q.call(this) || this;
              m.paddingLeftSetter = m.paddingSetter;
              m.paddingRightSetter = m.paddingSetter;
              m.init(g, "g");
              m.textStr = l;
              m.x = x;
              m.y = f;
              m.anchorX = w;
              m.anchorY = J;
              m.baseline = K;
              m.className = p;
              m.addClass("button" === p ? "highcharts-no-tooltip" : "highcharts-label");
              p && m.addClass("highcharts-" + p);
              m.text = g.text(void 0, 0, 0, C).attr({
                zIndex: 1
              });
              var t;
              "string" === typeof b && ((t = /^url\((.*?)\)$/.test(b)) || m.renderer.symbols[b]) && (m.symbolKey = b);
              m.bBox = c.emptyBBox;
              m.padding = 3;
              m.baselineOffset = 0;
              m.needsBox = g.styledMode || t;
              m.deferredAttr = {};
              m.alignFactor = 0;
              return m;
            }

            G(c, q);

            c.prototype.alignSetter = function (c) {
              c = {
                left: 0,
                center: .5,
                right: 1
              }[c];
              c !== this.alignFactor && (this.alignFactor = c, this.bBox && E(this.xSetting) && this.attr({
                x: this.xSetting
              }));
            };

            c.prototype.anchorXSetter = function (c, l) {
              this.anchorX = c;
              this.boxAttr(l, Math.round(c) - this.getCrispAdjust() - this.xSetting);
            };

            c.prototype.anchorYSetter = function (c, l) {
              this.anchorY = c;
              this.boxAttr(l, c - this.ySetting);
            };

            c.prototype.boxAttr = function (c, l) {
              this.box ? this.box.attr(c, l) : this.deferredAttr[c] = l;
            };

            c.prototype.css = function (g) {
              if (g) {
                var l = {};
                g = I(g);
                c.textProps.forEach(function (f) {
                  "undefined" !== typeof g[f] && (l[f] = g[f], delete g[f]);
                });
                this.text.css(l);
                var x = ("width" in l);
                "fontSize" in l || "fontWeight" in l ? this.updateTextPadding() : x && this.updateBoxSize();
              }

              return e.prototype.css.call(this, g);
            };

            c.prototype.destroy = function () {
              r(this.element, "mouseenter");
              r(this.element, "mouseleave");
              this.text && this.text.destroy();
              this.box && (this.box = this.box.destroy());
              e.prototype.destroy.call(this);
            };

            c.prototype.fillSetter = function (c, l) {
              c && (this.needsBox = !0);
              this.fill = c;
              this.boxAttr(l, c);
            };

            c.prototype.getBBox = function () {
              this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
              var c = this.padding,
                  l = y(this.paddingLeft, c);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - l,
                y: this.bBox.y - c
              };
            };

            c.prototype.getCrispAdjust = function () {
              return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };

            c.prototype.heightSetter = function (c) {
              this.heightSetting = c;
            };

            c.prototype.onAdd = function () {
              var c = this.textStr;
              this.text.add(this);
              this.attr({
                text: H(c) ? c : "",
                x: this.x,
                y: this.y
              });
              this.box && H(this.anchorX) && this.attr({
                anchorX: this.anchorX,
                anchorY: this.anchorY
              });
            };

            c.prototype.paddingSetter = function (c, l) {
              E(c) ? c !== this[l] && (this[l] = c, this.updateTextPadding()) : this[l] = void 0;
            };

            c.prototype.rSetter = function (c, l) {
              this.boxAttr(l, c);
            };

            c.prototype.shadow = function (c) {
              c && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(c));
              return this;
            };

            c.prototype.strokeSetter = function (c, l) {
              this.stroke = c;
              this.boxAttr(l, c);
            };

            c.prototype["stroke-widthSetter"] = function (c, l) {
              c && (this.needsBox = !0);
              this["stroke-width"] = c;
              this.boxAttr(l, c);
            };

            c.prototype["text-alignSetter"] = function (c) {
              this.textAlign = c;
            };

            c.prototype.textSetter = function (c) {
              "undefined" !== typeof c && this.text.attr({
                text: c
              });
              this.updateTextPadding();
            };

            c.prototype.updateBoxSize = function () {
              var g = this.text.element.style,
                  l = {},
                  x = this.padding,
                  f = this.bBox = E(this.widthSetting) && E(this.heightSetting) && !this.textAlign || !H(this.text.textStr) ? c.emptyBBox : this.text.getBBox();
              this.width = this.getPaddedWidth();
              this.height = (this.heightSetting || f.height || 0) + 2 * x;
              g = this.renderer.fontMetrics(g && g.fontSize, this.text);
              this.baselineOffset = x + Math.min((this.text.firstLineMetrics || g).b, f.height || Infinity);
              this.heightSetting && (this.baselineOffset += (this.heightSetting - g.h) / 2);
              this.needsBox && (this.box || (x = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), x.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), x.add(this)), x = this.getCrispAdjust(), l.x = x, l.y = (this.baseline ? -this.baselineOffset : 0) + x, l.width = Math.round(this.width), l.height = Math.round(this.height), this.box.attr(B(l, this.deferredAttr)), this.deferredAttr = {});
            };

            c.prototype.updateTextPadding = function () {
              var c = this.text;
              this.updateBoxSize();
              var l = this.baseline ? 0 : this.baselineOffset,
                  x = y(this.paddingLeft, this.padding);
              H(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (x += {
                center: .5,
                right: 1
              }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (x !== c.x || l !== c.y) c.attr("x", x), c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0)), "undefined" !== typeof l && c.attr("y", l);
              c.x = x;
              c.y = l;
            };

            c.prototype.widthSetter = function (c) {
              this.widthSetting = E(c) ? c : void 0;
            };

            c.prototype.getPaddedWidth = function () {
              var c = this.padding,
                  l = y(this.paddingLeft, c);
              c = y(this.paddingRight, c);
              return (this.widthSetting || this.bBox.width || 0) + l + c;
            };

            c.prototype.xSetter = function (c) {
              this.x = c;
              this.alignFactor && (c -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
              this.xSetting = Math.round(c);
              this.attr("translateX", this.xSetting);
            };

            c.prototype.ySetter = function (c) {
              this.ySetting = this.y = Math.round(c);
              this.attr("translateY", this.ySetting);
            };

            c.emptyBBox = {
              width: 0,
              height: 0,
              x: 0,
              y: 0
            };
            c.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return c;
          }(e);
        });
        N(e, "Core/Renderer/SVG/Symbols.js", [e["Core/Utilities.js"]], function (e) {
          function n(e, r, q, c, g) {
            var l = [];

            if (g) {
              var x = g.start || 0,
                  f = I(g.r, q);
              q = I(g.r, c || q);
              var b = (g.end || 0) - .001;
              c = g.innerR;
              var w = I(g.open, .001 > Math.abs((g.end || 0) - x - 2 * Math.PI)),
                  J = Math.cos(x),
                  C = Math.sin(x),
                  K = Math.cos(b),
                  p = Math.sin(b);
              x = I(g.longArc, .001 > b - x - Math.PI ? 0 : 1);
              l.push(["M", e + f * J, r + q * C], ["A", f, q, 0, x, I(g.clockwise, 1), e + f * K, r + q * p]);
              B(c) && l.push(w ? ["M", e + c * K, r + c * p] : ["L", e + c * K, r + c * p], ["A", c, c, 0, x, B(g.clockwise) ? 1 - g.clockwise : 0, e + c * J, r + c * C]);
              w || l.push(["Z"]);
            }

            return l;
          }

          function G(e, r, q, c, g) {
            return g && g.r ? H(e, r, q, c, g) : [["M", e, r], ["L", e + q, r], ["L", e + q, r + c], ["L", e, r + c], ["Z"]];
          }

          function H(e, r, q, c, g) {
            g = g && g.r || 0;
            return [["M", e + g, r], ["L", e + q - g, r], ["C", e + q, r, e + q, r, e + q, r + g], ["L", e + q, r + c - g], ["C", e + q, r + c, e + q, r + c, e + q - g, r + c], ["L", e + g, r + c], ["C", e, r + c, e, r + c, e, r + c - g], ["L", e, r + g], ["C", e, r, e, r, e + g, r]];
          }

          var B = e.defined,
              E = e.isNumber,
              I = e.pick;
          return {
            arc: n,
            callout: function callout(e, r, q, c, g) {
              var l = Math.min(g && g.r || 0, q, c),
                  x = l + 6,
                  f = g && g.anchorX;
              g = g && g.anchorY || 0;
              var b = H(e, r, q, c, {
                r: l
              });
              if (!E(f)) return b;
              e + f >= q ? g > r + x && g < r + c - x ? b.splice(3, 1, ["L", e + q, g - 6], ["L", e + q + 6, g], ["L", e + q, g + 6], ["L", e + q, r + c - l]) : b.splice(3, 1, ["L", e + q, c / 2], ["L", f, g], ["L", e + q, c / 2], ["L", e + q, r + c - l]) : 0 >= e + f ? g > r + x && g < r + c - x ? b.splice(7, 1, ["L", e, g + 6], ["L", e - 6, g], ["L", e, g - 6], ["L", e, r + l]) : b.splice(7, 1, ["L", e, c / 2], ["L", f, g], ["L", e, c / 2], ["L", e, r + l]) : g && g > c && f > e + x && f < e + q - x ? b.splice(5, 1, ["L", f + 6, r + c], ["L", f, r + c + 6], ["L", f - 6, r + c], ["L", e + l, r + c]) : g && 0 > g && f > e + x && f < e + q - x && b.splice(1, 1, ["L", f - 6, r], ["L", f, r - 6], ["L", f + 6, r], ["L", q - l, r]);
              return b;
            },
            circle: function circle(e, r, q, c) {
              return n(e + q / 2, r + c / 2, q / 2, c / 2, {
                start: .5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1
              });
            },
            diamond: function diamond(e, r, q, c) {
              return [["M", e + q / 2, r], ["L", e + q, r + c / 2], ["L", e + q / 2, r + c], ["L", e, r + c / 2], ["Z"]];
            },
            rect: G,
            roundedRect: H,
            square: G,
            triangle: function triangle(e, r, q, c) {
              return [["M", e + q / 2, r], ["L", e + q, r + c], ["L", e, r + c], ["Z"]];
            },
            "triangle-down": function triangleDown(e, r, q, c) {
              return [["M", e, r], ["L", e + q, r], ["L", e + q / 2, r + c], ["Z"]];
            }
          };
        });
        N(e, "Core/Renderer/SVG/TextBuilder.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = n.doc,
              B = n.SVG_NS,
              E = n.win,
              I = D.attr,
              y = D.extend,
              r = D.isString,
              q = D.objectEach,
              c = D.pick;
          return function () {
            function g(c) {
              var l = c.styles;
              this.renderer = c.renderer;
              this.svgElement = c;
              this.width = c.textWidth;
              this.textLineHeight = l && l.lineHeight;
              this.textOutline = l && l.textOutline;
              this.ellipsis = !(!l || "ellipsis" !== l.textOverflow);
              this.noWrap = !(!l || "nowrap" !== l.whiteSpace);
              this.fontSize = l && l.fontSize;
            }

            g.prototype.buildSVG = function () {
              var l = this.svgElement,
                  g = l.element,
                  f = l.renderer,
                  b = c(l.textStr, "").toString(),
                  w = -1 !== b.indexOf("<"),
                  J = g.childNodes;
              f = this.width && !l.added && f.box;
              var C = /<br.*?>/g,
                  K = [b, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();

              if (K !== l.textCache) {
                l.textCache = K;
                delete l.actualWidth;

                for (K = J.length; K--;) {
                  g.removeChild(J[K]);
                }

                w || this.ellipsis || this.width || -1 !== b.indexOf(" ") && (!this.noWrap || C.test(b)) ? "" !== b && (f && f.appendChild(g), b = new e(b), this.modifyTree(b.nodes), b.addToDOM(l.element), this.modifyDOM(), this.ellipsis && -1 !== (g.textContent || "").indexOf("\u2026") && l.attr("title", this.unescapeEntities(l.textStr || "", ["&lt;", "&gt;"])), f && f.removeChild(g)) : g.appendChild(G.createTextNode(this.unescapeEntities(b)));
                r(this.textOutline) && l.applyTextOutline && l.applyTextOutline(this.textOutline);
              }
            };

            g.prototype.modifyDOM = function () {
              var c = this,
                  g = this.svgElement,
                  f = I(g.element, "x");
              g.firstLineMetrics = void 0;

              for (var b; b = g.element.firstChild;) {
                if (/^[\s\u200B]*$/.test(b.textContent || " ")) g.element.removeChild(b);else break;
              }

              [].forEach.call(g.element.querySelectorAll("tspan.highcharts-br"), function (b, p) {
                b.nextSibling && b.previousSibling && (0 === p && 1 === b.previousSibling.nodeType && (g.firstLineMetrics = g.renderer.fontMetrics(void 0, b.previousSibling)), I(b, {
                  dy: c.getLineHeight(b.nextSibling),
                  x: f
                }));
              });
              var w = this.width || 0;

              if (w) {
                var J = function J(b, p) {
                  var m = b.textContent || "",
                      t = m.replace(/([^\^])-/g, "$1- ").split(" "),
                      a = !c.noWrap && (1 < t.length || 1 < g.element.childNodes.length),
                      z = c.getLineHeight(p),
                      d = 0,
                      l = g.actualWidth;
                  if (c.ellipsis) m && c.truncate(b, m, void 0, 0, Math.max(0, w - parseInt(c.fontSize || 12, 10)), function (a, d) {
                    return a.substring(0, d) + "\u2026";
                  });else if (a) {
                    m = [];

                    for (a = []; p.firstChild && p.firstChild !== b;) {
                      a.push(p.firstChild), p.removeChild(p.firstChild);
                    }

                    for (; t.length;) {
                      t.length && !c.noWrap && 0 < d && (m.push(b.textContent || ""), b.textContent = t.join(" ").replace(/- /g, "-")), c.truncate(b, void 0, t, 0 === d ? l || 0 : 0, w, function (a, d) {
                        return t.slice(0, d).join(" ").replace(/- /g, "-");
                      }), l = g.actualWidth, d++;
                    }

                    a.forEach(function (a) {
                      p.insertBefore(a, b);
                    });
                    m.forEach(function (a) {
                      p.insertBefore(G.createTextNode(a), b);
                      a = G.createElementNS(B, "tspan");
                      a.textContent = "\u200B";
                      I(a, {
                        dy: z,
                        x: f
                      });
                      p.insertBefore(a, b);
                    });
                  }
                },
                    C = function C(b) {
                  [].slice.call(b.childNodes).forEach(function (c) {
                    c.nodeType === E.Node.TEXT_NODE ? J(c, b) : (-1 !== c.className.baseVal.indexOf("highcharts-br") && (g.actualWidth = 0), C(c));
                  });
                };

                C(g.element);
              }
            };

            g.prototype.getLineHeight = function (c) {
              var g;
              c = c.nodeType === E.Node.TEXT_NODE ? c.parentElement : c;
              this.renderer.styledMode || (g = c && /(px|em)$/.test(c.style.fontSize) ? c.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
              return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(g, c || this.svgElement.element).h;
            };

            g.prototype.modifyTree = function (c) {
              var g = this,
                  f = function f(b, w) {
                var l = b.attributes;
                l = void 0 === l ? {} : l;
                var x = b.children,
                    K = b.style;
                K = void 0 === K ? {} : K;
                var p = b.tagName,
                    m = g.renderer.styledMode;
                if ("b" === p || "strong" === p) m ? l["class"] = "highcharts-strong" : K.fontWeight = "bold";else if ("i" === p || "em" === p) m ? l["class"] = "highcharts-emphasized" : K.fontStyle = "italic";
                K && K.color && (K.fill = K.color);
                "br" === p ? (l["class"] = "highcharts-br", b.textContent = "\u200B", (w = c[w + 1]) && w.textContent && (w.textContent = w.textContent.replace(/^ +/gm, ""))) : "a" === p && x && x.some(function (b) {
                  return "#text" === b.tagName;
                }) && (b.children = [{
                  children: x,
                  tagName: "tspan"
                }]);
                "#text" !== p && "a" !== p && (b.tagName = "tspan");
                y(b, {
                  attributes: l,
                  style: K
                });
                x && x.filter(function (b) {
                  return "#text" !== b.tagName;
                }).forEach(f);
              };

              c.forEach(f);
            };

            g.prototype.truncate = function (c, g, f, b, w, J) {
              var l = this.svgElement,
                  x = l.renderer,
                  p = l.rotation,
                  m = [],
                  t = f ? 1 : 0,
                  a = (g || f || "").length,
                  z = a,
                  d,
                  F = function F(a, d) {
                d = d || a;
                var h = c.parentNode;
                if (h && "undefined" === typeof m[d]) if (h.getSubStringLength) try {
                  m[d] = b + h.getSubStringLength(0, f ? d + 1 : d);
                } catch (u) {
                  "";
                } else x.getSpanWidth && (c.textContent = J(g || f, a), m[d] = b + x.getSpanWidth(l, c));
                return m[d];
              };

              l.rotation = 0;
              var k = F(c.textContent.length);

              if (b + k > w) {
                for (; t <= a;) {
                  z = Math.ceil((t + a) / 2), f && (d = J(f, z)), k = F(z, d && d.length - 1), t === a ? t = a + 1 : k > w ? a = z - 1 : t = z;
                }

                0 === a ? c.textContent = "" : g && a === g.length - 1 || (c.textContent = d || J(g || f, z));
              }

              f && f.splice(0, z);
              l.actualWidth = k;
              l.rotation = p;
            };

            g.prototype.unescapeEntities = function (c, g) {
              q(this.renderer.escapes, function (f, b) {
                g && -1 !== g.indexOf(f) || (c = c.toString().replace(new RegExp(f, "g"), b));
              });
              return c;
            };

            return g;
          }();
        });
        N(e, "Core/Renderer/SVG/SVGRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGLabel.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Renderer/SVG/TextBuilder.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E, I, y, r) {
          var q = D.charts,
              c = D.deg2rad,
              g = D.doc,
              l = D.isFirefox,
              x = D.isMS,
              f = D.isWebKit,
              b = D.noop,
              w = D.SVG_NS,
              J = D.symbolSizes,
              C = D.win,
              K = r.addEvent,
              p = r.attr,
              m = r.createElement,
              t = r.css,
              a = r.defined,
              z = r.destroyObjectProperties,
              d = r.extend,
              F = r.isArray,
              k = r.isNumber,
              h = r.isObject,
              L = r.isString,
              P = r.merge,
              u = r.pick,
              A = r.pInt,
              O = r.uniqueKey,
              aa;

          D = function () {
            function v(a, d, v, h, b, k, m) {
              this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
              this.init(a, d, v, h, b, k, m);
            }

            v.prototype.init = function (a, d, v, h, b, k, m) {
              var M = this.createElement("svg").attr({
                version: "1.1",
                "class": "highcharts-root"
              }),
                  c = M.element;
              m || M.css(this.getStyle(h));
              a.appendChild(c);
              p(a, "dir", "ltr");
              -1 === a.innerHTML.indexOf("xmlns") && p(c, "xmlns", this.SVG_NS);
              this.isSVG = !0;
              this.box = c;
              this.boxWrapper = M;
              this.alignedObjects = [];
              this.url = this.getReferenceURL();
              this.createElement("desc").add().element.appendChild(g.createTextNode("Created with Highcharts 10.2.0"));
              this.defs = this.createElement("defs").add();
              this.allowHTML = k;
              this.forExport = b;
              this.styledMode = m;
              this.gradients = {};
              this.cache = {};
              this.cacheKeys = [];
              this.imgCount = 0;
              this.setSize(d, v, !1);
              var u;
              l && a.getBoundingClientRect && (d = function d() {
                t(a, {
                  left: 0,
                  top: 0
                });
                u = a.getBoundingClientRect();
                t(a, {
                  left: Math.ceil(u.left) - u.left + "px",
                  top: Math.ceil(u.top) - u.top + "px"
                });
              }, d(), this.unSubPixelFix = K(C, "resize", d));
            };

            v.prototype.definition = function (a) {
              return new e([a]).addToDOM(this.defs.element);
            };

            v.prototype.getReferenceURL = function () {
              if ((l || f) && g.getElementsByTagName("base").length) {
                if (!a(aa)) {
                  var d = O();
                  d = new e([{
                    tagName: "svg",
                    attributes: {
                      width: 8,
                      height: 8
                    },
                    children: [{
                      tagName: "defs",
                      children: [{
                        tagName: "clipPath",
                        attributes: {
                          id: d
                        },
                        children: [{
                          tagName: "rect",
                          attributes: {
                            width: 4,
                            height: 4
                          }
                        }]
                      }]
                    }, {
                      tagName: "rect",
                      attributes: {
                        id: "hitme",
                        width: 8,
                        height: 8,
                        "clip-path": "url(#".concat(d, ")"),
                        fill: "rgba(0,0,0,0.001)"
                      }
                    }]
                  }]).addToDOM(g.body);
                  t(d, {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    zIndex: 9E5
                  });
                  var v = g.elementFromPoint(6, 6);
                  aa = "hitme" === (v && v.id);
                  g.body.removeChild(d);
                }

                if (aa) return C.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
              }

              return "";
            };

            v.prototype.getStyle = function (a) {
              return this.style = d({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
              }, a);
            };

            v.prototype.setStyle = function (a) {
              this.boxWrapper.css(this.getStyle(a));
            };

            v.prototype.isHidden = function () {
              return !this.boxWrapper.getBBox().width;
            };

            v.prototype.destroy = function () {
              var a = this.defs;
              this.box = null;
              this.boxWrapper = this.boxWrapper.destroy();
              z(this.gradients || {});
              this.gradients = null;
              a && (this.defs = a.destroy());
              this.unSubPixelFix && this.unSubPixelFix();
              return this.alignedObjects = null;
            };

            v.prototype.createElement = function (a) {
              var d = new this.Element();
              d.init(this, a);
              return d;
            };

            v.prototype.getRadialAttr = function (a, d) {
              return {
                cx: a[0] - a[2] / 2 + (d.cx || 0) * a[2],
                cy: a[1] - a[2] / 2 + (d.cy || 0) * a[2],
                r: (d.r || 0) * a[2]
              };
            };

            v.prototype.buildText = function (a) {
              new y(a).buildSVG();
            };

            v.prototype.getContrast = function (a) {
              a = n.parse(a).rgba.map(function (a) {
                a /= 255;
                return .03928 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4);
              });
              a = .2126 * a[0] + .7152 * a[1] + .0722 * a[2];
              return 1.05 / (a + .05) > (a + .05) / .05 ? "#FFFFFF" : "#000000";
            };

            v.prototype.button = function (a, v, b, m, k, c, u, t, A, p) {
              void 0 === k && (k = {});
              var M = this.label(a, v, b, A, void 0, void 0, p, void 0, "button"),
                  f = this.styledMode;
              a = k.states || {};
              var z = 0;
              k = P(k);
              delete k.states;
              var w = P({
                color: "#333333",
                cursor: "pointer",
                fontWeight: "normal"
              }, k.style);
              delete k.style;
              var Q = e.filterUserAttributes(k);
              M.attr(P({
                padding: 8,
                r: 2
              }, Q));

              if (!f) {
                Q = P({
                  fill: "#f7f7f7",
                  stroke: "#cccccc",
                  "stroke-width": 1
                }, Q);
                c = P(Q, {
                  fill: "#e6e6e6"
                }, e.filterUserAttributes(c || a.hover || {}));
                var g = c.style;
                delete c.style;
                u = P(Q, {
                  fill: "#e6ebf5",
                  style: {
                    color: "#000000",
                    fontWeight: "bold"
                  }
                }, e.filterUserAttributes(u || a.select || {}));
                var l = u.style;
                delete u.style;
                t = P(Q, {
                  style: {
                    color: "#cccccc"
                  }
                }, e.filterUserAttributes(t || a.disabled || {}));
                var F = t.style;
                delete t.style;
              }

              K(M.element, x ? "mouseover" : "mouseenter", function () {
                3 !== z && M.setState(1);
              });
              K(M.element, x ? "mouseout" : "mouseleave", function () {
                3 !== z && M.setState(z);
              });

              M.setState = function (a) {
                1 !== a && (M.state = z = a);
                M.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]);
                f || (M.attr([Q, c, u, t][a || 0]), a = [w, g, l, F][a || 0], h(a) && M.css(a));
              };

              f || M.attr(Q).css(d({
                cursor: "default"
              }, w));
              return M.on("touchstart", function (a) {
                return a.stopPropagation();
              }).on("click", function (a) {
                3 !== z && m.call(M, a);
              });
            };

            v.prototype.crispLine = function (d, v, h) {
              void 0 === h && (h = "round");
              var b = d[0],
                  k = d[1];
              a(b[1]) && b[1] === k[1] && (b[1] = k[1] = Math[h](b[1]) - v % 2 / 2);
              a(b[2]) && b[2] === k[2] && (b[2] = k[2] = Math[h](b[2]) + v % 2 / 2);
              return d;
            };

            v.prototype.path = function (a) {
              var v = this.styledMode ? {} : {
                fill: "none"
              };
              F(a) ? v.d = a : h(a) && d(v, a);
              return this.createElement("path").attr(v);
            };

            v.prototype.circle = function (a, d, v) {
              a = h(a) ? a : "undefined" === typeof a ? {} : {
                x: a,
                y: d,
                r: v
              };
              d = this.createElement("circle");

              d.xSetter = d.ySetter = function (a, d, v) {
                v.setAttribute("c" + d, a);
              };

              return d.attr(a);
            };

            v.prototype.arc = function (a, d, v, b, k, m) {
              h(a) ? (b = a, d = b.y, v = b.r, a = b.x) : b = {
                innerR: b,
                start: k,
                end: m
              };
              a = this.symbol("arc", a, d, v, v, b);
              a.r = v;
              return a;
            };

            v.prototype.rect = function (a, d, v, b, k, m) {
              k = h(a) ? a.r : k;
              var c = this.createElement("rect");
              a = h(a) ? a : "undefined" === typeof a ? {} : {
                x: a,
                y: d,
                width: Math.max(v, 0),
                height: Math.max(b, 0)
              };
              this.styledMode || ("undefined" !== typeof m && (a["stroke-width"] = m, a = c.crisp(a)), a.fill = "none");
              k && (a.r = k);

              c.rSetter = function (a, d, v) {
                c.r = a;
                p(v, {
                  rx: a,
                  ry: a
                });
              };

              c.rGetter = function () {
                return c.r || 0;
              };

              return c.attr(a);
            };

            v.prototype.setSize = function (a, d, v) {
              this.width = a;
              this.height = d;
              this.boxWrapper.animate({
                width: a,
                height: d
              }, {
                step: function step() {
                  this.attr({
                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                  });
                },
                duration: u(v, !0) ? void 0 : 0
              });
              this.alignElements();
            };

            v.prototype.g = function (a) {
              var d = this.createElement("g");
              return a ? d.attr({
                "class": "highcharts-" + a
              }) : d;
            };

            v.prototype.image = function (a, d, v, h, b, m) {
              var c = {
                preserveAspectRatio: "none"
              },
                  u = function u(a, d) {
                a.setAttributeNS ? a.setAttributeNS("http://www.w3.org/1999/xlink", "href", d) : a.setAttribute("hc-svg-href", d);
              };

              k(d) && (c.x = d);
              k(v) && (c.y = v);
              k(h) && (c.width = h);
              k(b) && (c.height = b);
              var t = this.createElement("image").attr(c);

              d = function d(_d12) {
                u(t.element, a);
                m.call(t, _d12);
              };

              m ? (u(t.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), v = new C.Image(), K(v, "load", d), v.src = a, v.complete && d({})) : u(t.element, a);
              return t;
            };

            v.prototype.symbol = function (v, h, b, k, c, A) {
              var M = this,
                  p = /^url\((.*?)\)$/,
                  f = p.test(v),
                  z = !f && (this.symbols[v] ? v : "circle"),
                  w = z && this.symbols[z],
                  Q;

              if (w) {
                "number" === typeof h && (Q = w.call(this.symbols, Math.round(h || 0), Math.round(b || 0), k || 0, c || 0, A));
                var l = this.path(Q);
                M.styledMode || l.attr("fill", "none");
                d(l, {
                  symbolName: z || void 0,
                  x: h,
                  y: b,
                  width: k,
                  height: c
                });
                A && d(l, A);
              } else if (f) {
                var F = v.match(p)[1];
                var L = l = this.image(F);
                L.imgwidth = u(J[F] && J[F].width, A && A.width);
                L.imgheight = u(J[F] && J[F].height, A && A.height);

                var P = function P(a) {
                  return a.attr({
                    width: a.width,
                    height: a.height
                  });
                };

                ["width", "height"].forEach(function (d) {
                  L[d + "Setter"] = function (d, v) {
                    var h = this["img" + v];
                    this[v] = d;
                    a(h) && (A && "within" === A.backgroundSize && this.width && this.height && (h = Math.round(h * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(v, h), this.alignByTranslate || (d = ((this[v] || 0) - h) / 2, this.attr("width" === v ? {
                      translateX: d
                    } : {
                      translateY: d
                    })));
                  };
                });
                a(h) && L.attr({
                  x: h,
                  y: b
                });
                L.isImg = !0;
                a(L.imgwidth) && a(L.imgheight) ? P(L) : (L.attr({
                  width: 0,
                  height: 0
                }), m("img", {
                  onload: function onload() {
                    var a = q[M.chartIndex];
                    0 === this.width && (t(this, {
                      position: "absolute",
                      top: "-999em"
                    }), g.body.appendChild(this));
                    J[F] = {
                      width: this.width,
                      height: this.height
                    };
                    L.imgwidth = this.width;
                    L.imgheight = this.height;
                    L.element && P(L);
                    this.parentNode && this.parentNode.removeChild(this);
                    M.imgCount--;
                    if (!M.imgCount && a && !a.hasLoaded) a.onload();
                  },
                  src: F
                }), this.imgCount++);
              }

              return l;
            };

            v.prototype.clipRect = function (a, d, v, h) {
              var b = O() + "-",
                  k = this.createElement("clipPath").attr({
                id: b
              }).add(this.defs);
              a = this.rect(a, d, v, h, 0).add(k);
              a.id = b;
              a.clipPath = k;
              a.count = 0;
              return a;
            };

            v.prototype.text = function (d, v, h, b) {
              var k = {};
              if (b && (this.allowHTML || !this.forExport)) return this.html(d, v, h);
              k.x = Math.round(v || 0);
              h && (k.y = Math.round(h));
              a(d) && (k.text = d);
              d = this.createElement("text").attr(k);
              if (!b || this.forExport && !this.allowHTML) d.xSetter = function (a, d, v) {
                for (var h = v.getElementsByTagName("tspan"), b = v.getAttribute(d), k = 0, m; k < h.length; k++) {
                  m = h[k], m.getAttribute(d) === b && m.setAttribute(d, a);
                }

                v.setAttribute(d, a);
              };
              return d;
            };

            v.prototype.fontMetrics = function (a, d) {
              a = !this.styledMode && /px/.test(a) || !C.getComputedStyle ? a || d && d.style && d.style.fontSize || this.style && this.style.fontSize : d && B.prototype.getStyle.call(d, "font-size");
              a = /px/.test(a) ? A(a) : 12;
              d = 24 > a ? a + 3 : Math.round(1.2 * a);
              return {
                h: d,
                b: Math.round(.8 * d),
                f: a
              };
            };

            v.prototype.rotCorr = function (a, d, v) {
              var h = a;
              d && v && (h = Math.max(h * Math.cos(d * c), 4));
              return {
                x: -a / 3 * Math.sin(d * c),
                y: h
              };
            };

            v.prototype.pathToSegments = function (a) {
              for (var d = [], v = [], h = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
              }, b = 0; b < a.length; b++) {
                L(v[0]) && k(a[b]) && v.length === h[v[0].toUpperCase()] && a.splice(b, 0, v[0].replace("M", "L").replace("m", "l")), "string" === typeof a[b] && (v.length && d.push(v.slice(0)), v.length = 0), v.push(a[b]);
              }

              d.push(v.slice(0));
              return d;
            };

            v.prototype.label = function (a, d, v, h, b, k, m, c, u) {
              return new E(this, a, d, v, h, b, k, m, c, u);
            };

            v.prototype.alignElements = function () {
              this.alignedObjects.forEach(function (a) {
                return a.align();
              });
            };

            return v;
          }();

          d(D.prototype, {
            Element: B,
            SVG_NS: w,
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            symbols: I,
            draw: b
          });
          H.registerRendererType("svg", D, !0);
          "";
          return D;
        });
        N(e, "Core/Renderer/HTML/HTMLElement.js", [e["Core/Globals.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = this && this.__extends || function () {
            var _c4 = function c(f, b) {
              _c4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var f in c) {
                  c.hasOwnProperty(f) && (b[f] = c[f]);
                }
              };

              return _c4(f, b);
            };

            return function (f, b) {
              function w() {
                this.constructor = f;
              }

              _c4(f, b);

              f.prototype = null === b ? Object.create(b) : (w.prototype = b.prototype, new w());
            };
          }(),
              B = e.isFirefox,
              E = e.isMS,
              I = e.isWebKit,
              y = e.win,
              r = D.css,
              q = D.defined,
              c = D.extend,
              g = D.pick,
              l = D.pInt;

          return function (x) {
            function f() {
              return null !== x && x.apply(this, arguments) || this;
            }

            G(f, x);

            f.compose = function (b) {
              if (-1 === f.composedClasses.indexOf(b)) {
                f.composedClasses.push(b);
                var c = f.prototype,
                    g = b.prototype;
                g.getSpanCorrection = c.getSpanCorrection;
                g.htmlCss = c.htmlCss;
                g.htmlGetBBox = c.htmlGetBBox;
                g.htmlUpdateTransform = c.htmlUpdateTransform;
                g.setSpanRotation = c.setSpanRotation;
              }

              return b;
            };

            f.prototype.getSpanCorrection = function (b, c, f) {
              this.xCorr = -b * f;
              this.yCorr = -c;
            };

            f.prototype.htmlCss = function (b) {
              var f = "SPAN" === this.element.tagName && b && "width" in b,
                  l = g(f && b.width, void 0);

              if (f) {
                delete b.width;
                this.textWidth = l;
                var x = !0;
              }

              b && "ellipsis" === b.textOverflow && (b.whiteSpace = "nowrap", b.overflow = "hidden");
              this.styles = c(this.styles, b);
              r(this.element, b);
              x && this.htmlUpdateTransform();
              return this;
            };

            f.prototype.htmlGetBBox = function () {
              var b = this.element;
              return {
                x: b.offsetLeft,
                y: b.offsetTop,
                width: b.offsetWidth,
                height: b.offsetHeight
              };
            };

            f.prototype.htmlUpdateTransform = function () {
              if (this.added) {
                var b = this.renderer,
                    c = this.element,
                    f = this.translateX || 0,
                    g = this.translateY || 0,
                    x = this.x || 0,
                    p = this.y || 0,
                    m = this.textAlign || "left",
                    t = {
                  left: 0,
                  center: .5,
                  right: 1
                }[m],
                    a = this.styles;
                a = a && a.whiteSpace;
                r(c, {
                  marginLeft: f,
                  marginTop: g
                });
                !b.styledMode && this.shadows && this.shadows.forEach(function (a) {
                  r(a, {
                    marginLeft: f + 1,
                    marginTop: g + 1
                  });
                });
                this.inverted && [].forEach.call(c.childNodes, function (a) {
                  b.invertChild(a, c);
                });

                if ("SPAN" === c.tagName) {
                  var z = this.rotation,
                      d = this.textWidth && l(this.textWidth),
                      F = [z, m, c.innerHTML, this.textWidth, this.textAlign].join(),
                      k = void 0;
                  k = !1;

                  if (d !== this.oldTextWidth) {
                    if (this.textPxLength) var h = this.textPxLength;else r(c, {
                      width: "",
                      whiteSpace: a || "nowrap"
                    }), h = c.offsetWidth;
                    (d > this.oldTextWidth || h > d) && (/[ \-]/.test(c.textContent || c.innerText) || "ellipsis" === c.style.textOverflow) && (r(c, {
                      width: h > d || z ? d + "px" : "auto",
                      display: "block",
                      whiteSpace: a || "normal"
                    }), this.oldTextWidth = d, k = !0);
                  }

                  this.hasBoxWidthChanged = k;
                  F !== this.cTT && (k = b.fontMetrics(c.style.fontSize, c).b, !q(z) || z === (this.oldRotation || 0) && m === this.oldAlign || this.setSpanRotation(z, t, k), this.getSpanCorrection(!q(z) && this.textPxLength || c.offsetWidth, k, t, z, m));
                  r(c, {
                    left: x + (this.xCorr || 0) + "px",
                    top: p + (this.yCorr || 0) + "px"
                  });
                  this.cTT = F;
                  this.oldRotation = z;
                  this.oldAlign = m;
                }
              } else this.alignOnAdd = !0;
            };

            f.prototype.setSpanRotation = function (b, c, f) {
              var w = {},
                  g = E && !/Edge/.test(y.navigator.userAgent) ? "-ms-transform" : I ? "-webkit-transform" : B ? "MozTransform" : y.opera ? "-o-transform" : void 0;
              g && (w[g] = w.transform = "rotate(" + b + "deg)", w[g + (B ? "Origin" : "-origin")] = w.transformOrigin = 100 * c + "% " + f + "px", r(this.element, w));
            };

            f.composedClasses = [];
            return f;
          }(n);
        });
        N(e, "Core/Renderer/HTML/HTMLRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"]], function (e, n, D, H) {
          var G = this && this.__extends || function () {
            var _e3 = function e(c, g) {
              _e3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, g) {
                c.__proto__ = g;
              } || function (c, g) {
                for (var f in g) {
                  g.hasOwnProperty(f) && (c[f] = g[f]);
                }
              };

              return _e3(c, g);
            };

            return function (c, g) {
              function l() {
                this.constructor = c;
              }

              _e3(c, g);

              c.prototype = null === g ? Object.create(g) : (l.prototype = g.prototype, new l());
            };
          }(),
              E = H.attr,
              I = H.createElement,
              y = H.extend,
              r = H.pick;

          return function (q) {
            function c() {
              return null !== q && q.apply(this, arguments) || this;
            }

            G(c, q);

            c.compose = function (g) {
              -1 === c.composedClasses.indexOf(g) && (c.composedClasses.push(g), g.prototype.html = c.prototype.html);
              return g;
            };

            c.prototype.html = function (c, l, x) {
              var f = this.createElement("span"),
                  b = f.element,
                  w = f.renderer,
                  g = w.isSVG,
                  C = function C(b, c) {
                ["opacity", "visibility"].forEach(function (m) {
                  b[m + "Setter"] = function (t, a, f) {
                    var d = b.div ? b.div.style : c;
                    n.prototype[m + "Setter"].call(this, t, a, f);
                    d && (d[a] = t);
                  };
                });
                b.addedSetters = !0;
              };

              f.textSetter = function (b) {
                b !== this.textStr && (delete this.bBox, delete this.oldTextWidth, e.setElementHTML(this.element, r(b, "")), this.textStr = b, f.doTransform = !0);
              };

              g && C(f, f.element.style);

              f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (b, c) {
                "align" === c ? f.alignValue = f.textAlign = b : f[c] = b;
                f.doTransform = !0;
              };

              f.afterSetters = function () {
                this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
              };

              f.attr({
                text: c,
                x: Math.round(l),
                y: Math.round(x)
              }).css({
                position: "absolute"
              });
              w.styledMode || f.css({
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
              });
              b.style.whiteSpace = "nowrap";
              f.css = f.htmlCss;
              g && (f.add = function (c) {
                var p = w.box.parentNode,
                    m = [];

                if (this.parentGroup = c) {
                  var t = c.div;

                  if (!t) {
                    for (; c;) {
                      m.push(c), c = c.parentGroup;
                    }

                    m.reverse().forEach(function (a) {
                      function b(d, b) {
                        a[b] = d;
                        "translateX" === b ? k.left = d + "px" : k.top = d + "px";
                        a.doTransform = !0;
                      }

                      var d = E(a.element, "class"),
                          c = a.styles || {};
                      t = a.div = a.div || I("div", d ? {
                        className: d
                      } : void 0, {
                        position: "absolute",
                        left: (a.translateX || 0) + "px",
                        top: (a.translateY || 0) + "px",
                        display: a.display,
                        opacity: a.opacity,
                        cursor: c.cursor,
                        pointerEvents: c.pointerEvents,
                        visibility: a.visibility
                      }, t || p);
                      var k = t.style;
                      y(a, {
                        classSetter: function (a) {
                          return function (d) {
                            this.element.setAttribute("class", d);
                            a.className = d;
                          };
                        }(t),
                        on: function on() {
                          m[0].div && f.on.apply({
                            element: m[0].div,
                            onEvents: a.onEvents
                          }, arguments);
                          return a;
                        },
                        translateXSetter: b,
                        translateYSetter: b
                      });
                      a.addedSetters || C(a);
                    });
                  }
                } else t = p;

                t.appendChild(b);
                f.added = !0;
                f.alignOnAdd && f.htmlUpdateTransform();
                return f;
              });
              return f;
            };

            c.composedClasses = [];
            return c;
          }(D);
        });
        N(e, "Core/Axis/AxisDefaults.js", [], function () {
          var e;

          (function (e) {
            e.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: !1
                },
                second: {
                  main: "%H:%M:%S",
                  range: !1
                },
                minute: {
                  main: "%H:%M",
                  range: !1
                },
                hour: {
                  main: "%H:%M",
                  range: !1
                },
                day: {
                  main: "%e. %b"
                },
                week: {
                  main: "%e. %b"
                },
                month: {
                  main: "%b '%y"
                },
                year: {
                  main: "%Y"
                }
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: void 0,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                x: 0,
                zIndex: 7,
                style: {
                  color: "#666666",
                  cursor: "default",
                  fontSize: "11px"
                }
              },
              maxPadding: .01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minPadding: .01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                  color: "#666666"
                }
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: "#f2f2f2",
              minorGridLineWidth: 1,
              minorTickColor: "#999999",
              lineColor: "#ccd6eb",
              lineWidth: 1,
              gridLineColor: "#e6e6e6",
              gridLineWidth: void 0,
              tickColor: "#ccd6eb"
            };
            e.defaultYAxisOptions = {
              reversedStacks: !0,
              endOnTick: !0,
              maxPadding: .05,
              minPadding: .05,
              tickPixelInterval: 72,
              showLastLabel: !0,
              labels: {
                x: -8
              },
              startOnTick: !0,
              title: {
                rotation: 270,
                text: "Values"
              },
              stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function formatter() {
                  var e = this.axis.chart.numberFormatter;
                  return e(this.total, -1);
                },
                style: {
                  color: "#000000",
                  fontSize: "11px",
                  fontWeight: "bold",
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
            };
            e.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            e.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            e.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            e.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(e || (e = {}));

          return e;
        });
        N(e, "Core/Foundation.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.addEvent,
              G = e.isFunction,
              H = e.objectEach,
              B = e.removeEvent,
              E;

          (function (e) {
            e.registerEventOptions = function (e, r) {
              e.eventOptions = e.eventOptions || {};
              H(r.events, function (q, c) {
                e.eventOptions[c] !== q && (e.eventOptions[c] && (B(e, c, e.eventOptions[c]), delete e.eventOptions[c]), G(q) && (e.eventOptions[c] = q, n(e, c, q)));
              });
            };
          })(E || (E = {}));

          return E;
        });
        N(e, "Core/Axis/Tick.js", [e["Core/FormatUtilities.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = n.deg2rad,
              B = D.clamp,
              E = D.correctFloat,
              I = D.defined,
              y = D.destroyObjectProperties,
              r = D.extend,
              q = D.fireEvent,
              c = D.isNumber,
              g = D.merge,
              l = D.objectEach,
              x = D.pick;

          n = function () {
            function f(b, c, f, g, l) {
              this.isNewLabel = this.isNew = !0;
              this.axis = b;
              this.pos = c;
              this.type = f || "";
              this.parameters = l || {};
              this.tickmarkOffset = this.parameters.tickmarkOffset;
              this.options = this.parameters.options;
              q(this, "init");
              f || g || this.addLabel();
            }

            f.prototype.addLabel = function () {
              var b = this,
                  f = b.axis,
                  g = f.options,
                  l = f.chart,
                  K = f.categories,
                  p = f.logarithmic,
                  m = f.names,
                  t = b.pos,
                  a = x(b.options && b.options.labels, g.labels),
                  z = f.tickPositions,
                  d = t === z[0],
                  F = t === z[z.length - 1],
                  k = (!a.step || 1 === a.step) && 1 === f.tickInterval;
              z = z.info;
              var h = b.label,
                  L;
              K = this.parameters.category || (K ? x(K[t], m[t], t) : t);
              p && c(K) && (K = E(p.lin2log(K)));
              if (f.dateTime) if (z) {
                var P = l.time.resolveDTLFormat(g.dateTimeLabelFormats[!g.grid && z.higherRanks[t] || z.unitName]);
                var u = P.main;
              } else c(K) && (u = f.dateTime.getXDateFormat(K, g.dateTimeLabelFormats || {}));
              b.isFirst = d;
              b.isLast = F;
              var A = {
                axis: f,
                chart: l,
                dateTimeLabelFormat: u,
                isFirst: d,
                isLast: F,
                pos: t,
                tick: b,
                tickPositionInfo: z,
                value: K
              };
              q(this, "labelFormat", A);

              var O = function O(d) {
                return a.formatter ? a.formatter.call(d, d) : a.format ? (d.text = f.defaultLabelFormatter.call(d), e.format(a.format, d, l)) : f.defaultLabelFormatter.call(d, d);
              };

              g = O.call(A, A);
              var n = P && P.list;
              b.shortenLabel = n ? function () {
                for (L = 0; L < n.length; L++) {
                  if (r(A, {
                    dateTimeLabelFormat: n[L]
                  }), h.attr({
                    text: O.call(A, A)
                  }), h.getBBox().width < f.getSlotWidth(b) - 2 * a.padding) return;
                }

                h.attr({
                  text: ""
                });
              } : void 0;
              k && f._addedPlotLB && b.moveLabel(g, a);
              I(h) || b.movedLabel ? h && h.textStr !== g && !k && (!h.textWidth || a.style.width || h.styles.width || h.css({
                width: null
              }), h.attr({
                text: g
              }), h.textPxLength = h.getBBox().width) : (b.label = h = b.createLabel({
                x: 0,
                y: 0
              }, g, a), b.rotation = 0);
            };

            f.prototype.createLabel = function (b, c, f) {
              var w = this.axis,
                  l = w.chart;
              if (b = I(c) && f.enabled ? l.renderer.text(c, b.x, b.y, f.useHTML).add(w.labelGroup) : null) l.styledMode || b.css(g(f.style)), b.textPxLength = b.getBBox().width;
              return b;
            };

            f.prototype.destroy = function () {
              y(this, this.axis);
            };

            f.prototype.getPosition = function (b, c, f, g) {
              var w = this.axis,
                  p = w.chart,
                  m = g && p.oldChartHeight || p.chartHeight;
              b = {
                x: b ? E(w.translate(c + f, void 0, void 0, g) + w.transB) : w.left + w.offset + (w.opposite ? (g && p.oldChartWidth || p.chartWidth) - w.right - w.left : 0),
                y: b ? m - w.bottom + w.offset - (w.opposite ? w.height : 0) : E(m - w.translate(c + f, void 0, void 0, g) - w.transB)
              };
              b.y = B(b.y, -1E5, 1E5);
              q(this, "afterGetPosition", {
                pos: b
              });
              return b;
            };

            f.prototype.getLabelPosition = function (b, c, f, g, l, p, m, t) {
              var a = this.axis,
                  z = a.transA,
                  d = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,
                  w = a.staggerLines,
                  k = a.tickRotCorr || {
                x: 0,
                y: 0
              },
                  h = g || a.reserveSpaceDefault ? 0 : -a.labelOffset * ("center" === a.labelAlign ? .5 : 1),
                  L = {};
              f = 0 === a.side ? f.rotation ? -8 : -f.getBBox().height : 2 === a.side ? k.y + 8 : Math.cos(f.rotation * G) * (k.y - f.getBBox(!1, 0).height / 2);
              I(l.y) && (f = 0 === a.side && a.horiz ? l.y + f : l.y);
              b = b + l.x + h + k.x - (p && g ? p * z * (d ? -1 : 1) : 0);
              c = c + f - (p && !g ? p * z * (d ? 1 : -1) : 0);
              w && (g = m / (t || 1) % w, a.opposite && (g = w - g - 1), c += a.labelOffset / w * g);
              L.x = b;
              L.y = Math.round(c);
              q(this, "afterGetLabelPosition", {
                pos: L,
                tickmarkOffset: p,
                index: m
              });
              return L;
            };

            f.prototype.getLabelSize = function () {
              return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };

            f.prototype.getMarkPath = function (b, c, f, g, l, p) {
              return p.crispLine([["M", b, c], ["L", b + (l ? 0 : -f), c + (l ? f : 0)]], g);
            };

            f.prototype.handleOverflow = function (b) {
              var c = this.axis,
                  f = c.options.labels,
                  g = b.x,
                  l = c.chart.chartWidth,
                  p = c.chart.spacing,
                  m = x(c.labelLeft, Math.min(c.pos, p[3]));
              p = x(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, l - p[1]));
              var t = this.label,
                  a = this.rotation,
                  z = {
                left: 0,
                center: .5,
                right: 1
              }[c.labelAlign || t.attr("align")],
                  d = t.getBBox().width,
                  F = c.getSlotWidth(this),
                  k = {},
                  h = F,
                  L = 1,
                  P;
              if (a || "justify" !== f.overflow) 0 > a && g - z * d < m ? P = Math.round(g / Math.cos(a * G) - m) : 0 < a && g + z * d > p && (P = Math.round((l - g) / Math.cos(a * G)));else if (l = g + (1 - z) * d, g - z * d < m ? h = b.x + h * (1 - z) - m : l > p && (h = p - b.x + h * z, L = -1), h = Math.min(F, h), h < F && "center" === c.labelAlign && (b.x += L * (F - h - z * (F - Math.min(d, h)))), d > h || c.autoRotation && (t.styles || {}).width) P = h;
              P && (this.shortenLabel ? this.shortenLabel() : (k.width = Math.floor(P) + "px", (f.style || {}).textOverflow || (k.textOverflow = "ellipsis"), t.css(k)));
            };

            f.prototype.moveLabel = function (b, c) {
              var f = this,
                  g = f.label,
                  w = f.axis,
                  p = w.reversed,
                  m = !1;
              g && g.textStr === b ? (f.movedLabel = g, m = !0, delete f.label) : l(w.ticks, function (a) {
                m || a.isNew || a === f || !a.label || a.label.textStr !== b || (f.movedLabel = a.label, m = !0, a.labelPos = f.movedLabel.xy, delete a.label);
              });

              if (!m && (f.labelPos || g)) {
                var t = f.labelPos || g.xy;
                g = w.horiz ? p ? 0 : w.width + w.left : t.x;
                w = w.horiz ? t.y : p ? w.width + w.left : 0;
                f.movedLabel = f.createLabel({
                  x: g,
                  y: w
                }, b, c);
                f.movedLabel && f.movedLabel.attr({
                  opacity: 0
                });
              }
            };

            f.prototype.render = function (b, c, f) {
              var g = this.axis,
                  l = g.horiz,
                  p = this.pos,
                  m = x(this.tickmarkOffset, g.tickmarkOffset);
              p = this.getPosition(l, p, m, c);
              m = p.x;
              var t = p.y;
              g = l && m === g.pos + g.len || !l && t === g.pos ? -1 : 1;
              l = x(f, this.label && this.label.newOpacity, 1);
              f = x(f, 1);
              this.isActive = !0;
              this.renderGridLine(c, f, g);
              this.renderMark(p, f, g);
              this.renderLabel(p, c, l, b);
              this.isNew = !1;
              q(this, "afterRender");
            };

            f.prototype.renderGridLine = function (b, c, f) {
              var g = this.axis,
                  l = g.options,
                  p = {},
                  m = this.pos,
                  t = this.type,
                  a = x(this.tickmarkOffset, g.tickmarkOffset),
                  z = g.chart.renderer,
                  d = this.gridLine,
                  w = l.gridLineWidth,
                  k = l.gridLineColor,
                  h = l.gridLineDashStyle;
              "minor" === this.type && (w = l.minorGridLineWidth, k = l.minorGridLineColor, h = l.minorGridLineDashStyle);
              d || (g.chart.styledMode || (p.stroke = k, p["stroke-width"] = w || 0, p.dashstyle = h), t || (p.zIndex = 1), b && (c = 0), this.gridLine = d = z.path().attr(p).addClass("highcharts-" + (t ? t + "-" : "") + "grid-line").add(g.gridGroup));
              if (d && (f = g.getPlotLinePath({
                value: m + a,
                lineWidth: d.strokeWidth() * f,
                force: "pass",
                old: b
              }))) d[b || this.isNew ? "attr" : "animate"]({
                d: f,
                opacity: c
              });
            };

            f.prototype.renderMark = function (b, c, f) {
              var g = this.axis,
                  l = g.options,
                  p = g.chart.renderer,
                  m = this.type,
                  t = g.tickSize(m ? m + "Tick" : "tick"),
                  a = b.x;
              b = b.y;
              var z = x(l["minor" !== m ? "tickWidth" : "minorTickWidth"], !m && g.isXAxis ? 1 : 0);
              l = l["minor" !== m ? "tickColor" : "minorTickColor"];
              var d = this.mark,
                  w = !d;
              t && (g.opposite && (t[0] = -t[0]), d || (this.mark = d = p.path().addClass("highcharts-" + (m ? m + "-" : "") + "tick").add(g.axisGroup), g.chart.styledMode || d.attr({
                stroke: l,
                "stroke-width": z
              })), d[w ? "attr" : "animate"]({
                d: this.getMarkPath(a, b, t[0], d.strokeWidth() * f, g.horiz, p),
                opacity: c
              }));
            };

            f.prototype.renderLabel = function (b, f, g, l) {
              var w = this.axis,
                  p = w.horiz,
                  m = w.options,
                  t = this.label,
                  a = m.labels,
                  z = a.step;
              w = x(this.tickmarkOffset, w.tickmarkOffset);
              var d = b.x;
              b = b.y;
              var F = !0;
              t && c(d) && (t.xy = b = this.getLabelPosition(d, b, t, p, a, w, l, z), this.isFirst && !this.isLast && !m.showFirstLabel || this.isLast && !this.isFirst && !m.showLastLabel ? F = !1 : !p || a.step || a.rotation || f || 0 === g || this.handleOverflow(b), z && l % z && (F = !1), F && c(b.y) ? (b.opacity = g, t[this.isNewLabel ? "attr" : "animate"](b).show(!0), this.isNewLabel = !1) : (t.hide(), this.isNewLabel = !0));
            };

            f.prototype.replaceMovedLabel = function () {
              var b = this.label,
                  c = this.axis,
                  f = c.reversed;

              if (b && !this.isNew) {
                var g = c.horiz ? f ? c.left : c.width + c.left : b.xy.x;
                f = c.horiz ? b.xy.y : f ? c.width + c.top : c.top;
                b.animate({
                  x: g,
                  y: f,
                  opacity: 0
                }, void 0, b.destroy);
                delete this.label;
              }

              c.isDirty = !0;
              this.label = this.movedLabel;
              delete this.movedLabel;
            };

            return f;
          }();

          "";
          return n;
        });
        N(e, "Core/Axis/Axis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/AxisDefaults.js"], e["Core/Color/Color.js"], e["Core/DefaultOptions.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Axis/Tick.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E, I, y) {
          var r = e.animObject,
              q = H.defaultOptions,
              c = B.registerEventOptions,
              g = E.deg2rad,
              l = y.arrayMax,
              x = y.arrayMin,
              f = y.clamp,
              b = y.correctFloat,
              w = y.defined,
              J = y.destroyObjectProperties,
              C = y.erase,
              K = y.error,
              p = y.extend,
              m = y.fireEvent,
              t = y.isArray,
              a = y.isNumber,
              z = y.isString,
              d = y.merge,
              F = y.normalizeTickInterval,
              k = y.objectEach,
              h = y.pick,
              L = y.relativeLength,
              P = y.removeEvent,
              u = y.splat,
              A = y.syncTimeout,
              O = function O(a, d) {
            return F(d, void 0, void 0, h(a.options.allowDecimals, .5 > d || void 0 !== a.tickAmount), !!a.tickAmount);
          };

          e = function () {
            function F(a, d) {
              this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
              this.init(a, d);
            }

            F.prototype.init = function (d, b) {
              var v = b.isX;
              this.chart = d;
              this.horiz = d.inverted && !this.isZAxis ? !v : v;
              this.isXAxis = v;
              this.coll = this.coll || (v ? "xAxis" : "yAxis");
              m(this, "init", {
                userOptions: b
              });
              this.opposite = h(b.opposite, this.opposite);
              this.side = h(b.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
              this.setOptions(b);
              var k = this.options,
                  f = k.labels,
                  t = k.type;
              this.userOptions = b;
              this.minPixelPadding = 0;
              this.reversed = h(k.reversed, this.reversed);
              this.visible = k.visible;
              this.zoomEnabled = k.zoomEnabled;
              this.hasNames = "category" === t || !0 === k.categories;
              this.categories = k.categories || (this.hasNames ? [] : void 0);
              this.names || (this.names = [], this.names.keys = {});
              this.plotLinesAndBandsGroups = {};
              this.positiveValuesOnly = !!this.logarithmic;
              this.isLinked = w(k.linkedTo);
              this.ticks = {};
              this.labelEdge = [];
              this.minorTicks = {};
              this.plotLinesAndBands = [];
              this.alternateBands = {};
              this.len = 0;
              this.minRange = this.userMinRange = k.minRange || k.maxZoom;
              this.range = k.range;
              this.offset = k.offset || 0;
              this.min = this.max = null;
              b = h(k.crosshair, u(d.options.tooltip.crosshairs)[v ? 0 : 1]);
              this.crosshair = !0 === b ? {} : b;
              -1 === d.axes.indexOf(this) && (v ? d.axes.splice(d.xAxis.length, 0, this) : d.axes.push(this), d[this.coll].push(this));
              this.series = this.series || [];
              d.inverted && !this.isZAxis && v && "undefined" === typeof this.reversed && (this.reversed = !0);
              this.labelRotation = a(f.rotation) ? f.rotation : void 0;
              c(this, k);
              m(this, "afterInit");
            };

            F.prototype.setOptions = function (a) {
              this.options = d(n.defaultXAxisOptions, "yAxis" === this.coll && n.defaultYAxisOptions, [n.defaultTopAxisOptions, n.defaultRightAxisOptions, n.defaultBottomAxisOptions, n.defaultLeftAxisOptions][this.side], d(q[this.coll], a));
              m(this, "afterSetOptions", {
                userOptions: a
              });
            };

            F.prototype.defaultLabelFormatter = function (d) {
              var v = this.axis;
              d = this.chart.numberFormatter;
              var h = a(this.value) ? this.value : NaN,
                  b = v.chart.time,
                  c = this.dateTimeLabelFormat,
                  k = q.lang,
                  m = k.numericSymbols;
              k = k.numericSymbolMagnitude || 1E3;
              var f = v.logarithmic ? Math.abs(h) : v.tickInterval,
                  u = m && m.length;
              if (v.categories) var t = "".concat(this.value);else if (c) t = b.dateFormat(c, h);else if (u && 1E3 <= f) for (; u-- && "undefined" === typeof t;) {
                v = Math.pow(k, u + 1), f >= v && 0 === 10 * h % v && null !== m[u] && 0 !== h && (t = d(h / v, -1) + m[u]);
              }
              "undefined" === typeof t && (t = 1E4 <= Math.abs(h) ? d(h, -1) : d(h, -1, void 0, ""));
              return t;
            };

            F.prototype.getSeriesExtremes = function () {
              var d = this,
                  b = d.chart,
                  c;
              m(this, "getSeriesExtremes", null, function () {
                d.hasVisibleSeries = !1;
                d.dataMin = d.dataMax = d.threshold = null;
                d.softThreshold = !d.isXAxis;
                d.stacking && d.stacking.buildStacks();
                d.series.forEach(function (v) {
                  if (v.visible || !b.options.chart.ignoreHiddenSeries) {
                    var k = v.options,
                        m = k.threshold;
                    d.hasVisibleSeries = !0;
                    d.positiveValuesOnly && 0 >= m && (m = null);

                    if (d.isXAxis) {
                      if (k = v.xData, k.length) {
                        k = d.logarithmic ? k.filter(d.validatePositiveValue) : k;
                        c = v.getXExtremes(k);
                        var f = c.min;
                        var u = c.max;
                        a(f) || f instanceof Date || (k = k.filter(a), c = v.getXExtremes(k), f = c.min, u = c.max);
                        k.length && (d.dataMin = Math.min(h(d.dataMin, f), f), d.dataMax = Math.max(h(d.dataMax, u), u));
                      }
                    } else if (v = v.applyExtremes(), a(v.dataMin) && (f = v.dataMin, d.dataMin = Math.min(h(d.dataMin, f), f)), a(v.dataMax) && (u = v.dataMax, d.dataMax = Math.max(h(d.dataMax, u), u)), w(m) && (d.threshold = m), !k.softThreshold || d.positiveValuesOnly) d.softThreshold = !1;
                  }
                });
              });
              m(this, "afterGetSeriesExtremes");
            };

            F.prototype.translate = function (d, h, c, k, m, f) {
              var v = this.linkedParent || this,
                  u = k && v.old ? v.old.min : v.min;
              if (!a(u)) return NaN;
              var t = v.minPixelPadding;
              m = (v.isOrdinal || v.brokenAxis && v.brokenAxis.hasBreaks || v.logarithmic && m) && v.lin2val;
              var A = 1,
                  p = 0;
              k = k && v.old ? v.old.transA : v.transA;
              k || (k = v.transA);
              c && (A *= -1, p = v.len);
              v.reversed && (A *= -1, p -= A * (v.sector || v.len));
              h ? (f = (d * A + p - t) / k + u, m && (f = v.lin2val(f))) : (m && (d = v.val2lin(d)), d = A * (d - u) * k, f = (v.isRadial ? d : b(d)) + p + A * t + (a(f) ? k * f : 0));
              return f;
            };

            F.prototype.toPixels = function (a, d) {
              return this.translate(a, !1, !this.horiz, void 0, !0) + (d ? 0 : this.pos);
            };

            F.prototype.toValue = function (a, d) {
              return this.translate(a - (d ? 0 : this.pos), !0, !this.horiz, void 0, !0);
            };

            F.prototype.getPlotLinePath = function (d) {
              function v(a, d, v) {
                if ("pass" !== w && a < d || a > v) w ? a = f(a, d, v) : q = !0;
                return a;
              }

              var b = this,
                  c = b.chart,
                  k = b.left,
                  u = b.top,
                  t = d.old,
                  A = d.value,
                  p = d.lineWidth,
                  g = t && c.oldChartHeight || c.chartHeight,
                  z = t && c.oldChartWidth || c.chartWidth,
                  F = b.transB,
                  l = d.translatedValue,
                  w = d.force,
                  L,
                  P,
                  e,
                  x,
                  q;
              d = {
                value: A,
                lineWidth: p,
                old: t,
                force: w,
                acrossPanes: d.acrossPanes,
                translatedValue: l
              };
              m(this, "getPlotLinePath", d, function (d) {
                l = h(l, b.translate(A, void 0, void 0, t));
                l = f(l, -1E5, 1E5);
                L = e = Math.round(l + F);
                P = x = Math.round(g - l - F);
                a(l) ? b.horiz ? (P = u, x = g - b.bottom, L = e = v(L, k, k + b.width)) : (L = k, e = z - b.right, P = x = v(P, u, u + b.height)) : (q = !0, w = !1);
                d.path = q && !w ? null : c.renderer.crispLine([["M", L, P], ["L", e, x]], p || 1);
              });
              return d.path;
            };

            F.prototype.getLinearTickPositions = function (a, d, h) {
              var v = b(Math.floor(d / a) * a);
              h = b(Math.ceil(h / a) * a);
              var c = [],
                  k;
              b(v + a) === v && (k = 20);
              if (this.single) return [d];

              for (d = v; d <= h;) {
                c.push(d);
                d = b(d + a, k);
                if (d === m) break;
                var m = d;
              }

              return c;
            };

            F.prototype.getMinorTickInterval = function () {
              var a = this.options;
              return !0 === a.minorTicks ? h(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
            };

            F.prototype.getMinorTickPositions = function () {
              var a = this.options,
                  d = this.tickPositions,
                  h = this.minorTickInterval,
                  b = this.pointRangePadding || 0,
                  c = this.min - b;
              b = this.max + b;
              var k = b - c,
                  m = [];

              if (k && k / h < this.len / 3) {
                var f = this.logarithmic;
                if (f) this.paddedTicks.forEach(function (a, d, v) {
                  d && m.push.apply(m, f.getLogTickPositions(h, v[d - 1], v[d], !0));
                });else if (this.dateTime && "auto" === this.getMinorTickInterval()) m = m.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(h), c, b, a.startOfWeek));else for (a = c + (d[0] - c) % h; a <= b && a !== m[0]; a += h) {
                  m.push(a);
                }
              }

              0 !== m.length && this.trimTicks(m);
              return m;
            };

            F.prototype.adjustForMinRange = function () {
              var a = this.options,
                  d = this.logarithmic,
                  b = this.min,
                  c = this.max,
                  k = 0,
                  m,
                  f,
                  u,
                  t;
              this.isXAxis && "undefined" === typeof this.minRange && !d && (w(a.min) || w(a.max) || w(a.floor) || w(a.ceiling) ? this.minRange = null : (this.series.forEach(function (a) {
                u = a.xData;
                t = a.xIncrement ? 1 : u.length - 1;
                if (1 < u.length) for (m = t; 0 < m; m--) {
                  if (f = u[m] - u[m - 1], !k || f < k) k = f;
                }
              }), this.minRange = Math.min(5 * k, this.dataMax - this.dataMin)));

              if (c - b < this.minRange) {
                var A = this.dataMax - this.dataMin >= this.minRange;
                var p = this.minRange;
                var g = (p - c + b) / 2;
                g = [b - g, h(a.min, b - g)];
                A && (g[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                b = l(g);
                c = [b + p, h(a.max, b + p)];
                A && (c[2] = d ? d.log2lin(this.dataMax) : this.dataMax);
                c = x(c);
                c - b < p && (g[0] = c - p, g[1] = h(a.min, c - p), b = l(g));
              }

              this.min = b;
              this.max = c;
            };

            F.prototype.getClosest = function () {
              var a;
              this.categories ? a = 1 : this.series.forEach(function (d) {
                var h = d.closestPointRange,
                    b = d.visible || !d.chart.options.chart.ignoreHiddenSeries;
                !d.noSharedTooltip && w(h) && b && (a = w(a) ? Math.min(a, h) : h);
              });
              return a;
            };

            F.prototype.nameToX = function (a) {
              var d = t(this.options.categories),
                  b = d ? this.categories : this.names,
                  v = a.options.x;
              a.series.requireSorting = !1;
              w(v) || (v = this.options.uniqueNames && b ? d ? b.indexOf(a.name) : h(b.keys[a.name], -1) : a.series.autoIncrement());

              if (-1 === v) {
                if (!d && b) var c = b.length;
              } else c = v;

              "undefined" !== typeof c && (this.names[c] = a.name, this.names.keys[a.name] = c);
              return c;
            };

            F.prototype.updateNames = function () {
              var a = this,
                  d = this.names;
              0 < d.length && (Object.keys(d.keys).forEach(function (a) {
                delete d.keys[a];
              }), d.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (d) {
                d.xIncrement = null;
                if (!d.points || d.isDirtyData) a.max = Math.max(a.max, d.xData.length - 1), d.processData(), d.generatePoints();
                d.data.forEach(function (h, b) {
                  if (h && h.options && "undefined" !== typeof h.name) {
                    var v = a.nameToX(h);
                    "undefined" !== typeof v && v !== h.x && (h.x = v, d.xData[b] = v);
                  }
                });
              }));
            };

            F.prototype.setAxisTranslation = function () {
              var a = this,
                  d = a.max - a.min,
                  b = a.linkedParent,
                  c = !!a.categories,
                  k = a.isXAxis,
                  f = a.axisPointRange || 0,
                  u = 0,
                  t = 0,
                  A = a.transA;

              if (k || c || f) {
                var p = a.getClosest();
                b ? (u = b.minPointOffset, t = b.pointRangePadding) : a.series.forEach(function (d) {
                  var b = c ? 1 : k ? h(d.options.pointRange, p, 0) : a.axisPointRange || 0,
                      v = d.options.pointPlacement;
                  f = Math.max(f, b);
                  if (!a.single || c) d = d.is("xrange") ? !k : k, u = Math.max(u, d && z(v) ? 0 : b / 2), t = Math.max(t, d && "on" === v ? 0 : b);
                });
                b = a.ordinal && a.ordinal.slope && p ? a.ordinal.slope / p : 1;
                a.minPointOffset = u *= b;
                a.pointRangePadding = t *= b;
                a.pointRange = Math.min(f, a.single && c ? 1 : d);
                k && (a.closestPointRange = p);
              }

              a.translationSlope = a.transA = A = a.staticScale || a.len / (d + t || 1);
              a.transB = a.horiz ? a.left : a.bottom;
              a.minPixelPadding = A * u;
              m(this, "afterSetAxisTranslation");
            };

            F.prototype.minFromRange = function () {
              return this.max - this.range;
            };

            F.prototype.setTickInterval = function (d) {
              var c = this.chart,
                  v = this.logarithmic,
                  k = this.options,
                  f = this.isXAxis,
                  u = this.isLinked,
                  t = k.tickPixelInterval,
                  A = this.categories,
                  p = this.softThreshold,
                  g = k.maxPadding,
                  z = k.minPadding,
                  l = a(k.tickInterval) && 0 <= k.tickInterval ? k.tickInterval : void 0,
                  F = a(this.threshold) ? this.threshold : null;
              this.dateTime || A || u || this.getTickAmount();
              var L = h(this.userMin, k.min);
              var P = h(this.userMax, k.max);

              if (u) {
                this.linkedParent = c[this.coll][k.linkedTo];
                var e = this.linkedParent.getExtremes();
                this.min = h(e.min, e.dataMin);
                this.max = h(e.max, e.dataMax);
                k.type !== this.linkedParent.options.type && K(11, 1, c);
              } else {
                if (p && w(F)) if (this.dataMin >= F) e = F, z = 0;else if (this.dataMax <= F) {
                  var x = F;
                  g = 0;
                }
                this.min = h(L, e, this.dataMin);
                this.max = h(P, x, this.dataMax);
              }

              v && (this.positiveValuesOnly && !d && 0 >= Math.min(this.min, h(this.dataMin, this.min)) && K(10, 1, c), this.min = b(v.log2lin(this.min), 16), this.max = b(v.log2lin(this.max), 16));
              this.range && w(this.max) && (this.userMin = this.min = L = Math.max(this.dataMin, this.minFromRange()), this.userMax = P = this.max, this.range = null);
              m(this, "foundExtremes");
              this.beforePadding && this.beforePadding();
              this.adjustForMinRange();
              !(A || this.axisPointRange || this.stacking && this.stacking.usePercentage || u) && w(this.min) && w(this.max) && (c = this.max - this.min) && (!w(L) && z && (this.min -= c * z), !w(P) && g && (this.max += c * g));
              a(this.userMin) || (a(k.softMin) && k.softMin < this.min && (this.min = L = k.softMin), a(k.floor) && (this.min = Math.max(this.min, k.floor)));
              a(this.userMax) || (a(k.softMax) && k.softMax > this.max && (this.max = P = k.softMax), a(k.ceiling) && (this.max = Math.min(this.max, k.ceiling)));
              p && w(this.dataMin) && (F = F || 0, !w(L) && this.min < F && this.dataMin >= F ? this.min = this.options.minRange ? Math.min(F, this.max - this.minRange) : F : !w(P) && this.max > F && this.dataMax <= F && (this.max = this.options.minRange ? Math.max(F, this.min + this.minRange) : F));
              a(this.min) && a(this.max) && !this.chart.polar && this.min > this.max && (w(this.options.min) ? this.max = this.min : w(this.options.max) && (this.min = this.max));
              this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : u && this.linkedParent && !l && t === this.linkedParent.options.tickPixelInterval ? l = this.linkedParent.tickInterval : h(l, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, A ? 1 : (this.max - this.min) * t / Math.max(this.len, t));

              if (f && !d) {
                var q = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
                this.series.forEach(function (a) {
                  a.forceCrop = a.forceCropping && a.forceCropping();
                  a.processData(q);
                });
                m(this, "postProcessData", {
                  hasExtemesChanged: q
                });
              }

              this.setAxisTranslation();
              m(this, "initialAxisTranslation");
              this.pointRange && !l && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
              d = h(k.minTickInterval, this.dateTime && !this.series.some(function (a) {
                return a.noSharedTooltip;
              }) ? this.closestPointRange : 0);
              !l && this.tickInterval < d && (this.tickInterval = d);
              this.dateTime || this.logarithmic || l || (this.tickInterval = O(this, this.tickInterval));
              this.tickAmount || (this.tickInterval = this.unsquish());
              this.setTickPositions();
            };

            F.prototype.setTickPositions = function () {
              var a = this.options,
                  d = a.tickPositions,
                  b = this.getMinorTickInterval(),
                  h = this.hasVerticalPanning(),
                  c = "colorAxis" === this.coll,
                  k = (c || !h) && a.startOnTick;
              h = (c || !h) && a.endOnTick;
              c = a.tickPositioner;
              this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
              this.minorTickInterval = "auto" === b && this.tickInterval ? this.tickInterval / 5 : b;
              this.single = this.min === this.max && w(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
              this.tickPositions = b = d && d.slice();

              if (!b) {
                if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {
                  if (this.dateTime) b = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) b = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (var f = a = this.tickInterval; f <= 2 * a;) {
                    if (b = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && b.length > this.tickAmount) this.tickInterval = O(this, f *= 1.1);else break;
                  }
                } else b = [this.min, this.max], K(19, !1, this.chart);
                b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1));
                this.tickPositions = b;
                c && (c = c.apply(this, [this.min, this.max])) && (this.tickPositions = b = c);
              }

              this.paddedTicks = b.slice(0);
              this.trimTicks(b, k, h);
              this.isLinked || (this.single && 2 > b.length && !this.categories && !this.series.some(function (a) {
                return a.is("heatmap") && "between" === a.options.pointPlacement;
              }) && (this.min -= .5, this.max += .5), d || c || this.adjustTickAmount());
              m(this, "afterSetTickPositions");
            };

            F.prototype.trimTicks = function (a, d, b) {
              var h = a[0],
                  c = a[a.length - 1],
                  k = !this.isOrdinal && this.minPointOffset || 0;
              m(this, "trimTicks");

              if (!this.isLinked) {
                if (d && -Infinity !== h) this.min = h;else for (; this.min - k > a[0];) {
                  a.shift();
                }
                if (b) this.max = c;else for (; this.max + k < a[a.length - 1];) {
                  a.pop();
                }
                0 === a.length && w(h) && !this.options.tickPositions && a.push((c + h) / 2);
              }
            };

            F.prototype.alignToOthers = function () {
              var d = this,
                  b = [this],
                  h = d.options,
                  c = "yAxis" === this.coll && this.chart.options.chart.alignThresholds,
                  k = [],
                  m;
              d.thresholdAlignment = void 0;

              if ((!1 !== this.chart.options.chart.alignTicks && h.alignTicks || c) && !1 !== h.startOnTick && !1 !== h.endOnTick && !d.logarithmic) {
                var f = function f(a) {
                  var d = a.options;
                  return [a.horiz ? d.left : d.top, d.width, d.height, d.pane].join();
                },
                    u = f(this);

                this.chart[this.coll].forEach(function (a) {
                  var h = a.series;
                  h.length && h.some(function (a) {
                    return a.visible;
                  }) && a !== d && f(a) === u && (m = !0, b.push(a));
                });
              }

              if (m && c) {
                b.forEach(function (b) {
                  b = b.getThresholdAlignment(d);
                  a(b) && k.push(b);
                });
                var t = 1 < k.length ? k.reduce(function (a, d) {
                  return a + d;
                }, 0) / k.length : void 0;
                b.forEach(function (a) {
                  a.thresholdAlignment = t;
                });
              }

              return m;
            };

            F.prototype.getThresholdAlignment = function (d) {
              (!a(this.dataMin) || this !== d && this.series.some(function (a) {
                return a.isDirty || a.isDirtyData;
              })) && this.getSeriesExtremes();
              if (a(this.threshold)) return d = f((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (d = 1 - d), d;
            };

            F.prototype.getTickAmount = function () {
              var a = this.options,
                  d = a.tickPixelInterval,
                  b = a.tickAmount;
              !w(a.tickInterval) && !b && this.len < d && !this.isRadial && !this.logarithmic && a.startOnTick && a.endOnTick && (b = 2);
              !b && this.alignToOthers() && (b = Math.ceil(this.len / d) + 1);
              4 > b && (this.finalTickAmt = b, b = 5);
              this.tickAmount = b;
            };

            F.prototype.adjustTickAmount = function () {
              var d = this,
                  c = d.finalTickAmt,
                  k = d.max,
                  m = d.min,
                  f = d.options,
                  u = d.tickPositions,
                  t = d.tickAmount,
                  A = d.thresholdAlignment,
                  p = u && u.length,
                  g = h(d.threshold, d.softThreshold ? 0 : null);
              var z = d.tickInterval;

              if (a(A)) {
                var F = .5 > A ? Math.ceil(A * (t - 1)) : Math.floor(A * (t - 1));
                f.reversed && (F = t - 1 - F);
              }

              if (d.hasData() && a(m) && a(k)) {
                A = function A() {
                  d.transA *= (p - 1) / (t - 1);
                  d.min = f.startOnTick ? u[0] : Math.min(m, u[0]);
                  d.max = f.endOnTick ? u[u.length - 1] : Math.max(k, u[u.length - 1]);
                };

                if (a(F) && a(d.threshold)) {
                  for (; u[F] !== g || u.length !== t || u[0] > m || u[u.length - 1] < k;) {
                    u.length = 0;

                    for (u.push(d.threshold); u.length < t;) {
                      void 0 === u[F] || u[F] > d.threshold ? u.unshift(b(u[0] - z)) : u.push(b(u[u.length - 1] + z));
                    }

                    if (z > 8 * d.tickInterval) break;
                    z *= 2;
                  }

                  A();
                } else if (p < t) {
                  for (; u.length < t;) {
                    u.length % 2 || m === g ? u.push(b(u[u.length - 1] + z)) : u.unshift(b(u[0] - z));
                  }

                  A();
                }

                if (w(c)) {
                  for (z = g = u.length; z--;) {
                    (3 === c && 1 === z % 2 || 2 >= c && 0 < z && z < g - 1) && u.splice(z, 1);
                  }

                  d.finalTickAmt = void 0;
                }
              }
            };

            F.prototype.setScale = function () {
              var a = !1,
                  d = !1;
              this.series.forEach(function (b) {
                a = a || b.isDirtyData || b.isDirty;
                d = d || b.xAxis && b.xAxis.isDirty || !1;
              });
              this.setAxisSize();
              var b = this.len !== (this.old && this.old.len);
              b || a || d || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = b || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
              a && this.panningState && (this.panningState.isDirty = !0);
              m(this, "afterSetScale");
            };

            F.prototype.setExtremes = function (a, d, b, c, k) {
              var v = this,
                  u = v.chart;
              b = h(b, !0);
              v.series.forEach(function (a) {
                delete a.kdTree;
              });
              k = p(k, {
                min: a,
                max: d
              });
              m(v, "setExtremes", k, function () {
                v.userMin = a;
                v.userMax = d;
                v.eventArgs = k;
                b && u.redraw(c);
              });
            };

            F.prototype.zoom = function (a, d) {
              var b = this,
                  c = this.dataMin,
                  k = this.dataMax,
                  v = this.options,
                  u = Math.min(c, h(v.min, c)),
                  f = Math.max(k, h(v.max, k));
              a = {
                newMin: a,
                newMax: d
              };
              m(this, "zoom", a, function (a) {
                var d = a.newMin,
                    h = a.newMax;
                if (d !== b.min || h !== b.max) b.allowZoomOutside || (w(c) && (d < u && (d = u), d > f && (d = f)), w(k) && (h < u && (h = u), h > f && (h = f))), b.displayBtn = "undefined" !== typeof d || "undefined" !== typeof h, b.setExtremes(d, h, !1, void 0, {
                  trigger: "zoom"
                });
                a.zoomed = !0;
              });
              return a.zoomed;
            };

            F.prototype.setAxisSize = function () {
              var a = this.chart,
                  d = this.options,
                  b = d.offsets || [0, 0, 0, 0],
                  c = this.horiz,
                  k = this.width = Math.round(L(h(d.width, a.plotWidth - b[3] + b[1]), a.plotWidth)),
                  m = this.height = Math.round(L(h(d.height, a.plotHeight - b[0] + b[2]), a.plotHeight)),
                  u = this.top = Math.round(L(h(d.top, a.plotTop + b[0]), a.plotHeight, a.plotTop));
              d = this.left = Math.round(L(h(d.left, a.plotLeft + b[3]), a.plotWidth, a.plotLeft));
              this.bottom = a.chartHeight - m - u;
              this.right = a.chartWidth - k - d;
              this.len = Math.max(c ? k : m, 0);
              this.pos = c ? d : u;
            };

            F.prototype.getExtremes = function () {
              var a = this.logarithmic;
              return {
                min: a ? b(a.lin2log(this.min)) : this.min,
                max: a ? b(a.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
              };
            };

            F.prototype.getThreshold = function (a) {
              var d = this.logarithmic,
                  b = d ? d.lin2log(this.min) : this.min;
              d = d ? d.lin2log(this.max) : this.max;
              null === a || -Infinity === a ? a = b : Infinity === a ? a = d : b > a ? a = b : d < a && (a = d);
              return this.translate(a, 0, 1, 0, 1);
            };

            F.prototype.autoLabelAlign = function (a) {
              var d = (h(a, 0) - 90 * this.side + 720) % 360;
              a = {
                align: "center"
              };
              m(this, "autoLabelAlign", a, function (a) {
                15 < d && 165 > d ? a.align = "right" : 195 < d && 345 > d && (a.align = "left");
              });
              return a.align;
            };

            F.prototype.tickSize = function (a) {
              var d = this.options,
                  b = h(d["tick" === a ? "tickWidth" : "minorTickWidth"], "tick" === a && this.isXAxis && !this.categories ? 1 : 0),
                  c = d["tick" === a ? "tickLength" : "minorTickLength"];

              if (b && c) {
                "inside" === d[a + "Position"] && (c = -c);
                var k = [c, b];
              }

              a = {
                tickSize: k
              };
              m(this, "afterTickSize", a);
              return a.tickSize;
            };

            F.prototype.labelMetrics = function () {
              var a = this.tickPositions && this.tickPositions[0] || 0;
              return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
            };

            F.prototype.unsquish = function () {
              var d = this.options.labels,
                  c = this.horiz,
                  k = this.tickInterval,
                  m = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / k),
                  u = d.rotation,
                  f = this.labelMetrics(),
                  t = Math.max(this.max - this.min, 0),
                  A = function A(a) {
                var d = a / (m || 1);
                d = 1 < d ? Math.ceil(d) : 1;
                d * k > t && Infinity !== a && Infinity !== m && t && (d = Math.ceil(t / k));
                return b(d * k);
              },
                  p = k,
                  z,
                  F,
                  l = Number.MAX_VALUE;

              if (c) {
                if (!d.staggerLines && !d.step) if (a(u)) var w = [u];else m < d.autoRotationLimit && (w = d.autoRotation);
                w && w.forEach(function (a) {
                  if (a === u || a && -90 <= a && 90 >= a) {
                    F = A(Math.abs(f.h / Math.sin(g * a)));
                    var d = F + Math.abs(a / 360);
                    d < l && (l = d, z = a, p = F);
                  }
                });
              } else d.step || (p = A(f.h));

              this.autoRotation = w;
              this.labelRotation = h(z, a(u) ? u : 0);
              return p;
            };

            F.prototype.getSlotWidth = function (d) {
              var b = this.chart,
                  h = this.horiz,
                  c = this.options.labels,
                  k = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                  m = b.margin[3];
              if (d && a(d.slotWidth)) return d.slotWidth;
              if (h && 2 > c.step) return c.rotation ? 0 : (this.staggerLines || 1) * this.len / k;

              if (!h) {
                d = c.style.width;
                if (void 0 !== d) return parseInt(String(d), 10);
                if (m) return m - b.spacing[3];
              }

              return .33 * b.chartWidth;
            };

            F.prototype.renderUnsquish = function () {
              var a = this.chart,
                  d = a.renderer,
                  b = this.tickPositions,
                  h = this.ticks,
                  c = this.options.labels,
                  k = c.style,
                  m = this.horiz,
                  u = this.getSlotWidth(),
                  f = Math.max(1, Math.round(u - 2 * c.padding)),
                  t = {},
                  A = this.labelMetrics(),
                  p = k.textOverflow,
                  g = 0;
              z(c.rotation) || (t.rotation = c.rotation || 0);
              b.forEach(function (a) {
                a = h[a];
                a.movedLabel && a.replaceMovedLabel();
                a && a.label && a.label.textPxLength > g && (g = a.label.textPxLength);
              });
              this.maxLabelLength = g;
              if (this.autoRotation) g > f && g > A.h ? t.rotation = this.labelRotation : this.labelRotation = 0;else if (u) {
                var F = f;

                if (!p) {
                  var l = "clip";

                  for (f = b.length; !m && f--;) {
                    var w = b[f];
                    if (w = h[w].label) w.styles && "ellipsis" === w.styles.textOverflow ? w.css({
                      textOverflow: "clip"
                    }) : w.textPxLength > u && w.css({
                      width: u + "px"
                    }), w.getBBox().height > this.len / b.length - (A.h - A.f) && (w.specificTextOverflow = "ellipsis");
                  }
                }
              }
              t.rotation && (F = g > .5 * a.chartHeight ? .33 * a.chartHeight : g, p || (l = "ellipsis"));
              if (this.labelAlign = c.align || this.autoLabelAlign(this.labelRotation)) t.align = this.labelAlign;
              b.forEach(function (a) {
                var d = (a = h[a]) && a.label,
                    b = k.width,
                    c = {};
                d && (d.attr(t), a.shortenLabel ? a.shortenLabel() : F && !b && "nowrap" !== k.whiteSpace && (F < d.textPxLength || "SPAN" === d.element.tagName) ? (c.width = F + "px", p || (c.textOverflow = d.specificTextOverflow || l), d.css(c)) : d.styles && d.styles.width && !c.width && !b && d.css({
                  width: null
                }), delete d.specificTextOverflow, a.rotation = t.rotation);
              }, this);
              this.tickRotCorr = d.rotCorr(A.b, this.labelRotation || 0, 0 !== this.side);
            };

            F.prototype.hasData = function () {
              return this.series.some(function (a) {
                return a.hasData();
              }) || this.options.showEmpty && w(this.min) && w(this.max);
            };

            F.prototype.addTitle = function (a) {
              var b = this.chart.renderer,
                  h = this.horiz,
                  c = this.opposite,
                  k = this.options.title,
                  m = this.chart.styledMode,
                  u;
              this.axisTitle || ((u = k.textAlign) || (u = (h ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: c ? "right" : "left",
                middle: "center",
                high: c ? "left" : "right"
              })[k.align]), this.axisTitle = b.text(k.text || "", 0, 0, k.useHTML).attr({
                zIndex: 7,
                rotation: k.rotation,
                align: u
              }).addClass("highcharts-axis-title"), m || this.axisTitle.css(d(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
              m || k.style.width || this.isRadial || this.axisTitle.css({
                width: this.len + "px"
              });
              this.axisTitle[a ? "show" : "hide"](a);
            };

            F.prototype.generateTick = function (a) {
              var d = this.ticks;
              d[a] ? d[a].addLabel() : d[a] = new I(this, a);
            };

            F.prototype.getOffset = function () {
              var a = this,
                  d = this,
                  b = d.chart,
                  c = d.horiz,
                  u = d.options,
                  f = d.side,
                  t = d.ticks,
                  A = d.tickPositions,
                  p = d.coll,
                  g = d.axisParent,
                  z = b.renderer,
                  F = b.inverted && !d.isZAxis ? [1, 0, 3, 2][f] : f,
                  l = d.hasData(),
                  L = u.title,
                  P = u.labels,
                  e = b.axisOffset;
              b = b.clipOffset;
              var x = [-1, 1, 1, -1][f],
                  q = u.className,
                  r,
                  O = 0,
                  J = 0,
                  C = 0;
              d.showAxis = r = l || u.showEmpty;
              d.staggerLines = d.horiz && P.staggerLines || void 0;

              if (!d.axisGroup) {
                var K = function K(d, b, h) {
                  return z.g(d).attr({
                    zIndex: h
                  }).addClass("highcharts-".concat(p.toLowerCase()).concat(b, " ") + (a.isRadial ? "highcharts-radial-axis".concat(b, " ") : "") + (q || "")).add(g);
                };

                d.gridGroup = K("grid", "-grid", u.gridZIndex);
                d.axisGroup = K("axis", "", u.zIndex);
                d.labelGroup = K("axis-labels", "-labels", P.zIndex);
              }

              l || d.isLinked ? (A.forEach(function (a) {
                d.generateTick(a);
              }), d.renderUnsquish(), d.reserveSpaceDefault = 0 === f || 2 === f || {
                1: "left",
                3: "right"
              }[f] === d.labelAlign, h(P.reserveSpace, "center" === d.labelAlign ? !0 : null, d.reserveSpaceDefault) && A.forEach(function (a) {
                C = Math.max(t[a].getLabelSize(), C);
              }), d.staggerLines && (C *= d.staggerLines), d.labelOffset = C * (d.opposite ? -1 : 1)) : k(t, function (a, d) {
                a.destroy();
                delete t[d];
              });

              if (L && L.text && !1 !== L.enabled && (d.addTitle(r), r && !1 !== L.reserveSpace)) {
                d.titleOffset = O = d.axisTitle.getBBox()[c ? "height" : "width"];
                var n = L.offset;
                J = w(n) ? 0 : h(L.margin, c ? 5 : 10);
              }

              d.renderLine();
              d.offset = x * h(u.offset, e[f] ? e[f] + (u.margin || 0) : 0);
              d.tickRotCorr = d.tickRotCorr || {
                x: 0,
                y: 0
              };
              L = 0 === f ? -d.labelMetrics().h : 2 === f ? d.tickRotCorr.y : 0;
              l = Math.abs(C) + J;
              C && (l = l - L + x * (c ? h(P.y, d.tickRotCorr.y + 8 * x) : P.x));
              d.axisTitleMargin = h(n, l);
              d.getMaxLabelDimensions && (d.maxLabelDimensions = d.getMaxLabelDimensions(t, A));
              "colorAxis" !== p && (c = this.tickSize("tick"), e[f] = Math.max(e[f], (d.axisTitleMargin || 0) + O + x * d.offset, l, A && A.length && c ? c[0] + x * d.offset : 0), u = !d.axisLine || u.offset ? 0 : 2 * Math.floor(d.axisLine.strokeWidth() / 2), b[F] = Math.max(b[F], u));
              m(this, "afterGetOffset");
            };

            F.prototype.getLinePath = function (a) {
              var d = this.chart,
                  b = this.opposite,
                  h = this.offset,
                  c = this.horiz,
                  k = this.left + (b ? this.width : 0) + h;
              h = d.chartHeight - this.bottom - (b ? this.height : 0) + h;
              b && (a *= -1);
              return d.renderer.crispLine([["M", c ? this.left : k, c ? h : this.top], ["L", c ? d.chartWidth - this.right : k, c ? h : d.chartHeight - this.bottom]], a);
            };

            F.prototype.renderLine = function () {
              this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              }));
            };

            F.prototype.getTitlePosition = function () {
              var a = this.horiz,
                  d = this.left,
                  b = this.top,
                  h = this.len,
                  c = this.options.title,
                  k = a ? d : b,
                  u = this.opposite,
                  f = this.offset,
                  t = c.x,
                  A = c.y,
                  p = this.axisTitle,
                  g = this.chart.renderer.fontMetrics(c.style.fontSize, p);
              p = p ? Math.max(p.getBBox(!1, 0).height - g.h - 1, 0) : 0;
              h = {
                low: k + (a ? 0 : h),
                middle: k + h / 2,
                high: k + (a ? h : 0)
              }[c.align];
              d = (a ? b + this.height : d) + (a ? 1 : -1) * (u ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, g.f, -p][this.side];
              a = {
                x: a ? h + t : d + (u ? this.width : 0) + f + t,
                y: a ? d + A - (u ? this.height : 0) + f : h + A
              };
              m(this, "afterGetTitlePosition", {
                titlePosition: a
              });
              return a;
            };

            F.prototype.renderMinorTick = function (a, d) {
              var b = this.minorTicks;
              b[a] || (b[a] = new I(this, a, "minor"));
              d && b[a].isNew && b[a].render(null, !0);
              b[a].render(null, !1, 1);
            };

            F.prototype.renderTick = function (a, d, b) {
              var h = this.ticks;
              if (!this.isLinked || a >= this.min && a <= this.max || this.grid && this.grid.isColumn) h[a] || (h[a] = new I(this, a)), b && h[a].isNew && h[a].render(d, !0, -1), h[a].render(d);
            };

            F.prototype.render = function () {
              var d = this,
                  b = d.chart,
                  h = d.logarithmic,
                  c = d.options,
                  u = d.isLinked,
                  f = d.tickPositions,
                  t = d.axisTitle,
                  p = d.ticks,
                  g = d.minorTicks,
                  z = d.alternateBands,
                  F = c.stackLabels,
                  l = c.alternateGridColor,
                  w = d.tickmarkOffset,
                  L = d.axisLine,
                  P = d.showAxis,
                  e = r(b.renderer.globalAnimation),
                  x,
                  q;
              d.labelEdge.length = 0;
              d.overlap = !1;
              [p, g, z].forEach(function (a) {
                k(a, function (a) {
                  a.isActive = !1;
                });
              });

              if (d.hasData() || u) {
                var O = d.chart.hasRendered && d.old && a(d.old.min);
                d.minorTickInterval && !d.categories && d.getMinorTickPositions().forEach(function (a) {
                  d.renderMinorTick(a, O);
                });
                f.length && (f.forEach(function (a, b) {
                  d.renderTick(a, b, O);
                }), w && (0 === d.min || d.single) && (p[-1] || (p[-1] = new I(d, -1, null, !0)), p[-1].render(-1)));
                l && f.forEach(function (a, c) {
                  q = "undefined" !== typeof f[c + 1] ? f[c + 1] + w : d.max - w;
                  0 === c % 2 && a < d.max && q <= d.max + (b.polar ? -w : w) && (z[a] || (z[a] = new E.PlotLineOrBand(d)), x = a + w, z[a].options = {
                    from: h ? h.lin2log(x) : x,
                    to: h ? h.lin2log(q) : q,
                    color: l,
                    className: "highcharts-alternate-grid"
                  }, z[a].render(), z[a].isActive = !0);
                });
                d._addedPlotLB || (d._addedPlotLB = !0, (c.plotLines || []).concat(c.plotBands || []).forEach(function (a) {
                  d.addPlotBandOrLine(a);
                }));
              }

              [p, g, z].forEach(function (a) {
                var d = [],
                    h = e.duration;
                k(a, function (a, b) {
                  a.isActive || (a.render(b, !1, 0), a.isActive = !1, d.push(b));
                });
                A(function () {
                  for (var b = d.length; b--;) {
                    a[d[b]] && !a[d[b]].isActive && (a[d[b]].destroy(), delete a[d[b]]);
                  }
                }, a !== z && b.hasRendered && h ? h : 0);
              });
              L && (L[L.isPlaced ? "animate" : "attr"]({
                d: this.getLinePath(L.strokeWidth())
              }), L.isPlaced = !0, L[P ? "show" : "hide"](P));
              t && P && (c = d.getTitlePosition(), t[t.isNew ? "attr" : "animate"](c), t.isNew = !1);
              F && F.enabled && d.stacking && d.stacking.renderStackTotals();
              d.old = {
                len: d.len,
                max: d.max,
                min: d.min,
                transA: d.transA,
                userMax: d.userMax,
                userMin: d.userMin
              };
              d.isDirty = !1;
              m(this, "afterRender");
            };

            F.prototype.redraw = function () {
              this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {
                a.render();
              }));
              this.series.forEach(function (a) {
                a.isDirty = !0;
              });
            };

            F.prototype.getKeepProps = function () {
              return this.keepProps || F.keepProps;
            };

            F.prototype.destroy = function (a) {
              var d = this,
                  b = d.plotLinesAndBands,
                  h = this.eventOptions;
              m(this, "destroy", {
                keepEvents: a
              });
              a || P(d);
              [d.ticks, d.minorTicks, d.alternateBands].forEach(function (a) {
                J(a);
              });
              if (b) for (a = b.length; a--;) {
                b[a].destroy();
              }
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (a) {
                d[a] && (d[a] = d[a].destroy());
              });

              for (var c in d.plotLinesAndBandsGroups) {
                d.plotLinesAndBandsGroups[c] = d.plotLinesAndBandsGroups[c].destroy();
              }

              k(d, function (a, b) {
                -1 === d.getKeepProps().indexOf(b) && delete d[b];
              });
              this.eventOptions = h;
            };

            F.prototype.drawCrosshair = function (a, d) {
              var b = this.crosshair,
                  c = h(b && b.snap, !0),
                  k = this.chart,
                  u,
                  f = this.cross;
              m(this, "drawCrosshair", {
                e: a,
                point: d
              });
              a || (a = this.cross && this.cross.e);

              if (b && !1 !== (w(d) || !c)) {
                c ? w(d) && (u = h("colorAxis" !== this.coll ? d.crosshairPos : null, this.isXAxis ? d.plotX : this.len - d.plotY)) : u = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);

                if (w(u)) {
                  var t = {
                    value: d && (this.isXAxis ? d.x : h(d.stackY, d.y)),
                    translatedValue: u
                  };
                  k.polar && p(t, {
                    isCrosshair: !0,
                    chartX: a && a.chartX,
                    chartY: a && a.chartY,
                    point: d
                  });
                  t = this.getPlotLinePath(t) || null;
                }

                if (!w(t)) {
                  this.hideCrosshair();
                  return;
                }

                c = this.categories && !this.isRadial;
                f || (this.cross = f = k.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (c ? "category " : "thin ") + (b.className || "")).attr({
                  zIndex: h(b.zIndex, 2)
                }).add(), k.styledMode || (f.attr({
                  stroke: b.color || (c ? D.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                  "stroke-width": h(b.width, 1)
                }).css({
                  "pointer-events": "none"
                }), b.dashStyle && f.attr({
                  dashstyle: b.dashStyle
                })));
                f.show().attr({
                  d: t
                });
                c && !b.width && f.attr({
                  "stroke-width": this.transA
                });
                this.cross.e = a;
              } else this.hideCrosshair();

              m(this, "afterDrawCrosshair", {
                e: a,
                point: d
              });
            };

            F.prototype.hideCrosshair = function () {
              this.cross && this.cross.hide();
              m(this, "afterHideCrosshair");
            };

            F.prototype.hasVerticalPanning = function () {
              var a = this.chart.options.chart.panning;
              return !!(a && a.enabled && /y/.test(a.type));
            };

            F.prototype.validatePositiveValue = function (d) {
              return a(d) && 0 < d;
            };

            F.prototype.update = function (a, b) {
              var c = this.chart;
              a = d(this.userOptions, a);
              this.destroy(!0);
              this.init(c, a);
              c.isDirtyBox = !0;
              h(b, !0) && c.redraw();
            };

            F.prototype.remove = function (a) {
              for (var d = this.chart, b = this.coll, c = this.series, k = c.length; k--;) {
                c[k] && c[k].remove(!1);
              }

              C(d.axes, this);
              C(d[b], this);
              d[b].forEach(function (a, d) {
                a.options.index = a.userOptions.index = d;
              });
              this.destroy();
              d.isDirtyBox = !0;
              h(a, !0) && d.redraw();
            };

            F.prototype.setTitle = function (a, d) {
              this.update({
                title: a
              }, d);
            };

            F.prototype.setCategories = function (a, d) {
              this.update({
                categories: a
              }, d);
            };

            F.defaultOptions = n.defaultXAxisOptions;
            F.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return F;
          }();

          "";
          return e;
        });
        N(e, "Core/Axis/DateTimeAxis.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.addEvent,
              G = e.getMagnitude,
              H = e.normalizeTickInterval,
              B = e.timeUnits,
              E;

          (function (e) {
            function y() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }

            function r(g) {
              "datetime" !== g.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new c(this));
            }

            var q = [];

            e.compose = function (c) {
              -1 === q.indexOf(c) && (q.push(c), c.keepProps.push("dateTime"), c.prototype.getTimeTicks = y, n(c, "init", r));
              return c;
            };

            var c = function () {
              function c(c) {
                this.axis = c;
              }

              c.prototype.normalizeTimeTickInterval = function (c, g) {
                var f = g || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                g = f[f.length - 1];
                var b = B[g[0]],
                    l = g[1],
                    e;

                for (e = 0; e < f.length && !(g = f[e], b = B[g[0]], l = g[1], f[e + 1] && c <= (b * l[l.length - 1] + B[f[e + 1][0]]) / 2); e++) {
                  ;
                }

                b === B.year && c < 5 * b && (l = [1, 2, 5]);
                c = H(c / b, l, "year" === g[0] ? Math.max(G(c / b), 1) : 1);
                return {
                  unitRange: b,
                  count: c,
                  unitName: g[0]
                };
              };

              c.prototype.getXDateFormat = function (c, g) {
                var f = this.axis,
                    b = f.chart.time;
                return f.closestPointRange ? b.getDateFormat(f.closestPointRange, c, f.options.startOfWeek, g) || b.resolveDTLFormat(g.year).main : b.resolveDTLFormat(g.day).main;
              };

              return c;
            }();

            e.Additions = c;
          })(E || (E = {}));

          return E;
        });
        N(e, "Core/Axis/LogarithmicAxis.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.addEvent,
              G = e.normalizeTickInterval,
              H = e.pick,
              B;

          (function (e) {
            function I(c) {
              var g = this.logarithmic;
              "logarithmic" !== c.userOptions.type ? this.logarithmic = void 0 : g || (this.logarithmic = new q(this));
            }

            function y() {
              var c = this.logarithmic;
              c && (this.lin2val = function (g) {
                return c.lin2log(g);
              }, this.val2lin = function (g) {
                return c.log2lin(g);
              });
            }

            var r = [];

            e.compose = function (c) {
              -1 === r.indexOf(c) && (r.push(c), c.keepProps.push("logarithmic"), n(c, "init", I), n(c, "afterInit", y));
              return c;
            };

            var q = function () {
              function c(c) {
                this.axis = c;
              }

              c.prototype.getLogTickPositions = function (c, l, e, f) {
                var b = this.axis,
                    g = b.len,
                    x = b.options,
                    q = [];
                f || (this.minorAutoInterval = void 0);
                if (.5 <= c) c = Math.round(c), q = b.getLinearTickPositions(c, l, e);else if (.08 <= c) {
                  var r = Math.floor(l),
                      p,
                      m = x = void 0;

                  for (g = .3 < c ? [1, 2, 4] : .15 < c ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; r < e + 1 && !m; r++) {
                    var t = g.length;

                    for (p = 0; p < t && !m; p++) {
                      var a = this.log2lin(this.lin2log(r) * g[p]);
                      a > l && (!f || x <= e) && "undefined" !== typeof x && q.push(x);
                      x > e && (m = !0);
                      x = a;
                    }
                  }
                } else l = this.lin2log(l), e = this.lin2log(e), c = f ? b.getMinorTickInterval() : x.tickInterval, c = H("auto" === c ? null : c, this.minorAutoInterval, x.tickPixelInterval / (f ? 5 : 1) * (e - l) / ((f ? g / b.tickPositions.length : g) || 1)), c = G(c), q = b.getLinearTickPositions(c, l, e).map(this.log2lin), f || (this.minorAutoInterval = c / 5);
                f || (b.tickInterval = c);
                return q;
              };

              c.prototype.lin2log = function (c) {
                return Math.pow(10, c);
              };

              c.prototype.log2lin = function (c) {
                return Math.log(c) / Math.LN10;
              };

              return c;
            }();

            e.Additions = q;
          })(B || (B = {}));

          return B;
        });
        N(e, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.erase,
              G = e.extend,
              H = e.isNumber,
              B;

          (function (e) {
            var I = [],
                y;

            e.compose = function (e, c) {
              y || (y = e);
              -1 === I.indexOf(c) && (I.push(c), G(c.prototype, r.prototype));
              return c;
            };

            var r = function () {
              function e() {}

              e.prototype.getPlotBandPath = function (c, g, l) {
                void 0 === l && (l = this.options);
                var e = this.getPlotLinePath({
                  value: g,
                  force: !0,
                  acrossPanes: l.acrossPanes
                }),
                    f = [],
                    b = this.horiz;
                g = !H(this.min) || !H(this.max) || c < this.min && g < this.min || c > this.max && g > this.max;
                c = this.getPlotLinePath({
                  value: c,
                  force: !0,
                  acrossPanes: l.acrossPanes
                });
                l = 1;

                if (c && e) {
                  if (g) {
                    var w = c.toString() === e.toString();
                    l = 0;
                  }

                  for (g = 0; g < c.length; g += 2) {
                    var q = c[g],
                        r = c[g + 1],
                        K = e[g],
                        p = e[g + 1];
                    "M" !== q[0] && "L" !== q[0] || "M" !== r[0] && "L" !== r[0] || "M" !== K[0] && "L" !== K[0] || "M" !== p[0] && "L" !== p[0] || (b && K[1] === q[1] ? (K[1] += l, p[1] += l) : b || K[2] !== q[2] || (K[2] += l, p[2] += l), f.push(["M", q[1], q[2]], ["L", r[1], r[2]], ["L", p[1], p[2]], ["L", K[1], K[2]], ["Z"]));
                    f.isFlat = w;
                  }
                }

                return f;
              };

              e.prototype.addPlotBand = function (c) {
                return this.addPlotBandOrLine(c, "plotBands");
              };

              e.prototype.addPlotLine = function (c) {
                return this.addPlotBandOrLine(c, "plotLines");
              };

              e.prototype.addPlotBandOrLine = function (c, g) {
                var l = this,
                    e = this.userOptions,
                    f = new y(this, c);
                this.visible && (f = f.render());

                if (f) {
                  this._addedPlotLB || (this._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (b) {
                    l.addPlotBandOrLine(b);
                  }));

                  if (g) {
                    var b = e[g] || [];
                    b.push(c);
                    e[g] = b;
                  }

                  this.plotLinesAndBands.push(f);
                }

                return f;
              };

              e.prototype.removePlotBandOrLine = function (c) {
                var g = this.plotLinesAndBands,
                    l = this.options,
                    e = this.userOptions;

                if (g) {
                  for (var f = g.length; f--;) {
                    g[f].id === c && g[f].destroy();
                  }

                  [l.plotLines || [], e.plotLines || [], l.plotBands || [], e.plotBands || []].forEach(function (b) {
                    for (f = b.length; f--;) {
                      (b[f] || {}).id === c && n(b, b[f]);
                    }
                  });
                }
              };

              e.prototype.removePlotBand = function (c) {
                this.removePlotBandOrLine(c);
              };

              e.prototype.removePlotLine = function (c) {
                this.removePlotBandOrLine(c);
              };

              return e;
            }();
          })(B || (B = {}));

          return B;
        });
        N(e, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [e["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], e["Core/Utilities.js"]], function (e, n) {
          var G = n.arrayMax,
              H = n.arrayMin,
              B = n.defined,
              E = n.destroyObjectProperties,
              I = n.erase,
              y = n.fireEvent,
              r = n.merge,
              q = n.objectEach,
              c = n.pick;

          n = function () {
            function g(c, g) {
              this.axis = c;
              g && (this.options = g, this.id = g.id);
            }

            g.compose = function (c) {
              return e.compose(g, c);
            };

            g.prototype.render = function () {
              y(this, "render");
              var g = this,
                  e = g.axis,
                  f = e.horiz,
                  b = e.logarithmic,
                  w = g.options,
                  J = w.color,
                  C = c(w.zIndex, 0),
                  K = w.events,
                  p = {},
                  m = e.chart.renderer,
                  t = w.label,
                  a = g.label,
                  z = w.to,
                  d = w.from,
                  F = w.value,
                  k = g.svgElem,
                  h = [],
                  L = B(d) && B(z);
              h = B(F);
              var P = !k,
                  u = {
                "class": "highcharts-plot-" + (L ? "band " : "line ") + (w.className || "")
              },
                  A = L ? "bands" : "lines";
              b && (d = b.log2lin(d), z = b.log2lin(z), F = b.log2lin(F));
              e.chart.styledMode || (h ? (u.stroke = J || "#999999", u["stroke-width"] = c(w.width, 1), w.dashStyle && (u.dashstyle = w.dashStyle)) : L && (u.fill = J || "#e6ebf5", w.borderWidth && (u.stroke = w.borderColor, u["stroke-width"] = w.borderWidth)));
              p.zIndex = C;
              A += "-" + C;
              (b = e.plotLinesAndBandsGroups[A]) || (e.plotLinesAndBandsGroups[A] = b = m.g("plot-" + A).attr(p).add());
              P && (g.svgElem = k = m.path().attr(u).add(b));
              if (h) h = e.getPlotLinePath({
                value: F,
                lineWidth: k.strokeWidth(),
                acrossPanes: w.acrossPanes
              });else if (L) h = e.getPlotBandPath(d, z, w);else return;
              !g.eventsAdded && K && (q(K, function (a, d) {
                k.on(d, function (a) {
                  K[d].apply(g, [a]);
                });
              }), g.eventsAdded = !0);
              (P || !k.d) && h && h.length ? k.attr({
                d: h
              }) : k && (h ? (k.show(), k.animate({
                d: h
              })) : k.d && (k.hide(), a && (g.label = a = a.destroy())));
              t && (B(t.text) || B(t.formatter)) && h && h.length && 0 < e.width && 0 < e.height && !h.isFlat ? (t = r({
                align: f && L && "center",
                x: f ? !L && 4 : 10,
                verticalAlign: !f && L && "middle",
                y: f ? L ? 16 : 10 : L ? 6 : -4,
                rotation: f && !L && 90
              }, t), this.renderLabel(t, h, L, C)) : a && a.hide();
              return g;
            };

            g.prototype.renderLabel = function (c, g, f, b) {
              var l = this.axis,
                  e = l.chart.renderer,
                  q = this.label;
              q || (this.label = q = e.text(this.getLabelText(c), 0, 0, c.useHTML).attr({
                align: c.textAlign || c.align,
                rotation: c.rotation,
                "class": "highcharts-plot-" + (f ? "band" : "line") + "-label " + (c.className || ""),
                zIndex: b
              }).add(), l.chart.styledMode || q.css(r({
                textOverflow: "ellipsis"
              }, c.style)));
              b = g.xBounds || [g[0][1], g[1][1], f ? g[2][1] : g[0][1]];
              g = g.yBounds || [g[0][2], g[1][2], f ? g[2][2] : g[0][2]];
              f = H(b);
              e = H(g);
              q.align(c, !1, {
                x: f,
                y: e,
                width: G(b) - f,
                height: G(g) - e
              });
              q.alignValue && "left" !== q.alignValue || q.css({
                width: (90 === q.rotation ? l.height - (q.alignAttr.y - l.top) : l.width - (q.alignAttr.x - l.left)) + "px"
              });
              q.show(!0);
            };

            g.prototype.getLabelText = function (c) {
              return B(c.formatter) ? c.formatter.call(this) : c.text;
            };

            g.prototype.destroy = function () {
              I(this.axis.plotLinesAndBands, this);
              delete this.axis;
              E(this);
            };

            return g;
          }();

          "";
          "";
          return n;
        });
        N(e, "Core/Tooltip.js", [e["Core/FormatUtilities.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function (e, n, D, H, B) {
          var G = e.format,
              I = n.doc,
              y = D.distribute,
              r = B.addEvent,
              q = B.clamp,
              c = B.css,
              g = B.defined,
              l = B.discardElement,
              x = B.extend,
              f = B.fireEvent,
              b = B.isArray,
              w = B.isNumber,
              J = B.isString,
              C = B.merge,
              K = B.pick,
              p = B.splat,
              m = B.syncTimeout;

          e = function () {
            function t(a, b) {
              this.allowShared = !0;
              this.container = void 0;
              this.crosshairs = [];
              this.distance = 0;
              this.isHidden = !0;
              this.isSticky = !1;
              this.now = {};
              this.options = {};
              this.outside = !1;
              this.chart = a;
              this.init(a, b);
            }

            t.prototype.applyFilter = function () {
              var a = this.chart;
              a.renderer.definition({
                tagName: "filter",
                attributes: {
                  id: "drop-shadow-" + a.index,
                  opacity: .5
                },
                children: [{
                  tagName: "feGaussianBlur",
                  attributes: {
                    "in": "SourceAlpha",
                    stdDeviation: 1
                  }
                }, {
                  tagName: "feOffset",
                  attributes: {
                    dx: 1,
                    dy: 1
                  }
                }, {
                  tagName: "feComponentTransfer",
                  children: [{
                    tagName: "feFuncA",
                    attributes: {
                      type: "linear",
                      slope: .3
                    }
                  }]
                }, {
                  tagName: "feMerge",
                  children: [{
                    tagName: "feMergeNode"
                  }, {
                    tagName: "feMergeNode",
                    attributes: {
                      "in": "SourceGraphic"
                    }
                  }]
                }]
              });
            };

            t.prototype.bodyFormatter = function (a) {
              return a.map(function (a) {
                var d = a.series.tooltipOptions;
                return (d[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, d[(a.point.formatPrefix || "point") + "Format"] || "");
              });
            };

            t.prototype.cleanSplit = function (a) {
              this.chart.series.forEach(function (b) {
                var d = b && b.tt;
                d && (!d.isActive || a ? b.tt = d.destroy() : d.isActive = !1);
              });
            };

            t.prototype.defaultFormatter = function (a) {
              var b = this.points || p(this);
              var d = [a.tooltipFooterHeaderFormatter(b[0])];
              d = d.concat(a.bodyFormatter(b));
              d.push(a.tooltipFooterHeaderFormatter(b[0], !0));
              return d;
            };

            t.prototype.destroy = function () {
              this.label && (this.label = this.label.destroy());
              this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
              this.renderer && (this.renderer = this.renderer.destroy(), l(this.container));
              B.clearTimeout(this.hideTimer);
              B.clearTimeout(this.tooltipTimeout);
            };

            t.prototype.getAnchor = function (a, b) {
              var d = this.chart,
                  c = d.pointer,
                  k = d.inverted,
                  h = d.plotTop,
                  m = d.plotLeft,
                  f,
                  u,
                  t = 0,
                  g = 0;
              a = p(a);
              this.followPointer && b ? ("undefined" === typeof b.chartX && (b = c.normalize(b)), c = [b.chartX - m, b.chartY - h]) : a[0].tooltipPos ? c = a[0].tooltipPos : (a.forEach(function (a) {
                f = a.series.yAxis;
                u = a.series.xAxis;
                t += a.plotX || 0;
                g += a.plotLow ? (a.plotLow + (a.plotHigh || 0)) / 2 : a.plotY || 0;
                u && f && (k ? (t += h + d.plotHeight - u.len - u.pos, g += m + d.plotWidth - f.len - f.pos) : (t += u.pos - m, g += f.pos - h));
              }), t /= a.length, g /= a.length, c = [k ? d.plotWidth - g : t, k ? d.plotHeight - t : g], this.shared && 1 < a.length && b && (k ? c[0] = b.chartX - m : c[1] = b.chartY - h));
              return c.map(Math.round);
            };

            t.prototype.getLabel = function () {
              var a = this,
                  b = this.chart.styledMode,
                  d = this.options,
                  m = this.split && this.allowShared,
                  k = "tooltip" + (g(d.className) ? " " + d.className : ""),
                  h = d.style.pointerEvents || (!this.followPointer && d.stickOnContact ? "auto" : "none"),
                  f = function f() {
                a.inContact = !0;
              },
                  t = function t(d) {
                var b = a.chart.hoverSeries;
                a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(d.relatedTarget, "highcharts-tooltip");
                if (!a.inContact && b && b.onMouseOut) b.onMouseOut();
              },
                  u,
                  A = this.chart.renderer;

              if (a.label) {
                var p = !a.label.hasClass("highcharts-label");
                (m && !p || !m && p) && a.destroy();
              }

              if (!this.label) {
                if (this.outside) {
                  p = this.chart.options.chart.style;
                  var l = H.getRendererType();
                  this.container = u = n.doc.createElement("div");
                  u.className = "highcharts-tooltip-container";
                  c(u, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: h,
                    zIndex: Math.max(this.options.style.zIndex || 0, (p && p.zIndex || 0) + 3)
                  });
                  r(u, "mouseenter", f);
                  r(u, "mouseleave", t);
                  n.doc.body.appendChild(u);
                  this.renderer = A = new l(u, 0, 0, p, void 0, void 0, A.styledMode);
                }

                m ? this.label = A.g(k) : (this.label = A.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, k).attr({
                  padding: d.padding,
                  r: d.borderRadius
                }), b || this.label.attr({
                  fill: d.backgroundColor,
                  "stroke-width": d.borderWidth
                }).css(d.style).css({
                  pointerEvents: h
                }).shadow(d.shadow));
                b && d.shadow && (this.applyFilter(), this.label.attr({
                  filter: "url(#drop-shadow-" + this.chart.index + ")"
                }));

                if (a.outside && !a.split) {
                  var v = this.label,
                      e = v.xSetter,
                      w = v.ySetter;

                  v.xSetter = function (d) {
                    e.call(v, a.distance);
                    u.style.left = d + "px";
                  };

                  v.ySetter = function (d) {
                    w.call(v, a.distance);
                    u.style.top = d + "px";
                  };
                }

                this.label.on("mouseenter", f).on("mouseleave", t).attr({
                  zIndex: 8
                }).add();
              }

              return this.label;
            };

            t.prototype.getPosition = function (a, b, d) {
              var c = this.chart,
                  k = this.distance,
                  h = {},
                  m = c.inverted && d.h || 0,
                  f = this.outside,
                  u = f ? I.documentElement.clientWidth - 2 * k : c.chartWidth,
                  t = f ? Math.max(I.body.scrollHeight, I.documentElement.scrollHeight, I.body.offsetHeight, I.documentElement.offsetHeight, I.documentElement.clientHeight) : c.chartHeight,
                  p = c.pointer.getChartPosition(),
                  g = function g(h) {
                var m = "x" === h;
                return [h, m ? u : t, m ? a : b].concat(f ? [m ? a * p.scaleX : b * p.scaleY, m ? p.left - k + (d.plotX + c.plotLeft) * p.scaleX : p.top - k + (d.plotY + c.plotTop) * p.scaleY, 0, m ? u : t] : [m ? a : b, m ? d.plotX + c.plotLeft : d.plotY + c.plotTop, m ? c.plotLeft : c.plotTop, m ? c.plotLeft + c.plotWidth : c.plotTop + c.plotHeight]);
              },
                  v = g("y"),
                  z = g("x"),
                  l;

              g = !!d.negative;
              !c.polar && c.hoverSeries && c.hoverSeries.yAxis && c.hoverSeries.yAxis.reversed && (g = !g);

              var e = !this.followPointer && K(d.ttBelow, !c.inverted === g),
                  w = function w(a, d, b, c, u, t, A) {
                var g = f ? "y" === a ? k * p.scaleY : k * p.scaleX : k,
                    v = (b - c) / 2,
                    z = c < u - k,
                    l = u + k + c < d,
                    F = u - g - b + v;
                u = u + g - v;
                if (e && l) h[a] = u;else if (!e && z) h[a] = F;else if (z) h[a] = Math.min(A - c, 0 > F - m ? F : F - m);else if (l) h[a] = Math.max(t, u + m + b > d ? u : u + m);else return !1;
              },
                  q = function q(a, d, b, c, m) {
                var u;
                m < k || m > d - k ? u = !1 : h[a] = m < b / 2 ? 1 : m > d - c / 2 ? d - c - 2 : m - b / 2;
                return u;
              },
                  Q = function Q(a) {
                var d = v;
                v = z;
                z = d;
                l = a;
              },
                  r = function r() {
                !1 !== w.apply(0, v) ? !1 !== q.apply(0, z) || l || (Q(!0), r()) : l ? h.x = h.y = 0 : (Q(!0), r());
              };

              (c.inverted || 1 < this.len) && Q();
              r();
              return h;
            };

            t.prototype.hide = function (a) {
              var b = this;
              B.clearTimeout(this.hideTimer);
              a = K(a, this.options.hideDelay);
              this.isHidden || (this.hideTimer = m(function () {
                b.getLabel().fadeOut(a ? void 0 : a);
                b.isHidden = !0;
              }, a));
            };

            t.prototype.init = function (a, b) {
              this.chart = a;
              this.options = b;
              this.crosshairs = [];
              this.now = {
                x: 0,
                y: 0
              };
              this.isHidden = !0;
              this.split = b.split && !a.inverted && !a.polar;
              this.shared = b.shared || this.split;
              this.outside = K(b.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));
            };

            t.prototype.shouldStickOnContact = function () {
              return !(this.followPointer || !this.options.stickOnContact);
            };

            t.prototype.isStickyOnContact = function () {
              return !(!this.shouldStickOnContact() || !this.inContact);
            };

            t.prototype.move = function (a, b, d, c) {
              var k = this,
                  h = k.now,
                  m = !1 !== k.options.animation && !k.isHidden && (1 < Math.abs(a - h.x) || 1 < Math.abs(b - h.y)),
                  f = k.followPointer || 1 < k.len;
              x(h, {
                x: m ? (2 * h.x + a) / 3 : a,
                y: m ? (h.y + b) / 2 : b,
                anchorX: f ? void 0 : m ? (2 * h.anchorX + d) / 3 : d,
                anchorY: f ? void 0 : m ? (h.anchorY + c) / 2 : c
              });
              k.getLabel().attr(h);
              k.drawTracker();
              m && (B.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                k && k.move(a, b, d, c);
              }, 32));
            };

            t.prototype.refresh = function (a, c) {
              var d = this.chart,
                  m = this.options,
                  k = p(a),
                  h = k[0],
                  t = [],
                  g = m.formatter || this.defaultFormatter,
                  u = this.shared,
                  A = d.styledMode,
                  z = {};

              if (m.enabled && h.series) {
                B.clearTimeout(this.hideTimer);
                this.allowShared = !(!b(a) && a.series && a.series.noSharedTooltip);
                this.followPointer = !this.split && h.series.tooltipOptions.followPointer;
                a = this.getAnchor(a, c);
                var l = a[0],
                    v = a[1];
                u && this.allowShared ? (d.pointer.applyInactiveState(k), k.forEach(function (a) {
                  a.setState("hover");
                  t.push(a.getLabelConfig());
                }), z = {
                  x: h.category,
                  y: h.y
                }, z.points = t) : z = h.getLabelConfig();
                this.len = t.length;
                g = g.call(z, this);
                u = h.series;
                this.distance = K(u.tooltipOptions.distance, 16);
                if (!1 === g) this.hide();else {
                  if (this.split && this.allowShared) this.renderSplit(g, k);else {
                    var e = l,
                        w = v;
                    c && d.pointer.isDirectTouch && (e = c.chartX - d.plotLeft, w = c.chartY - d.plotTop);
                    if (d.polar || !1 === u.options.clip || k.some(function (a) {
                      return a.series.shouldShowTooltip(e, w);
                    })) c = this.getLabel(), m.style.width && !A || c.css({
                      width: this.chart.spacingBox.width + "px"
                    }), c.attr({
                      text: g && g.join ? g.join("") : g
                    }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + K(h.colorIndex, u.colorIndex)), A || c.attr({
                      stroke: m.borderColor || h.color || u.color || "#666666"
                    }), this.updatePosition({
                      plotX: l,
                      plotY: v,
                      negative: h.negative,
                      ttBelow: h.ttBelow,
                      h: a[2] || 0
                    });else {
                      this.hide();
                      return;
                    }
                  }
                  this.isHidden && this.label && this.label.attr({
                    opacity: 1
                  }).show();
                  this.isHidden = !1;
                }
                f(this, "refresh");
              }
            };

            t.prototype.renderSplit = function (a, b) {
              function d(a, d, b, h, k) {
                void 0 === k && (k = !0);
                b ? (d = B ? 0 : N, a = q(a - h / 2, T.left, T.right - h - (c.outside ? E : 0))) : (d -= D, a = k ? a - h - r : a + r, a = q(a, k ? a : T.left, T.right));
                return {
                  x: a,
                  y: d
                };
              }

              var c = this,
                  k = c.chart,
                  h = c.chart,
                  m = h.chartWidth,
                  f = h.chartHeight,
                  u = h.plotHeight,
                  t = h.plotLeft,
                  p = h.plotTop,
                  g = h.pointer,
                  v = h.scrollablePixelsY;
              v = void 0 === v ? 0 : v;
              var z = h.scrollablePixelsX,
                  l = h.scrollingContainer;
              l = void 0 === l ? {
                scrollLeft: 0,
                scrollTop: 0
              } : l;
              var e = l.scrollLeft;
              l = l.scrollTop;
              var w = h.styledMode,
                  r = c.distance,
                  Q = c.options,
                  C = c.options.positioner,
                  T = c.outside && "number" !== typeof z ? I.documentElement.getBoundingClientRect() : {
                left: e,
                right: e + m,
                top: l,
                bottom: l + f
              },
                  n = c.getLabel(),
                  G = this.renderer || k.renderer,
                  B = !(!k.xAxis[0] || !k.xAxis[0].opposite);
              k = g.getChartPosition();
              var E = k.left;
              k = k.top;
              var D = p + l,
                  H = 0,
                  N = u - v;
              J(a) && (a = [!1, a]);
              a = a.slice(0, b.length + 1).reduce(function (a, h, k) {
                if (!1 !== h && "" !== h) {
                  k = b[k - 1] || {
                    isHeader: !0,
                    plotX: b[0].plotX,
                    plotY: u,
                    series: {}
                  };
                  var m = k.isHeader,
                      f = m ? c : k.series;
                  h = h.toString();
                  var g = f.tt,
                      A = k.isHeader;
                  var v = k.series;
                  var z = "highcharts-color-" + K(k.colorIndex, v.colorIndex, "none");
                  g || (g = {
                    padding: Q.padding,
                    r: Q.borderRadius
                  }, w || (g.fill = Q.backgroundColor, g["stroke-width"] = Q.borderWidth), g = G.label("", 0, 0, Q[A ? "headerShape" : "shape"], void 0, void 0, Q.useHTML).addClass((A ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + z).attr(g).add(n));
                  g.isActive = !0;
                  g.attr({
                    text: h
                  });
                  w || g.css(Q.style).shadow(Q.shadow).attr({
                    stroke: Q.borderColor || k.color || v.color || "#333333"
                  });
                  f = f.tt = g;
                  A = f.getBBox();
                  h = A.width + f.strokeWidth();
                  m && (H = A.height, N += H, B && (D -= H));
                  v = k.plotX;
                  v = void 0 === v ? 0 : v;
                  z = k.plotY;
                  z = void 0 === z ? 0 : z;
                  g = k.series;

                  if (k.isHeader) {
                    v = t + v;
                    var l = p + u / 2;
                  } else {
                    var e = g.xAxis,
                        F = g.yAxis;
                    v = e.pos + q(v, -r, e.len + r);
                    g.shouldShowTooltip(0, F.pos - p + z, {
                      ignoreX: !0
                    }) && (l = F.pos + z);
                  }

                  v = q(v, T.left - r, T.right + r);
                  "number" === typeof l ? (A = A.height + 1, z = C ? C.call(c, h, A, k) : d(v, l, m, h), a.push({
                    align: C ? 0 : void 0,
                    anchorX: v,
                    anchorY: l,
                    boxWidth: h,
                    point: k,
                    rank: K(z.rank, m ? 1 : 0),
                    size: A,
                    target: z.y,
                    tt: f,
                    x: z.x
                  })) : f.isActive = !1;
                }

                return a;
              }, []);
              !C && a.some(function (a) {
                var d = (c.outside ? E : 0) + a.anchorX;
                return d < T.left && d + a.boxWidth < T.right ? !0 : d < E - T.left + a.boxWidth && T.right - d > d;
              }) && (a = a.map(function (a) {
                var b = d(a.anchorX, a.anchorY, a.point.isHeader, a.boxWidth, !1);
                return x(a, {
                  target: b.y,
                  x: b.x
                });
              }));
              c.cleanSplit();
              y(a, N);
              var W = E,
                  Z = E;
              a.forEach(function (a) {
                var d = a.x,
                    b = a.boxWidth;
                a = a.isHeader;
                a || (c.outside && E + d < W && (W = E + d), !a && c.outside && W + b > Z && (Z = E + d));
              });
              a.forEach(function (a) {
                var d = a.x,
                    b = a.anchorX,
                    h = a.pos,
                    k = a.point.isHeader;
                h = {
                  visibility: "undefined" === typeof h ? "hidden" : "inherit",
                  x: d,
                  y: h + D,
                  anchorX: b,
                  anchorY: a.anchorY
                };

                if (c.outside && d < b) {
                  var m = E - W;
                  0 < m && (k || (h.x = d + m, h.anchorX = b + m), k && (h.x = (Z - W) / 2, h.anchorX = b + m));
                }

                a.tt.attr(h);
              });
              a = c.container;
              v = c.renderer;
              c.outside && a && v && (h = n.getBBox(), v.setSize(h.width + h.x, h.height + h.y, !1), a.style.left = W + "px", a.style.top = k + "px");
            };

            t.prototype.drawTracker = function () {
              if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
                var a = this.chart,
                    b = this.label,
                    d = this.shared ? a.hoverPoints : a.hoverPoint;

                if (b && d) {
                  var c = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                  d = this.getAnchor(d);
                  var k = b.getBBox();
                  d[0] += a.plotLeft - b.translateX;
                  d[1] += a.plotTop - b.translateY;
                  c.x = Math.min(0, d[0]);
                  c.y = Math.min(0, d[1]);
                  c.width = 0 > d[0] ? Math.max(Math.abs(d[0]), k.width - d[0]) : Math.max(Math.abs(d[0]), k.width);
                  c.height = 0 > d[1] ? Math.max(Math.abs(d[1]), k.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), k.height);
                  this.tracker ? this.tracker.attr(c) : (this.tracker = b.renderer.rect(c).addClass("highcharts-tracker").add(b), a.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                  }));
                }
              }
            };

            t.prototype.styledModeFormat = function (a) {
              return a.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };

            t.prototype.tooltipFooterHeaderFormatter = function (a, b) {
              var d = a.series,
                  c = d.tooltipOptions,
                  k = d.xAxis,
                  h = k && k.dateTime;
              k = {
                isFooter: b,
                labelConfig: a
              };
              var m = c.xDateFormat,
                  t = c[b ? "footerFormat" : "headerFormat"];
              f(this, "headerFormatter", k, function (b) {
                h && !m && w(a.key) && (m = h.getXDateFormat(a.key, c.dateTimeLabelFormats));
                h && m && (a.point && a.point.tooltipDateKeys || ["key"]).forEach(function (a) {
                  t = t.replace("{point." + a + "}", "{point." + a + ":" + m + "}");
                });
                d.chart.styledMode && (t = this.styledModeFormat(t));
                b.text = G(t, {
                  point: a,
                  series: d
                }, this.chart);
              });
              return k.text;
            };

            t.prototype.update = function (a) {
              this.destroy();
              C(!0, this.chart.options.tooltip.userOptions, a);
              this.init(this.chart, C(!0, this.options, a));
            };

            t.prototype.updatePosition = function (a) {
              var b = this.chart,
                  d = this.options,
                  m = b.pointer,
                  k = this.getLabel();
              m = m.getChartPosition();
              var h = (d.positioner || this.getPosition).call(this, k.width, k.height, a),
                  f = a.plotX + b.plotLeft;
              a = a.plotY + b.plotTop;

              if (this.outside) {
                d = d.borderWidth + 2 * this.distance;
                this.renderer.setSize(k.width + d, k.height + d, !1);
                if (1 !== m.scaleX || 1 !== m.scaleY) c(this.container, {
                  transform: "scale(".concat(m.scaleX, ", ").concat(m.scaleY, ")")
                }), f *= m.scaleX, a *= m.scaleY;
                f += m.left - h.x;
                a += m.top - h.y;
              }

              this.move(Math.round(h.x), Math.round(h.y || 0), f, a);
            };

            return t;
          }();

          "";
          return e;
        });
        N(e, "Core/Series/Point.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/DefaultOptions.js"], e["Core/FormatUtilities.js"], e["Core/Utilities.js"]], function (e, n, D, H, B) {
          var G = n.animObject,
              I = D.defaultOptions,
              y = H.format,
              r = B.addEvent,
              q = B.defined,
              c = B.erase,
              g = B.extend,
              l = B.fireEvent,
              x = B.getNestedProperty,
              f = B.isArray,
              b = B.isFunction,
              w = B.isNumber,
              J = B.isObject,
              C = B.merge,
              K = B.objectEach,
              p = B.pick,
              m = B.syncTimeout,
              t = B.removeEvent,
              a = B.uniqueKey;

          n = function () {
            function z() {
              this.colorIndex = this.category = void 0;
              this.formatPrefix = "point";
              this.id = void 0;
              this.isNull = !1;
              this.percentage = this.options = this.name = void 0;
              this.selected = !1;
              this.total = this.shapeArgs = this.series = void 0;
              this.visible = !0;
              this.x = void 0;
            }

            z.prototype.animateBeforeDestroy = function () {
              var a = this,
                  b = {
                x: a.startXPos,
                opacity: 0
              },
                  c = a.getGraphicalProps();
              c.singular.forEach(function (d) {
                a[d] = a[d].animate("dataLabel" === d ? {
                  x: a[d].startXPos,
                  y: a[d].startYPos,
                  opacity: 0
                } : b);
              });
              c.plural.forEach(function (d) {
                a[d].forEach(function (d) {
                  d.element && d.animate(g({
                    x: a.startXPos
                  }, d.startYPos ? {
                    x: d.startXPos,
                    y: d.startYPos
                  } : {}));
                });
              });
            };

            z.prototype.applyOptions = function (a, b) {
              var d = this.series,
                  c = d.options.pointValKey || d.pointValKey;
              a = z.prototype.optionsToObject.call(this, a);
              g(this, a);
              this.options = this.options ? g(this.options, a) : a;
              a.group && delete this.group;
              a.dataLabels && delete this.dataLabels;
              c && (this.y = z.prototype.getNestedProperty.call(this, c));
              this.formatPrefix = (this.isNull = p(this.isValid && !this.isValid(), null === this.x || !w(this.y))) ? "null" : "point";
              this.selected && (this.state = "select");
              "name" in this && "undefined" === typeof b && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
              "undefined" === typeof this.x && d ? this.x = "undefined" === typeof b ? d.autoIncrement() : b : w(a.x) && d.options.relativeXValue && (this.x = d.autoIncrement(a.x));
              return this;
            };

            z.prototype.destroy = function () {
              function a() {
                if (b.graphic || b.dataLabel || b.dataLabels) t(b), b.destroyElements();

                for (u in b) {
                  b[u] = null;
                }
              }

              var b = this,
                  k = b.series,
                  h = k.chart;
              k = k.options.dataSorting;
              var f = h.hoverPoints,
                  g = G(b.series.chart.renderer.globalAnimation),
                  u;
              b.legendItem && h.legend.destroyItem(b);
              f && (b.setState(), c(f, b), f.length || (h.hoverPoints = null));
              if (b === h.hoverPoint) b.onMouseOut();
              k && k.enabled ? (this.animateBeforeDestroy(), m(a, g.duration)) : a();
              h.pointCount--;
            };

            z.prototype.destroyElements = function (a) {
              var d = this;
              a = d.getGraphicalProps(a);
              a.singular.forEach(function (a) {
                d[a] = d[a].destroy();
              });
              a.plural.forEach(function (a) {
                d[a].forEach(function (a) {
                  a.element && a.destroy();
                });
                delete d[a];
              });
            };

            z.prototype.firePointEvent = function (a, b, c) {
              var d = this,
                  k = this.series.options;
              (k.point.events[a] || d.options && d.options.events && d.options.events[a]) && d.importEvents();
              "click" === a && k.allowPointSelect && (c = function c(a) {
                d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
              });
              l(d, a, b, c);
            };

            z.prototype.getClassName = function () {
              return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };

            z.prototype.getGraphicalProps = function (a) {
              var d = this,
                  b = [],
                  c = {
                singular: [],
                plural: []
              },
                  m;
              a = a || {
                graphic: 1,
                dataLabel: 1
              };
              a.graphic && b.push("graphic", "upperGraphic", "shadowGroup");
              a.dataLabel && b.push("dataLabel", "dataLabelUpper", "connector");

              for (m = b.length; m--;) {
                var f = b[m];
                d[f] && c.singular.push(f);
              }

              ["dataLabel", "connector"].forEach(function (b) {
                var h = b + "s";
                a[b] && d[h] && c.plural.push(h);
              });
              return c;
            };

            z.prototype.getLabelConfig = function () {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
              };
            };

            z.prototype.getNestedProperty = function (a) {
              if (a) return 0 === a.indexOf("custom.") ? x(a, this.options) : this[a];
            };

            z.prototype.getZone = function () {
              var a = this.series,
                  b = a.zones;
              a = a.zoneAxis || "y";
              var c,
                  h = 0;

              for (c = b[h]; this[a] >= c.value;) {
                c = b[++h];
              }

              this.nonZonedColor || (this.nonZonedColor = this.color);
              this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;
              return c;
            };

            z.prototype.hasNewShapeType = function () {
              return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };

            z.prototype.init = function (d, b, c) {
              this.series = d;
              this.applyOptions(b, c);
              this.id = q(this.id) ? this.id : a();
              this.resolveColor();
              d.chart.pointCount++;
              l(this, "afterInit");
              return this;
            };

            z.prototype.optionsToObject = function (a) {
              var d = this.series,
                  b = d.options.keys,
                  c = b || d.pointArrayMap || ["y"],
                  m = c.length,
                  t = {},
                  u = 0,
                  g = 0;
              if (w(a) || null === a) t[c[0]] = a;else if (f(a)) for (!b && a.length > m && (d = typeof a[0], "string" === d ? t.name = a[0] : "number" === d && (t.x = a[0]), u++); g < m;) {
                b && "undefined" === typeof a[u] || (0 < c[g].indexOf(".") ? z.prototype.setNestedProperty(t, a[u], c[g]) : t[c[g]] = a[u]), u++, g++;
              } else "object" === typeof a && (t = a, a.dataLabels && (d._hasPointLabels = !0), a.marker && (d._hasPointMarkers = !0));
              return t;
            };

            z.prototype.resolveColor = function () {
              var a = this.series,
                  b = a.chart.styledMode;
              var c = a.chart.options.chart.colorCount;
              delete this.nonZonedColor;

              if (a.options.colorByPoint) {
                if (!b) {
                  c = a.options.colors || a.chart.options.colors;
                  var h = c[a.colorCounter];
                  c = c.length;
                }

                b = a.colorCounter;
                a.colorCounter++;
                a.colorCounter === c && (a.colorCounter = 0);
              } else b || (h = a.color), b = a.colorIndex;

              this.colorIndex = p(this.options.colorIndex, b);
              this.color = p(this.options.color, h);
            };

            z.prototype.setNestedProperty = function (a, b, c) {
              c.split(".").reduce(function (a, d, c, k) {
                a[d] = k.length - 1 === c ? b : J(a[d], !0) ? a[d] : {};
                return a[d];
              }, a);
              return a;
            };

            z.prototype.tooltipFormatter = function (a) {
              var d = this.series,
                  b = d.tooltipOptions,
                  c = p(b.valueDecimals, ""),
                  m = b.valuePrefix || "",
                  f = b.valueSuffix || "";
              d.chart.styledMode && (a = d.chart.tooltip.styledModeFormat(a));
              (d.pointArrayMap || ["y"]).forEach(function (d) {
                d = "{point." + d;
                if (m || f) a = a.replace(RegExp(d + "}", "g"), m + d + "}" + f);
                a = a.replace(RegExp(d + "}", "g"), d + ":,." + c + "f}");
              });
              return y(a, {
                point: this,
                series: this.series
              }, d.chart);
            };

            z.prototype.update = function (a, b, c, h) {
              function d() {
                k.applyOptions(a);
                var d = f && k.hasDummyGraphic;
                d = null === k.y ? !d : d;
                f && d && (k.graphic = f.destroy(), delete k.hasDummyGraphic);
                J(a, !0) && (f && f.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (k.graphic = f.destroy()), a && a.dataLabels && k.dataLabel && (k.dataLabel = k.dataLabel.destroy()), k.connector && (k.connector = k.connector.destroy()));
                v = k.index;
                m.updateParallelArrays(k, v);
                g.data[v] = J(g.data[v], !0) || J(a, !0) ? k.options : p(a, g.data[v]);
                m.isDirty = m.isDirtyData = !0;
                !m.fixedBox && m.hasCartesianSeries && (t.isDirtyBox = !0);
                "point" === g.legendType && (t.isDirtyLegend = !0);
                b && t.redraw(c);
              }

              var k = this,
                  m = k.series,
                  f = k.graphic,
                  t = m.chart,
                  g = m.options,
                  v;
              b = p(b, !0);
              !1 === h ? d() : k.firePointEvent("update", {
                options: a
              }, d);
            };

            z.prototype.remove = function (a, b) {
              this.series.removePoint(this.series.data.indexOf(this), a, b);
            };

            z.prototype.select = function (a, b) {
              var d = this,
                  c = d.series,
                  m = c.chart;
              this.selectedStaging = a = p(a, !d.selected);
              d.firePointEvent(a ? "select" : "unselect", {
                accumulate: b
              }, function () {
                d.selected = d.options.selected = a;
                c.options.data[c.data.indexOf(d)] = d.options;
                d.setState(a && "select");
                b || m.getSelectedPoints().forEach(function (a) {
                  var b = a.series;
                  a.selected && a !== d && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options, a.setState(m.hoverPoints && b.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
                });
              });
              delete this.selectedStaging;
            };

            z.prototype.onMouseOver = function (a) {
              var d = this.series.chart,
                  b = d.pointer;
              a = a ? b.normalize(a) : b.getChartCoordinatesFromPoint(this, d.inverted);
              b.runPointActions(a, this);
            };

            z.prototype.onMouseOut = function () {
              var a = this.series.chart;
              this.firePointEvent("mouseOut");
              this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {
                a.setState();
              });
              a.hoverPoints = a.hoverPoint = null;
            };

            z.prototype.importEvents = function () {
              if (!this.hasImportedEvents) {
                var a = this,
                    c = C(a.series.options.point, a.options).events;
                a.events = c;
                K(c, function (d, c) {
                  b(d) && r(a, c, d);
                });
                this.hasImportedEvents = !0;
              }
            };

            z.prototype.setState = function (a, b) {
              var d = this.series,
                  c = this.state,
                  m = d.options.states[a || "normal"] || {},
                  f = I.plotOptions[d.type].marker && d.options.marker,
                  u = f && !1 === f.enabled,
                  t = f && f.states && f.states[a || "normal"] || {},
                  z = !1 === t.enabled,
                  F = this.marker || {},
                  v = d.chart,
                  q = f && d.markerAttribs,
                  r = d.halo,
                  x,
                  C = d.stateMarkerGraphic;
              a = a || "";

              if (!(a === this.state && !b || this.selected && "select" !== a || !1 === m.enabled || a && (z || u && !1 === t.enabled) || a && F.states && F.states[a] && !1 === F.states[a].enabled)) {
                this.state = a;
                q && (x = d.markerAttribs(this, a));

                if (this.graphic && !this.hasDummyGraphic) {
                  c && this.graphic.removeClass("highcharts-point-" + c);
                  a && this.graphic.addClass("highcharts-point-" + a);

                  if (!v.styledMode) {
                    var J = d.pointAttribs(this, a);
                    var Q = p(v.options.chart.animation, m.animation);
                    d.options.inactiveOtherPoints && w(J.opacity) && ((this.dataLabels || []).forEach(function (a) {
                      a && a.animate({
                        opacity: J.opacity
                      }, Q);
                    }), this.connector && this.connector.animate({
                      opacity: J.opacity
                    }, Q));
                    this.graphic.animate(J, Q);
                  }

                  x && this.graphic.animate(x, p(v.options.chart.animation, t.animation, f.animation));
                  C && C.hide();
                } else {
                  if (a && t) {
                    c = F.symbol || d.symbol;
                    C && C.currentSymbol !== c && (C = C.destroy());
                    if (x) if (C) C[b ? "animate" : "attr"]({
                      x: x.x,
                      y: x.y
                    });else c && (d.stateMarkerGraphic = C = v.renderer.symbol(c, x.x, x.y, x.width, x.height).add(d.markerGroup), C.currentSymbol = c);
                    !v.styledMode && C && "inactive" !== this.state && C.attr(d.pointAttribs(this, a));
                  }

                  C && (C[a && this.isInside ? "show" : "hide"](), C.element.point = this, C.addClass(this.getClassName(), !0));
                }

                m = m.halo;
                x = (C = this.graphic || C) && C.visibility || "inherit";
                m && m.size && C && "hidden" !== x && !this.isCluster ? (r || (d.halo = r = v.renderer.path().add(C.parentGroup)), r.show()[b ? "animate" : "attr"]({
                  d: this.haloPath(m.size)
                }), r.attr({
                  "class": "highcharts-halo highcharts-color-" + p(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
                  visibility: x,
                  zIndex: -1
                }), r.point = this, v.styledMode || r.attr(g({
                  fill: this.color || d.color,
                  "fill-opacity": m.opacity
                }, e.filterUserAttributes(m.attributes || {})))) : r && r.point && r.point.haloPath && r.animate({
                  d: r.point.haloPath(0)
                }, null, r.hide);
                l(this, "afterSetState", {
                  state: a
                });
              }
            };

            z.prototype.haloPath = function (a) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
            };

            return z;
          }();

          "";
          return n;
        });
        N(e, "Core/Pointer.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Tooltip.js"], e["Core/Utilities.js"]], function (e, n, D, H) {
          var G = e.parse,
              E = n.charts,
              I = n.noop,
              y = H.addEvent,
              r = H.attr,
              q = H.css,
              c = H.defined,
              g = H.extend,
              l = H.find,
              x = H.fireEvent,
              f = H.isNumber,
              b = H.isObject,
              w = H.objectEach,
              J = H.offset,
              C = H.pick,
              K = H.splat;

          e = function () {
            function p(b, c) {
              this.lastValidTouch = {};
              this.pinchDown = [];
              this.runChartClick = !1;
              this.eventsToUnbind = [];
              this.chart = b;
              this.hasDragged = !1;
              this.options = c;
              this.init(b, c);
            }

            p.prototype.applyInactiveState = function (b) {
              var c = [],
                  a;
              (b || []).forEach(function (b) {
                a = b.series;
                c.push(a);
                a.linkedParent && c.push(a.linkedParent);
                a.linkedSeries && (c = c.concat(a.linkedSeries));
                a.navigatorSeries && c.push(a.navigatorSeries);
              });
              this.chart.series.forEach(function (a) {
                -1 === c.indexOf(a) ? a.setState("inactive", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState("inactive");
              });
            };

            p.prototype.destroy = function () {
              var b = this;
              this.eventsToUnbind.forEach(function (b) {
                return b();
              });
              this.eventsToUnbind = [];
              n.chartCount || (p.unbindDocumentMouseUp && (p.unbindDocumentMouseUp = p.unbindDocumentMouseUp()), p.unbindDocumentTouchEnd && (p.unbindDocumentTouchEnd = p.unbindDocumentTouchEnd()));
              clearInterval(b.tooltipTimeout);
              w(b, function (c, a) {
                b[a] = void 0;
              });
            };

            p.prototype.drag = function (c) {
              var m = this.chart,
                  a = m.options.chart,
                  f = this.zoomHor,
                  d = this.zoomVert,
                  g = m.plotLeft,
                  k = m.plotTop,
                  h = m.plotWidth,
                  p = m.plotHeight,
                  l = this.mouseDownX || 0,
                  u = this.mouseDownY || 0,
                  A = b(a.panning) ? a.panning && a.panning.enabled : a.panning,
                  e = a.panKey && c[a.panKey + "Key"],
                  w = c.chartX,
                  v = c.chartY,
                  q = this.selectionMarker;
              if (!q || !q.touch) if (w < g ? w = g : w > g + h && (w = g + h), v < k ? v = k : v > k + p && (v = k + p), this.hasDragged = Math.sqrt(Math.pow(l - w, 2) + Math.pow(u - v, 2)), 10 < this.hasDragged) {
                var r = m.isInsidePlot(l - g, u - k, {
                  visiblePlotOnly: !0
                });
                !m.hasCartesianSeries && !m.mapView || !this.zoomX && !this.zoomY || !r || e || q || (this.selectionMarker = q = m.renderer.rect(g, k, f ? 1 : h, d ? 1 : p, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add(), m.styledMode || q.attr({
                  fill: a.selectionMarkerFill || G("#335cad").setOpacity(.25).get()
                }));
                q && f && (f = w - l, q.attr({
                  width: Math.abs(f),
                  x: (0 < f ? 0 : f) + l
                }));
                q && d && (f = v - u, q.attr({
                  height: Math.abs(f),
                  y: (0 < f ? 0 : f) + u
                }));
                r && !q && A && m.pan(c, a.panning);
              }
            };

            p.prototype.dragStart = function (b) {
              var c = this.chart;
              c.mouseIsDown = b.type;
              c.cancelClick = !1;
              c.mouseDownX = this.mouseDownX = b.chartX;
              c.mouseDownY = this.mouseDownY = b.chartY;
            };

            p.prototype.drop = function (b) {
              var m = this,
                  a = this.chart,
                  p = this.hasPinched;

              if (this.selectionMarker) {
                var d = this.selectionMarker,
                    l = d.attr ? d.attr("x") : d.x,
                    k = d.attr ? d.attr("y") : d.y,
                    h = d.attr ? d.attr("width") : d.width,
                    e = d.attr ? d.attr("height") : d.height,
                    w = {
                  originalEvent: b,
                  xAxis: [],
                  yAxis: [],
                  x: l,
                  y: k,
                  width: h,
                  height: e
                },
                    u = !!a.mapView;
                if (this.hasDragged || p) a.axes.forEach(function (a) {
                  if (a.zoomEnabled && c(a.min) && (p || m[{
                    xAxis: "zoomX",
                    yAxis: "zoomY"
                  }[a.coll]]) && f(l) && f(k)) {
                    var d = a.horiz,
                        t = "touchend" === b.type ? a.minPixelPadding : 0,
                        g = a.toValue((d ? l : k) + t);
                    d = a.toValue((d ? l + h : k + e) - t);
                    w[a.coll].push({
                      axis: a,
                      min: Math.min(g, d),
                      max: Math.max(g, d)
                    });
                    u = !0;
                  }
                }), u && x(a, "selection", w, function (d) {
                  a.zoom(g(d, p ? {
                    animation: !1
                  } : null));
                });
                f(a.index) && (this.selectionMarker = this.selectionMarker.destroy());
                p && this.scaleGroups();
              }

              a && f(a.index) && (q(a.container, {
                cursor: a._cursor
              }), a.cancelClick = 10 < this.hasDragged, a.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
            };

            p.prototype.findNearestKDPoint = function (c, f, a) {
              var m = this.chart,
                  d = m.hoverPoint;
              m = m.tooltip;
              if (d && m && m.isStickyOnContact()) return d;
              var t;
              c.forEach(function (d) {
                var c = !(d.noSharedTooltip && f) && 0 > d.options.findNearestPointBy.indexOf("y");
                d = d.searchPoint(a, c);

                if ((c = b(d, !0) && d.series) && !(c = !b(t, !0))) {
                  c = t.distX - d.distX;
                  var m = t.dist - d.dist,
                      k = (d.series.group && d.series.group.zIndex) - (t.series.group && t.series.group.zIndex);
                  c = 0 < (0 !== c && f ? c : 0 !== m ? m : 0 !== k ? k : t.series.index > d.series.index ? -1 : 1);
                }

                c && (t = d);
              });
              return t;
            };

            p.prototype.getChartCoordinatesFromPoint = function (b, c) {
              var a = b.series,
                  m = a.xAxis;
              a = a.yAxis;
              var d = b.shapeArgs;

              if (m && a) {
                var t = C(b.clientX, b.plotX),
                    k = b.plotY || 0;
                b.isNode && d && f(d.x) && f(d.y) && (t = d.x, k = d.y);
                return c ? {
                  chartX: a.len + a.pos - k,
                  chartY: m.len + m.pos - t
                } : {
                  chartX: t + m.pos,
                  chartY: k + a.pos
                };
              }

              if (d && d.x && d.y) return {
                chartX: d.x,
                chartY: d.y
              };
            };

            p.prototype.getChartPosition = function () {
              if (this.chartPosition) return this.chartPosition;
              var b = this.chart.container,
                  c = J(b);
              this.chartPosition = {
                left: c.left,
                top: c.top,
                scaleX: 1,
                scaleY: 1
              };
              var a = b.offsetWidth;
              b = b.offsetHeight;
              2 < a && 2 < b && (this.chartPosition.scaleX = c.width / a, this.chartPosition.scaleY = c.height / b);
              return this.chartPosition;
            };

            p.prototype.getCoordinates = function (b) {
              var c = {
                xAxis: [],
                yAxis: []
              };
              this.chart.axes.forEach(function (a) {
                c[a.isXAxis ? "xAxis" : "yAxis"].push({
                  axis: a,
                  value: a.toValue(b[a.horiz ? "chartX" : "chartY"])
                });
              });
              return c;
            };

            p.prototype.getHoverData = function (c, f, a, g, d, p) {
              var m = [];
              g = !(!g || !c);
              var h = {
                chartX: p ? p.chartX : void 0,
                chartY: p ? p.chartY : void 0,
                shared: d
              };
              x(this, "beforeGetHoverData", h);
              var t = f && !f.stickyTracking ? [f] : a.filter(function (a) {
                return h.filter ? h.filter(a) : a.visible && !(!d && a.directTouch) && C(a.options.enableMouseTracking, !0) && a.stickyTracking;
              });
              var e = g || !p ? c : this.findNearestKDPoint(t, d, p);
              f = e && e.series;
              e && (d && !f.noSharedTooltip ? (t = a.filter(function (a) {
                return h.filter ? h.filter(a) : a.visible && !(!d && a.directTouch) && C(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
              }), t.forEach(function (a) {
                var d = l(a.points, function (a) {
                  return a.x === e.x && !a.isNull;
                });
                b(d) && (a.chart.isBoosting && (d = a.getPoint(d)), m.push(d));
              })) : m.push(e));
              h = {
                hoverPoint: e
              };
              x(this, "afterGetHoverData", h);
              return {
                hoverPoint: h.hoverPoint,
                hoverSeries: f,
                hoverPoints: m
              };
            };

            p.prototype.getPointFromEvent = function (b) {
              b = b.target;

              for (var c; b && !c;) {
                c = b.point, b = b.parentNode;
              }

              return c;
            };

            p.prototype.onTrackerMouseOut = function (b) {
              b = b.relatedTarget || b.toElement;
              var c = this.chart.hoverSeries;
              this.isDirectTouch = !1;
              if (!(!c || !b || c.stickyTracking || this.inClass(b, "highcharts-tooltip") || this.inClass(b, "highcharts-series-" + c.index) && this.inClass(b, "highcharts-tracker"))) c.onMouseOut();
            };

            p.prototype.inClass = function (b, c) {
              for (var a; b;) {
                if (a = r(b, "class")) {
                  if (-1 !== a.indexOf(c)) return !0;
                  if (-1 !== a.indexOf("highcharts-container")) return !1;
                }

                b = b.parentElement;
              }
            };

            p.prototype.init = function (b, c) {
              this.options = c;
              this.chart = b;
              this.runChartClick = !(!c.chart.events || !c.chart.events.click);
              this.pinchDown = [];
              this.lastValidTouch = {};
              D && (b.tooltip = new D(b, c.tooltip), this.followTouchMove = C(c.tooltip.followTouchMove, !0));
              this.setDOMEvents();
            };

            p.prototype.normalize = function (b, c) {
              var a = b.touches,
                  f = a ? a.length ? a.item(0) : C(a.changedTouches, b.changedTouches)[0] : b;
              c || (c = this.getChartPosition());
              a = f.pageX - c.left;
              f = f.pageY - c.top;
              a /= c.scaleX;
              f /= c.scaleY;
              return g(b, {
                chartX: Math.round(a),
                chartY: Math.round(f)
              });
            };

            p.prototype.onContainerClick = function (b) {
              var c = this.chart,
                  a = c.hoverPoint;
              b = this.normalize(b);
              var f = c.plotLeft,
                  d = c.plotTop;
              c.cancelClick || (a && this.inClass(b.target, "highcharts-tracker") ? (x(a.series, "click", g(b, {
                point: a
              })), c.hoverPoint && a.firePointEvent("click", b)) : (g(b, this.getCoordinates(b)), c.isInsidePlot(b.chartX - f, b.chartY - d, {
                visiblePlotOnly: !0
              }) && x(c, "click", b)));
            };

            p.prototype.onContainerMouseDown = function (b) {
              var c = 1 === ((b.buttons || b.button) & 1);
              b = this.normalize(b);
              if (n.isFirefox && 0 !== b.button) this.onContainerMouseMove(b);
              if ("undefined" === typeof b.button || c) this.zoomOption(b), c && b.preventDefault && b.preventDefault(), this.dragStart(b);
            };

            p.prototype.onContainerMouseLeave = function (b) {
              var c = E[C(p.hoverChartIndex, -1)],
                  a = this.chart.tooltip;
              a && a.shouldStickOnContact() && this.inClass(b.relatedTarget, "highcharts-tooltip-container") || (b = this.normalize(b), c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = void 0), a && !a.isHidden && this.reset());
            };

            p.prototype.onContainerMouseEnter = function (b) {
              delete this.chartPosition;
            };

            p.prototype.onContainerMouseMove = function (b) {
              var c = this.chart;
              b = this.normalize(b);
              this.setHoverChartIndex();
              b.preventDefault || (b.returnValue = !1);
              ("mousedown" === c.mouseIsDown || this.touchSelect(b)) && this.drag(b);
              c.openMenu || !this.inClass(b.target, "highcharts-tracker") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || (this.inClass(b.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(b));
            };

            p.prototype.onDocumentTouchEnd = function (b) {
              var c = E[C(p.hoverChartIndex, -1)];
              c && c.pointer.drop(b);
            };

            p.prototype.onContainerTouchMove = function (b) {
              if (this.touchSelect(b)) this.onContainerMouseMove(b);else this.touch(b);
            };

            p.prototype.onContainerTouchStart = function (b) {
              if (this.touchSelect(b)) this.onContainerMouseDown(b);else this.zoomOption(b), this.touch(b, !0);
            };

            p.prototype.onDocumentMouseMove = function (b) {
              var c = this.chart,
                  a = this.chartPosition;
              b = this.normalize(b, a);
              var f = c.tooltip;
              !a || f && f.isStickyOnContact() || c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || this.inClass(b.target, "highcharts-tracker") || this.reset();
            };

            p.prototype.onDocumentMouseUp = function (b) {
              var c = E[C(p.hoverChartIndex, -1)];
              c && c.pointer.drop(b);
            };

            p.prototype.pinch = function (b) {
              var c = this,
                  a = c.chart,
                  f = c.pinchDown,
                  d = b.touches || [],
                  m = d.length,
                  k = c.lastValidTouch,
                  h = c.hasZoom,
                  p = {},
                  l = 1 === m && (c.inClass(b.target, "highcharts-tracker") && a.runTrackerClick || c.runChartClick),
                  u = {},
                  A = c.selectionMarker;
              1 < m ? c.initiated = !0 : 1 === m && this.followTouchMove && (c.initiated = !1);
              h && c.initiated && !l && !1 !== b.cancelable && b.preventDefault();
              [].map.call(d, function (a) {
                return c.normalize(a);
              });
              "touchstart" === b.type ? ([].forEach.call(d, function (a, d) {
                f[d] = {
                  chartX: a.chartX,
                  chartY: a.chartY
                };
              }), k.x = [f[0].chartX, f[1] && f[1].chartX], k.y = [f[0].chartY, f[1] && f[1].chartY], a.axes.forEach(function (d) {
                if (d.zoomEnabled) {
                  var b = a.bounds[d.horiz ? "h" : "v"],
                      c = d.minPixelPadding,
                      h = d.toPixels(Math.min(C(d.options.min, d.dataMin), d.dataMin)),
                      f = d.toPixels(Math.max(C(d.options.max, d.dataMax), d.dataMax)),
                      k = Math.max(h, f);
                  b.min = Math.min(d.pos, Math.min(h, f) - c);
                  b.max = Math.max(d.pos + d.len, k + c);
                }
              }), c.res = !0) : c.followTouchMove && 1 === m ? this.runPointActions(c.normalize(b)) : f.length && (x(a, "touchpan", {
                originalEvent: b
              }, function () {
                A || (c.selectionMarker = A = g({
                  destroy: I,
                  touch: !0
                }, a.plotBox));
                c.pinchTranslate(f, d, p, A, u, k);
                c.hasPinched = h;
                c.scaleGroups(p, u);
              }), c.res && (c.res = !1, this.reset(!1, 0)));
            };

            p.prototype.pinchTranslate = function (b, c, a, f, d, g) {
              this.zoomHor && this.pinchTranslateDirection(!0, b, c, a, f, d, g);
              this.zoomVert && this.pinchTranslateDirection(!1, b, c, a, f, d, g);
            };

            p.prototype.pinchTranslateDirection = function (b, c, a, f, d, g, k, h) {
              var m = this.chart,
                  p = b ? "x" : "y",
                  u = b ? "X" : "Y",
                  t = "chart" + u,
                  l = b ? "width" : "height",
                  e = m["plot" + (b ? "Left" : "Top")],
                  v = m.inverted,
                  w = m.bounds[b ? "h" : "v"],
                  z = 1 === c.length,
                  q = c[0][t],
                  r = !z && c[1][t];

              c = function c() {
                "number" === typeof J && 20 < Math.abs(q - r) && (x = h || Math.abs(C - J) / Math.abs(q - r));
                Q = (e - C) / x + q;
                F = m["plot" + (b ? "Width" : "Height")] / x;
              };

              var F,
                  Q,
                  x = h || 1,
                  C = a[0][t],
                  J = !z && a[1][t];
              c();
              a = Q;

              if (a < w.min) {
                a = w.min;
                var K = !0;
              } else a + F > w.max && (a = w.max - F, K = !0);

              K ? (C -= .8 * (C - k[p][0]), "number" === typeof J && (J -= .8 * (J - k[p][1])), c()) : k[p] = [C, J];
              v || (g[p] = Q - e, g[l] = F);
              g = v ? 1 / x : x;
              d[l] = F;
              d[p] = a;
              f[v ? b ? "scaleY" : "scaleX" : "scale" + u] = x;
              f["translate" + u] = g * e + (C - g * q);
            };

            p.prototype.reset = function (b, c) {
              var a = this.chart,
                  f = a.hoverSeries,
                  d = a.hoverPoint,
                  m = a.hoverPoints,
                  k = a.tooltip,
                  h = k && k.shared ? m : d;
              b && h && K(h).forEach(function (a) {
                a.series.isCartesian && "undefined" === typeof a.plotX && (b = !1);
              });
              if (b) k && h && K(h).length && (k.refresh(h), k.shared && m ? m.forEach(function (a) {
                a.setState(a.state, !0);
                a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
              }) : d && (d.setState(d.state, !0), a.axes.forEach(function (a) {
                a.crosshair && d.series[a.coll] === a && a.drawCrosshair(null, d);
              })));else {
                if (d) d.onMouseOut();
                m && m.forEach(function (a) {
                  a.setState();
                });
                if (f) f.onMouseOut();
                k && k.hide(c);
                this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                a.axes.forEach(function (a) {
                  a.hideCrosshair();
                });
                this.hoverX = a.hoverPoints = a.hoverPoint = null;
              }
            };

            p.prototype.runPointActions = function (b, c) {
              var a = this.chart,
                  f = a.tooltip && a.tooltip.options.enabled ? a.tooltip : void 0,
                  d = f ? f.shared : !1,
                  m = c || a.hoverPoint,
                  k = m && m.series || a.hoverSeries;
              c = this.getHoverData(m, k, a.series, (!b || "touchmove" !== b.type) && (!!c || k && k.directTouch && this.isDirectTouch), d, b);
              m = c.hoverPoint;
              k = c.hoverSeries;
              var h = c.hoverPoints;
              c = k && k.tooltipOptions.followPointer && !k.tooltipOptions.split;
              var g = d && k && !k.noSharedTooltip;

              if (m && (m !== a.hoverPoint || f && f.isHidden)) {
                (a.hoverPoints || []).forEach(function (a) {
                  -1 === h.indexOf(a) && a.setState();
                });
                if (a.hoverSeries !== k) k.onMouseOver();
                this.applyInactiveState(h);
                (h || []).forEach(function (a) {
                  a.setState("hover");
                });
                a.hoverPoint && a.hoverPoint.firePointEvent("mouseOut");
                if (!m.series) return;
                a.hoverPoints = h;
                a.hoverPoint = m;
                m.firePointEvent("mouseOver", void 0, function () {
                  f && m && f.refresh(g ? h : m, b);
                });
              } else c && f && !f.isHidden && (d = f.getAnchor([{}], b), a.isInsidePlot(d[0], d[1], {
                visiblePlotOnly: !0
              }) && f.updatePosition({
                plotX: d[0],
                plotY: d[1]
              }));

              this.unDocMouseMove || (this.unDocMouseMove = y(a.container.ownerDocument, "mousemove", function (a) {
                var d = E[p.hoverChartIndex];
                if (d) d.pointer.onDocumentMouseMove(a);
              }), this.eventsToUnbind.push(this.unDocMouseMove));
              a.axes.forEach(function (d) {
                var c = C((d.crosshair || {}).snap, !0),
                    f;
                c && ((f = a.hoverPoint) && f.series[d.coll] === d || (f = l(h, function (a) {
                  return a.series && a.series[d.coll] === d;
                })));
                f || !c ? d.drawCrosshair(b, f) : d.hideCrosshair();
              });
            };

            p.prototype.scaleGroups = function (b, c) {
              var a = this.chart;
              a.series.forEach(function (f) {
                var d = b || f.getPlotBox();
                f.group && (f.xAxis && f.xAxis.zoomEnabled || a.mapView) && (f.group.attr(d), f.markerGroup && (f.markerGroup.attr(d), f.markerGroup.clip(c ? a.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(d));
              });
              a.clipRect.attr(c || a.clipBox);
            };

            p.prototype.setDOMEvents = function () {
              var b = this,
                  c = this.chart.container,
                  a = c.ownerDocument;
              c.onmousedown = this.onContainerMouseDown.bind(this);
              c.onmousemove = this.onContainerMouseMove.bind(this);
              c.onclick = this.onContainerClick.bind(this);
              this.eventsToUnbind.push(y(c, "mouseenter", this.onContainerMouseEnter.bind(this)));
              this.eventsToUnbind.push(y(c, "mouseleave", this.onContainerMouseLeave.bind(this)));
              p.unbindDocumentMouseUp || (p.unbindDocumentMouseUp = y(a, "mouseup", this.onDocumentMouseUp.bind(this)));

              for (var f = this.chart.renderTo.parentElement; f && "BODY" !== f.tagName;) {
                this.eventsToUnbind.push(y(f, "scroll", function () {
                  delete b.chartPosition;
                })), f = f.parentElement;
              }

              n.hasTouch && (this.eventsToUnbind.push(y(c, "touchstart", this.onContainerTouchStart.bind(this), {
                passive: !1
              })), this.eventsToUnbind.push(y(c, "touchmove", this.onContainerTouchMove.bind(this), {
                passive: !1
              })), p.unbindDocumentTouchEnd || (p.unbindDocumentTouchEnd = y(a, "touchend", this.onDocumentTouchEnd.bind(this), {
                passive: !1
              })));
            };

            p.prototype.setHoverChartIndex = function () {
              var b = this.chart,
                  c = n.charts[C(p.hoverChartIndex, -1)];
              if (c && c !== b) c.pointer.onContainerMouseLeave({
                relatedTarget: b.container
              });
              c && c.mouseIsDown || (p.hoverChartIndex = b.index);
            };

            p.prototype.touch = function (b, c) {
              var a = this.chart,
                  f;
              this.setHoverChartIndex();
              if (1 === b.touches.length) {
                if (b = this.normalize(b), (f = a.isInsidePlot(b.chartX - a.plotLeft, b.chartY - a.plotTop, {
                  visiblePlotOnly: !0
                })) && !a.openMenu) {
                  c && this.runPointActions(b);

                  if ("touchmove" === b.type) {
                    c = this.pinchDown;
                    var d = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - b.chartX, 2) + Math.pow(c[0].chartY - b.chartY, 2)) : !1;
                  }

                  C(d, !0) && this.pinch(b);
                } else c && this.reset();
              } else 2 === b.touches.length && this.pinch(b);
            };

            p.prototype.touchSelect = function (b) {
              return !(!this.chart.options.chart.zoomBySingleTouch || !b.touches || 1 !== b.touches.length);
            };

            p.prototype.zoomOption = function (b) {
              var c = this.chart,
                  a = c.options.chart;
              c = c.inverted;
              var f = a.zoomType || "";
              /touch/.test(b.type) && (f = C(a.pinchType, f));
              this.zoomX = b = /x/.test(f);
              this.zoomY = a = /y/.test(f);
              this.zoomHor = b && !c || a && c;
              this.zoomVert = a && !c || b && c;
              this.hasZoom = b || a;
            };

            return p;
          }();

          "";
          return e;
        });
        N(e, "Core/MSPointer.js", [e["Core/Globals.js"], e["Core/Pointer.js"], e["Core/Utilities.js"]], function (e, n, D) {
          function G() {
            var b = [];

            b.item = function (b) {
              return this[b];
            };

            l(f, function (c) {
              b.push({
                pageX: c.pageX,
                pageY: c.pageY,
                target: c.target
              });
            });
            return b;
          }

          function B(b, c, f, g) {
            var p = I[n.hoverChartIndex || NaN];
            "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !p || (p = p.pointer, g(b), p[c]({
              type: f,
              target: b.currentTarget,
              preventDefault: r,
              touches: G()
            }));
          }

          var E = this && this.__extends || function () {
            var _b2 = function b(c, f) {
              _b2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var f in c) {
                  c.hasOwnProperty(f) && (b[f] = c[f]);
                }
              };

              return _b2(c, f);
            };

            return function (c, f) {
              function g() {
                this.constructor = c;
              }

              _b2(c, f);

              c.prototype = null === f ? Object.create(f) : (g.prototype = f.prototype, new g());
            };
          }(),
              I = e.charts,
              y = e.doc,
              r = e.noop,
              q = e.win,
              c = D.addEvent,
              g = D.css,
              l = D.objectEach,
              x = D.removeEvent,
              f = {},
              b = !!q.PointerEvent;

          return function (l) {
            function w() {
              return null !== l && l.apply(this, arguments) || this;
            }

            E(w, l);

            w.isRequired = function () {
              return !(e.hasTouch || !q.PointerEvent && !q.MSPointerEvent);
            };

            w.prototype.batchMSEvents = function (c) {
              c(this.chart.container, b ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              c(this.chart.container, b ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              c(y, b ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };

            w.prototype.destroy = function () {
              this.batchMSEvents(x);
              l.prototype.destroy.call(this);
            };

            w.prototype.init = function (b, c) {
              l.prototype.init.call(this, b, c);
              this.hasZoom && g(b.container, {
                "-ms-touch-action": "none",
                "touch-action": "none"
              });
            };

            w.prototype.onContainerPointerDown = function (b) {
              B(b, "onContainerTouchStart", "touchstart", function (b) {
                f[b.pointerId] = {
                  pageX: b.pageX,
                  pageY: b.pageY,
                  target: b.currentTarget
                };
              });
            };

            w.prototype.onContainerPointerMove = function (b) {
              B(b, "onContainerTouchMove", "touchmove", function (b) {
                f[b.pointerId] = {
                  pageX: b.pageX,
                  pageY: b.pageY
                };
                f[b.pointerId].target || (f[b.pointerId].target = b.currentTarget);
              });
            };

            w.prototype.onDocumentPointerUp = function (b) {
              B(b, "onDocumentTouchEnd", "touchend", function (b) {
                delete f[b.pointerId];
              });
            };

            w.prototype.setDOMEvents = function () {
              l.prototype.setDOMEvents.call(this);
              (this.hasZoom || this.followTouchMove) && this.batchMSEvents(c);
            };

            return w;
          }(n);
        });
        N(e, "Core/Legend/Legend.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/FormatUtilities.js"], e["Core/Globals.js"], e["Core/Series/Point.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E) {
          var G = e.animObject,
              y = e.setAnimation,
              r = n.format;
          e = D.isFirefox;
          var q = D.marginNames;
          D = D.win;
          var c = B.distribute,
              g = E.addEvent,
              l = E.createElement,
              x = E.css,
              f = E.defined,
              b = E.discardElement,
              w = E.find,
              J = E.fireEvent,
              C = E.isNumber,
              K = E.merge,
              p = E.pick,
              m = E.relativeLength,
              t = E.stableSort,
              a = E.syncTimeout;
          B = E.wrap;

          E = function () {
            function e(a, b) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = !1;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = void 0;
              this.padding = 0;
              this.pages = [];
              this.proximate = !1;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = a;
              this.init(a, b);
            }

            e.prototype.init = function (a, b) {
              this.chart = a;
              this.setOptions(b);
              b.enabled && (this.render(), g(this.chart, "endResize", function () {
                this.legend.positionCheckboxes();
              }), this.proximate ? this.unchartrender = g(this.chart, "render", function () {
                this.legend.proximatePositions();
                this.legend.positionItems();
              }) : this.unchartrender && this.unchartrender());
            };

            e.prototype.setOptions = function (a) {
              var d = p(a.padding, 8);
              this.options = a;
              this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = K(this.itemStyle, a.itemHiddenStyle));
              this.itemMarginTop = a.itemMarginTop || 0;
              this.itemMarginBottom = a.itemMarginBottom || 0;
              this.padding = d;
              this.initialItemY = d - 5;
              this.symbolWidth = p(a.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === a.layout && !this.chart.inverted;
              this.baseline = void 0;
            };

            e.prototype.update = function (a, b) {
              var d = this.chart;
              this.setOptions(K(!0, this.options, a));
              this.destroy();
              d.isDirtyLegend = d.isDirtyBox = !0;
              p(b, !0) && d.redraw();
              J(this, "afterUpdate");
            };

            e.prototype.colorizeItem = function (a, b) {
              a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

              if (!this.chart.styledMode) {
                var d = this.options,
                    c = a.legendItem,
                    f = a.legendLine,
                    m = a.legendSymbol,
                    u = this.itemHiddenStyle.color;
                d = b ? d.itemStyle.color : u;
                var g = b ? a.color || u : u,
                    p = a.options && a.options.marker,
                    t = {
                  fill: g
                };
                c && c.css({
                  fill: d,
                  color: d
                });
                f && f.attr({
                  stroke: g
                });
                m && (p && m.isMarker && (t = a.pointAttribs(), b || (t.stroke = t.fill = u)), m.attr(t));
              }

              J(this, "afterColorizeItem", {
                item: a,
                visible: b
              });
            };

            e.prototype.positionItems = function () {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            };

            e.prototype.positionItem = function (a) {
              var d = this,
                  b = this.options,
                  c = b.symbolPadding,
                  m = !b.rtl,
                  g = a._legendItemPos;
              b = g[0];
              g = g[1];
              var u = a.checkbox,
                  p = a.legendGroup;
              p && p.element && (c = {
                translateX: m ? b : this.legendWidth - b - 2 * c - 4,
                translateY: g
              }, m = function m() {
                J(d, "afterPositionItem", {
                  item: a
                });
              }, f(p.translateY) ? p.animate(c, void 0, m) : (p.attr(c), m()));
              u && (u.x = b, u.y = g);
            };

            e.prototype.destroyItem = function (a) {
              var d = a.checkbox;
              ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (d) {
                a[d] && (a[d] = a[d].destroy());
              });
              d && b(a.checkbox);
            };

            e.prototype.destroy = function () {
              function a(a) {
                this[a] && (this[a] = this[a].destroy());
              }

              this.getAllItems().forEach(function (d) {
                ["legendItem", "legendGroup"].forEach(a, d);
              });
              "clipRect up down pager nav box title group".split(" ").forEach(a, this);
              this.display = null;
            };

            e.prototype.positionCheckboxes = function () {
              var a = this.group && this.group.alignAttr,
                  b = this.clipHeight || this.legendHeight,
                  c = this.titleHeight;

              if (a) {
                var f = a.translateY;
                this.allItems.forEach(function (d) {
                  var h = d.checkbox;

                  if (h) {
                    var k = f + c + h.y + (this.scrollOffset || 0) + 3;
                    x(h, {
                      left: a.translateX + d.checkboxOffset + h.x - 20 + "px",
                      top: k + "px",
                      display: this.proximate || k > f - 6 && k < f + b - 6 ? "" : "none"
                    });
                  }
                }, this);
              }
            };

            e.prototype.renderTitle = function () {
              var a = this.options,
                  b = this.padding,
                  c = a.title,
                  f = 0;
              c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, void 0, void 0, void 0, a.useHTML, void 0, "legend-title").attr({
                zIndex: 1
              }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({
                width: this.maxLegendWidth + "px"
              }), a = this.title.getBBox(), f = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
                translateY: f
              }));
              this.titleHeight = f;
            };

            e.prototype.setText = function (a) {
              var d = this.options;
              a.legendItem.attr({
                text: d.labelFormat ? r(d.labelFormat, a, this.chart) : d.labelFormatter.call(a)
              });
            };

            e.prototype.renderItem = function (a) {
              var d = this.chart,
                  b = d.renderer,
                  c = this.options,
                  f = this.symbolWidth,
                  m = c.symbolPadding || 0,
                  u = this.itemStyle,
                  g = this.itemHiddenStyle,
                  t = "horizontal" === c.layout ? p(c.itemDistance, 20) : 0,
                  e = !c.rtl,
                  v = !a.series,
                  l = !v && a.series.drawLegendSymbol ? a.series : a,
                  w = l.options,
                  z = this.createCheckboxForItem && w && w.showCheckbox,
                  q = c.useHTML,
                  r = a.options.className,
                  x = a.legendItem;
              w = f + m + t + (z ? 20 : 0);
              x || (a.legendGroup = b.g("legend-item").addClass("highcharts-" + l.type + "-series highcharts-color-" + a.colorIndex + (r ? " " + r : "") + (v ? " highcharts-series-" + a.index : "")).attr({
                zIndex: 1
              }).add(this.scrollGroup), a.legendItem = x = b.text("", e ? f + m : -m, this.baseline || 0, q), d.styledMode || x.css(K(a.visible ? u : g)), x.attr({
                align: e ? "left" : "right",
                zIndex: 2
              }).add(a.legendGroup), this.baseline || (this.fontMetrics = b.fontMetrics(d.styledMode ? 12 : u.fontSize, x), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, x.attr("y", this.baseline), this.symbolHeight = c.symbolHeight || this.fontMetrics.f, c.squareSymbol && (this.symbolWidth = p(c.symbolWidth, Math.max(this.symbolHeight, 16)), w = this.symbolWidth + m + t + (z ? 20 : 0), e && x.attr("x", this.symbolWidth + m))), l.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, x, q));
              z && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);
              this.colorizeItem(a, a.visible);
              !d.styledMode && u.width || x.css({
                width: (c.itemWidth || this.widthOption || d.spacingBox.width) - w + "px"
              });
              this.setText(a);
              d = x.getBBox();
              b = this.fontMetrics && this.fontMetrics.h || 0;
              a.itemWidth = a.checkboxOffset = c.itemWidth || a.legendItemWidth || d.width + w;
              this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
              this.totalItemWidth += a.itemWidth;
              this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || (d.height > 1.5 * b ? d.height : b));
            };

            e.prototype.layoutItem = function (a) {
              var d = this.options,
                  b = this.padding,
                  c = "horizontal" === d.layout,
                  f = a.itemHeight,
                  m = this.itemMarginBottom,
                  u = this.itemMarginTop,
                  g = c ? p(d.itemDistance, 20) : 0,
                  t = this.maxLegendWidth;
              d = d.alignColumns && this.totalItemWidth > t ? this.maxItemWidth : a.itemWidth;
              c && this.itemX - b + d > t && (this.itemX = b, this.lastLineHeight && (this.itemY += u + this.lastLineHeight + m), this.lastLineHeight = 0);
              this.lastItemY = u + this.itemY + m;
              this.lastLineHeight = Math.max(f, this.lastLineHeight);
              a._legendItemPos = [this.itemX, this.itemY];
              c ? this.itemX += d : (this.itemY += u + f + m, this.lastLineHeight = f);
              this.offsetWidth = this.widthOption || Math.max((c ? this.itemX - b - (a.checkbox ? 0 : g) : d) + b, this.offsetWidth);
            };

            e.prototype.getAllItems = function () {
              var a = [];
              this.chart.series.forEach(function (d) {
                var b = d && d.options;
                d && p(b.showInLegend, f(b.linkedTo) ? !1 : void 0, !0) && (a = a.concat(d.legendItems || ("point" === b.legendType ? d.data : d)));
              });
              J(this, "afterGetAllItems", {
                allItems: a
              });
              return a;
            };

            e.prototype.getAlignment = function () {
              var a = this.options;
              return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
            };

            e.prototype.adjustMargins = function (a, b) {
              var d = this.chart,
                  c = this.options,
                  m = this.getAlignment();
              m && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (h, k) {
                h.test(m) && !f(a[k]) && (d[q[k]] = Math.max(d[q[k]], d.legend[(k + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][k] * c[k % 2 ? "x" : "y"] + p(c.margin, 12) + b[k] + (d.titleOffset[k] || 0)));
              });
            };

            e.prototype.proximatePositions = function () {
              var a = this.chart,
                  b = [],
                  f = "left" === this.options.align;
              this.allItems.forEach(function (d) {
                var c;
                var h = f;

                if (d.yAxis) {
                  d.xAxis.options.reversed && (h = !h);
                  d.points && (c = w(h ? d.points : d.points.slice(0).reverse(), function (a) {
                    return C(a.plotY);
                  }));
                  h = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;
                  var k = d.yAxis.top - a.plotTop;
                  d.visible ? (c = c ? c.plotY : d.yAxis.height, c += k - .3 * h) : c = k + d.yAxis.height;
                  b.push({
                    target: c,
                    size: h,
                    item: d
                  });
                }
              }, this);
              c(b, a.plotHeight).forEach(function (d) {
                d.item._legendItemPos && d.pos && (d.item._legendItemPos[1] = a.plotTop - a.spacing[0] + d.pos);
              });
            };

            e.prototype.render = function () {
              var a = this.chart,
                  b = a.renderer,
                  c = this.options,
                  f = this.padding,
                  g = this.getAllItems(),
                  p = this.group,
                  u = this.box;
              this.itemX = f;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = m(c.width, a.spacingBox.width - f);
              var A = a.spacingBox.width - 2 * f - c.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (A /= 2);
              this.maxLegendWidth = this.widthOption || A;
              p || (this.group = p = b.g("legend").addClass(c.className || "").attr({
                zIndex: 7
              }).add(), this.contentGroup = b.g().attr({
                zIndex: 1
              }).add(p), this.scrollGroup = b.g().add(this.contentGroup));
              this.renderTitle();
              t(g, function (a, d) {
                return (a.options && a.options.legendIndex || 0) - (d.options && d.options.legendIndex || 0);
              });
              c.reversed && g.reverse();
              this.allItems = g;
              this.display = A = !!g.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              g.forEach(this.renderItem, this);
              g.forEach(this.layoutItem, this);
              g = (this.widthOption || this.offsetWidth) + f;
              var e = this.lastItemY + this.lastLineHeight + this.titleHeight;
              e = this.handleOverflow(e);
              e += f;
              u || (this.box = u = b.rect().addClass("highcharts-legend-box").attr({
                r: c.borderRadius
              }).add(p));
              a.styledMode || u.attr({
                stroke: c.borderColor,
                "stroke-width": c.borderWidth || 0,
                fill: c.backgroundColor || "none"
              }).shadow(c.shadow);
              if (0 < g && 0 < e) u[u.placed ? "animate" : "attr"](u.crisp.call({}, {
                x: 0,
                y: 0,
                width: g,
                height: e
              }, u.strokeWidth()));
              p[A ? "show" : "hide"]();
              a.styledMode && "none" === p.getStyle("display") && (g = e = 0);
              this.legendWidth = g;
              this.legendHeight = e;
              A && this.align();
              this.proximate || this.positionItems();
              J(this, "afterRender");
            };

            e.prototype.align = function (a) {
              void 0 === a && (a = this.chart.spacingBox);
              var d = this.chart,
                  b = this.options,
                  c = a.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < d.titleOffset[0] ? c += d.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < d.titleOffset[2] && (c -= d.titleOffset[2]);
              c !== a.y && (a = K(a, {
                y: c
              }));
              d.hasRendered || (this.group.placed = !1);
              this.group.align(K(b, {
                width: this.legendWidth,
                height: this.legendHeight,
                verticalAlign: this.proximate ? "top" : b.verticalAlign
              }), !0, a);
            };

            e.prototype.handleOverflow = function (a) {
              var d = this,
                  b = this.chart,
                  c = b.renderer,
                  f = this.options,
                  m = f.y,
                  g = "top" === f.verticalAlign,
                  t = this.padding,
                  e = f.maxHeight,
                  l = f.navigation,
                  v = p(l.animation, !0),
                  w = l.arrowSize || 12,
                  z = this.pages,
                  q = this.allItems,
                  r = function r(a) {
                "number" === typeof a ? n.attr({
                  height: a
                }) : n && (d.clipRect = n.destroy(), d.contentGroup.clip());
                d.contentGroup.div && (d.contentGroup.div.style.clip = a ? "rect(" + t + "px,9999px," + (t + a) + "px,0)" : "auto");
              },
                  x = function x(a) {
                d[a] = c.circle(0, 0, 1.3 * w).translate(w / 2, w / 2).add(J);
                b.styledMode || d[a].attr("fill", "rgba(0,0,0,0.0001)");
                return d[a];
              },
                  Q,
                  C;

              m = b.spacingBox.height + (g ? -m : m) - t;
              var J = this.nav,
                  n = this.clipRect;
              "horizontal" !== f.layout || "middle" === f.verticalAlign || f.floating || (m /= 2);
              e && (m = Math.min(m, e));
              z.length = 0;
              a && 0 < m && a > m && !1 !== l.enabled ? (this.clipHeight = Q = Math.max(m - 20 - this.titleHeight - t, 0), this.currentPage = p(this.currentPage, 1), this.fullHeight = a, q.forEach(function (a, d) {
                var b = a._legendItemPos[1],
                    c = Math.round(a.legendItem.getBBox().height),
                    f = z.length;
                if (!f || b - z[f - 1] > Q && (C || b) !== z[f - 1]) z.push(C || b), f++;
                a.pageIx = f - 1;
                C && (q[d - 1].pageIx = f - 1);
                d === q.length - 1 && b + c - z[f - 1] > Q && c <= Q && (z.push(b), a.pageIx = f);
                b !== C && (C = b);
              }), n || (n = d.clipRect = c.clipRect(0, t, 9999, 0), d.contentGroup.clip(n)), r(Q), J || (this.nav = J = c.g().attr({
                zIndex: 1
              }).add(this.group), this.up = c.symbol("triangle", 0, 0, w, w).add(J), x("upTracker").on("click", function () {
                d.scroll(-1, v);
              }), this.pager = c.text("", 15, 10).addClass("highcharts-legend-navigation"), !b.styledMode && l.style && this.pager.css(l.style), this.pager.add(J), this.down = c.symbol("triangle-down", 0, 0, w, w).add(J), x("downTracker").on("click", function () {
                d.scroll(1, v);
              })), d.scroll(0), a = m) : J && (r(), this.nav = J.destroy(), this.scrollGroup.attr({
                translateY: 1
              }), this.clipHeight = 0);
              return a;
            };

            e.prototype.scroll = function (d, b) {
              var c = this,
                  f = this.chart,
                  m = this.pages,
                  g = m.length,
                  u = this.clipHeight,
                  t = this.options.navigation,
                  e = this.pager,
                  l = this.padding,
                  v = this.currentPage + d;
              v > g && (v = g);
              0 < v && ("undefined" !== typeof b && y(b, f), this.nav.attr({
                translateX: l,
                translateY: u + this.padding + 7 + this.titleHeight,
                visibility: "inherit"
              }), [this.up, this.upTracker].forEach(function (a) {
                a.attr({
                  "class": 1 === v ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }), e.attr({
                text: v + "/" + g
              }), [this.down, this.downTracker].forEach(function (a) {
                a.attr({
                  x: 18 + this.pager.getBBox().width,
                  "class": v === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }, this), f.styledMode || (this.up.attr({
                fill: 1 === v ? t.inactiveColor : t.activeColor
              }), this.upTracker.css({
                cursor: 1 === v ? "default" : "pointer"
              }), this.down.attr({
                fill: v === g ? t.inactiveColor : t.activeColor
              }), this.downTracker.css({
                cursor: v === g ? "default" : "pointer"
              })), this.scrollOffset = -m[v - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: this.scrollOffset
              }), this.currentPage = v, this.positionCheckboxes(), d = G(p(b, f.renderer.globalAnimation, !0)), a(function () {
                J(c, "afterScroll", {
                  currentPage: v
                });
              }, d.duration));
            };

            e.prototype.setItemEvents = function (a, b, c) {
              var d = this,
                  f = d.chart.renderer.boxWrapper,
                  k = a instanceof H,
                  m = "highcharts-legend-" + (k ? "point" : "series") + "-active",
                  g = d.chart.styledMode,
                  p = function p(b) {
                d.allItems.forEach(function (d) {
                  a !== d && [d].concat(d.linkedSeries || []).forEach(function (a) {
                    a.setState(b, !k);
                  });
                });
              };

              (c ? [b, a.legendSymbol] : [a.legendGroup]).forEach(function (c) {
                if (c) c.on("mouseover", function () {
                  a.visible && p("inactive");
                  a.setState("hover");
                  a.visible && f.addClass(m);
                  g || b.css(d.options.itemHoverStyle);
                }).on("mouseout", function () {
                  d.chart.styledMode || b.css(K(a.visible ? d.itemStyle : d.itemHiddenStyle));
                  p("");
                  f.removeClass(m);
                  a.setState();
                }).on("click", function (d) {
                  var b = function b() {
                    a.setVisible && a.setVisible();
                    p(a.visible ? "inactive" : "");
                  };

                  f.removeClass(m);
                  d = {
                    browserEvent: d
                  };
                  a.firePointEvent ? a.firePointEvent("legendItemClick", d, b) : J(a, "legendItemClick", d, b);
                });
              });
            };

            e.prototype.createCheckboxForItem = function (a) {
              a.checkbox = l("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: a.selected,
                defaultChecked: a.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              g(a.checkbox, "click", function (d) {
                J(a.series || a, "checkboxClick", {
                  checked: d.target.checked,
                  item: a
                }, function () {
                  a.select();
                });
              });
            };

            return e;
          }();

          (/Trident\/7\.0/.test(D.navigator && D.navigator.userAgent) || e) && B(E.prototype, "positionItem", function (a, d) {
            var b = this,
                c = function c() {
              d._legendItemPos && a.call(b, d);
            };

            c();
            b.bubbleLegend || setTimeout(c);
          });
          "";
          return E;
        });
        N(e, "Core/Series/SeriesRegistry.js", [e["Core/Globals.js"], e["Core/DefaultOptions.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (e, n, D, H) {
          var G = n.defaultOptions,
              E = H.error,
              I = H.extendClass,
              y = H.merge,
              r;

          (function (q) {
            function c(c, e) {
              var g = G.plotOptions || {},
                  f = e.defaultOptions;
              e.prototype.pointClass || (e.prototype.pointClass = D);
              e.prototype.type = c;
              f && (g[c] = f);
              q.seriesTypes[c] = e;
            }

            q.seriesTypes = e.seriesTypes;

            q.getSeries = function (c, e) {
              void 0 === e && (e = {});
              var g = c.options.chart;
              g = e.type || g.type || g.defaultSeriesType || "";
              var f = q.seriesTypes[g];
              q || E(17, !0, c, {
                missingModuleFor: g
              });
              g = new f();
              "function" === typeof g.init && g.init(c, e);
              return g;
            };

            q.registerSeriesType = c;

            q.seriesType = function (g, e, r, f, b) {
              var l = G.plotOptions || {};
              e = e || "";
              l[g] = y(l[e], r);
              c(g, I(q.seriesTypes[e] || function () {}, f));
              q.seriesTypes[g].prototype.type = g;
              b && (q.seriesTypes[g].prototype.pointClass = I(D, b));
              return q.seriesTypes[g];
            };
          })(r || (r = {}));

          return r;
        });
        N(e, "Core/Chart/Chart.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/FormatUtilities.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Legend/Legend.js"], e["Core/MSPointer.js"], e["Core/DefaultOptions.js"], e["Core/Pointer.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Time.js"], e["Core/Utilities.js"], e["Core/Renderer/HTML/AST.js"]], function (e, n, D, H, B, E, I, y, r, q, c, g, l, x, f) {
          var b = e.animate,
              w = e.animObject,
              J = e.setAnimation,
              C = D.numberFormat,
              K = H.registerEventOptions,
              p = B.charts,
              m = B.doc,
              t = B.marginNames,
              a = B.svg,
              z = B.win,
              d = y.defaultOptions,
              F = y.defaultTime,
              k = c.seriesTypes,
              h = x.addEvent,
              L = x.attr,
              P = x.cleanRecursively,
              u = x.createElement,
              A = x.css,
              O = x.defined,
              G = x.discardElement,
              v = x.erase,
              M = x.error,
              Y = x.extend,
              ba = x.find,
              R = x.fireEvent,
              ca = x.getStyle,
              Q = x.isArray,
              da = x.isNumber,
              T = x.isObject,
              ea = x.isString,
              X = x.merge,
              V = x.objectEach,
              S = x.pick,
              fa = x.pInt,
              ha = x.relativeLength,
              N = x.removeEvent,
              W = x.splat,
              Z = x.syncTimeout,
              ia = x.uniqueKey;

          e = function () {
            function c(a, d, b) {
              this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
              this.sharedClips = {};
              this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
              this.getArgs(a, d, b);
            }

            c.chart = function (a, d, b) {
              return new c(a, d, b);
            };

            c.prototype.getArgs = function (a, d, b) {
              ea(a) || a.nodeName ? (this.renderTo = a, this.init(d, b)) : this.init(a, d);
            };

            c.prototype.init = function (a, b) {
              var c = a.plotOptions || {};
              R(this, "init", {
                args: arguments
              }, function () {
                var f = X(d, a),
                    h = f.chart;
                V(f.plotOptions, function (a, d) {
                  T(a) && (a.tooltip = c[d] && X(c[d].tooltip) || void 0);
                });
                f.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;
                this.userOptions = a;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                  h: {},
                  v: {}
                };
                this.labelCollectors = [];
                this.callback = b;
                this.isResizing = 0;
                this.options = f;
                this.axes = [];
                this.series = [];
                this.time = a.time && Object.keys(a.time).length ? new l(a.time) : B.time;
                this.numberFormatter = h.numberFormatter || C;
                this.styledMode = h.styledMode;
                this.hasCartesianSeries = h.showAxes;
                this.index = p.length;
                p.push(this);
                B.chartCount++;
                K(this, h);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                R(this, "afterInit");
                this.firstRender();
              });
            };

            c.prototype.initSeries = function (a) {
              var d = this.options.chart;
              d = a.type || d.type || d.defaultSeriesType;
              var b = k[d];
              b || M(17, !0, this, {
                missingModuleFor: d
              });
              d = new b();
              "function" === typeof d.init && d.init(this, a);
              return d;
            };

            c.prototype.setSeriesData = function () {
              this.getSeriesOrderByLinks().forEach(function (a) {
                a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);
              });
            };

            c.prototype.getSeriesOrderByLinks = function () {
              return this.series.concat().sort(function (a, d) {
                return a.linkedSeries.length || d.linkedSeries.length ? d.linkedSeries.length - a.linkedSeries.length : 0;
              });
            };

            c.prototype.orderSeries = function (a) {
              var d = this.series;
              a = a || 0;

              for (var b = d.length; a < b; ++a) {
                d[a] && (d[a].index = a, d[a].name = d[a].getName());
              }
            };

            c.prototype.isInsidePlot = function (a, d, b) {
              void 0 === b && (b = {});
              var c = this.inverted,
                  f = this.plotBox,
                  h = this.plotLeft,
                  m = this.plotTop,
                  k = this.scrollablePlotBox,
                  g = 0;
              var u = 0;
              b.visiblePlotOnly && this.scrollingContainer && (u = this.scrollingContainer, g = u.scrollLeft, u = u.scrollTop);
              var p = b.series;
              f = b.visiblePlotOnly && k || f;
              k = b.inverted ? d : a;
              d = b.inverted ? a : d;
              a = {
                x: k,
                y: d,
                isInsidePlot: !0
              };

              if (!b.ignoreX) {
                var e = p && (c ? p.yAxis : p.xAxis) || {
                  pos: h,
                  len: Infinity
                };
                k = b.paneCoordinates ? e.pos + k : h + k;
                k >= Math.max(g + h, e.pos) && k <= Math.min(g + h + f.width, e.pos + e.len) || (a.isInsidePlot = !1);
              }

              !b.ignoreY && a.isInsidePlot && (c = p && (c ? p.xAxis : p.yAxis) || {
                pos: m,
                len: Infinity
              }, b = b.paneCoordinates ? c.pos + d : m + d, b >= Math.max(u + m, c.pos) && b <= Math.min(u + m + f.height, c.pos + c.len) || (a.isInsidePlot = !1));
              R(this, "afterIsInsidePlot", a);
              return a.isInsidePlot;
            };

            c.prototype.redraw = function (a) {
              R(this, "beforeRedraw");
              var d = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                  b = this.series,
                  c = this.pointer,
                  f = this.legend,
                  h = this.userOptions.legend,
                  k = this.renderer,
                  m = k.isHidden(),
                  g = [],
                  u = this.isDirtyBox,
                  p = this.isDirtyLegend;
              this.setResponsive && this.setResponsive(!1);
              J(this.hasRendered ? a : !1, this);
              m && this.temporaryDisplay();
              this.layOutTitles();

              for (a = b.length; a--;) {
                var e = b[a];

                if (e.options.stacking || e.options.centerInCategory) {
                  var t = !0;

                  if (e.isDirty) {
                    var v = !0;
                    break;
                  }
                }
              }

              if (v) for (a = b.length; a--;) {
                e = b[a], e.options.stacking && (e.isDirty = !0);
              }
              b.forEach(function (a) {
                a.isDirty && ("point" === a.options.legendType ? ("function" === typeof a.updateTotals && a.updateTotals(), p = !0) : h && (h.labelFormatter || h.labelFormat) && (p = !0));
                a.isDirtyData && R(a, "updatedData");
              });
              p && f && f.options.enabled && (f.render(), this.isDirtyLegend = !1);
              t && this.getStacks();
              d.forEach(function (a) {
                a.updateNames();
                a.setScale();
              });
              this.getMargins();
              d.forEach(function (a) {
                a.isDirty && (u = !0);
              });
              d.forEach(function (a) {
                var d = a.min + "," + a.max;
                a.extKey !== d && (a.extKey = d, g.push(function () {
                  R(a, "afterSetExtremes", Y(a.eventArgs, a.getExtremes()));
                  delete a.eventArgs;
                }));
                (u || t) && a.redraw();
              });
              u && this.drawChartBox();
              R(this, "predraw");
              b.forEach(function (a) {
                (u || a.isDirty) && a.visible && a.redraw();
                a.isDirtyData = !1;
              });
              c && c.reset(!0);
              k.draw();
              R(this, "redraw");
              R(this, "render");
              m && this.temporaryDisplay(!0);
              g.forEach(function (a) {
                a.call();
              });
            };

            c.prototype.get = function (a) {
              function d(d) {
                return d.id === a || d.options && d.options.id === a;
              }

              for (var b = this.series, c = ba(this.axes, d) || ba(this.series, d), f = 0; !c && f < b.length; f++) {
                c = ba(b[f].points || [], d);
              }

              return c;
            };

            c.prototype.getAxes = function () {
              var a = this,
                  d = this.options,
                  b = d.xAxis = W(d.xAxis || {});
              d = d.yAxis = W(d.yAxis || {});
              R(this, "getAxes");
              b.forEach(function (a, d) {
                a.index = d;
                a.isX = !0;
              });
              d.forEach(function (a, d) {
                a.index = d;
              });
              b.concat(d).forEach(function (d) {
                new n(a, d);
              });
              R(this, "afterGetAxes");
            };

            c.prototype.getSelectedPoints = function () {
              return this.series.reduce(function (a, d) {
                d.getPointsCollection().forEach(function (d) {
                  S(d.selectedStaging, d.selected) && a.push(d);
                });
                return a;
              }, []);
            };

            c.prototype.getSelectedSeries = function () {
              return this.series.filter(function (a) {
                return a.selected;
              });
            };

            c.prototype.setTitle = function (a, d, b) {
              this.applyDescription("title", a);
              this.applyDescription("subtitle", d);
              this.applyDescription("caption", void 0);
              this.layOutTitles(b);
            };

            c.prototype.applyDescription = function (a, d) {
              var b = this,
                  c = "title" === a ? {
                color: "#333333",
                fontSize: this.options.isStock ? "16px" : "18px"
              } : {
                color: "#666666"
              };
              c = this.options[a] = X(!this.styledMode && {
                style: c
              }, this.options[a], d);
              var f = this[a];
              f && d && (this[a] = f = f.destroy());
              c && !f && (f = this.renderer.text(c.text, 0, 0, c.useHTML).attr({
                align: c.align,
                "class": "highcharts-" + a,
                zIndex: c.zIndex || 4
              }).add(), f.update = function (d) {
                b[{
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }[a]](d);
              }, this.styledMode || f.css(c.style), this[a] = f);
            };

            c.prototype.layOutTitles = function (a) {
              var d = [0, 0, 0],
                  b = this.renderer,
                  c = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (a) {
                var f = this[a],
                    h = this.options[a],
                    k = h.verticalAlign || "top";
                a = "title" === a ? "top" === k ? -3 : 0 : "top" === k ? d[0] + 2 : 0;
                var m;

                if (f) {
                  this.styledMode || (m = h.style && h.style.fontSize);
                  m = b.fontMetrics(m, f).b;
                  f.css({
                    width: (h.width || c.width + (h.widthAdjust || 0)) + "px"
                  });
                  var g = Math.round(f.getBBox(h.useHTML).height);
                  f.align(Y({
                    y: "bottom" === k ? m : a + m,
                    height: g
                  }, h), !1, "spacingBox");
                  h.floating || ("top" === k ? d[0] = Math.ceil(d[0] + g) : "bottom" === k && (d[2] = Math.ceil(d[2] + g)));
                }
              }, this);
              d[0] && "top" === (this.options.title.verticalAlign || "top") && (d[0] += this.options.title.margin);
              d[2] && "bottom" === this.options.caption.verticalAlign && (d[2] += this.options.caption.margin);
              var f = !this.titleOffset || this.titleOffset.join(",") !== d.join(",");
              this.titleOffset = d;
              R(this, "afterLayOutTitles");
              !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && S(a, !0) && this.isDirtyBox && this.redraw());
            };

            c.prototype.getChartSize = function () {
              var a = this.options.chart,
                  d = a.width;
              a = a.height;
              var b = this.renderTo;
              O(d) || (this.containerWidth = ca(b, "width"));
              O(a) || (this.containerHeight = ca(b, "height"));
              this.chartWidth = Math.max(0, d || this.containerWidth || 600);
              this.chartHeight = Math.max(0, ha(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };

            c.prototype.temporaryDisplay = function (a) {
              var d = this.renderTo;
              if (a) for (; d && d.style;) {
                d.hcOrigStyle && (A(d, d.hcOrigStyle), delete d.hcOrigStyle), d.hcOrigDetached && (m.body.removeChild(d), d.hcOrigDetached = !1), d = d.parentNode;
              } else for (; d && d.style;) {
                m.body.contains(d) || d.parentNode || (d.hcOrigDetached = !0, m.body.appendChild(d));
                if ("none" === ca(d, "display", !1) || d.hcOricDetached) d.hcOrigStyle = {
                  display: d.style.display,
                  height: d.style.height,
                  overflow: d.style.overflow
                }, a = {
                  display: "block",
                  overflow: "hidden"
                }, d !== this.renderTo && (a.height = 0), A(d, a), d.offsetWidth || d.style.setProperty("display", "block", "important");
                d = d.parentNode;
                if (d === m.body) break;
              }
            };

            c.prototype.setClassName = function (a) {
              this.container.className = "highcharts-container " + (a || "");
            };

            c.prototype.getContainer = function () {
              var d = this.options,
                  b = d.chart,
                  c = ia(),
                  h,
                  k = this.renderTo;
              k || (this.renderTo = k = b.renderTo);
              ea(k) && (this.renderTo = k = m.getElementById(k));
              k || M(13, !0, this);
              var e = fa(L(k, "data-highcharts-chart"));
              da(e) && p[e] && p[e].hasRendered && p[e].destroy();
              L(k, "data-highcharts-chart", this.index);
              k.innerHTML = f.emptyHTML;
              b.skipClone || k.offsetWidth || this.temporaryDisplay();
              this.getChartSize();
              e = this.chartWidth;
              var t = this.chartHeight;
              A(k, {
                overflow: "hidden"
              });
              this.styledMode || (h = Y({
                position: "relative",
                overflow: "hidden",
                width: e + "px",
                height: t + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                userSelect: "none",
                "touch-action": "manipulation",
                outline: "none"
              }, b.style || {}));
              this.container = c = u("div", {
                id: c
              }, h, k);
              this._cursor = c.style.cursor;
              this.renderer = new (b.renderer || !a ? q.getRendererType(b.renderer) : g)(c, e, t, void 0, b.forExport, d.exporting && d.exporting.allowHTML, this.styledMode);
              J(void 0, this);
              this.setClassName(b.className);
              if (this.styledMode) for (var v in d.defs) {
                this.renderer.definition(d.defs[v]);
              } else this.renderer.setStyle(b.style);
              this.renderer.chartIndex = this.index;
              R(this, "afterGetContainer");
            };

            c.prototype.getMargins = function (a) {
              var d = this.spacing,
                  b = this.margin,
                  c = this.titleOffset;
              this.resetMargins();
              c[0] && !O(b[0]) && (this.plotTop = Math.max(this.plotTop, c[0] + d[0]));
              c[2] && !O(b[2]) && (this.marginBottom = Math.max(this.marginBottom, c[2] + d[2]));
              this.legend && this.legend.display && this.legend.adjustMargins(b, d);
              R(this, "getMargins");
              a || this.getAxisMargins();
            };

            c.prototype.getAxisMargins = function () {
              var a = this,
                  d = a.axisOffset = [0, 0, 0, 0],
                  b = a.colorAxis,
                  c = a.margin,
                  f = function f(a) {
                a.forEach(function (a) {
                  a.visible && a.getOffset();
                });
              };

              a.hasCartesianSeries ? f(a.axes) : b && b.length && f(b);
              t.forEach(function (b, f) {
                O(c[f]) || (a[b] += d[f]);
              });
              a.setChartSize();
            };

            c.prototype.reflow = function (a) {
              var d = this,
                  b = d.options.chart,
                  c = d.renderTo,
                  f = O(b.width) && O(b.height),
                  h = b.width || ca(c, "width");
              b = b.height || ca(c, "height");
              c = a ? a.target : z;
              delete d.pointer.chartPosition;

              if (!f && !d.isPrinting && h && b && (c === z || c === m)) {
                if (h !== d.containerWidth || b !== d.containerHeight) x.clearTimeout(d.reflowTimeout), d.reflowTimeout = Z(function () {
                  d.container && d.setSize(void 0, void 0, !1);
                }, a ? 100 : 0);
                d.containerWidth = h;
                d.containerHeight = b;
              }
            };

            c.prototype.setReflow = function (a) {
              var d = this;
              !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = h(z, "resize", function (a) {
                d.options && d.reflow(a);
              }), h(this, "destroy", this.unbindReflow));
            };

            c.prototype.setSize = function (a, d, c) {
              var f = this,
                  h = f.renderer;
              f.isResizing += 1;
              J(c, f);
              c = h.globalAnimation;
              f.oldChartHeight = f.chartHeight;
              f.oldChartWidth = f.chartWidth;
              "undefined" !== typeof a && (f.options.chart.width = a);
              "undefined" !== typeof d && (f.options.chart.height = d);
              f.getChartSize();
              f.styledMode || (c ? b : A)(f.container, {
                width: f.chartWidth + "px",
                height: f.chartHeight + "px"
              }, c);
              f.setChartSize(!0);
              h.setSize(f.chartWidth, f.chartHeight, c);
              f.axes.forEach(function (a) {
                a.isDirty = !0;
                a.setScale();
              });
              f.isDirtyLegend = !0;
              f.isDirtyBox = !0;
              f.layOutTitles();
              f.getMargins();
              f.redraw(c);
              f.oldChartHeight = null;
              R(f, "resize");
              Z(function () {
                f && R(f, "endResize", null, function () {
                  --f.isResizing;
                });
              }, w(c).duration);
            };

            c.prototype.setChartSize = function (a) {
              var d = this.inverted,
                  b = this.renderer,
                  c = this.chartWidth,
                  f = this.chartHeight,
                  h = this.options.chart,
                  k = this.spacing,
                  m = this.clipOffset,
                  g,
                  u,
                  p,
                  e;
              this.plotLeft = g = Math.round(this.plotLeft);
              this.plotTop = u = Math.round(this.plotTop);
              this.plotWidth = p = Math.max(0, Math.round(c - g - this.marginRight));
              this.plotHeight = e = Math.max(0, Math.round(f - u - this.marginBottom));
              this.plotSizeX = d ? e : p;
              this.plotSizeY = d ? p : e;
              this.plotBorderWidth = h.plotBorderWidth || 0;
              this.spacingBox = b.spacingBox = {
                x: k[3],
                y: k[0],
                width: c - k[3] - k[1],
                height: f - k[0] - k[2]
              };
              this.plotBox = b.plotBox = {
                x: g,
                y: u,
                width: p,
                height: e
              };
              d = 2 * Math.floor(this.plotBorderWidth / 2);
              c = Math.ceil(Math.max(d, m[3]) / 2);
              f = Math.ceil(Math.max(d, m[0]) / 2);
              this.clipBox = {
                x: c,
                y: f,
                width: Math.floor(this.plotSizeX - Math.max(d, m[1]) / 2 - c),
                height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, m[2]) / 2 - f))
              };
              a || (this.axes.forEach(function (a) {
                a.setAxisSize();
                a.setAxisTranslation();
              }), b.alignElements());
              R(this, "afterSetChartSize", {
                skipAxes: a
              });
            };

            c.prototype.resetMargins = function () {
              R(this, "resetMargins");
              var a = this,
                  d = a.options.chart;
              ["margin", "spacing"].forEach(function (b) {
                var c = d[b],
                    f = T(c) ? c : [c, c, c, c];
                ["Top", "Right", "Bottom", "Left"].forEach(function (c, h) {
                  a[b][h] = S(d[b + c], f[h]);
                });
              });
              t.forEach(function (d, b) {
                a[d] = S(a.margin[b], a.spacing[b]);
              });
              a.axisOffset = [0, 0, 0, 0];
              a.clipOffset = [0, 0, 0, 0];
            };

            c.prototype.drawChartBox = function () {
              var a = this.options.chart,
                  d = this.renderer,
                  b = this.chartWidth,
                  c = this.chartHeight,
                  f = this.styledMode,
                  h = this.plotBGImage,
                  k = a.backgroundColor,
                  m = a.plotBackgroundColor,
                  g = a.plotBackgroundImage,
                  u = this.plotLeft,
                  p = this.plotTop,
                  e = this.plotWidth,
                  t = this.plotHeight,
                  v = this.plotBox,
                  A = this.clipRect,
                  l = this.clipBox,
                  w = this.chartBackground,
                  z = this.plotBackground,
                  q = this.plotBorder,
                  r,
                  x = "animate";
              w || (this.chartBackground = w = d.rect().addClass("highcharts-background").add(), x = "attr");
              if (f) var Q = r = w.strokeWidth();else {
                Q = a.borderWidth || 0;
                r = Q + (a.shadow ? 8 : 0);
                k = {
                  fill: k || "none"
                };
                if (Q || w["stroke-width"]) k.stroke = a.borderColor, k["stroke-width"] = Q;
                w.attr(k).shadow(a.shadow);
              }
              w[x]({
                x: r / 2,
                y: r / 2,
                width: b - r - Q % 2,
                height: c - r - Q % 2,
                r: a.borderRadius
              });
              x = "animate";
              z || (x = "attr", this.plotBackground = z = d.rect().addClass("highcharts-plot-background").add());
              z[x](v);
              f || (z.attr({
                fill: m || "none"
              }).shadow(a.plotShadow), g && (h ? (g !== h.attr("href") && h.attr("href", g), h.animate(v)) : this.plotBGImage = d.image(g, u, p, e, t).add()));
              A ? A.animate({
                width: l.width,
                height: l.height
              }) : this.clipRect = d.clipRect(l);
              x = "animate";
              q || (x = "attr", this.plotBorder = q = d.rect().addClass("highcharts-plot-border").attr({
                zIndex: 1
              }).add());
              f || q.attr({
                stroke: a.plotBorderColor,
                "stroke-width": a.plotBorderWidth || 0,
                fill: "none"
              });
              q[x](q.crisp({
                x: u,
                y: p,
                width: e,
                height: t
              }, -q.strokeWidth()));
              this.isDirtyBox = !1;
              R(this, "afterDrawChartBox");
            };

            c.prototype.propFromSeries = function () {
              var a = this,
                  d = a.options.chart,
                  b = a.options.series,
                  c,
                  f,
                  h;
              ["inverted", "angular", "polar"].forEach(function (m) {
                f = k[d.type || d.defaultSeriesType];
                h = d[m] || f && f.prototype[m];

                for (c = b && b.length; !h && c--;) {
                  (f = k[b[c].type]) && f.prototype[m] && (h = !0);
                }

                a[m] = h;
              });
            };

            c.prototype.linkSeries = function () {
              var a = this,
                  d = a.series;
              d.forEach(function (a) {
                a.linkedSeries.length = 0;
              });
              d.forEach(function (d) {
                var b = d.options.linkedTo;
                ea(b) && (b = ":previous" === b ? a.series[d.index - 1] : a.get(b)) && b.linkedParent !== d && (b.linkedSeries.push(d), d.linkedParent = b, b.enabledDataSorting && d.setDataSortingOptions(), d.visible = S(d.options.visible, b.options.visible, d.visible));
              });
              R(this, "afterLinkSeries");
            };

            c.prototype.renderSeries = function () {
              this.series.forEach(function (a) {
                a.translate();
                a.render();
              });
            };

            c.prototype.renderLabels = function () {
              var a = this,
                  d = a.options.labels;
              d.items && d.items.forEach(function (b) {
                var c = Y(d.style, b.style),
                    f = fa(c.left) + a.plotLeft,
                    h = fa(c.top) + a.plotTop + 12;
                delete c.left;
                delete c.top;
                a.renderer.text(b.html, f, h).attr({
                  zIndex: 2
                }).css(c).add();
              });
            };

            c.prototype.render = function () {
              var a = this.axes,
                  d = this.colorAxis,
                  b = this.renderer,
                  c = this.options,
                  f = function f(a) {
                a.forEach(function (a) {
                  a.visible && a.render();
                });
              },
                  h = 0;

              this.setTitle();
              this.legend = new E(this, c.legend);
              this.getStacks && this.getStacks();
              this.getMargins(!0);
              this.setChartSize();
              c = this.plotWidth;
              a.some(function (a) {
                if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return h = 21, !0;
              });
              var k = this.plotHeight = Math.max(this.plotHeight - h, 0);
              a.forEach(function (a) {
                a.setScale();
              });
              this.getAxisMargins();
              var m = 1.1 < c / this.plotWidth,
                  g = 1.05 < k / this.plotHeight;
              if (m || g) a.forEach(function (a) {
                (a.horiz && m || !a.horiz && g) && a.setTickInterval(!0);
              }), this.getMargins();
              this.drawChartBox();
              this.hasCartesianSeries ? f(a) : d && d.length && f(d);
              this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({
                zIndex: 3
              }).add());
              this.renderSeries();
              this.renderLabels();
              this.addCredits();
              this.setResponsive && this.setResponsive();
              this.hasRendered = !0;
            };

            c.prototype.addCredits = function (a) {
              var d = this,
                  b = X(!0, this.options.credits, a);
              b.enabled && !this.credits && (this.credits = this.renderer.text(b.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                b.href && (z.location.href = b.href);
              }).attr({
                align: b.position.align,
                zIndex: 8
              }), d.styledMode || this.credits.css(b.style), this.credits.add().align(b.position), this.credits.update = function (a) {
                d.credits = d.credits.destroy();
                d.addCredits(a);
              });
            };

            c.prototype.destroy = function () {
              var a = this,
                  d = a.axes,
                  b = a.series,
                  c = a.container,
                  h = c && c.parentNode,
                  k;
              R(a, "destroy");
              a.renderer.forExport ? v(p, a) : p[a.index] = void 0;
              B.chartCount--;
              a.renderTo.removeAttribute("data-highcharts-chart");
              N(a);

              for (k = d.length; k--;) {
                d[k] = d[k].destroy();
              }

              this.scroller && this.scroller.destroy && this.scroller.destroy();

              for (k = b.length; k--;) {
                b[k] = b[k].destroy();
              }

              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (d) {
                var b = a[d];
                b && b.destroy && (a[d] = b.destroy());
              });
              c && (c.innerHTML = f.emptyHTML, N(c), h && G(c));
              V(a, function (d, b) {
                delete a[b];
              });
            };

            c.prototype.firstRender = function () {
              var a = this,
                  d = a.options;

              if (!a.isReadyToRender || a.isReadyToRender()) {
                a.getContainer();
                a.resetMargins();
                a.setChartSize();
                a.propFromSeries();
                a.getAxes();
                (Q(d.series) ? d.series : []).forEach(function (d) {
                  a.initSeries(d);
                });
                a.linkSeries();
                a.setSeriesData();
                R(a, "beforeRender");
                r && (I.isRequired() ? a.pointer = new I(a, d) : a.pointer = new r(a, d));
                a.render();
                a.pointer.getChartPosition();
                if (!a.renderer.imgCount && !a.hasLoaded) a.onload();
                a.temporaryDisplay(!0);
              }
            };

            c.prototype.onload = function () {
              this.callbacks.concat([this.callback]).forEach(function (a) {
                a && "undefined" !== typeof this.index && a.apply(this, [this]);
              }, this);
              R(this, "load");
              R(this, "render");
              O(this.index) && this.setReflow(this.options.chart.reflow);
              this.warnIfA11yModuleNotLoaded();
              this.hasLoaded = !0;
            };

            c.prototype.warnIfA11yModuleNotLoaded = function () {
              var a = this.options,
                  d = this.title;
              a && !this.accessibility && (this.renderer.boxWrapper.attr({
                role: "img",
                "aria-label": d && d.element.textContent || ""
              }), a.accessibility && !1 === a.accessibility.enabled || M('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
            };

            c.prototype.addSeries = function (a, d, b) {
              var c = this,
                  f;
              a && (d = S(d, !0), R(c, "addSeries", {
                options: a
              }, function () {
                f = c.initSeries(a);
                c.isDirtyLegend = !0;
                c.linkSeries();
                f.enabledDataSorting && f.setData(a.data, !1);
                R(c, "afterAddSeries", {
                  series: f
                });
                d && c.redraw(b);
              }));
              return f;
            };

            c.prototype.addAxis = function (a, d, b, c) {
              return this.createAxis(d ? "xAxis" : "yAxis", {
                axis: a,
                redraw: b,
                animation: c
              });
            };

            c.prototype.addColorAxis = function (a, d, b) {
              return this.createAxis("colorAxis", {
                axis: a,
                redraw: d,
                animation: b
              });
            };

            c.prototype.createAxis = function (a, d) {
              a = new n(this, X(d.axis, {
                index: this[a].length,
                isX: "xAxis" === a
              }));
              S(d.redraw, !0) && this.redraw(d.animation);
              return a;
            };

            c.prototype.showLoading = function (a) {
              var d = this,
                  c = d.options,
                  k = c.loading,
                  m = function m() {
                g && A(g, {
                  left: d.plotLeft + "px",
                  top: d.plotTop + "px",
                  width: d.plotWidth + "px",
                  height: d.plotHeight + "px"
                });
              },
                  g = d.loadingDiv,
                  p = d.loadingSpan;

              g || (d.loadingDiv = g = u("div", {
                className: "highcharts-loading highcharts-loading-hidden"
              }, null, d.container));
              p || (d.loadingSpan = p = u("span", {
                className: "highcharts-loading-inner"
              }, null, g), h(d, "redraw", m));
              g.className = "highcharts-loading";
              f.setElementHTML(p, S(a, c.lang.loading, ""));
              d.styledMode || (A(g, Y(k.style, {
                zIndex: 10
              })), A(p, k.labelStyle), d.loadingShown || (A(g, {
                opacity: 0,
                display: ""
              }), b(g, {
                opacity: k.style.opacity || .5
              }, {
                duration: k.showDuration || 0
              })));
              d.loadingShown = !0;
              m();
            };

            c.prototype.hideLoading = function () {
              var a = this.options,
                  d = this.loadingDiv;
              d && (d.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || b(d, {
                opacity: 0
              }, {
                duration: a.loading.hideDuration || 100,
                complete: function complete() {
                  A(d, {
                    display: "none"
                  });
                }
              }));
              this.loadingShown = !1;
            };

            c.prototype.update = function (a, d, b, c) {
              var f = this,
                  h = {
                credits: "addCredits",
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              },
                  k = a.isResponsiveOptions,
                  m = [],
                  g,
                  u;
              R(f, "update", {
                options: a
              });
              k || f.setResponsive(!1, !0);
              a = P(a, f.options);
              f.userOptions = X(f.userOptions, a);
              var p = a.chart;

              if (p) {
                X(!0, f.options.chart, p);
                "className" in p && f.setClassName(p.className);
                "reflow" in p && f.setReflow(p.reflow);

                if ("inverted" in p || "polar" in p || "type" in p) {
                  f.propFromSeries();
                  var e = !0;
                }

                "alignTicks" in p && (e = !0);
                "events" in p && K(this, p);
                V(p, function (a, d) {
                  -1 !== f.propsRequireUpdateSeries.indexOf("chart." + d) && (g = !0);
                  -1 !== f.propsRequireDirtyBox.indexOf(d) && (f.isDirtyBox = !0);
                  -1 !== f.propsRequireReflow.indexOf(d) && (k ? f.isDirtyBox = !0 : u = !0);
                });
                !f.styledMode && p.style && f.renderer.setStyle(f.options.chart.style || {});
              }

              !f.styledMode && a.colors && (this.options.colors = a.colors);
              a.time && (this.time === F && (this.time = new l(a.time)), X(!0, f.options.time, a.time));
              V(a, function (d, b) {
                if (f[b] && "function" === typeof f[b].update) f[b].update(d, !1);else if ("function" === typeof f[h[b]]) f[h[b]](d);else "colors" !== b && -1 === f.collectionsWithUpdate.indexOf(b) && X(!0, f.options[b], a[b]);
                "chart" !== b && -1 !== f.propsRequireUpdateSeries.indexOf(b) && (g = !0);
              });
              this.collectionsWithUpdate.forEach(function (d) {
                if (a[d]) {
                  var c = [];
                  f[d].forEach(function (a, d) {
                    a.options.isInternal || c.push(S(a.options.index, d));
                  });
                  W(a[d]).forEach(function (a, h) {
                    var k = O(a.id),
                        m;
                    k && (m = f.get(a.id));
                    !m && f[d] && (m = f[d][c ? c[h] : h]) && k && O(m.options.id) && (m = void 0);
                    m && m.coll === d && (m.update(a, !1), b && (m.touched = !0));
                    !m && b && f.collectionsWithInit[d] && (f.collectionsWithInit[d][0].apply(f, [a].concat(f.collectionsWithInit[d][1] || []).concat([!1])).touched = !0);
                  });
                  b && f[d].forEach(function (a) {
                    a.touched || a.options.isInternal ? delete a.touched : m.push(a);
                  });
                }
              });
              m.forEach(function (a) {
                a.chart && a.remove && a.remove(!1);
              });
              e && f.axes.forEach(function (a) {
                a.update({}, !1);
              });
              g && f.getSeriesOrderByLinks().forEach(function (a) {
                a.chart && a.update({}, !1);
              }, this);
              e = p && p.width;
              p = p && (ea(p.height) ? ha(p.height, e || f.chartWidth) : p.height);
              u || da(e) && e !== f.chartWidth || da(p) && p !== f.chartHeight ? f.setSize(e, p, c) : S(d, !0) && f.redraw(c);
              R(f, "afterUpdate", {
                options: a,
                redraw: d,
                animation: c
              });
            };

            c.prototype.setSubtitle = function (a, d) {
              this.applyDescription("subtitle", a);
              this.layOutTitles(d);
            };

            c.prototype.setCaption = function (a, d) {
              this.applyDescription("caption", a);
              this.layOutTitles(d);
            };

            c.prototype.showResetZoom = function () {
              function a() {
                b.zoomOut();
              }

              var b = this,
                  c = d.lang,
                  f = b.options.chart.resetZoomButton,
                  h = f.theme,
                  k = "chart" === f.relativeTo || "spacingBox" === f.relativeTo ? null : "scrollablePlotBox";
              R(this, "beforeShowResetZoom", null, function () {
                b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, h).attr({
                  align: f.position.align,
                  title: c.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(f.position, !1, k);
              });
              R(this, "afterShowResetZoom");
            };

            c.prototype.zoomOut = function () {
              R(this, "selection", {
                resetSelection: !0
              }, this.zoom);
            };

            c.prototype.zoom = function (a) {
              var d = this,
                  b = d.pointer,
                  c = d.inverted ? b.mouseDownX : b.mouseDownY,
                  f = !1,
                  h;
              !a || a.resetSelection ? (d.axes.forEach(function (a) {
                h = a.zoom();
              }), b.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
                var k = a.axis,
                    m = d.inverted ? k.left : k.top,
                    g = d.inverted ? m + k.width : m + k.height,
                    u = k.isXAxis,
                    p = !1;
                if (!u && c >= m && c <= g || u || !O(c)) p = !0;
                b[u ? "zoomX" : "zoomY"] && p && (h = k.zoom(a.min, a.max), k.displayBtn && (f = !0));
              });
              var k = d.resetZoomButton;
              f && !k ? d.showResetZoom() : !f && T(k) && (d.resetZoomButton = k.destroy());
              h && d.redraw(S(d.options.chart.animation, a && a.animation, 100 > d.pointCount));
            };

            c.prototype.pan = function (a, d) {
              var b = this,
                  c = b.hoverPoints;
              d = "object" === typeof d ? d : {
                enabled: d,
                type: "x"
              };
              var f = b.options.chart;
              f && f.panning && (f.panning = d);
              var h = d.type,
                  k;
              R(this, "pan", {
                originalEvent: a
              }, function () {
                c && c.forEach(function (a) {
                  a.setState();
                });
                var d = b.xAxis;
                "xy" === h ? d = d.concat(b.yAxis) : "y" === h && (d = b.yAxis);
                var f = {};
                d.forEach(function (d) {
                  if (d.options.panningEnabled && !d.options.isInternal) {
                    var c = d.horiz,
                        m = a[c ? "chartX" : "chartY"];
                    c = c ? "mouseDownX" : "mouseDownY";
                    var g = b[c],
                        u = d.minPointOffset || 0,
                        p = d.reversed && !b.inverted || !d.reversed && b.inverted ? -1 : 1,
                        e = d.getExtremes(),
                        t = d.toValue(g - m, !0) + u * p,
                        v = d.toValue(g + d.len - m, !0) - (u * p || d.isXAxis && d.pointRangePadding || 0),
                        A = v < t;
                    p = d.hasVerticalPanning();
                    g = A ? v : t;
                    t = A ? t : v;
                    var l = d.panningState;
                    !p || d.isXAxis || l && !l.isDirty || d.series.forEach(function (a) {
                      var d = a.getProcessedData(!0);
                      d = a.getExtremes(d.yData, !0);
                      l || (l = {
                        startMin: Number.MAX_VALUE,
                        startMax: -Number.MAX_VALUE
                      });
                      da(d.dataMin) && da(d.dataMax) && (l.startMin = Math.min(S(a.options.threshold, Infinity), d.dataMin, l.startMin), l.startMax = Math.max(S(a.options.threshold, -Infinity), d.dataMax, l.startMax));
                    });
                    p = Math.min(S(l && l.startMin, e.dataMin), u ? e.min : d.toValue(d.toPixels(e.min) - d.minPixelPadding));
                    v = Math.max(S(l && l.startMax, e.dataMax), u ? e.max : d.toValue(d.toPixels(e.max) + d.minPixelPadding));
                    d.panningState = l;
                    d.isOrdinal || (u = p - g, 0 < u && (t += u, g = p), u = t - v, 0 < u && (t = v, g -= u), d.series.length && g !== e.min && t !== e.max && g >= p && t <= v && (d.setExtremes(g, t, !1, !1, {
                      trigger: "pan"
                    }), !b.resetZoomButton && g !== p && t !== v && h.match("y") && (b.showResetZoom(), d.displayBtn = !1), k = !0), f[c] = m);
                  }
                });
                V(f, function (a, d) {
                  b[d] = a;
                });
                k && b.redraw(!1);
                A(b.container, {
                  cursor: "move"
                });
              });
            };

            return c;
          }();

          Y(e.prototype, {
            callbacks: [],
            collectionsWithInit: {
              xAxis: [e.prototype.addAxis, [!0]],
              yAxis: [e.prototype.addAxis, [!1]],
              series: [e.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
          });
          "";
          return e;
        });
        N(e, "Core/Legend/LegendSymbol.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.merge,
              G = e.pick,
              H;

          (function (e) {
            e.drawLineMarker = function (e) {
              var I = this.options,
                  y = e.symbolWidth,
                  r = e.symbolHeight,
                  q = r / 2,
                  c = this.chart.renderer,
                  g = this.legendGroup;
              e = e.baseline - Math.round(.3 * e.fontMetrics.b);
              var l = {},
                  x = I.marker;
              this.chart.styledMode || (l = {
                "stroke-width": I.lineWidth || 0
              }, I.dashStyle && (l.dashstyle = I.dashStyle));
              this.legendLine = c.path([["M", 0, e], ["L", y, e]]).addClass("highcharts-graph").attr(l).add(g);
              x && !1 !== x.enabled && y && (I = Math.min(G(x.radius, q), q), 0 === this.symbol.indexOf("url") && (x = n(x, {
                width: r,
                height: r
              }), I = 0), this.legendSymbol = y = c.symbol(this.symbol, y / 2 - I, e - I, 2 * I, 2 * I, x).addClass("highcharts-point").add(g), y.isMarker = !0);
            };

            e.drawRectangle = function (e, n) {
              var y = e.symbolHeight,
                  r = e.options.squareSymbol;
              n.legendSymbol = this.chart.renderer.rect(r ? (e.symbolWidth - y) / 2 : 0, e.baseline - y + 1, r ? y : e.symbolWidth, y, G(e.options.symbolRadius, y / 2)).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(n.legendGroup);
            };
          })(H || (H = {}));

          return H;
        });
        N(e, "Core/Series/SeriesDefaults.js", [], function () {
          return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
              duration: 1E3
            },
            events: {},
            marker: {
              enabledThreshold: 2,
              lineColor: "#ffffff",
              lineWidth: 0,
              radius: 4,
              states: {
                normal: {
                  animation: !0
                },
                hover: {
                  animation: {
                    duration: 50
                  },
                  enabled: !0,
                  radiusPlus: 2,
                  lineWidthPlus: 1
                },
                select: {
                  fillColor: "#cccccc",
                  lineColor: "#000000",
                  lineWidth: 2
                }
              }
            },
            point: {
              events: {}
            },
            dataLabels: {
              animation: {},
              align: "center",
              defer: !0,
              formatter: function formatter() {
                var e = this.series.chart.numberFormatter;
                return "number" !== typeof this.y ? "" : e(this.y, -1);
              },
              padding: 5,
              style: {
                fontSize: "11px",
                fontWeight: "bold",
                color: "contrast",
                textOutline: "1px contrast"
              },
              verticalAlign: "bottom",
              x: 0,
              y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                lineWidthPlus: 1,
                marker: {},
                halo: {
                  size: 10,
                  opacity: .25
                }
              },
              select: {
                animation: {
                  duration: 0
                }
              },
              inactive: {
                animation: {
                  duration: 50
                },
                opacity: .2
              }
            },
            stickyTracking: !0,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
          };
        });
        N(e, "Core/Series/Series.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/DefaultOptions.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/Point.js"], e["Core/Series/SeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E, I, y, r, q) {
          var c = e.animObject,
              g = e.setAnimation,
              l = n.defaultOptions,
              x = D.registerEventOptions,
              f = H.hasTouch,
              b = H.svg,
              w = H.win,
              J = y.seriesTypes,
              C = q.addEvent,
              K = q.arrayMax,
              p = q.arrayMin,
              m = q.clamp,
              t = q.cleanRecursively,
              a = q.correctFloat,
              z = q.defined,
              d = q.erase,
              F = q.error,
              k = q.extend,
              h = q.find,
              L = q.fireEvent,
              P = q.getNestedProperty,
              u = q.isArray,
              A = q.isNumber,
              O = q.isString,
              G = q.merge,
              v = q.objectEach,
              M = q.pick,
              Y = q.removeEvent,
              ba = q.splat,
              R = q.syncTimeout;

          e = function () {
            function e() {
              this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }

            e.prototype.init = function (a, d) {
              L(this, "init", {
                options: d
              });
              var b = this,
                  c = a.series;
              this.eventsToUnbind = [];
              b.chart = a;
              b.options = b.setOptions(d);
              d = b.options;
              b.linkedSeries = [];
              b.bindAxes();
              k(b, {
                name: d.name,
                state: "",
                visible: !1 !== d.visible,
                selected: !0 === d.selected
              });
              x(this, d);
              var f = d.events;
              if (f && f.click || d.point && d.point.events && d.point.events.click || d.allowPointSelect) a.runTrackerClick = !0;
              b.getColor();
              b.getSymbol();
              b.parallelArrays.forEach(function (a) {
                b[a + "Data"] || (b[a + "Data"] = []);
              });
              b.isCartesian && (a.hasCartesianSeries = !0);
              var h;
              c.length && (h = c[c.length - 1]);
              b._i = M(h && h._i, -1) + 1;
              b.opacity = b.options.opacity;
              a.orderSeries(this.insert(c));
              d.dataSorting && d.dataSorting.enabled ? b.setDataSortingOptions() : b.points || b.data || b.setData(d.data, !1);
              L(this, "afterInit");
            };

            e.prototype.is = function (a) {
              return J[a] && this instanceof J[a];
            };

            e.prototype.insert = function (a) {
              var d = this.options.index,
                  b;

              if (A(d)) {
                for (b = a.length; b--;) {
                  if (d >= M(a[b].options.index, a[b]._i)) {
                    a.splice(b + 1, 0, this);
                    break;
                  }
                }

                -1 === b && a.unshift(this);
                b += 1;
              } else a.push(this);

              return M(b, a.length - 1);
            };

            e.prototype.bindAxes = function () {
              var a = this,
                  d = a.options,
                  b = a.chart,
                  c;
              L(this, "bindAxes", null, function () {
                (a.axisTypes || []).forEach(function (f) {
                  var h = 0;
                  b[f].forEach(function (b) {
                    c = b.options;
                    if (d[f] === h && !c.isInternal || "undefined" !== typeof d[f] && d[f] === c.id || "undefined" === typeof d[f] && 0 === c.index) a.insert(b.series), a[f] = b, b.isDirty = !0;
                    c.isInternal || h++;
                  });
                  a[f] || a.optionalAxis === f || F(18, !0, b);
                });
              });
              L(this, "afterBindAxes");
            };

            e.prototype.updateParallelArrays = function (a, d) {
              var b = a.series,
                  c = arguments,
                  f = A(d) ? function (c) {
                var f = "y" === c && b.toYData ? b.toYData(a) : a[c];
                b[c + "Data"][d] = f;
              } : function (a) {
                Array.prototype[d].apply(b[a + "Data"], Array.prototype.slice.call(c, 2));
              };
              b.parallelArrays.forEach(f);
            };

            e.prototype.hasData = function () {
              return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };

            e.prototype.autoIncrement = function (a) {
              var d = this.options,
                  b = d.pointIntervalUnit,
                  c = d.relativeXValue,
                  f = this.chart.time,
                  h = this.xIncrement,
                  k;
              h = M(h, d.pointStart, 0);
              this.pointInterval = k = M(this.pointInterval, d.pointInterval, 1);
              c && A(a) && (k *= a);
              b && (d = new f.Date(h), "day" === b ? f.set("Date", d, f.get("Date", d) + k) : "month" === b ? f.set("Month", d, f.get("Month", d) + k) : "year" === b && f.set("FullYear", d, f.get("FullYear", d) + k), k = d.getTime() - h);
              if (c && A(a)) return h + k;
              this.xIncrement = h + k;
              return h;
            };

            e.prototype.setDataSortingOptions = function () {
              var a = this.options;
              k(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1
              });
              z(a.pointRange) || (a.pointRange = 1);
            };

            e.prototype.setOptions = function (a) {
              var d = this.chart,
                  b = d.options,
                  c = b.plotOptions,
                  f = d.userOptions || {};
              a = G(a);
              d = d.styledMode;
              var h = {
                plotOptions: c,
                userOptions: a
              };
              L(this, "setOptions", h);
              var k = h.plotOptions[this.type],
                  m = f.plotOptions || {};
              this.userOptions = h.userOptions;
              f = G(k, c.series, f.plotOptions && f.plotOptions[this.type], a);
              this.tooltipOptions = G(l.tooltip, l.plotOptions.series && l.plotOptions.series.tooltip, l.plotOptions[this.type].tooltip, b.tooltip.userOptions, c.series && c.series.tooltip, c[this.type].tooltip, a.tooltip);
              this.stickyTracking = M(a.stickyTracking, m[this.type] && m[this.type].stickyTracking, m.series && m.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);
              null === k.marker && delete f.marker;
              this.zoneAxis = f.zoneAxis;
              c = this.zones = (f.zones || []).slice();
              !f.negativeColor && !f.negativeFillColor || f.zones || (b = {
                value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,
                className: "highcharts-negative"
              }, d || (b.color = f.negativeColor, b.fillColor = f.negativeFillColor), c.push(b));
              c.length && z(c[c.length - 1].value) && c.push(d ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
              L(this, "afterSetOptions", {
                options: f
              });
              return f;
            };

            e.prototype.getName = function () {
              return M(this.options.name, "Series " + (this.index + 1));
            };

            e.prototype.getCyclic = function (a, d, b) {
              var c = this.chart,
                  f = this.userOptions,
                  h = a + "Index",
                  k = a + "Counter",
                  m = b ? b.length : M(c.options.chart[a + "Count"], c[a + "Count"]);

              if (!d) {
                var g = M(f[h], f["_" + h]);
                z(g) || (c.series.length || (c[k] = 0), f["_" + h] = g = c[k] % m, c[k] += 1);
                b && (d = b[g]);
              }

              "undefined" !== typeof g && (this[h] = g);
              this[a] = d;
            };

            e.prototype.getColor = function () {
              this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || l.plotOptions[this.type].color, this.chart.options.colors);
            };

            e.prototype.getPointsCollection = function () {
              return (this.hasGroupedData ? this.points : this.data) || [];
            };

            e.prototype.getSymbol = function () {
              this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };

            e.prototype.findPointIndex = function (a, d) {
              var b = a.id,
                  c = a.x,
                  f = this.points,
                  k = this.options.dataSorting,
                  m,
                  g;
              if (b) k = this.chart.get(b), k instanceof E && (m = k);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (m = function m(d) {
                return !d.touched && d.index === a.index;
              }, k && k.matchByName ? m = function m(d) {
                return !d.touched && d.name === a.name;
              } : this.options.relativeXValue && (m = function m(d) {
                return !d.touched && d.options.x === a.x;
              }), m = h(f, m), !m) return;

              if (m) {
                var e = m && m.index;
                "undefined" !== typeof e && (g = !0);
              }

              "undefined" === typeof e && A(c) && (e = this.xData.indexOf(c, d));
              -1 !== e && "undefined" !== typeof e && this.cropped && (e = e >= this.cropStart ? e - this.cropStart : e);
              !g && A(e) && f[e] && f[e].touched && (e = void 0);
              return e;
            };

            e.prototype.updateData = function (a, d) {
              var b = this.options,
                  c = b.dataSorting,
                  f = this.points,
                  h = [],
                  k = this.requireSorting,
                  m = a.length === f.length,
                  g,
                  e,
                  u,
                  p = !0;
              this.xIncrement = null;
              a.forEach(function (a, d) {
                var e = z(a) && this.pointClass.prototype.optionsToObject.call({
                  series: this
                }, a) || {},
                    p = e.x;

                if (e.id || A(p)) {
                  if (e = this.findPointIndex(e, u), -1 === e || "undefined" === typeof e ? h.push(a) : f[e] && a !== b.data[e] ? (f[e].update(a, !1, null, !1), f[e].touched = !0, k && (u = e + 1)) : f[e] && (f[e].touched = !0), !m || d !== e || c && c.enabled || this.hasDerivedData) g = !0;
                } else h.push(a);
              }, this);
              if (g) for (a = f.length; a--;) {
                (e = f[a]) && !e.touched && e.remove && e.remove(!1, d);
              } else !m || c && c.enabled ? p = !1 : (a.forEach(function (a, d) {
                a !== f[d].y && f[d].update && f[d].update(a, !1, null, !1);
              }), h.length = 0);
              f.forEach(function (a) {
                a && (a.touched = !1);
              });
              if (!p) return !1;
              h.forEach(function (a) {
                this.addPoint(a, !1, null, null, !1);
              }, this);
              null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = K(this.xData), this.autoIncrement());
              return !0;
            };

            e.prototype.setData = function (a, d, b, c) {
              var f = this,
                  h = f.points,
                  k = h && h.length || 0,
                  m = f.options,
                  g = f.chart,
                  e = m.dataSorting,
                  p = f.xAxis,
                  t = m.turboThreshold,
                  v = this.xData,
                  l = this.yData,
                  w = f.pointArrayMap;
              w = w && w.length;
              var z = m.keys,
                  q,
                  r = 0,
                  x = 1,
                  C = null;

              if (!g.options.chart.allowMutatingData) {
                m.data && delete f.options.data;
                f.userOptions.data && delete f.userOptions.data;
                var L = G(!0, a);
              }

              a = L || a || [];
              L = a.length;
              d = M(d, !0);
              e && e.enabled && (a = this.sortData(a));
              g.options.chart.allowMutatingData && !1 !== c && L && k && !f.cropped && !f.hasGroupedData && f.visible && !f.isSeriesBoosting && (q = this.updateData(a, b));

              if (!q) {
                f.xIncrement = null;
                f.colorCounter = 0;
                this.parallelArrays.forEach(function (a) {
                  f[a + "Data"].length = 0;
                });
                if (t && L > t) {
                  if (C = f.getFirstValidPoint(a), A(C)) for (b = 0; b < L; b++) {
                    v[b] = this.autoIncrement(), l[b] = a[b];
                  } else if (u(C)) {
                    if (w) {
                      if (C.length === w) for (b = 0; b < L; b++) {
                        v[b] = this.autoIncrement(), l[b] = a[b];
                      } else for (b = 0; b < L; b++) {
                        c = a[b], v[b] = c[0], l[b] = c.slice(1, w + 1);
                      }
                    } else if (z && (r = z.indexOf("x"), x = z.indexOf("y"), r = 0 <= r ? r : 0, x = 0 <= x ? x : 1), 1 === C.length && (x = 0), r === x) for (b = 0; b < L; b++) {
                      v[b] = this.autoIncrement(), l[b] = a[b][x];
                    } else for (b = 0; b < L; b++) {
                      c = a[b], v[b] = c[r], l[b] = c[x];
                    }
                  } else F(12, !1, g);
                } else for (b = 0; b < L; b++) {
                  "undefined" !== typeof a[b] && (c = {
                    series: f
                  }, f.pointClass.prototype.applyOptions.apply(c, [a[b]]), f.updateParallelArrays(c, b));
                }
                l && O(l[0]) && F(14, !0, g);
                f.data = [];
                f.options.data = f.userOptions.data = a;

                for (b = k; b--;) {
                  h[b] && h[b].destroy && h[b].destroy();
                }

                p && (p.minRange = p.userMinRange);
                f.isDirty = g.isDirtyBox = !0;
                f.isDirtyData = !!h;
                b = !1;
              }

              "point" === m.legendType && (this.processData(), this.generatePoints());
              d && g.redraw(b);
            };

            e.prototype.sortData = function (a) {
              var d = this,
                  b = d.options.dataSorting.sortKey || "y",
                  c = function c(a, d) {
                return z(d) && a.pointClass.prototype.optionsToObject.call({
                  series: a
                }, d) || {};
              };

              a.forEach(function (b, f) {
                a[f] = c(d, b);
                a[f].index = f;
              }, this);
              a.concat().sort(function (a, d) {
                a = P(b, a);
                d = P(b, d);
                return d < a ? -1 : d > a ? 1 : 0;
              }).forEach(function (a, d) {
                a.x = d;
              }, this);
              d.linkedSeries && d.linkedSeries.forEach(function (d) {
                var b = d.options,
                    f = b.data;
                b.dataSorting && b.dataSorting.enabled || !f || (f.forEach(function (b, h) {
                  f[h] = c(d, b);
                  a[h] && (f[h].x = a[h].x, f[h].index = h);
                }), d.setData(f, !1));
              });
              return a;
            };

            e.prototype.getProcessedData = function (a) {
              var d = this.xAxis,
                  b = this.options,
                  c = b.cropThreshold,
                  f = a || this.getExtremesFromAll || b.getExtremesFromAll,
                  h = this.isCartesian;
              a = d && d.val2lin;
              b = !(!d || !d.logarithmic);
              var k = 0,
                  m = this.xData,
                  g = this.yData,
                  e = this.requireSorting;
              var p = !1;
              var u = m.length;

              if (d) {
                p = d.getExtremes();
                var t = p.min;
                var v = p.max;
                p = !(!d.categories || d.names.length);
              }

              if (h && this.sorted && !f && (!c || u > c || this.forceCrop)) if (m[u - 1] < t || m[0] > v) m = [], g = [];else if (this.yData && (m[0] < t || m[u - 1] > v)) {
                var l = this.cropData(this.xData, this.yData, t, v);
                m = l.xData;
                g = l.yData;
                k = l.start;
                l = !0;
              }

              for (c = m.length || 1; --c;) {
                if (d = b ? a(m[c]) - a(m[c - 1]) : m[c] - m[c - 1], 0 < d && ("undefined" === typeof A || d < A)) var A = d;else 0 > d && e && !p && (F(15, !1, this.chart), e = !1);
              }

              return {
                xData: m,
                yData: g,
                cropped: l,
                cropStart: k,
                closestPointRange: A
              };
            };

            e.prototype.processData = function (a) {
              var d = this.xAxis;
              if (this.isCartesian && !this.isDirty && !d.isDirty && !this.yAxis.isDirty && !a) return !1;
              a = this.getProcessedData();
              this.cropped = a.cropped;
              this.cropStart = a.cropStart;
              this.processedXData = a.xData;
              this.processedYData = a.yData;
              this.closestPointRange = this.basePointRange = a.closestPointRange;
              L(this, "afterProcessData");
            };

            e.prototype.cropData = function (a, d, b, c, f) {
              var h = a.length,
                  k,
                  m = 0,
                  g = h;
              f = M(f, this.cropShoulder);

              for (k = 0; k < h; k++) {
                if (a[k] >= b) {
                  m = Math.max(0, k - f);
                  break;
                }
              }

              for (b = k; b < h; b++) {
                if (a[b] > c) {
                  g = b + f;
                  break;
                }
              }

              return {
                xData: a.slice(m, g),
                yData: d.slice(m, g),
                start: m,
                end: g
              };
            };

            e.prototype.generatePoints = function () {
              var a = this.options,
                  d = this.processedData || a.data,
                  b = this.processedXData,
                  c = this.processedYData,
                  f = this.pointClass,
                  h = b.length,
                  m = this.cropStart || 0,
                  g = this.hasGroupedData,
                  e = a.keys,
                  p = [];
              a = a.dataGrouping && a.dataGrouping.groupAll ? m : 0;
              var u,
                  t,
                  v = this.data;

              if (!v && !g) {
                var l = [];
                l.length = d.length;
                v = this.data = l;
              }

              e && g && (this.options.keys = !1);

              for (t = 0; t < h; t++) {
                l = m + t;

                if (g) {
                  var A = new f().init(this, [b[t]].concat(ba(c[t])));
                  A.dataGroup = this.groupMap[a + t];
                  A.dataGroup.options && (A.options = A.dataGroup.options, k(A, A.dataGroup.options), delete A.dataLabels);
                } else (A = v[l]) || "undefined" === typeof d[l] || (v[l] = A = new f().init(this, d[l], b[t]));

                A && (A.index = g ? a + t : l, p[t] = A);
              }

              this.options.keys = e;
              if (v && (h !== (u = v.length) || g)) for (t = 0; t < u; t++) {
                t !== m || g || (t += h), v[t] && (v[t].destroyElements(), v[t].plotX = void 0);
              }
              this.data = v;
              this.points = p;
              L(this, "afterGeneratePoints");
            };

            e.prototype.getXExtremes = function (a) {
              return {
                min: p(a),
                max: K(a)
              };
            };

            e.prototype.getExtremes = function (a, d) {
              var b = this.xAxis,
                  c = this.yAxis,
                  f = this.processedXData || this.xData,
                  h = [],
                  k = this.requireSorting ? this.cropShoulder : 0;
              c = c ? c.positiveValuesOnly : !1;
              var m,
                  g = 0,
                  e = 0,
                  t = 0;
              a = a || this.stackedYData || this.processedYData || [];
              var v = a.length;

              if (b) {
                var l = b.getExtremes();
                g = l.min;
                e = l.max;
              }

              for (m = 0; m < v; m++) {
                var w = f[m];
                l = a[m];
                var z = (A(l) || u(l)) && (l.length || 0 < l || !c);
                w = d || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !b || (f[m + k] || w) >= g && (f[m - k] || w) <= e;
                if (z && w) if (z = l.length) for (; z--;) {
                  A(l[z]) && (h[t++] = l[z]);
                } else h[t++] = l;
              }

              a = {
                activeYData: h,
                dataMin: p(h),
                dataMax: K(h)
              };
              L(this, "afterGetExtremes", {
                dataExtremes: a
              });
              return a;
            };

            e.prototype.applyExtremes = function () {
              var a = this.getExtremes();
              this.dataMin = a.dataMin;
              this.dataMax = a.dataMax;
              return a;
            };

            e.prototype.getFirstValidPoint = function (a) {
              for (var d = a.length, b = 0, c = null; null === c && b < d;) {
                c = a[b], b++;
              }

              return c;
            };

            e.prototype.translate = function () {
              this.processedXData || this.processData();
              this.generatePoints();
              var d = this.options,
                  b = d.stacking,
                  c = this.xAxis,
                  f = c.categories,
                  h = this.enabledDataSorting,
                  k = this.yAxis,
                  g = this.points,
                  e = g.length,
                  p = this.pointPlacementToXValue(),
                  t = !!p,
                  l = d.threshold,
                  v = d.startFromThreshold ? l : 0,
                  w = this.zoneAxis || "y",
                  q,
                  r,
                  x = Number.MAX_VALUE;

              for (q = 0; q < e; q++) {
                var C = g[q],
                    J = C.x,
                    n = void 0,
                    P = void 0,
                    F = C.y,
                    K = C.low,
                    O = b && k.stacking && k.stacking.stacks[(this.negStacks && F < (v ? 0 : l) ? "-" : "") + this.stackKey];
                if (k.positiveValuesOnly && !k.validatePositiveValue(F) || c.positiveValuesOnly && !c.validatePositiveValue(J)) C.isNull = !0;
                C.plotX = r = a(m(c.translate(J, 0, 0, 0, 1, p, "flags" === this.type), -1E5, 1E5));

                if (b && this.visible && O && O[J]) {
                  var y = this.getStackIndicator(y, J, this.index);
                  C.isNull || (n = O[J], P = n.points[y.key]);
                }

                u(P) && (K = P[0], F = P[1], K === v && y.key === O[J].base && (K = M(A(l) && l, k.min)), k.positiveValuesOnly && 0 >= K && (K = null), C.total = C.stackTotal = n.total, C.percentage = n.total && C.y / n.total * 100, C.stackY = F, this.irregularWidths || n.setOffset(this.pointXOffset || 0, this.barW || 0));
                C.yBottom = z(K) ? m(k.translate(K, 0, 1, 0, 1), -1E5, 1E5) : null;
                this.dataModify && (F = this.dataModify.modifyValue(F, q));
                C.plotY = void 0;
                A(F) && (n = k.translate(F, !1, !0, !1, !0), "undefined" !== typeof n && (C.plotY = m(n, -1E5, 1E5)));
                C.isInside = this.isPointInside(C);
                C.clientX = t ? a(c.translate(J, 0, 0, 0, 1, p)) : r;
                C.negative = C[w] < (d[w + "Threshold"] || l || 0);
                C.category = M(f && f[C.x], C.x);

                if (!C.isNull && !1 !== C.visible) {
                  "undefined" !== typeof G && (x = Math.min(x, Math.abs(r - G)));
                  var G = r;
                }

                C.zone = this.zones.length ? C.getZone() : void 0;
                !C.graphic && this.group && h && (C.isNew = !0);
              }

              this.closestPointRangePx = x;
              L(this, "afterTranslate");
            };

            e.prototype.getValidPoints = function (a, d, b) {
              var c = this.chart;
              return (a || this.points || []).filter(function (a) {
                return d && !c.isInsidePlot(a.plotX, a.plotY, {
                  inverted: c.inverted
                }) ? !1 : !1 !== a.visible && (b || !a.isNull);
              });
            };

            e.prototype.getClipBox = function () {
              var a = this.chart,
                  d = this.xAxis,
                  b = this.yAxis,
                  c = G(a.clipBox);
              d && d.len !== a.plotSizeX && (c.width = d.len);
              b && b.len !== a.plotSizeY && (c.height = b.len);
              return c;
            };

            e.prototype.getSharedClipKey = function () {
              return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
            };

            e.prototype.setClip = function () {
              var a = this.chart,
                  d = this.group,
                  b = this.markerGroup,
                  c = a.sharedClips;
              a = a.renderer;
              var f = this.getClipBox(),
                  h = this.getSharedClipKey(),
                  k = c[h];
              k ? k.animate(f) : c[h] = k = a.clipRect(f);
              d && d.clip(!1 === this.options.clip ? void 0 : k);
              b && b.clip();
            };

            e.prototype.animate = function (a) {
              var d = this.chart,
                  b = this.group,
                  f = this.markerGroup,
                  h = d.inverted,
                  k = c(this.options.animation),
                  m = [this.getSharedClipKey(), k.duration, k.easing, k.defer].join(),
                  g = d.sharedClips[m],
                  e = d.sharedClips[m + "m"];
              if (a && b) k = this.getClipBox(), g ? g.attr("height", k.height) : (k.width = 0, h && (k.x = d.plotHeight), g = d.renderer.clipRect(k), d.sharedClips[m] = g, e = d.renderer.clipRect({
                x: h ? (d.plotSizeX || 0) + 99 : -99,
                y: h ? -d.plotLeft : -d.plotTop,
                width: 99,
                height: h ? d.chartWidth : d.chartHeight
              }), d.sharedClips[m + "m"] = e), b.clip(g), f && f.clip(e);else if (g && !g.hasClass("highcharts-animating")) {
                d = this.getClipBox();
                var p = k.step;
                f && f.element.childNodes.length && (k.step = function (a, d) {
                  p && p.apply(d, arguments);
                  e && e.element && e.attr(d.prop, "width" === d.prop ? a + 99 : a);
                });
                g.addClass("highcharts-animating").animate(d, k);
              }
            };

            e.prototype.afterAnimate = function () {
              var a = this;
              this.setClip();
              v(this.chart.sharedClips, function (d, b, c) {
                d && !a.chart.container.querySelector('[clip-path="url(#'.concat(d.id, ')"]')) && (d.destroy(), delete c[b]);
              });
              this.finishedAnimating = !0;
              L(this, "afterAnimate");
            };

            e.prototype.drawPoints = function () {
              var a = this.points,
                  d = this.chart,
                  b = this.options.marker,
                  c = this[this.specialGroup] || this.markerGroup,
                  f = this.xAxis,
                  h = M(b.enabled, !f || f.isRadial ? !0 : null, this.closestPointRangePx >= b.enabledThreshold * b.radius),
                  k,
                  m;
              if (!1 !== b.enabled || this._hasPointMarkers) for (k = 0; k < a.length; k++) {
                var g = a[k];
                var e = (m = g.graphic) ? "animate" : "attr";
                var p = g.marker || {};
                var u = !!g.marker;

                if ((h && "undefined" === typeof p.enabled || p.enabled) && !g.isNull && !1 !== g.visible) {
                  var t = M(p.symbol, this.symbol, "rect");
                  var l = this.markerAttribs(g, g.selected && "select");
                  this.enabledDataSorting && (g.startXPos = f.reversed ? -(l.width || 0) : f.width);
                  var v = !1 !== g.isInside;
                  m ? m[v ? "show" : "hide"](v).animate(l) : v && (0 < (l.width || 0) || g.hasImage) && (g.graphic = m = d.renderer.symbol(t, l.x, l.y, l.width, l.height, u ? p : b).add(c), this.enabledDataSorting && d.hasRendered && (m.attr({
                    x: g.startXPos
                  }), e = "animate"));
                  m && "animate" === e && m[v ? "show" : "hide"](v).animate(l);
                  if (m && !d.styledMode) m[e](this.pointAttribs(g, g.selected && "select"));
                  m && m.addClass(g.getClassName(), !0);
                } else m && (g.graphic = m.destroy());
              }
            };

            e.prototype.markerAttribs = function (a, d) {
              var b = this.options,
                  c = b.marker,
                  f = a.marker || {},
                  h = f.symbol || c.symbol,
                  k = M(f.radius, c && c.radius);
              d && (c = c.states[d], d = f.states && f.states[d], k = M(d && d.radius, c && c.radius, k && k + (c && c.radiusPlus || 0)));
              a.hasImage = h && 0 === h.indexOf("url");
              a.hasImage && (k = 0);
              a = A(k) ? {
                x: b.crisp ? Math.floor(a.plotX - k) : a.plotX - k,
                y: a.plotY - k
              } : {};
              k && (a.width = a.height = 2 * k);
              return a;
            };

            e.prototype.pointAttribs = function (a, d) {
              var b = this.options.marker,
                  c = a && a.options,
                  f = c && c.marker || {},
                  h = c && c.color,
                  k = a && a.color,
                  m = a && a.zone && a.zone.color,
                  g = this.color;
              a = M(f.lineWidth, b.lineWidth);
              c = 1;
              g = h || m || k || g;
              h = f.fillColor || b.fillColor || g;
              k = f.lineColor || b.lineColor || g;
              d = d || "normal";
              b = b.states[d] || {};
              d = f.states && f.states[d] || {};
              a = M(d.lineWidth, b.lineWidth, a + M(d.lineWidthPlus, b.lineWidthPlus, 0));
              h = d.fillColor || b.fillColor || h;
              k = d.lineColor || b.lineColor || k;
              c = M(d.opacity, b.opacity, c);
              return {
                stroke: k,
                "stroke-width": a,
                fill: h,
                opacity: c
              };
            };

            e.prototype.destroy = function (a) {
              var b = this,
                  c = b.chart,
                  f = /AppleWebKit\/533/.test(w.navigator.userAgent),
                  h = b.data || [],
                  k,
                  m,
                  g,
                  e;
              L(b, "destroy", {
                keepEventsForUpdate: a
              });
              this.removeEvents(a);
              (b.axisTypes || []).forEach(function (a) {
                (e = b[a]) && e.series && (d(e.series, b), e.isDirty = e.forceRedraw = !0);
              });
              b.legendItem && b.chart.legend.destroyItem(b);

              for (m = h.length; m--;) {
                (g = h[m]) && g.destroy && g.destroy();
              }

              b.clips && b.clips.forEach(function (a) {
                return a.destroy();
              });
              q.clearTimeout(b.animationTimeout);
              v(b, function (a, d) {
                a instanceof r && !a.survive && (k = f && "group" === d ? "hide" : "destroy", a[k]());
              });
              c.hoverSeries === b && (c.hoverSeries = void 0);
              d(c.series, b);
              c.orderSeries();
              v(b, function (d, c) {
                a && "hcEvents" === c || delete b[c];
              });
            };

            e.prototype.applyZones = function () {
              var a = this,
                  d = this.chart,
                  b = d.renderer,
                  c = this.zones,
                  f = this.clips || [],
                  h = this.graph,
                  k = this.area,
                  g = Math.max(d.chartWidth, d.chartHeight),
                  e = this[(this.zoneAxis || "y") + "Axis"],
                  p = d.inverted,
                  u,
                  t,
                  l,
                  v,
                  A,
                  w,
                  z,
                  q,
                  r = !1;

              if (c.length && (h || k) && e && "undefined" !== typeof e.min) {
                var x = e.reversed;
                var C = e.horiz;
                h && !this.showLine && h.hide();
                k && k.hide();
                var L = e.getExtremes();
                c.forEach(function (c, J) {
                  u = x ? C ? d.plotWidth : 0 : C ? 0 : e.toPixels(L.min) || 0;
                  u = m(M(t, u), 0, g);
                  t = m(Math.round(e.toPixels(M(c.value, L.max), !0) || 0), 0, g);
                  r && (u = t = e.toPixels(L.max));
                  v = Math.abs(u - t);
                  A = Math.min(u, t);
                  w = Math.max(u, t);
                  e.isXAxis ? (l = {
                    x: p ? w : A,
                    y: 0,
                    width: v,
                    height: g
                  }, C || (l.x = d.plotHeight - l.x)) : (l = {
                    x: 0,
                    y: p ? w : A,
                    width: g,
                    height: v
                  }, C && (l.y = d.plotWidth - l.y));
                  p && b.isVML && (l = e.isXAxis ? {
                    x: 0,
                    y: x ? A : w,
                    height: l.width,
                    width: d.chartWidth
                  } : {
                    x: l.y - d.plotLeft - d.spacingBox.x,
                    y: 0,
                    width: l.height,
                    height: d.chartHeight
                  });
                  f[J] ? f[J].animate(l) : f[J] = b.clipRect(l);
                  z = a["zone-area-" + J];
                  q = a["zone-graph-" + J];
                  h && q && q.clip(f[J]);
                  k && z && z.clip(f[J]);
                  r = c.value > L.max;
                  a.resetZones && 0 === t && (t = void 0);
                });
                this.clips = f;
              } else a.visible && (h && h.show(), k && k.show());
            };

            e.prototype.invertGroups = function (a) {
              function d() {
                ["group", "markerGroup"].forEach(function (d) {
                  b[d] && (c.renderer.isVML && b[d].attr({
                    width: b.yAxis.len,
                    height: b.xAxis.len
                  }), b[d].width = b.yAxis.len, b[d].height = b.xAxis.len, b[d].invert(b.isRadialSeries ? !1 : a));
                });
              }

              var b = this,
                  c = b.chart;
              b.xAxis && (b.eventsToUnbind.push(C(c, "resize", d)), d(), b.invertGroups = d);
            };

            e.prototype.plotGroup = function (a, d, b, c, f) {
              var h = this[a],
                  k = !h;
              b = {
                visibility: b,
                zIndex: c || .1
              };
              "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (b.opacity = this.opacity);
              k && (this[a] = h = this.chart.renderer.g().add(f));
              h.addClass("highcharts-" + d + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (z(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (h.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
              h.attr(b)[k ? "attr" : "animate"](this.getPlotBox());
              return h;
            };

            e.prototype.getPlotBox = function () {
              var a = this.chart,
                  d = this.xAxis,
                  b = this.yAxis;
              a.inverted && (d = b, b = this.xAxis);
              return {
                translateX: d ? d.left : a.plotLeft,
                translateY: b ? b.top : a.plotTop,
                scaleX: 1,
                scaleY: 1
              };
            };

            e.prototype.removeEvents = function (a) {
              a || Y(this);
              this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
                a();
              }), this.eventsToUnbind.length = 0);
            };

            e.prototype.render = function () {
              var a = this,
                  d = a.chart,
                  b = a.options,
                  f = c(b.animation),
                  h = a.visible ? "inherit" : "hidden",
                  k = b.zIndex,
                  m = a.hasRendered,
                  g = d.seriesGroup,
                  e = d.inverted;
              d = !a.finishedAnimating && d.renderer.isSVG ? f.duration : 0;
              L(this, "render");
              var p = a.plotGroup("group", "series", h, k, g);
              a.markerGroup = a.plotGroup("markerGroup", "markers", h, k, g);
              !1 !== b.clip && a.setClip();
              a.animate && d && a.animate(!0);
              p.inverted = M(a.invertible, a.isCartesian) ? e : !1;
              a.drawGraph && (a.drawGraph(), a.applyZones());
              a.visible && a.drawPoints();
              a.drawDataLabels && a.drawDataLabels();
              a.redrawPoints && a.redrawPoints();
              a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
              a.invertGroups(e);
              a.animate && d && a.animate();
              m || (d && f.defer && (d += f.defer), a.animationTimeout = R(function () {
                a.afterAnimate();
              }, d || 0));
              a.isDirty = !1;
              a.hasRendered = !0;
              L(a, "afterRender");
            };

            e.prototype.redraw = function () {
              var a = this.chart,
                  d = this.isDirty || this.isDirtyData,
                  b = this.group,
                  c = this.xAxis,
                  f = this.yAxis;
              b && (a.inverted && b.attr({
                width: a.plotWidth,
                height: a.plotHeight
              }), b.animate({
                translateX: M(c && c.left, a.plotLeft),
                translateY: M(f && f.top, a.plotTop)
              }));
              this.translate();
              this.render();
              d && delete this.kdTree;
            };

            e.prototype.searchPoint = function (a, d) {
              var b = this.xAxis,
                  c = this.yAxis,
                  f = this.chart.inverted;
              return this.searchKDTree({
                clientX: f ? b.len - a.chartY + b.pos : a.chartX - b.pos,
                plotY: f ? c.len - a.chartX + c.pos : a.chartY - c.pos
              }, d, a);
            };

            e.prototype.buildKDTree = function (a) {
              function d(a, c, f) {
                var h = a && a.length;

                if (h) {
                  var k = b.kdAxisArray[c % f];
                  a.sort(function (a, d) {
                    return a[k] - d[k];
                  });
                  h = Math.floor(h / 2);
                  return {
                    point: a[h],
                    left: d(a.slice(0, h), c + 1, f),
                    right: d(a.slice(h + 1), c + 1, f)
                  };
                }
              }

              this.buildingKdTree = !0;
              var b = this,
                  c = -1 < b.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete b.kdTree;
              R(function () {
                b.kdTree = d(b.getValidPoints(null, !b.directTouch), c, c);
                b.buildingKdTree = !1;
              }, b.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
            };

            e.prototype.searchKDTree = function (a, d, b) {
              function c(a, d, b, g) {
                var e = d.point,
                    p = f.kdAxisArray[b % g],
                    u = e,
                    t = z(a[h]) && z(e[h]) ? Math.pow(a[h] - e[h], 2) : null;
                var l = z(a[k]) && z(e[k]) ? Math.pow(a[k] - e[k], 2) : null;
                l = (t || 0) + (l || 0);
                e.dist = z(l) ? Math.sqrt(l) : Number.MAX_VALUE;
                e.distX = z(t) ? Math.sqrt(t) : Number.MAX_VALUE;
                p = a[p] - e[p];
                l = 0 > p ? "left" : "right";
                t = 0 > p ? "right" : "left";
                d[l] && (l = c(a, d[l], b + 1, g), u = l[m] < u[m] ? l : e);
                d[t] && Math.sqrt(p * p) < u[m] && (a = c(a, d[t], b + 1, g), u = a[m] < u[m] ? a : u);
                return u;
              }

              var f = this,
                  h = this.kdAxisArray[0],
                  k = this.kdAxisArray[1],
                  m = d ? "distX" : "dist";
              d = -1 < f.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              this.kdTree || this.buildingKdTree || this.buildKDTree(b);
              if (this.kdTree) return c(a, this.kdTree, d, d);
            };

            e.prototype.pointPlacementToXValue = function () {
              var a = this.options,
                  d = a.pointRange,
                  b = this.xAxis;
              a = a.pointPlacement;
              "between" === a && (a = b.reversed ? -.5 : .5);
              return A(a) ? a * (d || b.pointRange) : 0;
            };

            e.prototype.isPointInside = function (a) {
              var d = this.chart,
                  b = this.xAxis,
                  c = this.yAxis;
              return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= (c ? c.len : d.plotHeight) && 0 <= a.plotX && a.plotX <= (b ? b.len : d.plotWidth);
            };

            e.prototype.drawTracker = function () {
              var a = this,
                  d = a.options,
                  c = d.trackByArea,
                  h = [].concat(c ? a.areaPath : a.graphPath),
                  k = a.chart,
                  m = k.pointer,
                  g = k.renderer,
                  e = k.options.tooltip.snap,
                  p = a.tracker,
                  u = function u(d) {
                if (k.hoverSeries !== a) a.onMouseOver();
              },
                  t = "rgba(192,192,192," + (b ? .0001 : .002) + ")";

              p ? p.attr({
                d: h
              }) : a.graph && (a.tracker = g.path(h).attr({
                visibility: a.visible ? "inherit" : "hidden",
                zIndex: 2
              }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), k.styledMode || a.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: t,
                fill: c ? t : "none",
                "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * e)
              }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function (a) {
                if (a && (a.addClass("highcharts-tracker").on("mouseover", u).on("mouseout", function (a) {
                  m.onTrackerMouseOut(a);
                }), d.cursor && !k.styledMode && a.css({
                  cursor: d.cursor
                }), f)) a.on("touchstart", u);
              }));
              L(this, "afterDrawTracker");
            };

            e.prototype.addPoint = function (a, d, b, c, f) {
              var h = this.options,
                  k = this.data,
                  m = this.chart,
                  g = this.xAxis;
              g = g && g.hasNames && g.names;
              var e = h.data,
                  p = this.xData,
                  u;
              d = M(d, !0);
              var t = {
                series: this
              };
              this.pointClass.prototype.applyOptions.apply(t, [a]);
              var l = t.x;
              var v = p.length;
              if (this.requireSorting && l < p[v - 1]) for (u = !0; v && p[v - 1] > l;) {
                v--;
              }
              this.updateParallelArrays(t, "splice", v, 0, 0);
              this.updateParallelArrays(t, v);
              g && t.name && (g[l] = t.name);
              e.splice(v, 0, a);
              if (u || this.processedData) this.data.splice(v, 0, null), this.processData();
              "point" === h.legendType && this.generatePoints();
              b && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(t, "shift"), e.shift()));
              !1 !== f && L(this, "addPoint", {
                point: t
              });
              this.isDirtyData = this.isDirty = !0;
              d && m.redraw(c);
            };

            e.prototype.removePoint = function (a, d, b) {
              var c = this,
                  f = c.data,
                  h = f[a],
                  k = c.points,
                  m = c.chart,
                  e = function e() {
                k && k.length === f.length && k.splice(a, 1);
                f.splice(a, 1);
                c.options.data.splice(a, 1);
                c.updateParallelArrays(h || {
                  series: c
                }, "splice", a, 1);
                h && h.destroy();
                c.isDirty = !0;
                c.isDirtyData = !0;
                d && m.redraw();
              };

              g(b, m);
              d = M(d, !0);
              h ? h.firePointEvent("remove", null, e) : e();
            };

            e.prototype.remove = function (a, d, b, c) {
              function f() {
                h.destroy(c);
                k.isDirtyLegend = k.isDirtyBox = !0;
                k.linkSeries();
                M(a, !0) && k.redraw(d);
              }

              var h = this,
                  k = h.chart;
              !1 !== b ? L(h, "remove", null, f) : f();
            };

            e.prototype.update = function (a, d) {
              a = t(a, this.userOptions);
              L(this, "update", {
                options: a
              });
              var b = this,
                  c = b.chart,
                  f = b.userOptions,
                  h = b.initialType || b.type,
                  m = c.options.plotOptions,
                  g = J[h].prototype,
                  e = b.finishedAnimating && {
                animation: !1
              },
                  p = {},
                  u,
                  l = ["eventOptions", "navigatorSeries", "baseSeries"],
                  v = a.type || f.type || c.options.chart.type,
                  A = !(this.hasDerivedData || v && v !== this.type || "undefined" !== typeof a.pointStart || "undefined" !== typeof a.pointInterval || "undefined" !== typeof a.relativeXValue || a.joinBy || a.mapData || b.hasOptionChanged("dataGrouping") || b.hasOptionChanged("pointStart") || b.hasOptionChanged("pointInterval") || b.hasOptionChanged("pointIntervalUnit") || b.hasOptionChanged("keys"));
              v = v || h;
              A && (l.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && l.push("area", "graph"), b.parallelArrays.forEach(function (a) {
                l.push(a + "Data");
              }), a.data && (a.dataSorting && k(b.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
              a = G(f, e, {
                index: "undefined" === typeof f.index ? b.index : f.index,
                pointStart: M(m && m.series && m.series.pointStart, f.pointStart, b.xData[0])
              }, !A && {
                data: b.options.data
              }, a);
              A && a.data && (a.data = b.options.data);
              l = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(l);
              l.forEach(function (a) {
                l[a] = b[a];
                delete b[a];
              });
              m = !1;

              if (J[v]) {
                if (m = v !== b.type, b.remove(!1, !1, !1, !0), m) if (Object.setPrototypeOf) Object.setPrototypeOf(b, J[v].prototype);else {
                  e = Object.hasOwnProperty.call(b, "hcEvents") && b.hcEvents;

                  for (u in g) {
                    b[u] = void 0;
                  }

                  k(b, J[v].prototype);
                  e ? b.hcEvents = e : delete b.hcEvents;
                }
              } else F(17, !0, c, {
                missingModuleFor: v
              });

              l.forEach(function (a) {
                b[a] = l[a];
              });
              b.init(c, a);

              if (A && this.points) {
                var w = b.options;
                !1 === w.visible ? (p.graphic = 1, p.dataLabel = 1) : b._hasPointLabels || (a = w.marker, g = w.dataLabels, !a || !1 !== a.enabled && (f.marker && f.marker.symbol) === a.symbol || (p.graphic = 1), g && !1 === g.enabled && (p.dataLabel = 1));
                this.points.forEach(function (a) {
                  a && a.series && (a.resolveColor(), Object.keys(p).length && a.destroyElements(p), !1 === w.showInLegend && a.legendItem && c.legend.destroyItem(a));
                }, this);
              }

              b.initialType = h;
              c.linkSeries();
              m && b.linkedSeries.length && (b.isDirtyData = !0);
              L(this, "afterUpdate");
              M(d, !0) && c.redraw(A ? void 0 : !1);
            };

            e.prototype.setName = function (a) {
              this.name = this.options.name = this.userOptions.name = a;
              this.chart.isDirtyLegend = !0;
            };

            e.prototype.hasOptionChanged = function (a) {
              var d = this.options[a],
                  b = this.chart.options.plotOptions,
                  c = this.userOptions[a];
              return c ? d !== c : d !== M(b && b[this.type] && b[this.type][a], b && b.series && b.series[a], d);
            };

            e.prototype.onMouseOver = function () {
              var a = this.chart,
                  d = a.hoverSeries;
              a.pointer.setHoverChartIndex();
              if (d && d !== this) d.onMouseOut();
              this.options.events.mouseOver && L(this, "mouseOver");
              this.setState("hover");
              a.hoverSeries = this;
            };

            e.prototype.onMouseOut = function () {
              var a = this.options,
                  d = this.chart,
                  b = d.tooltip,
                  c = d.hoverPoint;
              d.hoverSeries = null;
              if (c) c.onMouseOut();
              this && a.events.mouseOut && L(this, "mouseOut");
              !b || this.stickyTracking || b.shared && !this.noSharedTooltip || b.hide();
              d.series.forEach(function (a) {
                a.setState("", !0);
              });
            };

            e.prototype.setState = function (a, d) {
              var b = this,
                  c = b.options,
                  f = b.graph,
                  h = c.inactiveOtherPoints,
                  k = c.states,
                  m = M(k[a || "normal"] && k[a || "normal"].animation, b.chart.options.chart.animation),
                  g = c.lineWidth,
                  e = 0,
                  p = c.opacity;
              a = a || "";

              if (b.state !== a && ([b.group, b.markerGroup, b.dataLabelsGroup].forEach(function (d) {
                d && (b.state && d.removeClass("highcharts-series-" + b.state), a && d.addClass("highcharts-series-" + a));
              }), b.state = a, !b.chart.styledMode)) {
                if (k[a] && !1 === k[a].enabled) return;
                a && (g = k[a].lineWidth || g + (k[a].lineWidthPlus || 0), p = M(k[a].opacity, p));
                if (f && !f.dashstyle) for (c = {
                  "stroke-width": g
                }, f.animate(c, m); b["zone-graph-" + e];) {
                  b["zone-graph-" + e].animate(c, m), e += 1;
                }
                h || [b.group, b.markerGroup, b.dataLabelsGroup, b.labelBySeries].forEach(function (a) {
                  a && a.animate({
                    opacity: p
                  }, m);
                });
              }

              d && h && b.points && b.setAllPointsToState(a || void 0);
            };

            e.prototype.setAllPointsToState = function (a) {
              this.points.forEach(function (d) {
                d.setState && d.setState(a);
              });
            };

            e.prototype.setVisible = function (a, d) {
              var b = this,
                  c = b.chart,
                  f = b.legendItem,
                  h = c.options.chart.ignoreHiddenSeries,
                  k = b.visible,
                  m = (b.visible = a = b.options.visible = b.userOptions.visible = "undefined" === typeof a ? !k : a) ? "show" : "hide";
              ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
                if (b[a]) b[a][m]();
              });
              if (c.hoverSeries === b || (c.hoverPoint && c.hoverPoint.series) === b) b.onMouseOut();
              f && c.legend.colorizeItem(b, a);
              b.isDirty = !0;
              b.options.stacking && c.series.forEach(function (a) {
                a.options.stacking && a.visible && (a.isDirty = !0);
              });
              b.linkedSeries.forEach(function (d) {
                d.setVisible(a, !1);
              });
              h && (c.isDirtyBox = !0);
              L(b, m);
              !1 !== d && c.redraw();
            };

            e.prototype.show = function () {
              this.setVisible(!0);
            };

            e.prototype.hide = function () {
              this.setVisible(!1);
            };

            e.prototype.select = function (a) {
              this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
              this.checkbox && (this.checkbox.checked = a);
              L(this, a ? "select" : "unselect");
            };

            e.prototype.shouldShowTooltip = function (a, d, b) {
              void 0 === b && (b = {});
              b.series = this;
              b.visiblePlotOnly = !0;
              return this.chart.isInsidePlot(a, d, b);
            };

            e.defaultOptions = I;
            return e;
          }();

          k(e.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: B.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: E,
            requireSorting: !0,
            sorted: !0
          });
          y.series = e;
          "";
          "";
          return e;
        });
        N(e, "Extensions/ScrollablePlotArea.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Chart/Chart.js"], e["Core/Series/Series.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E) {
          var G = e.stop,
              y = E.addEvent,
              r = E.createElement,
              q = E.defined,
              c = E.merge,
              g = E.pick;
          y(D, "afterSetChartSize", function (g) {
            var e = this.options.chart.scrollablePlotArea,
                f = e && e.minWidth;
            e = e && e.minHeight;

            if (!this.renderer.forExport) {
              if (f) {
                if (this.scrollablePixelsX = f = Math.max(0, f - this.chartWidth)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox);
                  this.plotBox.width = this.plotWidth += f;
                  this.inverted ? this.clipBox.height += f : this.clipBox.width += f;
                  var b = {
                    1: {
                      name: "right",
                      value: f
                    }
                  };
                }
              } else e && (this.scrollablePixelsY = f = Math.max(0, e - this.chartHeight), q(f) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.height = this.plotHeight += f, this.inverted ? this.clipBox.width += f : this.clipBox.height += f, b = {
                2: {
                  name: "bottom",
                  value: f
                }
              }));

              b && !g.skipAxes && this.axes.forEach(function (c) {
                b[c.side] ? c.getPlotLinePath = function () {
                  var f = b[c.side].name,
                      g = this[f];
                  this[f] = g - b[c.side].value;
                  var e = n.prototype.getPlotLinePath.apply(this, arguments);
                  this[f] = g;
                  return e;
                } : (c.setAxisSize(), c.setAxisTranslation());
              });
            }
          });
          y(D, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });

          D.prototype.setUpScrolling = function () {
            var c = this,
                g = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            this.scrollablePixelsX && (g.overflowX = "auto");
            this.scrollablePixelsY && (g.overflowY = "auto");
            this.scrollingParent = r("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = r("div", {
              className: "highcharts-scrolling"
            }, g, this.scrollingParent);
            y(this.scrollingContainer, "scroll", function () {
              c.pointer && delete c.pointer.chartPosition;
            });
            this.innerContainer = r("div", {
              className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };

          D.prototype.moveFixedElements = function () {
            var c = this.container,
                g = this.fixedRenderer,
                f = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
                b;
            this.scrollablePixelsX && !this.inverted ? b = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? b = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? b = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (b = ".highcharts-yaxis");
            b && f.push("" + b + ":not(.highcharts-radial-axis)", "" + b + "-labels:not(.highcharts-radial-axis-labels)");
            f.forEach(function (b) {
              [].forEach.call(c.querySelectorAll(b), function (b) {
                (b.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(b);
                b.style.pointerEvents = "auto";
              });
            });
          };

          D.prototype.applyFixed = function () {
            var c = !this.fixedDiv,
                e = this.options.chart,
                f = e.scrollablePlotArea,
                b = B.getRendererType();
            c ? (this.fixedDiv = r("div", {
              className: "highcharts-fixed"
            }, {
              position: "absolute",
              overflow: "hidden",
              pointerEvents: "none",
              zIndex: (e.style && e.style.zIndex || 0) + 2,
              top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = e = new b(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = e.path().attr({
              fill: this.options.chart.backgroundColor || "#fff",
              "fill-opacity": g(f.opacity, .85),
              zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), y(this, "afterShowResetZoom", this.moveFixedElements), y(this, "afterApplyDrilldown", this.moveFixedElements), y(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || c) this.scrollableDirty = !1, this.moveFixedElements();
            e = this.chartWidth + (this.scrollablePixelsX || 0);
            b = this.chartHeight + (this.scrollablePixelsY || 0);
            G(this.container);
            this.container.style.width = e + "px";
            this.container.style.height = b + "px";
            this.renderer.boxWrapper.attr({
              width: e,
              height: b,
              viewBox: [0, 0, e, b].join(" ")
            });
            this.chartBackground.attr({
              width: e,
              height: b
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            c && (f.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * f.scrollPositionX), f.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * f.scrollPositionY));
            b = this.axisOffset;
            c = this.plotTop - b[0] - 1;
            f = this.plotLeft - b[3] - 1;
            e = this.plotTop + this.plotHeight + b[2] + 1;
            b = this.plotLeft + this.plotWidth + b[1] + 1;
            var w = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                q = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            c = this.scrollablePixelsX ? [["M", 0, c], ["L", this.plotLeft - 1, c], ["L", this.plotLeft - 1, e], ["L", 0, e], ["Z"], ["M", w, c], ["L", this.chartWidth, c], ["L", this.chartWidth, e], ["L", w, e], ["Z"]] : this.scrollablePixelsY ? [["M", f, 0], ["L", f, this.plotTop - 1], ["L", b, this.plotTop - 1], ["L", b, 0], ["Z"], ["M", f, q], ["L", f, this.chartHeight], ["L", b, this.chartHeight], ["L", b, q], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
              d: c
            });
          };

          y(n, "afterInit", function () {
            this.chart.scrollableDirty = !0;
          });
          y(H, "show", function () {
            this.chart.scrollableDirty = !0;
          });
          "";
        });
        N(e, "Core/Axis/StackingAxis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = e.getDeferredAnimation,
              B = D.addEvent,
              E = D.destroyObjectProperties,
              I = D.fireEvent,
              y = D.isNumber,
              r = D.objectEach,
              q;

          (function (c) {
            function g() {
              var b = this.stacking;

              if (b) {
                var c = b.stacks;
                r(c, function (b, f) {
                  E(b);
                  c[f] = null;
                });
                b && b.stackTotalGroup && b.stackTotalGroup.destroy();
              }
            }

            function e() {
              this.stacking || (this.stacking = new f(this));
            }

            var q = [];

            c.compose = function (b) {
              -1 === q.indexOf(b) && (q.push(b), B(b, "init", e), B(b, "destroy", g));
              return b;
            };

            var f = function () {
              function b(b) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = b;
              }

              b.prototype.buildStacks = function () {
                var b = this.axis,
                    c = b.series,
                    f = b.options.reversedStacks,
                    g = c.length,
                    e;

                if (!b.isXAxis) {
                  this.usePercentage = !1;

                  for (e = g; e--;) {
                    var m = c[f ? e : g - e - 1];
                    m.setStackedPoints();
                    m.setGroupedPoints();
                  }

                  for (e = 0; e < g; e++) {
                    c[e].modifyStacks();
                  }

                  I(b, "afterBuildStacks");
                }
              };

              b.prototype.cleanStacks = function () {
                if (!this.axis.isXAxis) {
                  if (this.oldStacks) var b = this.stacks = this.oldStacks;
                  r(b, function (b) {
                    r(b, function (b) {
                      b.cumulative = b.total;
                    });
                  });
                }
              };

              b.prototype.resetStacks = function () {
                var b = this,
                    c = b.stacks;
                b.axis.isXAxis || r(c, function (c) {
                  r(c, function (f, g) {
                    y(f.touched) && f.touched < b.stacksTouched ? (f.destroy(), delete c[g]) : (f.total = null, f.cumulative = null);
                  });
                });
              };

              b.prototype.renderStackTotals = function () {
                var b = this.axis,
                    c = b.chart,
                    f = c.renderer,
                    g = this.stacks;
                b = G(c, b.options.stackLabels && b.options.stackLabels.animation || !1);
                var e = this.stackTotalGroup = this.stackTotalGroup || f.g("stack-labels").attr({
                  zIndex: 6,
                  opacity: 0
                }).add();
                e.translate(c.plotLeft, c.plotTop);
                r(g, function (b) {
                  r(b, function (b) {
                    b.render(e);
                  });
                });
                e.animate({
                  opacity: 1
                }, b);
              };

              return b;
            }();

            c.Additions = f;
          })(q || (q = {}));

          return q;
        });
        N(e, "Extensions/Stacking.js", [e["Core/Axis/Axis.js"], e["Core/Chart/Chart.js"], e["Core/FormatUtilities.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Axis/StackingAxis.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E, I) {
          var y = D.format,
              r = I.correctFloat,
              q = I.defined,
              c = I.destroyObjectProperties,
              g = I.isArray,
              l = I.isNumber,
              x = I.objectEach,
              f = I.pick,
              b = function () {
            function b(b, c, f, g, m) {
              var e = b.chart.inverted;
              this.axis = b;
              this.isNegative = f;
              this.options = c = c || {};
              this.x = g;
              this.total = null;
              this.points = {};
              this.hasValidPoints = !1;
              this.stack = m;
              this.rightCliff = this.leftCliff = 0;
              this.alignOptions = {
                align: c.align || (e ? f ? "left" : "right" : "center"),
                verticalAlign: c.verticalAlign || (e ? "middle" : f ? "bottom" : "top"),
                y: c.y,
                x: c.x
              };
              this.textAlign = c.textAlign || (e ? f ? "right" : "left" : "center");
            }

            b.prototype.destroy = function () {
              c(this, this.axis);
            };

            b.prototype.render = function (b) {
              var c = this.axis.chart,
                  g = this.options,
                  e = g.format;
              e = e ? y(e, this, c) : g.formatter.call(this);
              this.label ? this.label.attr({
                text: e,
                visibility: "hidden"
              }) : (this.label = c.renderer.label(e, null, null, g.shape, null, null, g.useHTML, !1, "stack-labels"), e = {
                r: g.borderRadius || 0,
                text: e,
                rotation: g.rotation,
                padding: f(g.padding, 5),
                visibility: "hidden"
              }, c.styledMode || (e.fill = g.backgroundColor, e.stroke = g.borderColor, e["stroke-width"] = g.borderWidth, this.label.css(g.style)), this.label.attr(e), this.label.added || this.label.add(b));
              this.label.labelrank = c.plotSizeY;
            };

            b.prototype.setOffset = function (b, c, g, e, m) {
              var p = this.axis,
                  a = p.chart;
              e = p.translate(p.stacking.usePercentage ? 100 : e ? e : this.total, 0, 0, 0, 1);
              g = p.translate(g ? g : 0);
              g = q(e) && Math.abs(e - g);
              b = f(m, a.xAxis[0].translate(this.x)) + b;
              p = q(e) && this.getStackBox(a, this, b, e, c, g, p);
              c = this.label;
              g = this.isNegative;
              b = "justify" === f(this.options.overflow, "justify");
              var w = this.textAlign;
              c && p && (m = c.getBBox(), e = c.padding, w = "left" === w ? a.inverted ? -e : e : "right" === w ? m.width : a.inverted && "center" === w ? m.width / 2 : a.inverted ? g ? m.width + e : -e : m.width / 2, g = a.inverted ? m.height / 2 : g ? -e : m.height, this.alignOptions.x = f(this.options.x, 0), this.alignOptions.y = f(this.options.y, 0), p.x -= w, p.y -= g, c.align(this.alignOptions, null, p), a.isInsidePlot(c.alignAttr.x + w - this.alignOptions.x, c.alignAttr.y + g - this.alignOptions.y) ? c.show() : (c.hide(), b = !1), b && B.prototype.justifyDataLabel.call(this.axis, c, this.alignOptions, c.alignAttr, m, p), c.attr({
                x: c.alignAttr.x,
                y: c.alignAttr.y
              }), f(!b && this.options.crop, !0) && ((a = l(c.x) && l(c.y) && a.isInsidePlot(c.x - e + c.width, c.y) && a.isInsidePlot(c.x + e, c.y)) || c.hide()));
            };

            b.prototype.getStackBox = function (b, c, f, g, e, t, a) {
              var m = c.axis.reversed,
                  d = b.inverted,
                  p = a.height + a.pos - (d ? b.plotLeft : b.plotTop);
              c = c.isNegative && !m || !c.isNegative && m;
              return {
                x: d ? c ? g - a.right : g - t + a.pos - b.plotLeft : f + b.xAxis[0].transB - b.plotLeft,
                y: d ? a.height - f - e : c ? p - g - t : p - g,
                width: d ? t : e,
                height: d ? e : t
              };
            };

            return b;
          }();

          n.prototype.getStacks = function () {
            var b = this,
                c = b.inverted;
            b.yAxis.forEach(function (b) {
              b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);
            });
            b.series.forEach(function (g) {
              var e = g.xAxis && g.xAxis.options || {};
              !g.options.stacking || !0 !== g.visible && !1 !== b.options.chart.ignoreHiddenSeries || (g.stackKey = [g.type, f(g.options.stack, ""), c ? e.top : e.left, c ? e.height : e.width].join());
            });
          };

          E.compose(e);

          B.prototype.setGroupedPoints = function () {
            var b = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? B.prototype.setStackedPoints.call(this, "group") : b && x(b.stacks, function (c, f) {
              "group" === f.slice(-5) && (x(c, function (b) {
                return b.destroy();
              }), delete b.stacks[f]);
            });
          };

          B.prototype.setStackedPoints = function (c) {
            var e = c || this.options.stacking;

            if (e && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
              var l = this.processedXData,
                  w = this.processedYData,
                  p = [],
                  m = w.length,
                  t = this.options,
                  a = t.threshold,
                  z = f(t.startFromThreshold && a, 0);
              t = t.stack;
              c = c ? "" + this.type + ",".concat(e) : this.stackKey;
              var d = "-" + c,
                  x = this.negStacks,
                  k = this.yAxis,
                  h = k.stacking.stacks,
                  L = k.stacking.oldStacks,
                  n,
                  u;
              k.stacking.stacksTouched += 1;

              for (u = 0; u < m; u++) {
                var A = l[u];
                var O = w[u];
                var y = this.getStackIndicator(y, A, this.index);
                var v = y.key;
                var M = (n = x && O < (z ? 0 : a)) ? d : c;
                h[M] || (h[M] = {});
                h[M][A] || (L[M] && L[M][A] ? (h[M][A] = L[M][A], h[M][A].total = null) : h[M][A] = new b(k, k.options.stackLabels, n, A, t));
                M = h[M][A];
                null !== O ? (M.points[v] = M.points[this.index] = [f(M.cumulative, z)], q(M.cumulative) || (M.base = v), M.touched = k.stacking.stacksTouched, 0 < y.index && !1 === this.singleStacks && (M.points[v][0] = M.points[this.index + "," + A + ",0"][0])) : M.points[v] = M.points[this.index] = null;
                "percent" === e ? (n = n ? c : d, x && h[n] && h[n][A] ? (n = h[n][A], M.total = n.total = Math.max(n.total, M.total) + Math.abs(O) || 0) : M.total = r(M.total + (Math.abs(O) || 0))) : "group" === e ? (g(O) && (O = O[0]), null !== O && (M.total = (M.total || 0) + 1)) : M.total = r(M.total + (O || 0));
                M.cumulative = "group" === e ? (M.total || 1) - 1 : f(M.cumulative, z) + (O || 0);
                null !== O && (M.points[v].push(M.cumulative), p[u] = M.cumulative, M.hasValidPoints = !0);
              }

              "percent" === e && (k.stacking.usePercentage = !0);
              "group" !== e && (this.stackedYData = p);
              k.stacking.oldStacks = {};
            }
          };

          B.prototype.modifyStacks = function () {
            var b = this,
                c = b.stackKey,
                f = b.yAxis.stacking.stacks,
                g = b.processedXData,
                e,
                m = b.options.stacking;
            b[m + "Stacker"] && [c, "-" + c].forEach(function (c) {
              for (var a = g.length, p, d; a--;) {
                if (p = g[a], e = b.getStackIndicator(e, p, b.index, c), d = (p = f[c] && f[c][p]) && p.points[e.key]) b[m + "Stacker"](d, p, a);
              }
            });
          };

          B.prototype.percentStacker = function (b, c, f) {
            c = c.total ? 100 / c.total : 0;
            b[0] = r(b[0] * c);
            b[1] = r(b[1] * c);
            this.stackedYData[f] = b[1];
          };

          B.prototype.getStackIndicator = function (b, c, f, g) {
            !q(b) || b.x !== c || g && b.stackKey !== g ? b = {
              x: c,
              index: 0,
              key: g,
              stackKey: g
            } : b.index++;
            b.key = [f, c, b.index].join();
            return b;
          };

          H.StackItem = b;
          "";
          return H.StackItem;
        });
        N(e, "Series/Line/LineSeries.js", [e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = this && this.__extends || function () {
            var _e4 = function e(n, r) {
              _e4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, c) {
                e.__proto__ = c;
              } || function (e, c) {
                for (var g in c) {
                  c.hasOwnProperty(g) && (e[g] = c[g]);
                }
              };

              return _e4(n, r);
            };

            return function (n, r) {
              function q() {
                this.constructor = n;
              }

              _e4(n, r);

              n.prototype = null === r ? Object.create(r) : (q.prototype = r.prototype, new q());
            };
          }(),
              B = D.defined,
              E = D.merge;

          D = function (n) {
            function y() {
              var e = null !== n && n.apply(this, arguments) || this;
              e.data = void 0;
              e.options = void 0;
              e.points = void 0;
              return e;
            }

            G(y, n);

            y.prototype.drawGraph = function () {
              var e = this,
                  q = this.options,
                  c = (this.gappedPath || this.getGraphPath).call(this),
                  g = this.chart.styledMode,
                  l = [["graph", "highcharts-graph"]];
              g || l[0].push(q.lineColor || this.color || "#cccccc", q.dashStyle);
              l = e.getZonesGraphs(l);
              l.forEach(function (l, f) {
                var b = l[0],
                    w = e[b],
                    r = w ? "animate" : "attr";
                w ? (w.endX = e.preventGraphAnimation ? null : c.xMap, w.animate({
                  d: c
                })) : c.length && (e[b] = w = e.chart.renderer.path(c).addClass(l[1]).attr({
                  zIndex: 1
                }).add(e.group));
                w && !g && (b = {
                  stroke: l[2],
                  "stroke-width": q.lineWidth,
                  fill: e.fillGraph && e.color || "none"
                }, l[3] ? b.dashstyle = l[3] : "square" !== q.linecap && (b["stroke-linecap"] = b["stroke-linejoin"] = "round"), w[r](b).shadow(2 > f && q.shadow));
                w && (w.startX = c.xMap, w.isArea = c.isArea);
              });
            };

            y.prototype.getGraphPath = function (e, q, c) {
              var g = this,
                  l = g.options,
                  r = [],
                  f = [],
                  b,
                  w = l.step;
              e = e || g.points;
              var n = e.reversed;
              n && e.reverse();
              (w = {
                right: 1,
                center: 2
              }[w] || w && 3) && n && (w = 4 - w);
              e = this.getValidPoints(e, !1, !(l.connectNulls && !q && !c));
              e.forEach(function (x, n) {
                var p = x.plotX,
                    m = x.plotY,
                    t = e[n - 1];
                (x.leftCliff || t && t.rightCliff) && !c && (b = !0);
                x.isNull && !B(q) && 0 < n ? b = !l.connectNulls : x.isNull && !q ? b = !0 : (0 === n || b ? n = [["M", x.plotX, x.plotY]] : g.getPointSpline ? n = [g.getPointSpline(e, x, n)] : w ? (n = 1 === w ? [["L", t.plotX, m]] : 2 === w ? [["L", (t.plotX + p) / 2, t.plotY], ["L", (t.plotX + p) / 2, m]] : [["L", p, t.plotY]], n.push(["L", p, m])) : n = [["L", p, m]], f.push(x.x), w && (f.push(x.x), 2 === w && f.push(x.x)), r.push.apply(r, n), b = !1);
              });
              r.xMap = f;
              return g.graphPath = r;
            };

            y.prototype.getZonesGraphs = function (e) {
              this.zones.forEach(function (q, c) {
                c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (q.className || "")];
                this.chart.styledMode || c.push(q.color || this.color, q.dashStyle || this.options.dashStyle);
                e.push(c);
              }, this);
              return e;
            };

            y.defaultOptions = E(e.defaultOptions, {});
            return y;
          }(e);

          n.registerSeriesType("line", D);
          "";
          return D;
        });
        N(e, "Series/Area/AreaSeries.js", [e["Core/Color/Color.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D, H) {
          var G = this && this.__extends || function () {
            var _c5 = function c(e, l) {
              _c5 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, f) {
                c.__proto__ = f;
              } || function (c, f) {
                for (var b in f) {
                  f.hasOwnProperty(b) && (c[b] = f[b]);
                }
              };

              return _c5(e, l);
            };

            return function (e, l) {
              function g() {
                this.constructor = e;
              }

              _c5(e, l);

              e.prototype = null === l ? Object.create(l) : (g.prototype = l.prototype, new g());
            };
          }(),
              E = e.parse,
              I = D.seriesTypes.line;

          e = H.extend;
          var y = H.merge,
              r = H.objectEach,
              q = H.pick;

          H = function (c) {
            function e() {
              var e = null !== c && c.apply(this, arguments) || this;
              e.data = void 0;
              e.options = void 0;
              e.points = void 0;
              return e;
            }

            G(e, c);

            e.prototype.drawGraph = function () {
              this.areaPath = [];
              c.prototype.drawGraph.apply(this);
              var e = this,
                  g = this.areaPath,
                  f = this.options,
                  b = [["area", "highcharts-area", this.color, f.fillColor]];
              this.zones.forEach(function (c, g) {
                b.push(["zone-area-" + g, "highcharts-area highcharts-zone-area-" + g + " " + c.className, c.color || e.color, c.fillColor || f.fillColor]);
              });
              b.forEach(function (b) {
                var c = b[0],
                    l = {},
                    w = e[c],
                    p = w ? "animate" : "attr";
                w ? (w.endX = e.preventGraphAnimation ? null : g.xMap, w.animate({
                  d: g
                })) : (l.zIndex = 0, w = e[c] = e.chart.renderer.path(g).addClass(b[1]).add(e.group), w.isArea = !0);
                e.chart.styledMode || (l.fill = q(b[3], E(b[2]).setOpacity(q(f.fillOpacity, .75)).get()));
                w[p](l);
                w.startX = g.xMap;
                w.shiftUnit = f.step ? 2 : 1;
              });
            };

            e.prototype.getGraphPath = function (c) {
              var e = I.prototype.getGraphPath,
                  f = this.options,
                  b = f.stacking,
                  g = this.yAxis,
                  l = [],
                  r = [],
                  n = this.index,
                  p = g.stacking.stacks[this.stackKey],
                  m = f.threshold,
                  t = Math.round(g.getThreshold(f.threshold));
              f = q(f.connectNulls, "percent" === b);

              var a = function a(_a9, d, f) {
                var h = c[_a9];
                _a9 = b && p[h.x].points[n];
                var e = h[f + "Null"] || 0;
                f = h[f + "Cliff"] || 0;
                h = !0;

                if (f || e) {
                  var u = (e ? _a9[0] : _a9[1]) + f;
                  var v = _a9[0] + f;
                  h = !!e;
                } else !b && c[d] && c[d].isNull && (u = v = m);

                "undefined" !== typeof u && (r.push({
                  plotX: k,
                  plotY: null === u ? t : g.getThreshold(u),
                  isNull: h,
                  isCliff: !0
                }), l.push({
                  plotX: k,
                  plotY: null === v ? t : g.getThreshold(v),
                  doCurve: !1
                }));
              };

              c = c || this.points;
              b && (c = this.getStackPoints(c));

              for (var z = 0, d = c.length; z < d; ++z) {
                b || (c[z].leftCliff = c[z].rightCliff = c[z].leftNull = c[z].rightNull = void 0);
                var F = c[z].isNull;
                var k = q(c[z].rectPlotX, c[z].plotX);
                var h = b ? q(c[z].yBottom, t) : t;
                if (!F || f) f || a(z, z - 1, "left"), F && !b && f || (r.push(c[z]), l.push({
                  x: z,
                  plotX: k,
                  plotY: h
                })), f || a(z, z + 1, "right");
              }

              a = e.call(this, r, !0, !0);
              l.reversed = !0;
              F = e.call(this, l, !0, !0);
              (h = F[0]) && "M" === h[0] && (F[0] = ["L", h[1], h[2]]);
              F = a.concat(F);
              F.length && F.push(["Z"]);
              e = e.call(this, r, !1, f);
              F.xMap = a.xMap;
              this.areaPath = F;
              return e;
            };

            e.prototype.getStackPoints = function (c) {
              var e = this,
                  f = [],
                  b = [],
                  g = this.xAxis,
                  l = this.yAxis,
                  n = l.stacking.stacks[this.stackKey],
                  y = {},
                  p = l.series,
                  m = p.length,
                  t = l.options.reversedStacks ? 1 : -1,
                  a = p.indexOf(e);
              c = c || this.points;

              if (this.options.stacking) {
                for (var z = 0; z < c.length; z++) {
                  c[z].leftNull = c[z].rightNull = void 0, y[c[z].x] = c[z];
                }

                r(n, function (a, d) {
                  null !== a.total && b.push(d);
                });
                b.sort(function (a, d) {
                  return a - d;
                });
                var d = p.map(function (a) {
                  return a.visible;
                });
                b.forEach(function (c, k) {
                  var h = 0,
                      w,
                      z;
                  if (y[c] && !y[c].isNull) f.push(y[c]), [-1, 1].forEach(function (f) {
                    var h = 1 === f ? "rightNull" : "leftNull",
                        g = n[b[k + f]],
                        u = 0;
                    if (g) for (var l = a; 0 <= l && l < m;) {
                      var A = p[l].index;
                      w = g.points[A];
                      w || (A === e.index ? y[c][h] = !0 : d[l] && (z = n[c].points[A]) && (u -= z[1] - z[0]));
                      l += t;
                    }
                    y[c][1 === f ? "rightCliff" : "leftCliff"] = u;
                  });else {
                    for (var u = a; 0 <= u && u < m;) {
                      if (w = n[c].points[p[u].index]) {
                        h = w[1];
                        break;
                      }

                      u += t;
                    }

                    h = q(h, 0);
                    h = l.translate(h, 0, 1, 0, 1);
                    f.push({
                      isNull: !0,
                      plotX: g.translate(c, 0, 0, 0, 1),
                      x: c,
                      plotY: h,
                      yBottom: h
                    });
                  }
                });
              }

              return f;
            };

            e.defaultOptions = y(I.defaultOptions, {
              threshold: 0
            });
            return e;
          }(I);

          e(H.prototype, {
            singleStacks: !1,
            drawLegendSymbol: n.drawRectangle
          });
          D.registerSeriesType("area", H);
          "";
          return H;
        });
        N(e, "Series/Spline/SplineSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n) {
          var G = this && this.__extends || function () {
            var _e5 = function e(n, r) {
              _e5 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, c) {
                e.__proto__ = c;
              } || function (e, c) {
                for (var g in c) {
                  c.hasOwnProperty(g) && (e[g] = c[g]);
                }
              };

              return _e5(n, r);
            };

            return function (n, r) {
              function q() {
                this.constructor = n;
              }

              _e5(n, r);

              n.prototype = null === r ? Object.create(r) : (q.prototype = r.prototype, new q());
            };
          }(),
              H = e.seriesTypes.line,
              B = n.merge,
              E = n.pick;

          n = function (e) {
            function n() {
              var r = null !== e && e.apply(this, arguments) || this;
              r.data = void 0;
              r.options = void 0;
              r.points = void 0;
              return r;
            }

            G(n, e);

            n.prototype.getPointSpline = function (e, q, c) {
              var g = q.plotX || 0,
                  l = q.plotY || 0,
                  r = e[c - 1];
              c = e[c + 1];

              if (r && !r.isNull && !1 !== r.doCurve && !q.isCliff && c && !c.isNull && !1 !== c.doCurve && !q.isCliff) {
                e = r.plotY || 0;
                var f = c.plotX || 0;
                c = c.plotY || 0;
                var b = 0;
                var w = (1.5 * g + (r.plotX || 0)) / 2.5;
                var n = (1.5 * l + e) / 2.5;
                f = (1.5 * g + f) / 2.5;
                var C = (1.5 * l + c) / 2.5;
                f !== w && (b = (C - n) * (f - g) / (f - w) + l - C);
                n += b;
                C += b;
                n > e && n > l ? (n = Math.max(e, l), C = 2 * l - n) : n < e && n < l && (n = Math.min(e, l), C = 2 * l - n);
                C > c && C > l ? (C = Math.max(c, l), n = 2 * l - C) : C < c && C < l && (C = Math.min(c, l), n = 2 * l - C);
                q.rightContX = f;
                q.rightContY = C;
              }

              q = ["C", E(r.rightContX, r.plotX, 0), E(r.rightContY, r.plotY, 0), E(w, g, 0), E(n, l, 0), g, l];
              r.rightContX = r.rightContY = void 0;
              return q;
            };

            n.defaultOptions = B(H.defaultOptions);
            return n;
          }(H);

          e.registerSeriesType("spline", n);
          "";
          return n;
        });
        N(e, "Series/AreaSpline/AreaSplineSeries.js", [e["Series/Spline/SplineSeries.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D, H) {
          var G = this && this.__extends || function () {
            var _e6 = function e(c, g) {
              _e6 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, e) {
                c.__proto__ = e;
              } || function (c, e) {
                for (var f in e) {
                  e.hasOwnProperty(f) && (c[f] = e[f]);
                }
              };

              return _e6(c, g);
            };

            return function (c, g) {
              function l() {
                this.constructor = c;
              }

              _e6(c, g);

              c.prototype = null === g ? Object.create(g) : (l.prototype = g.prototype, new l());
            };
          }(),
              E = D.seriesTypes,
              I = E.area;

          E = E.area.prototype;
          var y = H.extend,
              r = H.merge;

          H = function (q) {
            function c() {
              var c = null !== q && q.apply(this, arguments) || this;
              c.data = void 0;
              c.points = void 0;
              c.options = void 0;
              return c;
            }

            G(c, q);
            c.defaultOptions = r(e.defaultOptions, I.defaultOptions);
            return c;
          }(e);

          y(H.prototype, {
            getGraphPath: E.getGraphPath,
            getStackPoints: E.getStackPoints,
            drawGraph: E.drawGraph,
            drawLegendSymbol: n.drawRectangle
          });
          D.registerSeriesType("areaspline", H);
          "";
          return H;
        });
        N(e, "Series/Column/ColumnSeries.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E, I) {
          var y = this && this.__extends || function () {
            var _b3 = function b(c, a) {
              _b3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _b3(c, a);
            };

            return function (c, a) {
              function f() {
                this.constructor = c;
              }

              _b3(c, a);

              c.prototype = null === a ? Object.create(a) : (f.prototype = a.prototype, new f());
            };
          }(),
              r = e.animObject,
              q = n.parse,
              c = D.hasTouch;

          e = D.noop;
          var g = I.clamp,
              l = I.css,
              x = I.defined,
              f = I.extend,
              b = I.fireEvent,
              w = I.isArray,
              J = I.isNumber,
              C = I.merge,
              K = I.pick,
              p = I.objectEach;

          I = function (e) {
            function m() {
              var a = null !== e && e.apply(this, arguments) || this;
              a.borderWidth = void 0;
              a.data = void 0;
              a.group = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            y(m, e);

            m.prototype.animate = function (a) {
              var b = this,
                  d = this.yAxis,
                  c = b.options,
                  e = this.chart.inverted,
                  h = {},
                  m = e ? "translateX" : "translateY";
              if (a) h.scaleY = .001, a = g(d.toPixels(c.threshold), d.pos, d.pos + d.len), e ? h.translateX = a - d.len : h.translateY = a, b.clipBox && b.setClip(), b.group.attr(h);else {
                var p = Number(b.group.attr(m));
                b.group.animate({
                  scaleY: 1
                }, f(r(b.options.animation), {
                  step: function step(a, c) {
                    b.group && (h[m] = p + c.pos * (d.pos - p), b.group.attr(h));
                  }
                }));
              }
            };

            m.prototype.init = function (a, b) {
              e.prototype.init.apply(this, arguments);
              var d = this;
              a = d.chart;
              a.hasRendered && a.series.forEach(function (a) {
                a.type === d.type && (a.isDirty = !0);
              });
            };

            m.prototype.getColumnMetrics = function () {
              var a = this,
                  b = a.options,
                  d = a.xAxis,
                  c = a.yAxis,
                  f = d.options.reversedStacks;
              f = d.reversed && !f || !d.reversed && f;
              var e = {},
                  g,
                  m = 0;
              !1 === b.grouping ? m = 1 : a.chart.series.forEach(function (d) {
                var b = d.yAxis,
                    f = d.options;

                if (d.type === a.type && (d.visible || !a.chart.options.chart.ignoreHiddenSeries) && c.len === b.len && c.pos === b.pos) {
                  if (f.stacking && "group" !== f.stacking) {
                    g = d.stackKey;
                    "undefined" === typeof e[g] && (e[g] = m++);
                    var h = e[g];
                  } else !1 !== f.grouping && (h = m++);

                  d.columnIndex = h;
                }
              });
              var u = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || b.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),
                  p = u * b.groupPadding,
                  t = (u - 2 * p) / (m || 1);
              b = Math.min(b.maxPointWidth || d.len, K(b.pointWidth, t * (1 - 2 * b.pointPadding)));
              a.columnMetrics = {
                width: b,
                offset: (t - b) / 2 + (p + ((a.columnIndex || 0) + (f ? 1 : 0)) * t - u / 2) * (f ? -1 : 1),
                paddedWidth: t,
                columnCount: m
              };
              return a.columnMetrics;
            };

            m.prototype.crispCol = function (a, b, d, c) {
              var f = this.chart,
                  e = this.borderWidth,
                  g = -(e % 2 ? .5 : 0);
              e = e % 2 ? .5 : 1;
              f.inverted && f.renderer.isVML && (e += 1);
              this.options.crisp && (d = Math.round(a + d) + g, a = Math.round(a) + g, d -= a);
              c = Math.round(b + c) + e;
              g = .5 >= Math.abs(b) && .5 < c;
              b = Math.round(b) + e;
              c -= b;
              g && c && (--b, c += 1);
              return {
                x: a,
                y: b,
                width: d,
                height: c
              };
            };

            m.prototype.adjustForMissingColumns = function (a, b, d, c) {
              var f = this,
                  e = this.options.stacking;

              if (!d.isNull && 1 < c.columnCount) {
                var g = this.yAxis.options.reversedStacks,
                    m = 0,
                    u = g ? 0 : -c.columnCount;
                p(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {
                  if ("number" === typeof d.x && (a = a[d.x.toString()])) {
                    var b = a.points[f.index],
                        c = a.total;
                    e ? (b && (m = u), a.hasValidPoints && (g ? u++ : u--)) : w(b) && (m = b[1], u = c || 0);
                  }
                });
                a = (d.plotX || 0) + ((u - 1) * c.paddedWidth + b) / 2 - b - m * c.paddedWidth;
              }

              return a;
            };

            m.prototype.translate = function () {
              var a = this,
                  b = a.chart,
                  d = a.options,
                  c = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
              c = a.borderWidth = K(d.borderWidth, c ? 0 : 1);
              var f = a.xAxis,
                  e = a.yAxis,
                  m = d.threshold,
                  p = a.translatedThreshold = e.getThreshold(m),
                  u = K(d.minPointLength, 5),
                  t = a.getColumnMetrics(),
                  l = t.width,
                  w = a.pointXOffset = t.offset,
                  v = a.dataMin,
                  q = a.dataMax,
                  r = a.barW = Math.max(l, 1 + 2 * c);
              b.inverted && (p -= .5);
              d.pointPadding && (r = Math.ceil(r));
              B.prototype.translate.apply(a);
              a.points.forEach(function (c) {
                var h = K(c.yBottom, p),
                    k = 999 + Math.abs(h),
                    A = c.plotX || 0;
                k = g(c.plotY, -k, e.len + k);
                var z = Math.min(k, h),
                    n = Math.max(k, h) - z,
                    L = l,
                    M = A + w,
                    C = r;
                u && Math.abs(n) < u && (n = u, A = !e.reversed && !c.negative || e.reversed && c.negative, J(m) && J(q) && c.y === m && q <= m && (e.min || 0) < m && (v !== q || (e.max || 0) <= m) && (A = !A), z = Math.abs(z - p) > u ? h - u : p - (A ? u : 0));
                x(c.options.pointWidth) && (L = C = Math.ceil(c.options.pointWidth), M -= Math.round((L - l) / 2));
                d.centerInCategory && (M = a.adjustForMissingColumns(M, L, c, t));
                c.barX = M;
                c.pointWidth = L;
                c.tooltipPos = b.inverted ? [g(e.len + e.pos - b.plotLeft - k, e.pos - b.plotLeft, e.len + e.pos - b.plotLeft), f.len + f.pos - b.plotTop - M - C / 2, n] : [f.left - b.plotLeft + M + C / 2, g(k + e.pos - b.plotTop, e.pos - b.plotTop, e.len + e.pos - b.plotTop), n];
                c.shapeType = a.pointClass.prototype.shapeType || "rect";
                c.shapeArgs = a.crispCol.apply(a, c.isNull ? [M, p, C, 0] : [M, z, C, n]);
              });
            };

            m.prototype.drawGraph = function () {
              this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };

            m.prototype.pointAttribs = function (a, b) {
              var d = this.options,
                  c = this.pointAttrToOptions || {},
                  f = c.stroke || "borderColor",
                  e = c["stroke-width"] || "borderWidth",
                  g = a && a.color || this.color,
                  m = a && a[f] || d[f] || g;
              c = a && a.options.dashStyle || d.dashStyle;
              var p = a && a[e] || d[e] || this[e] || 0,
                  t = K(a && a.opacity, d.opacity, 1);

              if (a && this.zones.length) {
                var l = a.getZone();
                g = a.options.color || l && (l.color || a.nonZonedColor) || this.color;
                l && (m = l.borderColor || m, c = l.dashStyle || c, p = l.borderWidth || p);
              }

              b && a && (a = C(d.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, g = a.color || "undefined" !== typeof b && q(g).brighten(a.brightness).get() || g, m = a[f] || m, p = a[e] || p, c = a.dashStyle || c, t = K(a.opacity, t));
              f = {
                fill: g,
                stroke: m,
                "stroke-width": p,
                opacity: t
              };
              c && (f.dashstyle = c);
              return f;
            };

            m.prototype.drawPoints = function () {
              var a = this,
                  b = this.chart,
                  d = a.options,
                  c = b.renderer,
                  f = d.animationLimit || 250,
                  e;
              a.points.forEach(function (h) {
                var g = h.graphic,
                    k = !!g,
                    m = g && b.pointCount < f ? "animate" : "attr";

                if (J(h.plotY) && null !== h.y) {
                  e = h.shapeArgs;
                  g && h.hasNewShapeType() && (g = g.destroy());
                  a.enabledDataSorting && (h.startXPos = a.xAxis.reversed ? -(e ? e.width || 0 : 0) : a.xAxis.width);
                  g || (h.graphic = g = c[h.shapeType](e).add(h.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < f && (g.attr({
                    x: h.startXPos
                  }), k = !0, m = "animate");
                  if (g && k) g[m](C(e));
                  if (d.borderRadius) g[m]({
                    r: d.borderRadius
                  });
                  b.styledMode || g[m](a.pointAttribs(h, h.selected && "select")).shadow(!1 !== h.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);
                  g && (g.addClass(h.getClassName(), !0), g.attr({
                    visibility: h.visible ? "inherit" : "hidden"
                  }));
                } else g && (h.graphic = g.destroy());
              });
            };

            m.prototype.drawTracker = function () {
              var a = this,
                  f = a.chart,
                  d = f.pointer,
                  e = function e(a) {
                var b = d.getPointFromEvent(a);
                "undefined" !== typeof b && (d.isDirectTouch = !0, b.onMouseOver(a));
              },
                  g;

              a.points.forEach(function (a) {
                g = w(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
                a.graphic && (a.graphic.element.point = a);
                g.forEach(function (b) {
                  b.div ? b.div.point = a : b.element.point = a;
                });
              });
              a._hasTracking || (a.trackerGroups.forEach(function (b) {
                if (a[b]) {
                  a[b].addClass("highcharts-tracker").on("mouseover", e).on("mouseout", function (a) {
                    d.onTrackerMouseOut(a);
                  });
                  if (c) a[b].on("touchstart", e);
                  !f.styledMode && a.options.cursor && a[b].css(l).css({
                    cursor: a.options.cursor
                  });
                }
              }), a._hasTracking = !0);
              b(this, "afterDrawTracker");
            };

            m.prototype.remove = function () {
              var a = this,
                  b = a.chart;
              b.hasRendered && b.series.forEach(function (b) {
                b.type === a.type && (b.isDirty = !0);
              });
              B.prototype.remove.apply(a, arguments);
            };

            m.defaultOptions = C(B.defaultOptions, {
              borderRadius: 0,
              centerInCategory: !1,
              groupPadding: .2,
              marker: null,
              pointPadding: .1,
              minPointLength: 0,
              cropThreshold: 50,
              pointRange: null,
              states: {
                hover: {
                  halo: !1,
                  brightness: .1
                },
                select: {
                  color: "#cccccc",
                  borderColor: "#000000"
                }
              },
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
              },
              startFromThreshold: !0,
              stickyTracking: !1,
              tooltip: {
                distance: 6
              },
              threshold: 0,
              borderColor: "#ffffff"
            });
            return m;
          }(B);

          f(I.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: H.drawRectangle,
            getSymbol: e,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          E.registerSeriesType("column", I);
          "";
          "";
          return I;
        });
        N(e, "Core/Series/DataLabel.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/FormatUtilities.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = e.getDeferredAnimation,
              B = n.format,
              E = D.defined,
              I = D.extend,
              y = D.fireEvent,
              r = D.isArray,
              q = D.merge,
              c = D.objectEach,
              g = D.pick,
              l = D.splat,
              x;

          (function (f) {
            function b(b, a, c, d, f) {
              var e = this,
                  h = this.chart,
                  m = this.isCartesian && h.inverted,
                  p = this.enabledDataSorting,
                  u = g(b.dlBox && b.dlBox.centerX, b.plotX),
                  l = b.plotY,
                  t = c.rotation,
                  w = c.align,
                  v = E(u) && E(l) && h.isInsidePlot(u, Math.round(l), {
                inverted: m,
                paneCoordinates: !0,
                series: e
              }),
                  q = function q(d) {
                p && e.xAxis && !r && e.setDataLabelStartPos(b, a, f, v, d);
              },
                  r = "justify" === g(c.overflow, p ? "none" : "justify"),
                  z = this.visible && !1 !== b.visible && (b.series.forceDL || p && !r || v || g(c.inside, !!this.options.stacking) && d && h.isInsidePlot(u, m ? d.x + 1 : d.y + d.height - 1, {
                inverted: m,
                paneCoordinates: !0,
                series: e
              }));

              if (z && E(u) && E(l)) {
                t && a.attr({
                  align: w
                });
                w = a.getBBox(!0);
                var n = [0, 0];
                var x = h.renderer.fontMetrics(h.styledMode ? void 0 : c.style.fontSize, a).b;
                d = I({
                  x: m ? this.yAxis.len - l : u,
                  y: Math.round(m ? this.xAxis.len - u : l),
                  width: 0,
                  height: 0
                }, d);
                I(c, {
                  width: w.width,
                  height: w.height
                });
                t ? (r = !1, n = h.renderer.rotCorr(x, t), u = {
                  x: d.x + (c.x || 0) + d.width / 2 + n.x,
                  y: d.y + (c.y || 0) + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                  }[c.verticalAlign] * d.height
                }, n = [w.x - Number(a.attr("x")), w.y - Number(a.attr("y"))], q(u), a[f ? "attr" : "animate"](u)) : (q(d), a.align(c, void 0, d), u = a.alignAttr);
                r && 0 <= d.height ? this.justifyDataLabel(a, c, u, w, d, f) : g(c.crop, !0) && (d = u.x, q = u.y, d += n[0], q += n[1], z = h.isInsidePlot(d, q, {
                  paneCoordinates: !0,
                  series: e
                }) && h.isInsidePlot(d + w.width, q + w.height, {
                  paneCoordinates: !0,
                  series: e
                }));
                if (c.shape && !t) a[f ? "attr" : "animate"]({
                  anchorX: m ? h.plotWidth - b.plotY : b.plotX,
                  anchorY: m ? h.plotHeight - b.plotX : b.plotY
                });
              }

              f && p && (a.placed = !1);
              z || p && !r ? a.show() : (a.hide(), a.placed = !1);
            }

            function e(b, a) {
              var c = a.filter;
              return c ? (a = c.operator, b = b[c.property], c = c.value, ">" === a && b > c || "<" === a && b < c || ">=" === a && b >= c || "<=" === a && b <= c || "==" === a && b == c || "===" === a && b === c ? !0 : !1) : !0;
            }

            function n() {
              var b = this,
                  a = b.chart,
                  f = b.options,
                  d = b.points,
                  m = b.hasRendered || 0,
                  k = a.renderer,
                  h = f.dataLabels,
                  p,
                  w = h.animation;
              w = h.defer ? G(a, w, b) : {
                defer: 0,
                duration: 0
              };
              h = K(K(a.options.plotOptions && a.options.plotOptions.series && a.options.plotOptions.series.dataLabels, a.options.plotOptions && a.options.plotOptions[b.type] && a.options.plotOptions[b.type].dataLabels), h);
              y(this, "drawDataLabels");

              if (r(h) || h.enabled || b._hasPointLabels) {
                var u = b.plotGroup("dataLabelsGroup", "data-labels", m ? "inherit" : "hidden", h.zIndex || 6);
                u.attr({
                  opacity: +m
                });
                !m && (m = b.dataLabelsGroup) && (b.visible && u.show(), m[f.animation ? "animate" : "attr"]({
                  opacity: 1
                }, w));
                d.forEach(function (d) {
                  p = l(K(h, d.dlOptions || d.options && d.options.dataLabels));
                  p.forEach(function (h, m) {
                    var p = h.enabled && (!d.isNull || d.dataLabelOnNull) && e(d, h),
                        l = d.connectors ? d.connectors[m] : d.connector,
                        t = d.dataLabels ? d.dataLabels[m] : d.dataLabel,
                        A = !t,
                        w = g(h.distance, d.labelDistance);

                    if (p) {
                      var q = d.getLabelConfig();
                      var r = g(h[d.formatPrefix + "Format"], h.format);
                      q = E(r) ? B(r, q, a) : (h[d.formatPrefix + "Formatter"] || h.formatter).call(q, h);
                      r = h.style;
                      var z = h.rotation;
                      a.styledMode || (r.color = g(h.color, r.color, b.color, "#000000"), "contrast" === r.color ? (d.contrastColor = k.getContrast(d.color || b.color), r.color = !E(w) && h.inside || 0 > w || f.stacking ? d.contrastColor : "#000000") : delete d.contrastColor, f.cursor && (r.cursor = f.cursor));
                      var n = {
                        r: h.borderRadius || 0,
                        rotation: z,
                        padding: h.padding,
                        zIndex: 1
                      };
                      a.styledMode || (n.fill = h.backgroundColor, n.stroke = h.borderColor, n["stroke-width"] = h.borderWidth);
                      c(n, function (a, b) {
                        "undefined" === typeof a && delete n[b];
                      });
                    }

                    !t || p && E(q) && !!t.div === !!h.useHTML && (t.rotation && h.rotation || t.rotation === h.rotation) || (A = !0, d.dataLabel = t = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[m]), m || delete d.dataLabel, l && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[m])));
                    p && E(q) ? (t ? n.text = q : (d.dataLabels = d.dataLabels || [], t = d.dataLabels[m] = z ? k.text(q, 0, 0, h.useHTML).addClass("highcharts-data-label") : k.label(q, 0, 0, h.shape, null, null, h.useHTML, null, "data-label"), m || (d.dataLabel = t), t.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (h.className || "") + (h.useHTML ? " highcharts-tracker" : ""))), t.options = h, t.attr(n), a.styledMode || t.css(r).shadow(h.shadow), t.added || t.add(u), h.textPath && !h.useHTML && (t.setTextPath(d.getDataLabelPath && d.getDataLabelPath(t) || d.graphic, h.textPath), d.dataLabelPath && !h.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), b.alignDataLabel(d, t, h, null, A)) : t && t.hide();
                  });
                });
              }

              y(this, "afterDrawDataLabels");
            }

            function x(b, a, c, d, f, e) {
              var h = this.chart,
                  g = a.align,
                  m = a.verticalAlign,
                  k = b.box ? 0 : b.padding || 0,
                  p = a.x;
              p = void 0 === p ? 0 : p;
              var l = a.y;
              l = void 0 === l ? 0 : l;
              var t = (c.x || 0) + k;

              if (0 > t) {
                "right" === g && 0 <= p ? (a.align = "left", a.inside = !0) : p -= t;
                var v = !0;
              }

              t = (c.x || 0) + d.width - k;
              t > h.plotWidth && ("left" === g && 0 >= p ? (a.align = "right", a.inside = !0) : p += h.plotWidth - t, v = !0);
              t = c.y + k;
              0 > t && ("bottom" === m && 0 <= l ? (a.verticalAlign = "top", a.inside = !0) : l -= t, v = !0);
              t = (c.y || 0) + d.height - k;
              t > h.plotHeight && ("top" === m && 0 >= l ? (a.verticalAlign = "bottom", a.inside = !0) : l += h.plotHeight - t, v = !0);
              v && (a.x = p, a.y = l, b.placed = !e, b.align(a, void 0, f));
              return v;
            }

            function K(b, a) {
              var c = [],
                  d;
              if (r(b) && !r(a)) c = b.map(function (b) {
                return q(b, a);
              });else if (r(a) && !r(b)) c = a.map(function (a) {
                return q(b, a);
              });else if (r(b) || r(a)) for (d = Math.max(b.length, a.length); d--;) {
                c[d] = q(b[d], a[d]);
              } else c = q(b, a);
              return c;
            }

            function p(b, a, c, d, f) {
              var e = this.chart,
                  h = e.inverted,
                  g = this.xAxis,
                  m = g.reversed,
                  p = h ? a.height / 2 : a.width / 2;
              b = (b = b.pointWidth) ? b / 2 : 0;
              a.startXPos = h ? f.x : m ? -p - b : g.width - p + b;
              a.startYPos = h ? m ? this.yAxis.height - p + b : -p - b : f.y;
              d ? "hidden" === a.visibility && (a.show(), a.attr({
                opacity: 0
              }).animate({
                opacity: 1
              })) : a.attr({
                opacity: 1
              }).animate({
                opacity: 0
              }, void 0, a.hide);
              e.hasRendered && (c && a.attr({
                x: a.startXPos,
                y: a.startYPos
              }), a.placed = !0);
            }

            var m = [];

            f.compose = function (c) {
              if (-1 === m.indexOf(c)) {
                var a = c.prototype;
                m.push(c);
                a.alignDataLabel = b;
                a.drawDataLabels = n;
                a.justifyDataLabel = x;
                a.setDataLabelStartPos = p;
              }
            };
          })(x || (x = {}));

          "";
          return x;
        });
        N(e, "Series/Column/ColumnDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = n.series,
              B = D.merge,
              E = D.pick,
              I;

          (function (n) {
            function r(c, e, l, q, f) {
              var b = this.chart.inverted,
                  g = c.series,
                  r = (g.xAxis ? g.xAxis.len : this.chart.plotSizeX) || 0;
              g = (g.yAxis ? g.yAxis.len : this.chart.plotSizeY) || 0;
              var n = c.dlBox || c.shapeArgs,
                  x = E(c.below, c.plotY > E(this.translatedThreshold, g)),
                  p = E(l.inside, !!this.options.stacking);
              n && (q = B(n), 0 > q.y && (q.height += q.y, q.y = 0), n = q.y + q.height - g, 0 < n && n < q.height && (q.height -= n), b && (q = {
                x: g - q.y - q.height,
                y: r - q.x - q.width,
                width: q.height,
                height: q.width
              }), p || (b ? (q.x += x ? 0 : q.width, q.width = 0) : (q.y += x ? q.height : 0, q.height = 0)));
              l.align = E(l.align, !b || p ? "center" : x ? "right" : "left");
              l.verticalAlign = E(l.verticalAlign, b || p ? "middle" : x ? "top" : "bottom");
              G.prototype.alignDataLabel.call(this, c, e, l, q, f);
              l.inside && c.contrastColor && e.css({
                color: c.contrastColor
              });
            }

            var q = [];

            n.compose = function (c) {
              e.compose(G);
              -1 === q.indexOf(c) && (q.push(c), c.prototype.alignDataLabel = r);
            };
          })(I || (I = {}));

          return I;
        });
        N(e, "Series/Bar/BarSeries.js", [e["Series/Column/ColumnSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = this && this.__extends || function () {
            var _e7 = function e(n, r) {
              _e7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, c) {
                e.__proto__ = c;
              } || function (e, c) {
                for (var g in c) {
                  c.hasOwnProperty(g) && (e[g] = c[g]);
                }
              };

              return _e7(n, r);
            };

            return function (n, r) {
              function q() {
                this.constructor = n;
              }

              _e7(n, r);

              n.prototype = null === r ? Object.create(r) : (q.prototype = r.prototype, new q());
            };
          }(),
              B = D.extend,
              E = D.merge;

          D = function (n) {
            function y() {
              var e = null !== n && n.apply(this, arguments) || this;
              e.data = void 0;
              e.options = void 0;
              e.points = void 0;
              return e;
            }

            G(y, n);
            y.defaultOptions = E(e.defaultOptions, {});
            return y;
          }(e);

          B(D.prototype, {
            inverted: !0
          });
          n.registerSeriesType("bar", D);
          "";
          return D;
        });
        N(e, "Series/Scatter/ScatterSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n) {
          var G = this && this.__extends || function () {
            var _e8 = function e(q, c) {
              _e8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, e) {
                c.__proto__ = e;
              } || function (c, e) {
                for (var g in e) {
                  e.hasOwnProperty(g) && (c[g] = e[g]);
                }
              };

              return _e8(q, c);
            };

            return function (q, c) {
              function g() {
                this.constructor = q;
              }

              _e8(q, c);

              q.prototype = null === c ? Object.create(c) : (g.prototype = c.prototype, new g());
            };
          }(),
              H = e.seriesTypes,
              B = H.column,
              E = H.line;

          H = n.addEvent;
          var I = n.extend,
              y = n.merge;

          n = function (e) {
            function q() {
              var c = null !== e && e.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            G(q, e);

            q.prototype.applyJitter = function () {
              var c = this,
                  e = this.options.jitter,
                  l = this.points.length;
              e && this.points.forEach(function (g, f) {
                ["x", "y"].forEach(function (b, w) {
                  var q = "plot" + b.toUpperCase();

                  if (e[b] && !g.isNull) {
                    var r = c[b + "Axis"];
                    var n = e[b] * r.transA;

                    if (r && !r.isLog) {
                      var p = Math.max(0, g[q] - n);
                      r = Math.min(r.len, g[q] + n);
                      w = 1E4 * Math.sin(f + w * l);
                      g[q] = p + (r - p) * (w - Math.floor(w));
                      "x" === b && (g.clientX = g.plotX);
                    }
                  }
                });
              });
            };

            q.prototype.drawGraph = function () {
              this.options.lineWidth ? e.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };

            q.defaultOptions = y(E.defaultOptions, {
              lineWidth: 0,
              findNearestPointBy: "xy",
              jitter: {
                x: 0,
                y: 0
              },
              marker: {
                enabled: !0
              },
              tooltip: {
                headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
              }
            });
            return q;
          }(E);

          I(n.prototype, {
            drawTracker: B.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
          });
          H(n, "afterTranslate", function () {
            this.applyJitter();
          });
          e.registerSeriesType("scatter", n);
          "";
          return n;
        });
        N(e, "Series/CenteredUtilities.js", [e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = e.deg2rad,
              B = D.fireEvent,
              E = D.isNumber,
              I = D.pick,
              y = D.relativeLength,
              r;

          (function (e) {
            e.getCenter = function () {
              var c = this.options,
                  e = this.chart,
                  l = 2 * (c.slicedOffset || 0),
                  q = e.plotWidth - 2 * l,
                  f = e.plotHeight - 2 * l,
                  b = c.center,
                  w = Math.min(q, f),
                  r = c.thickness,
                  C = c.size,
                  K = c.innerSize || 0;
              "string" === typeof C && (C = parseFloat(C));
              "string" === typeof K && (K = parseFloat(K));
              c = [I(b[0], "50%"), I(b[1], "50%"), I(C && 0 > C ? void 0 : c.size, "100%"), I(K && 0 > K ? void 0 : c.innerSize || 0, "0%")];
              !e.angular || this instanceof n || (c[3] = 0);

              for (b = 0; 4 > b; ++b) {
                C = c[b], e = 2 > b || 2 === b && /%$/.test(C), c[b] = y(C, [q, f, w, c[2]][b]) + (e ? l : 0);
              }

              c[3] > c[2] && (c[3] = c[2]);
              E(r) && 2 * r < c[2] && 0 < r && (c[3] = c[2] - 2 * r);
              B(this, "afterGetCenter", {
                positions: c
              });
              return c;
            };

            e.getStartAndEndRadians = function (c, e) {
              c = E(c) ? c : 0;
              e = E(e) && e > c && 360 > e - c ? e : c + 360;
              return {
                start: G * (c + -90),
                end: G * (e + -90)
              };
            };
          })(r || (r = {}));

          "";
          return r;
        });
        N(e, "Series/Pie/PiePoint.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = this && this.__extends || function () {
            var _c6 = function c(e, l) {
              _c6 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, f) {
                c.__proto__ = f;
              } || function (c, f) {
                for (var b in f) {
                  f.hasOwnProperty(b) && (c[b] = f[b]);
                }
              };

              return _c6(e, l);
            };

            return function (e, l) {
              function g() {
                this.constructor = e;
              }

              _c6(e, l);

              e.prototype = null === l ? Object.create(l) : (g.prototype = l.prototype, new g());
            };
          }(),
              B = e.setAnimation,
              E = D.addEvent,
              I = D.defined;

          e = D.extend;
          var y = D.isNumber,
              r = D.pick,
              q = D.relativeLength;

          n = function (c) {
            function e() {
              var e = null !== c && c.apply(this, arguments) || this;
              e.labelDistance = void 0;
              e.options = void 0;
              e.series = void 0;
              return e;
            }

            G(e, c);

            e.prototype.getConnectorPath = function () {
              var c = this.labelPosition,
                  e = this.series.options.dataLabels,
                  f = this.connectorShapes,
                  b = e.connectorShape;
              f[b] && (b = f[b]);
              return b.call(this, {
                x: c["final"].x,
                y: c["final"].y,
                alignment: c.alignment
              }, c.connectorPosition, e);
            };

            e.prototype.getTranslate = function () {
              return this.sliced ? this.slicedTranslation : {
                translateX: 0,
                translateY: 0
              };
            };

            e.prototype.haloPath = function (c) {
              var e = this.shapeArgs;
              return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + c, e.r + c, {
                innerR: e.r - 1,
                start: e.start,
                end: e.end
              });
            };

            e.prototype.init = function () {
              var e = this;
              c.prototype.init.apply(this, arguments);
              this.name = r(this.name, "Slice");

              var g = function g(c) {
                e.slice("select" === c.type);
              };

              E(this, "select", g);
              E(this, "unselect", g);
              return this;
            };

            e.prototype.isValid = function () {
              return y(this.y) && 0 <= this.y;
            };

            e.prototype.setVisible = function (c, e) {
              var f = this,
                  b = this.series,
                  g = b.chart,
                  l = b.options.ignoreHiddenPoint;
              e = r(e, l);
              c !== this.visible && (this.visible = this.options.visible = c = "undefined" === typeof c ? !this.visible : c, b.options.data[b.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (b) {
                if (f[b]) f[b][c ? "show" : "hide"](c);
              }), this.legendItem && g.legend.colorizeItem(this, c), c || "hover" !== this.state || this.setState(""), l && (b.isDirty = !0), e && g.redraw());
            };

            e.prototype.slice = function (c, e, f) {
              var b = this.series;
              B(f, b.chart);
              r(e, !0);
              this.sliced = this.options.sliced = I(c) ? c : !this.sliced;
              b.options.data[b.data.indexOf(this)] = this.options;
              this.graphic && this.graphic.animate(this.getTranslate());
              this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };

            return e;
          }(n);

          e(n.prototype, {
            connectorShapes: {
              fixedOffset: function fixedOffset(c, e, l) {
                var g = e.breakAt;
                e = e.touchingSliceAt;
                return [["M", c.x, c.y], l.softConnector ? ["C", c.x + ("left" === c.alignment ? -5 : 5), c.y, 2 * g.x - e.x, 2 * g.y - e.y, g.x, g.y] : ["L", g.x, g.y], ["L", e.x, e.y]];
              },
              straight: function straight(c, e) {
                e = e.touchingSliceAt;
                return [["M", c.x, c.y], ["L", e.x, e.y]];
              },
              crookedLine: function crookedLine(c, e, l) {
                e = e.touchingSliceAt;
                var g = this.series,
                    f = g.center[0],
                    b = g.chart.plotWidth,
                    w = g.chart.plotLeft;
                g = c.alignment;
                var r = this.shapeArgs.r;
                l = q(l.crookDistance, 1);
                b = "left" === g ? f + r + (b + w - f - r) * (1 - l) : w + (f - r) * l;
                l = ["L", b, c.y];
                f = !0;
                if ("left" === g ? b > c.x || b < e.x : b < c.x || b > e.x) f = !1;
                c = [["M", c.x, c.y]];
                f && c.push(l);
                c.push(["L", e.x, e.y]);
                return c;
              }
            }
          });
          return n;
        });
        N(e, "Series/Pie/PieSeries.js", [e["Series/CenteredUtilities.js"], e["Series/Column/ColumnSeries.js"], e["Core/Globals.js"], e["Core/Legend/LegendSymbol.js"], e["Series/Pie/PiePoint.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E, I, y, r) {
          var q = this && this.__extends || function () {
            var _b4 = function b(c, f) {
              _b4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var f in c) {
                  c.hasOwnProperty(f) && (b[f] = c[f]);
                }
              };

              return _b4(c, f);
            };

            return function (c, f) {
              function e() {
                this.constructor = c;
              }

              _b4(c, f);

              c.prototype = null === f ? Object.create(f) : (e.prototype = f.prototype, new e());
            };
          }(),
              c = e.getStartAndEndRadians;

          D = D.noop;
          var g = r.clamp,
              l = r.extend,
              x = r.fireEvent,
              f = r.merge,
              b = r.pick,
              w = r.relativeLength;

          r = function (e) {
            function l() {
              var b = null !== e && e.apply(this, arguments) || this;
              b.center = void 0;
              b.data = void 0;
              b.maxLabelDistance = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            q(l, e);

            l.prototype.animate = function (c) {
              var f = this,
                  e = f.points,
                  g = f.startAngleRad;
              c || e.forEach(function (a) {
                var c = a.graphic,
                    d = a.shapeArgs;
                c && d && (c.attr({
                  r: b(a.startR, f.center && f.center[3] / 2),
                  start: g,
                  end: g
                }), c.animate({
                  r: d.r,
                  start: d.start,
                  end: d.end
                }, f.options.animation));
              });
            };

            l.prototype.drawEmpty = function () {
              var b = this.startAngleRad,
                  c = this.endAngleRad,
                  f = this.options;

              if (0 === this.total && this.center) {
                var e = this.center[0];
                var a = this.center[1];
                this.graph || (this.graph = this.chart.renderer.arc(e, a, this.center[1] / 2, 0, b, c).addClass("highcharts-empty-series").add(this.group));
                this.graph.attr({
                  d: y.arc(e, a, this.center[2] / 2, 0, {
                    start: b,
                    end: c,
                    innerR: this.center[3] / 2
                  })
                });
                this.chart.styledMode || this.graph.attr({
                  "stroke-width": f.borderWidth,
                  fill: f.fillColor || "none",
                  stroke: f.color || "#cccccc"
                });
              } else this.graph && (this.graph = this.graph.destroy());
            };

            l.prototype.drawPoints = function () {
              var b = this.chart.renderer;
              this.points.forEach(function (c) {
                c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
                c.graphic || (c.graphic = b[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
              });
            };

            l.prototype.generatePoints = function () {
              e.prototype.generatePoints.call(this);
              this.updateTotals();
            };

            l.prototype.getX = function (b, c, f) {
              var e = this.center,
                  a = this.radii ? this.radii[f.index] || 0 : e[2] / 2;
              b = Math.asin(g((b - e[1]) / (a + f.labelDistance), -1, 1));
              return e[0] + (c ? -1 : 1) * Math.cos(b) * (a + f.labelDistance) + (0 < f.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
            };

            l.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            l.prototype.redrawPoints = function () {
              var b = this,
                  c = b.chart,
                  e = c.renderer,
                  g = b.options.shadow,
                  a,
                  l,
                  d,
                  w;
              this.drawEmpty();
              !g || b.shadowGroup || c.styledMode || (b.shadowGroup = e.g("shadow").attr({
                zIndex: -1
              }).add(b.group));
              b.points.forEach(function (m) {
                var h = {};
                l = m.graphic;

                if (!m.isNull && l) {
                  var k = void 0;
                  w = m.shapeArgs;
                  a = m.getTranslate();
                  c.styledMode || (k = m.shadowGroup, g && !k && (k = m.shadowGroup = e.g("shadow").add(b.shadowGroup)), k && k.attr(a), d = b.pointAttribs(m, m.selected && "select"));
                  m.delayedRendering ? (l.setRadialReference(b.center).attr(w).attr(a), c.styledMode || l.attr(d).attr({
                    "stroke-linejoin": "round"
                  }).shadow(g, k), m.delayedRendering = !1) : (l.setRadialReference(b.center), c.styledMode || f(!0, h, d), f(!0, h, w, a), l.animate(h));
                  l.attr({
                    visibility: m.visible ? "inherit" : "hidden"
                  });
                  l.addClass(m.getClassName(), !0);
                } else l && (m.graphic = l.destroy());
              });
            };

            l.prototype.sortByAngle = function (b, c) {
              b.sort(function (b, f) {
                return "undefined" !== typeof b.angle && (f.angle - b.angle) * c;
              });
            };

            l.prototype.translate = function (f) {
              x(this, "translate");
              this.generatePoints();
              var e = this.options,
                  g = e.slicedOffset,
                  l = g + (e.borderWidth || 0),
                  a = c(e.startAngle, e.endAngle),
                  q = this.startAngleRad = a.start;
              a = (this.endAngleRad = a.end) - q;
              var d = this.points,
                  r = e.dataLabels.distance;
              e = e.ignoreHiddenPoint;
              var k = d.length,
                  h,
                  n = 0;
              f || (this.center = f = this.getCenter());

              for (h = 0; h < k; h++) {
                var C = d[h];
                var u = q + n * a;
                !C.isValid() || e && !C.visible || (n += C.percentage / 100);
                var A = q + n * a;
                var y = {
                  x: f[0],
                  y: f[1],
                  r: f[2] / 2,
                  innerR: f[3] / 2,
                  start: Math.round(1E3 * u) / 1E3,
                  end: Math.round(1E3 * A) / 1E3
                };
                C.shapeType = "arc";
                C.shapeArgs = y;
                C.labelDistance = b(C.options.dataLabels && C.options.dataLabels.distance, r);
                C.labelDistance = w(C.labelDistance, y.r);
                this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, C.labelDistance);
                A = (A + u) / 2;
                A > 1.5 * Math.PI ? A -= 2 * Math.PI : A < -Math.PI / 2 && (A += 2 * Math.PI);
                C.slicedTranslation = {
                  translateX: Math.round(Math.cos(A) * g),
                  translateY: Math.round(Math.sin(A) * g)
                };
                y = Math.cos(A) * f[2] / 2;
                var J = Math.sin(A) * f[2] / 2;
                C.tooltipPos = [f[0] + .7 * y, f[1] + .7 * J];
                C.half = A < -Math.PI / 2 || A > Math.PI / 2 ? 1 : 0;
                C.angle = A;
                u = Math.min(l, C.labelDistance / 5);
                C.labelPosition = {
                  natural: {
                    x: f[0] + y + Math.cos(A) * C.labelDistance,
                    y: f[1] + J + Math.sin(A) * C.labelDistance
                  },
                  "final": {},
                  alignment: 0 > C.labelDistance ? "center" : C.half ? "right" : "left",
                  connectorPosition: {
                    breakAt: {
                      x: f[0] + y + Math.cos(A) * u,
                      y: f[1] + J + Math.sin(A) * u
                    },
                    touchingSliceAt: {
                      x: f[0] + y,
                      y: f[1] + J
                    }
                  }
                };
              }

              x(this, "afterTranslate");
            };

            l.prototype.updateTotals = function () {
              var b = this.points,
                  c = b.length,
                  f = this.options.ignoreHiddenPoint,
                  e,
                  a = 0;

              for (e = 0; e < c; e++) {
                var g = b[e];
                !g.isValid() || f && !g.visible || (a += g.y);
              }

              this.total = a;

              for (e = 0; e < c; e++) {
                g = b[e], g.percentage = 0 < a && (g.visible || !f) ? g.y / a * 100 : 0, g.total = a;
              }
            };

            l.defaultOptions = f(E.defaultOptions, {
              center: [null, null],
              clip: !1,
              colorByPoint: !0,
              dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0
              },
              fillColor: void 0,
              ignoreHiddenPoint: !0,
              inactiveOtherPoints: !0,
              legendType: "point",
              marker: null,
              size: null,
              showInLegend: !1,
              slicedOffset: 10,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0
              },
              borderColor: "#ffffff",
              borderWidth: 1,
              lineWidth: void 0,
              states: {
                hover: {
                  brightness: .1
                }
              }
            });
            return l;
          }(E);

          l(r.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: H.drawRectangle,
            drawTracker: n.prototype.drawTracker,
            getCenter: e.getCenter,
            getSymbol: D,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: n.prototype.pointAttribs,
            pointClass: B,
            requireSorting: !1,
            searchPoint: D,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          I.registerSeriesType("pie", r);
          "";
          return r;
        });
        N(e, "Series/Pie/PieDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D, H, B) {
          var G = n.noop,
              I = D.distribute,
              y = H.series,
              r = B.arrayMax,
              q = B.clamp,
              c = B.defined,
              g = B.merge,
              l = B.pick,
              x = B.relativeLength,
              f;

          (function (b) {
            function f() {
              var b = this,
                  f = b.data,
                  a = b.chart,
                  e = b.options.dataLabels || {},
                  d = e.connectorPadding,
                  p = a.plotWidth,
                  k = a.plotHeight,
                  h = a.plotLeft,
                  w = Math.round(a.chartWidth / 3),
                  q = b.center,
                  u = q[2] / 2,
                  A = q[1],
                  n = [[], []],
                  x = [0, 0, 0, 0],
                  v = b.dataLabelPositioners,
                  M,
                  C,
                  J,
                  G,
                  K,
                  B,
                  E,
                  D,
                  H,
                  N,
                  V,
                  S;
              b.visible && (e.enabled || b._hasPointLabels) && (f.forEach(function (a) {
                a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
                  width: "auto"
                }).css({
                  width: "auto",
                  textOverflow: "clip"
                }), a.dataLabel.shortened = !1);
              }), y.prototype.drawDataLabels.apply(b), f.forEach(function (a) {
                a.dataLabel && (a.visible ? (n[a.half].push(a), a.dataLabel._pos = null, !c(e.style.width) && !c(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > w && (a.dataLabel.css({
                  width: Math.round(.7 * w) + "px"
                }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
              }), n.forEach(function (f, g) {
                var m = f.length,
                    t = [],
                    w;

                if (m) {
                  b.sortByAngle(f, g - .5);

                  if (0 < b.maxLabelDistance) {
                    var r = Math.max(0, A - u - b.maxLabelDistance);
                    var n = Math.min(A + u + b.maxLabelDistance, a.plotHeight);
                    f.forEach(function (b) {
                      0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, A - u - b.labelDistance), b.bottom = Math.min(A + u + b.labelDistance, a.plotHeight), w = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                        target: b.labelPosition.natural.y - b.top + w / 2,
                        size: w,
                        rank: b.y
                      }, t.push(b.distributeBox));
                    });
                    r = n + w - r;
                    I(t, r, r / 5);
                  }

                  for (V = 0; V < m; V++) {
                    M = f[V];
                    B = M.labelPosition;
                    G = M.dataLabel;
                    N = !1 === M.visible ? "hidden" : "inherit";
                    H = r = B.natural.y;
                    t && c(M.distributeBox) && ("undefined" === typeof M.distributeBox.pos ? N = "hidden" : (E = M.distributeBox.size, H = v.radialDistributionY(M)));
                    delete M.positionIndex;
                    if (e.justify) D = v.justify(M, u, q);else switch (e.alignTo) {
                      case "connectors":
                        D = v.alignToConnectors(f, g, p, h);
                        break;

                      case "plotEdges":
                        D = v.alignToPlotEdges(G, g, p, h);
                        break;

                      default:
                        D = v.radialDistributionX(b, M, H, r);
                    }
                    G._attr = {
                      visibility: N,
                      align: B.alignment
                    };
                    S = M.options.dataLabels || {};
                    G._pos = {
                      x: D + l(S.x, e.x) + ({
                        left: d,
                        right: -d
                      }[B.alignment] || 0),
                      y: H + l(S.y, e.y) - 10
                    };
                    B["final"].x = D;
                    B["final"].y = H;
                    l(e.crop, !0) && (K = G.getBBox().width, r = null, D - K < d && 1 === g ? (r = Math.round(K - D + d), x[3] = Math.max(r, x[3])) : D + K > p - d && 0 === g && (r = Math.round(D + K - p + d), x[1] = Math.max(r, x[1])), 0 > H - E / 2 ? x[0] = Math.max(Math.round(-H + E / 2), x[0]) : H + E / 2 > k && (x[2] = Math.max(Math.round(H + E / 2 - k), x[2])), G.sideOverflow = r);
                  }
                }
              }), 0 === r(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach(function (d) {
                S = g(e, d.options.dataLabels);

                if (C = l(S.connectorWidth, 1)) {
                  var c;
                  J = d.connector;

                  if ((G = d.dataLabel) && G._pos && d.visible && 0 < d.labelDistance) {
                    N = G._attr.visibility;
                    if (c = !J) d.connector = J = a.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + d.colorIndex + (d.className ? " " + d.className : "")).add(b.dataLabelsGroup), a.styledMode || J.attr({
                      "stroke-width": C,
                      stroke: S.connectorColor || d.color || "#666666"
                    });
                    J[c ? "attr" : "animate"]({
                      d: d.getConnectorPath()
                    });
                    J.attr("visibility", N);
                  } else J && (d.connector = J.destroy());
                }
              }));
            }

            function n() {
              this.points.forEach(function (b) {
                var c = b.dataLabel,
                    a;
                c && b.visible && ((a = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
                  width: c._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](a), c.moved = !0) : c && c.attr({
                  y: -9999
                }));
                delete b.distributeBox;
              }, this);
            }

            function C(b) {
              var c = this.center,
                  a = this.options,
                  f = a.center,
                  d = a.minSize || 80,
                  e = null !== a.size;

              if (!e) {
                if (null !== f[0]) var g = Math.max(c[2] - Math.max(b[1], b[3]), d);else g = Math.max(c[2] - b[1] - b[3], d), c[0] += (b[3] - b[1]) / 2;
                null !== f[1] ? g = q(g, d, c[2] - Math.max(b[0], b[2])) : (g = q(g, d, c[2] - b[0] - b[2]), c[1] += (b[0] - b[2]) / 2);
                g < c[2] ? (c[2] = g, c[3] = Math.min(a.thickness ? Math.max(0, g - 2 * a.thickness) : Math.max(0, x(a.innerSize || 0, g)), g), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : e = !0;
              }

              return e;
            }

            var K = [],
                p = {
              radialDistributionY: function radialDistributionY(b) {
                return b.top + b.distributeBox.pos;
              },
              radialDistributionX: function radialDistributionX(b, c, a, f) {
                return b.getX(a < c.top + 2 || a > c.bottom - 2 ? f : a, c.half, c);
              },
              justify: function justify(b, c, a) {
                return a[0] + (b.half ? -1 : 1) * (c + b.labelDistance);
              },
              alignToPlotEdges: function alignToPlotEdges(b, c, a, f) {
                b = b.getBBox().width;
                return c ? b + f : a - b - f;
              },
              alignToConnectors: function alignToConnectors(b, c, a, f) {
                var d = 0,
                    e;
                b.forEach(function (a) {
                  e = a.dataLabel.getBBox().width;
                  e > d && (d = e);
                });
                return c ? d + f : a - d - f;
              }
            };

            b.compose = function (b) {
              e.compose(y);
              -1 === K.indexOf(b) && (K.push(b), b = b.prototype, b.dataLabelPositioners = p, b.alignDataLabel = G, b.drawDataLabels = f, b.placeDataLabels = n, b.verifyDataLabelOverflow = C);
            };
          })(f || (f = {}));

          return f;
        });
        N(e, "Extensions/OverlappingDataLabels.js", [e["Core/Chart/Chart.js"], e["Core/Utilities.js"]], function (e, n) {
          function G(e, c) {
            var g = !1;

            if (e) {
              var l = e.newOpacity;
              e.oldOpacity !== l && (e.alignAttr && e.placed ? (e[l ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), g = !0, e.alignAttr.opacity = l, e[e.isOld ? "animate" : "attr"](e.alignAttr, null, function () {
                c.styledMode || e.css({
                  pointerEvents: l ? "auto" : "none"
                });
              }), B(c, "afterHideOverlappingLabel")) : e.attr({
                opacity: l
              }));
              e.isOld = !0;
            }

            return g;
          }

          var H = n.addEvent,
              B = n.fireEvent,
              E = n.isArray,
              I = n.isNumber,
              y = n.objectEach,
              r = n.pick;
          H(e, "render", function () {
            var e = this,
                c = [];
            (this.labelCollectors || []).forEach(function (e) {
              c = c.concat(e());
            });
            (this.yAxis || []).forEach(function (e) {
              e.stacking && e.options.stackLabels && !e.options.stackLabels.allowOverlap && y(e.stacking.stacks, function (e) {
                y(e, function (e) {
                  e.label && c.push(e.label);
                });
              });
            });
            (this.series || []).forEach(function (g) {
              var l = g.options.dataLabels;
              g.visible && (!1 !== l.enabled || g._hasPointLabels) && (l = function l(g) {
                return g.forEach(function (f) {
                  f.visible && (E(f.dataLabels) ? f.dataLabels : f.dataLabel ? [f.dataLabel] : []).forEach(function (b) {
                    var g = b.options;
                    b.labelrank = r(g.labelrank, f.labelrank, f.shapeArgs && f.shapeArgs.height);
                    g.allowOverlap ? (b.oldOpacity = b.opacity, b.newOpacity = 1, G(b, e)) : c.push(b);
                  });
                });
              }, l(g.nodes || []), l(g.points));
            });
            this.hideOverlappingLabels(c);
          });

          e.prototype.hideOverlappingLabels = function (e) {
            var c = this,
                g = e.length,
                l = c.renderer,
                q,
                f,
                b,
                w = !1;

            var r = function r(b) {
              var c,
                  f = b.box ? 0 : b.padding || 0,
                  a = c = 0,
                  e;

              if (b && (!b.alignAttr || b.placed)) {
                var d = b.alignAttr || {
                  x: b.attr("x"),
                  y: b.attr("y")
                };
                var g = b.parentGroup;
                b.width || (c = b.getBBox(), b.width = c.width, b.height = c.height, c = l.fontMetrics(null, b.element).h);
                var k = b.width - 2 * f;
                (e = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[b.alignValue]) ? a = +e * k : I(b.x) && Math.round(b.x) !== b.translateX && (a = b.x - b.translateX);
                return {
                  x: d.x + (g.translateX || 0) + f - (a || 0),
                  y: d.y + (g.translateY || 0) + f - c,
                  width: b.width - 2 * f,
                  height: b.height - 2 * f
                };
              }
            };

            for (f = 0; f < g; f++) {
              if (q = e[f]) q.oldOpacity = q.opacity, q.newOpacity = 1, q.absoluteBox = r(q);
            }

            e.sort(function (b, c) {
              return (c.labelrank || 0) - (b.labelrank || 0);
            });

            for (f = 0; f < g; f++) {
              var n = (r = e[f]) && r.absoluteBox;

              for (q = f + 1; q < g; ++q) {
                var y = (b = e[q]) && b.absoluteBox;
                !n || !y || r === b || 0 === r.newOpacity || 0 === b.newOpacity || "hidden" === r.visibility || "hidden" === b.visibility || y.x >= n.x + n.width || y.x + y.width <= n.x || y.y >= n.y + n.height || y.y + y.height <= n.y || ((r.labelrank < b.labelrank ? r : b).newOpacity = 0);
              }
            }

            e.forEach(function (b) {
              G(b, c) && (w = !0);
            });
            w && B(c, "afterHideAllOverlappingLabels");
          };
        });
        N(e, "Core/Responsive.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.extend,
              G = e.find,
              H = e.isArray,
              B = e.isObject,
              E = e.merge,
              I = e.objectEach,
              y = e.pick,
              r = e.splat,
              q = e.uniqueKey,
              c;

          (function (c) {
            var e = [];

            c.compose = function (c) {
              -1 === e.indexOf(c) && (e.push(c), n(c.prototype, g.prototype));
              return c;
            };

            var g = function () {
              function c() {}

              c.prototype.currentOptions = function (b) {
                function c(b, e, g, l) {
                  var a;
                  I(b, function (b, d) {
                    if (!l && -1 < f.collectionsWithUpdate.indexOf(d) && e[d]) for (b = r(b), g[d] = [], a = 0; a < Math.max(b.length, e[d].length); a++) {
                      e[d][a] && (void 0 === b[a] ? g[d][a] = e[d][a] : (g[d][a] = {}, c(b[a], e[d][a], g[d][a], l + 1)));
                    } else B(b) ? (g[d] = H(b) ? [] : {}, c(b, e[d] || {}, g[d], l + 1)) : g[d] = "undefined" === typeof e[d] ? null : e[d];
                  });
                }

                var f = this,
                    e = {};
                c(b, this.options, e, 0);
                return e;
              };

              c.prototype.matchResponsiveRule = function (b, c) {
                var f = b.condition;
                (f.callback || function () {
                  return this.chartWidth <= y(f.maxWidth, Number.MAX_VALUE) && this.chartHeight <= y(f.maxHeight, Number.MAX_VALUE) && this.chartWidth >= y(f.minWidth, 0) && this.chartHeight >= y(f.minHeight, 0);
                }).call(this) && c.push(b._id);
              };

              c.prototype.setResponsive = function (b, c) {
                var f = this,
                    e = this.options.responsive,
                    g = this.currentResponsive,
                    p = [];
                !c && e && e.rules && e.rules.forEach(function (b) {
                  "undefined" === typeof b._id && (b._id = q());
                  f.matchResponsiveRule(b, p);
                }, this);
                c = E.apply(void 0, p.map(function (b) {
                  return G((e || {}).rules || [], function (c) {
                    return c._id === b;
                  });
                }).map(function (b) {
                  return b && b.chartOptions;
                }));
                c.isResponsiveOptions = !0;
                p = p.toString() || void 0;
                p !== (g && g.ruleIds) && (g && this.update(g.undoOptions, b, !0), p ? (g = this.currentOptions(c), g.isResponsiveOptions = !0, this.currentResponsive = {
                  ruleIds: p,
                  mergedOptions: c,
                  undoOptions: g
                }, this.update(c, b, !0)) : this.currentResponsive = void 0);
              };

              return c;
            }();
          })(c || (c = {}));

          "";
          "";
          return c;
        });
        N(e, "masters/highcharts.src.js", [e["Core/Globals.js"], e["Core/Utilities.js"], e["Core/DefaultOptions.js"], e["Core/Animation/Fx.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/FormatUtilities.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Renderer/HTML/HTMLElement.js"], e["Core/Renderer/HTML/HTMLRenderer.js"], e["Core/Axis/Axis.js"], e["Core/Axis/DateTimeAxis.js"], e["Core/Axis/LogarithmicAxis.js"], e["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], e["Core/Axis/Tick.js"], e["Core/Tooltip.js"], e["Core/Series/Point.js"], e["Core/Pointer.js"], e["Core/MSPointer.js"], e["Core/Legend/Legend.js"], e["Core/Chart/Chart.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Series/Column/ColumnSeries.js"], e["Series/Column/ColumnDataLabel.js"], e["Series/Pie/PieSeries.js"], e["Series/Pie/PieDataLabel.js"], e["Core/Series/DataLabel.js"], e["Core/Responsive.js"], e["Core/Color/Color.js"], e["Core/Time.js"]], function (e, n, D, H, B, E, I, y, r, q, c, g, l, x, f, b, w, J, C, K, p, m, t, a, z, d, F, k, h, L, P, u, A) {
          e.animate = B.animate;
          e.animObject = B.animObject;
          e.getDeferredAnimation = B.getDeferredAnimation;
          e.setAnimation = B.setAnimation;
          e.stop = B.stop;
          e.timers = H.timers;
          e.AST = E;
          e.Axis = l;
          e.Chart = t;
          e.chart = t.chart;
          e.Fx = H;
          e.Legend = m;
          e.PlotLineOrBand = b;
          e.Point = C;
          e.Pointer = p.isRequired() ? p : K;
          e.Series = a;
          e.SVGElement = r;
          e.SVGRenderer = q;
          e.Tick = w;
          e.Time = A;
          e.Tooltip = J;
          e.Color = u;
          e.color = u.parse;
          g.compose(q);
          c.compose(r);
          e.defaultOptions = D.defaultOptions;
          e.getOptions = D.getOptions;
          e.time = D.defaultTime;
          e.setOptions = D.setOptions;
          e.dateFormat = I.dateFormat;
          e.format = I.format;
          e.numberFormat = I.numberFormat;
          e.addEvent = n.addEvent;
          e.arrayMax = n.arrayMax;
          e.arrayMin = n.arrayMin;
          e.attr = n.attr;
          e.clearTimeout = n.clearTimeout;
          e.correctFloat = n.correctFloat;
          e.createElement = n.createElement;
          e.css = n.css;
          e.defined = n.defined;
          e.destroyObjectProperties = n.destroyObjectProperties;
          e.discardElement = n.discardElement;
          e.distribute = y.distribute;
          e.erase = n.erase;
          e.error = n.error;
          e.extend = n.extend;
          e.extendClass = n.extendClass;
          e.find = n.find;
          e.fireEvent = n.fireEvent;
          e.getMagnitude = n.getMagnitude;
          e.getStyle = n.getStyle;
          e.inArray = n.inArray;
          e.isArray = n.isArray;
          e.isClass = n.isClass;
          e.isDOMElement = n.isDOMElement;
          e.isFunction = n.isFunction;
          e.isNumber = n.isNumber;
          e.isObject = n.isObject;
          e.isString = n.isString;
          e.keys = n.keys;
          e.merge = n.merge;
          e.normalizeTickInterval = n.normalizeTickInterval;
          e.objectEach = n.objectEach;
          e.offset = n.offset;
          e.pad = n.pad;
          e.pick = n.pick;
          e.pInt = n.pInt;
          e.relativeLength = n.relativeLength;
          e.removeEvent = n.removeEvent;
          e.seriesType = z.seriesType;
          e.splat = n.splat;
          e.stableSort = n.stableSort;
          e.syncTimeout = n.syncTimeout;
          e.timeUnits = n.timeUnits;
          e.uniqueKey = n.uniqueKey;
          e.useSerialIds = n.useSerialIds;
          e.wrap = n.wrap;
          F.compose(d);
          L.compose(a);
          x.compose(l);
          f.compose(l);
          h.compose(k);
          b.compose(l);
          P.compose(t);
          return e;
        });
        N(e, "Series/XRange/XRangePoint.js", [e["Core/Series/Point.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = this && this.__extends || function () {
            var _e9 = function e(n, B) {
              _e9 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, r) {
                e.__proto__ = r;
              } || function (e, r) {
                for (var q in r) {
                  r.hasOwnProperty(q) && (e[q] = r[q]);
                }
              };

              return _e9(n, B);
            };

            return function (n, B) {
              function y() {
                this.constructor = n;
              }

              _e9(n, B);

              n.prototype = null === B ? Object.create(B) : (y.prototype = B.prototype, new y());
            };
          }();

          D = D.extend;

          n = function (n) {
            function B() {
              var e = null !== n && n.apply(this, arguments) || this;
              e.options = void 0;
              e.series = void 0;
              return e;
            }

            G(B, n);

            B.getColorByCategory = function (e, n) {
              var r = e.options.colors || e.chart.options.colors;
              e = n.y % (r ? r.length : e.chart.options.chart.colorCount);
              return {
                colorIndex: e,
                color: r && r[e]
              };
            };

            B.prototype.resolveColor = function () {
              var e = this.series;

              if (e.options.colorByPoint && !this.options.color) {
                var n = B.getColorByCategory(e, this);
                e.chart.styledMode || (this.color = n.color);
                this.options.colorIndex || (this.colorIndex = n.colorIndex);
              } else this.color || (this.color = e.color);
            };

            B.prototype.init = function () {
              e.prototype.init.apply(this, arguments);
              this.y || (this.y = 0);
              return this;
            };

            B.prototype.setState = function () {
              e.prototype.setState.apply(this, arguments);
              this.series.drawPoint(this, this.series.getAnimationVerb());
            };

            B.prototype.getLabelConfig = function () {
              var n = e.prototype.getLabelConfig.call(this),
                  y = this.series.yAxis.categories;
              n.x2 = this.x2;
              n.yCategory = this.yCategory = y && y[this.y];
              return n;
            };

            B.prototype.isValid = function () {
              return "number" === typeof this.x && "number" === typeof this.x2;
            };

            return B;
          }(n.seriesTypes.column.prototype.pointClass);

          D(n.prototype, {
            ttBelow: !1,
            tooltipDateKeys: ["x", "x2"]
          });
          return n;
        });
        N(e, "Series/XRange/XRangeComposition.js", [e["Core/Axis/Axis.js"], e["Core/Utilities.js"]], function (e, n) {
          var D = n.addEvent,
              G = n.pick;
          D(e, "afterGetSeriesExtremes", function () {
            var e = this.series,
                n;

            if (this.isXAxis) {
              var I = G(this.dataMax, -Number.MAX_VALUE);
              e.forEach(function (e) {
                e.x2Data && e.x2Data.forEach(function (e) {
                  e > I && (I = e, n = !0);
                });
              });
              n && (this.dataMax = I);
            }
          });
        });
        N(e, "Series/XRange/XRangeSeries.js", [e["Core/Globals.js"], e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"], e["Series/XRange/XRangePoint.js"]], function (e, n, D, H, B) {
          var E = this && this.__extends || function () {
            var _b5 = function b(c, e) {
              _b5 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var a in c) {
                  c.hasOwnProperty(a) && (b[a] = c[a]);
                }
              };

              return _b5(c, e);
            };

            return function (c, e) {
              function f() {
                this.constructor = c;
              }

              _b5(c, e);

              c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
            };
          }(),
              I = n.parse,
              y = D.series,
              r = D.seriesTypes.column,
              q = r.prototype,
              c = H.clamp,
              g = H.correctFloat,
              l = H.defined;

          n = H.extend;
          var x = H.find,
              f = H.isNumber,
              b = H.isObject,
              w = H.merge,
              J = H.pick;

          H = function (e) {
            function n() {
              var b = null !== e && e.apply(this, arguments) || this;
              b.data = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            E(n, e);

            n.prototype.init = function () {
              r.prototype.init.apply(this, arguments);
              this.options.stacking = void 0;
            };

            n.prototype.getColumnMetrics = function () {
              function b() {
                c.series.forEach(function (a) {
                  var b = a.xAxis;
                  a.xAxis = a.yAxis;
                  a.yAxis = b;
                });
              }

              var c = this.chart;
              b();
              var e = q.getColumnMetrics.call(this);
              b();
              return e;
            };

            n.prototype.cropData = function (b, c, e, a) {
              c = y.prototype.cropData.call(this, this.x2Data, c, e, a);
              c.xData = b.slice(c.start, c.end);
              return c;
            };

            n.prototype.findPointIndex = function (b) {
              var c = this.cropped,
                  e = this.cropStart,
                  a = this.points,
                  g = b.id;
              if (g) var d = (d = x(a, function (a) {
                return a.id === g;
              })) ? d.index : void 0;
              "undefined" === typeof d && (d = (d = x(a, function (a) {
                return a.x === b.x && a.x2 === b.x2 && !a.touched;
              })) ? d.index : void 0);
              c && f(d) && f(e) && d >= e && (d -= e);
              return d;
            };

            n.prototype.translatePoint = function (e) {
              var g = this.xAxis,
                  p = this.yAxis,
                  a = this.columnMetrics,
                  q = this.options,
                  d = q.minPointLength || 0,
                  r = (e.shapeArgs && e.shapeArgs.width || 0) / 2,
                  k = this.pointXOffset = a.offset,
                  h = e.plotX,
                  n = J(e.x2, e.x + (e.len || 0)),
                  x = g.translate(n, 0, 0, 0, 1);
              n = Math.abs(x - h);
              var u = this.chart.inverted,
                  A = J(q.borderWidth, 1) % 2 / 2,
                  C = a.offset,
                  y = Math.round(a.width);
              d && (d -= n, 0 > d && (d = 0), h -= d / 2, x += d / 2);
              h = Math.max(h, -10);
              x = c(x, -10, g.len + 10);
              l(e.options.pointWidth) && (C -= (Math.ceil(e.options.pointWidth) - y) / 2, y = Math.ceil(e.options.pointWidth));
              q.pointPlacement && f(e.plotY) && p.categories && (e.plotY = p.translate(e.y, 0, 1, 0, 1, q.pointPlacement));
              q = Math.floor(Math.min(h, x)) + A;
              q = {
                x: q,
                y: Math.floor(e.plotY + C) + A,
                width: Math.floor(Math.max(h, x)) + A - q,
                height: y,
                r: this.options.borderRadius
              };
              e.shapeArgs = q;
              u ? e.tooltipPos[1] += k + r : e.tooltipPos[0] -= r + k - q.width / 2;
              r = q.x;
              k = r + q.width;
              0 > r || k > g.len ? (r = c(r, 0, g.len), k = c(k, 0, g.len), x = k - r, e.dlBox = w(q, {
                x: r,
                width: k - r,
                centerX: x ? x / 2 : null
              })) : e.dlBox = null;
              r = e.tooltipPos;
              k = u ? 1 : 0;
              x = u ? 0 : 1;
              a = this.columnMetrics ? this.columnMetrics.offset : -a.width / 2;
              r[k] = u ? r[k] + q.width / 2 : r[k] + (g.reversed ? -1 : 0) * q.width;
              r[x] = c(r[x] + (u ? -1 : 1) * a, 0, p.len - 1);
              if (p = e.partialFill) b(p) && (p = p.amount), f(p) || (p = 0), e.partShapeArgs = w(q, {
                r: this.options.borderRadius
              }), h = Math.max(Math.round(n * p + e.plotX - h), 0), e.clipRectArgs = {
                x: g.reversed ? q.x + n - h : q.x,
                y: q.y,
                width: h,
                height: q.height
              };
            };

            n.prototype.translate = function () {
              q.translate.apply(this, arguments);
              this.points.forEach(function (b) {
                this.translatePoint(b);
              }, this);
            };

            n.prototype.drawPoint = function (c, e) {
              var f = this.options,
                  a = this.chart.renderer,
                  g = c.graphic,
                  d = c.shapeType,
                  m = c.shapeArgs,
                  k = c.partShapeArgs,
                  h = c.clipRectArgs,
                  p = c.partialFill,
                  l = f.stacking && !f.borderRadius,
                  u = c.state,
                  A = f.states[u || "normal"] || {},
                  q = "undefined" === typeof u ? "attr" : e;
              u = this.pointAttribs(c, u);
              A = J(this.chart.options.chart.animation, A.animation);
              if (c.isNull || !1 === c.visible) g && (c.graphic = g.destroy());else {
                if (g) g.rect[e](m);else c.graphic = g = a.g("point").addClass(c.getClassName()).add(c.group || this.group), g.rect = a[d](w(m)).addClass(c.getClassName()).addClass("highcharts-partfill-original").add(g);
                k && (g.partRect ? (g.partRect[e](w(k)), g.partialClipRect[e](w(h))) : (g.partialClipRect = a.clipRect(h.x, h.y, h.width, h.height), g.partRect = a[d](k).addClass("highcharts-partfill-overlay").add(g).clip(g.partialClipRect)));
                this.chart.styledMode || (g.rect[e](u, A).shadow(f.shadow, null, l), k && (b(p) || (p = {}), b(f.partialFill) && (p = w(f.partialFill, p)), c = p.fill || I(u.fill).brighten(-.3).get() || I(c.color || this.color).brighten(-.3).get(), u.fill = c, g.partRect[q](u, A).shadow(f.shadow, null, l)));
              }
            };

            n.prototype.drawPoints = function () {
              var b = this,
                  c = b.getAnimationVerb();
              b.points.forEach(function (e) {
                b.drawPoint(e, c);
              });
            };

            n.prototype.getAnimationVerb = function () {
              return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
            };

            n.prototype.isPointInside = function (b) {
              var c = b.shapeArgs,
                  f = b.plotX,
                  a = b.plotY;
              return c ? "undefined" !== typeof f && "undefined" !== typeof a && 0 <= a && a <= this.yAxis.len && 0 <= (c.x || 0) + (c.width || 0) && f <= this.xAxis.len : e.prototype.isPointInside.apply(this, arguments);
            };

            n.defaultOptions = w(r.defaultOptions, {
              colorByPoint: !0,
              dataLabels: {
                formatter: function formatter() {
                  var c = this.point.partialFill;
                  b(c) && (c = c.amount);
                  if (f(c) && 0 < c) return g(100 * c) + "%";
                },
                inside: !0,
                verticalAlign: "middle"
              },
              tooltip: {
                headerFormat: '<span style="font-size: 10px">{point.x} - {point.x2}</span><br/>',
                pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>"
              },
              borderRadius: 3,
              pointRange: 0
            });
            return n;
          }(r);

          n(H.prototype, {
            type: "xrange",
            parallelArrays: ["x", "x2", "y"],
            requireSorting: !1,
            animate: y.prototype.animate,
            cropShoulder: 1,
            getExtremesFromAll: !0,
            autoIncrement: e.noop,
            buildKDTree: e.noop,
            pointClass: B
          });
          D.registerSeriesType("xrange", H);
          "";
          return H;
        });
        N(e, "Series/Gantt/GanttPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n) {
          var D = this && this.__extends || function () {
            var _e10 = function e(n, B) {
              _e10 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, r) {
                e.__proto__ = r;
              } || function (e, r) {
                for (var q in r) {
                  r.hasOwnProperty(q) && (e[q] = r[q]);
                }
              };

              return _e10(n, B);
            };

            return function (n, B) {
              function y() {
                this.constructor = n;
              }

              _e10(n, B);

              n.prototype = null === B ? Object.create(B) : (y.prototype = B.prototype, new y());
            };
          }(),
              G = n.pick;

          return function (e) {
            function n() {
              var n = null !== e && e.apply(this, arguments) || this;
              n.options = void 0;
              n.series = void 0;
              return n;
            }

            D(n, e);

            n.setGanttPointAliases = function (e) {
              function n(n, q) {
                "undefined" !== typeof q && (e[n] = q);
              }

              n("x", G(e.start, e.x));
              n("x2", G(e.end, e.x2));
              n("partialFill", G(e.completed, e.partialFill));
            };

            n.prototype.applyOptions = function (B, y) {
              B = e.prototype.applyOptions.call(this, B, y);
              n.setGanttPointAliases(B);
              return B;
            };

            n.prototype.isValid = function () {
              return ("number" === typeof this.start || "number" === typeof this.x) && ("number" === typeof this.end || "number" === typeof this.x2 || this.milestone);
            };

            return n;
          }(e.seriesTypes.xrange.prototype.pointClass);
        });
        N(e, "Core/Axis/BrokenAxis.js", [e["Extensions/Stacking.js"], e["Core/Utilities.js"]], function (e, n) {
          var D = n.addEvent,
              G = n.find,
              B = n.fireEvent,
              E = n.isArray,
              I = n.isNumber,
              y = n.pick,
              r;

          (function (q) {
            function c() {
              "undefined" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);
            }

            function g() {
              this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);
            }

            function l() {
              var b = this.brokenAxis;

              if (b && b.hasBreaks) {
                for (var c = this.tickPositions, e = this.tickPositions.info, a = [], f = 0; f < c.length; f++) {
                  b.isInAnyBreak(c[f]) || a.push(c[f]);
                }

                this.tickPositions = a;
                this.tickPositions.info = e;
              }
            }

            function n() {
              this.brokenAxis || (this.brokenAxis = new K(this));
            }

            function f() {
              var b = this.options.connectNulls,
                  c = this.points,
                  e = this.xAxis,
                  a = this.yAxis;
              if (this.isDirty) for (var f = c.length; f--;) {
                var d = c[f],
                    g = !(null === d.y && !1 === b) && (e && e.brokenAxis && e.brokenAxis.isInAnyBreak(d.x, !0) || a && a.brokenAxis && a.brokenAxis.isInAnyBreak(d.y, !0));
                d.visible = g ? !1 : !1 !== d.options.visible;
              }
            }

            function b() {
              this.drawBreaks(this.xAxis, ["x"]);
              this.drawBreaks(this.yAxis, y(this.pointArrayMap, ["y"]));
            }

            function w(b, c) {
              var e = this,
                  a = e.points,
                  f,
                  d,
                  g,
                  k;

              if (b && b.brokenAxis && b.brokenAxis.hasBreaks) {
                var h = b.brokenAxis;
                c.forEach(function (c) {
                  f = h && h.breakArray || [];
                  d = b.isXAxis ? b.min : y(e.options.threshold, b.min);
                  a.forEach(function (a) {
                    k = y(a["stack" + c.toUpperCase()], a[c]);
                    f.forEach(function (c) {
                      if (I(d) && I(k)) {
                        g = !1;
                        if (d < c.from && k > c.to || d > c.from && k < c.from) g = "pointBreak";else if (d < c.from && k > c.from && k < c.to || d > c.from && k > c.to && k < c.from) g = "pointInBreak";
                        g && B(b, g, {
                          point: a,
                          brk: c
                        });
                      }
                    });
                  });
                });
              }
            }

            function r() {
              var b = this.currentDataGrouping,
                  c = b && b.gapSize;
              b = this.points.slice();
              var f = this.yAxis,
                  a = this.options.gapSize,
                  g = b.length - 1,
                  d;
              if (a && 0 < g) for ("value" !== this.options.gapUnit && (a *= this.basePointRange), c && c > a && c >= this.basePointRange && (a = c), d = void 0; g--;) {
                d && !1 !== d.visible || (d = b[g + 1]), c = b[g], !1 !== d.visible && !1 !== c.visible && (d.x - c.x > a && (d = (c.x + d.x) / 2, b.splice(g + 1, 0, {
                  isNull: !0,
                  x: d
                }), f.stacking && this.options.stacking && (d = f.stacking.stacks[this.stackKey][d] = new e(f, f.options.stackLabels, !1, d, this.stack), d.total = 0)), d = c);
              }
              return this.getGraphPath(b);
            }

            var C = [];

            q.compose = function (e, m) {
              -1 === C.indexOf(e) && (C.push(e), e.keepProps.push("brokenAxis"), D(e, "init", n), D(e, "afterInit", c), D(e, "afterSetTickPositions", l), D(e, "afterSetOptions", g));

              if (-1 === C.indexOf(m)) {
                C.push(m);
                var p = m.prototype;
                p.drawBreaks = w;
                p.gappedPath = r;
                D(m, "afterGeneratePoints", f);
                D(m, "afterRender", b);
              }

              return e;
            };

            var K = function () {
              function b(b) {
                this.hasBreaks = !1;
                this.axis = b;
              }

              b.isInBreak = function (b, c) {
                var a = b.repeat || Infinity,
                    e = b.from,
                    d = b.to - b.from;
                c = c >= e ? (c - e) % a : a - (e - c) % a;
                return b.inclusive ? c <= d : c < d && 0 !== c;
              };

              b.lin2Val = function (c) {
                var e = this.brokenAxis;
                e = e && e.breakArray;
                if (!e || !I(c)) return c;
                var a;

                for (a = 0; a < e.length; a++) {
                  var f = e[a];
                  if (f.from >= c) break;else f.to < c ? c += f.len : b.isInBreak(f, c) && (c += f.len);
                }

                return c;
              };

              b.val2Lin = function (c) {
                var e = this.brokenAxis;
                e = e && e.breakArray;
                if (!e || !I(c)) return c;
                var a = c,
                    f;

                for (f = 0; f < e.length; f++) {
                  var d = e[f];
                  if (d.to <= c) a -= d.len;else if (d.from >= c) break;else if (b.isInBreak(d, c)) {
                    a -= c - d.from;
                    break;
                  }
                }

                return a;
              };

              b.prototype.findBreakAt = function (b, c) {
                return G(c, function (a) {
                  return a.from < b && b < a.to;
                });
              };

              b.prototype.isInAnyBreak = function (c, e) {
                var a = this.axis,
                    f = a.options.breaks || [],
                    d = f.length,
                    g;

                if (d && I(c)) {
                  for (; d--;) {
                    if (b.isInBreak(f[d], c)) {
                      var k = !0;
                      g || (g = y(f[d].showPoints, !a.isXAxis));
                    }
                  }

                  var h = k && e ? k && !g : k;
                }

                return h;
              };

              b.prototype.setBreaks = function (c, e) {
                var a = this,
                    f = a.axis,
                    d = E(c) && !!c.length;
                f.isDirty = a.hasBreaks !== d;
                a.hasBreaks = d;
                f.options.breaks = f.userOptions.breaks = c;
                f.forceRedraw = !0;
                f.series.forEach(function (a) {
                  a.isDirty = !0;
                });
                d || f.val2lin !== b.val2Lin || (delete f.val2lin, delete f.lin2val);
                d && (f.userOptions.ordinal = !1, f.lin2val = b.lin2Val, f.val2lin = b.val2Lin, f.setExtremes = function (b, c, d, e, g) {
                  if (a.hasBreaks) {
                    for (var h = this.options.breaks || [], k; k = a.findBreakAt(b, h);) {
                      b = k.to;
                    }

                    for (; k = a.findBreakAt(c, h);) {
                      c = k.from;
                    }

                    c < b && (c = b);
                  }

                  f.constructor.prototype.setExtremes.call(this, b, c, d, e, g);
                }, f.setAxisTranslation = function () {
                  f.constructor.prototype.setAxisTranslation.call(this);
                  a.unitLength = void 0;

                  if (a.hasBreaks) {
                    var c = f.options.breaks || [],
                        d = [],
                        e = [],
                        g = y(f.pointRangePadding, 0),
                        m = 0,
                        u,
                        l = f.userMin || f.min,
                        p = f.userMax || f.max,
                        q;
                    c.forEach(function (a) {
                      u = a.repeat || Infinity;
                      I(l) && I(p) && (b.isInBreak(a, l) && (l += a.to % u - l % u), b.isInBreak(a, p) && (p -= p % u - a.from % u));
                    });
                    c.forEach(function (a) {
                      w = a.from;
                      u = a.repeat || Infinity;

                      if (I(l) && I(p)) {
                        for (; w - u > l;) {
                          w -= u;
                        }

                        for (; w < l;) {
                          w += u;
                        }

                        for (q = w; q < p; q += u) {
                          d.push({
                            value: q,
                            move: "in"
                          }), d.push({
                            value: q + a.to - a.from,
                            move: "out",
                            size: a.breakSize
                          });
                        }
                      }
                    });
                    d.sort(function (a, b) {
                      return a.value === b.value ? ("in" === a.move ? 0 : 1) - ("in" === b.move ? 0 : 1) : a.value - b.value;
                    });
                    var v = 0;
                    var w = l;
                    d.forEach(function (a) {
                      v += "in" === a.move ? 1 : -1;
                      1 === v && "in" === a.move && (w = a.value);
                      0 === v && I(w) && (e.push({
                        from: w,
                        to: a.value,
                        len: a.value - w - (a.size || 0)
                      }), m += a.value - w - (a.size || 0));
                    });
                    a.breakArray = e;
                    I(l) && I(p) && I(f.min) && (a.unitLength = p - l - m + g, B(f, "afterBreaks"), f.staticScale ? f.transA = f.staticScale : a.unitLength && (f.transA *= (p - f.min + g) / a.unitLength), g && (f.minPixelPadding = f.transA * (f.minPointOffset || 0)), f.min = l, f.max = p);
                  }
                });
                y(e, !0) && f.chart.redraw();
              };

              return b;
            }();

            q.Additions = K;
          })(r || (r = {}));

          return r;
        });
        N(e, "Core/Axis/GridAxis.js", [e["Core/Axis/Axis.js"], e["Core/Axis/AxisDefaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n, D, H) {
          function B(a, b) {
            var c = {
              width: 0,
              height: 0
            };
            b.forEach(function (b) {
              b = a[b];

              if (H.isObject(b, !0)) {
                var d = H.isObject(b.label, !0) ? b.label : {};
                b = d.getBBox ? d.getBBox().height : 0;
                d.textStr && !k(d.textPxLength) && (d.textPxLength = d.getBBox().width);
                var e = k(d.textPxLength) ? Math.round(d.textPxLength) : 0;
                d.textStr && (e = Math.round(d.getBBox().width));
                c.height = Math.max(b, c.height);
                c.width = Math.max(e, c.width);
              }
            });
            "treegrid" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode && (c.width += this.options.labels.indentation * ((this.treeGrid.mapOfPosToGridNode[-1].height || 0) - 1));
            return c;
          }

          function E() {
            var a = this.grid;
            (a && a.columns || []).forEach(function (a) {
              a.getOffset();
            });
          }

          function G(a) {
            if (!0 === (this.options.grid || {}).enabled) {
              var b = this.axisTitle,
                  c = this.height,
                  d = this.horiz,
                  e = this.left,
                  f = this.offset,
                  g = this.opposite,
                  h = this.options,
                  k = this.top,
                  m = this.width,
                  u = this.tickSize(),
                  l = b && b.getBBox().width,
                  p = h.title.x,
                  v = h.title.y,
                  w = L(h.title.margin, d ? 5 : 10);
              b = this.chart.renderer.fontMetrics(h.title.style.fontSize, b).f;
              u = (d ? k + c : e) + (d ? 1 : -1) * (g ? -1 : 1) * (u ? u[0] / 2 : 0) + (this.side === A.bottom ? b : 0);
              a.titlePosition.x = d ? e - (l || 0) / 2 - w + p : u + (g ? m : 0) + f + p;
              a.titlePosition.y = d ? u - (g ? c : 0) + (g ? b : -b) / 2 + f + v : k - w + v;
            }
          }

          function y() {
            var a = this.chart,
                b = this.options.grid;
            b = void 0 === b ? {} : b;
            var c = this.userOptions;

            if (b.enabled) {
              var d = this.options;
              d.labels.align = L(d.labels.align, "center");
              this.categories || (d.showLastLabel = !1);
              this.labelRotation = 0;
              d.labels.rotation = 0;
            }

            if (b.columns) {
              d = this.grid.columns = [];

              for (var f = this.grid.columnIndex = 0; ++f < b.columns.length;) {
                var g = h(c, b.columns[b.columns.length - f - 1], {
                  linkedTo: 0,
                  type: "category",
                  scrollbar: {
                    enabled: !1
                  }
                });
                delete g.grid.columns;
                g = new e(this.chart, g);
                g.grid.isColumn = !0;
                g.grid.columnIndex = f;
                z(a.axes, g);
                z(a[this.coll], g);
                d.push(g);
              }
            }
          }

          function r() {
            var a = this.grid,
                b = this.options;

            if (!0 === (b.grid || {}).enabled) {
              var c = this.min || 0,
                  d = this.max || 0;
              this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions);
              this.rightWall && this.rightWall.destroy();

              if (this.grid && this.grid.isOuterAxis() && this.axisLine) {
                var e = b.lineWidth;

                if (e) {
                  e = this.getLinePath(e);
                  var f = e[0],
                      g = e[1],
                      h = ((this.tickSize("tick") || [1])[0] - 1) * (this.side === A.top || this.side === A.left ? -1 : 1);
                  "M" === f[0] && "L" === g[0] && (this.horiz ? (f[2] += h, g[2] += h) : (f[1] += h, g[1] += h));
                  !this.horiz && this.chart.marginRight && (f = [f, ["L", this.left, f[2] || 0]], h = ["L", this.chart.chartWidth - this.chart.marginRight, this.toPixels(d + this.tickmarkOffset)], g = [["M", g[1] || 0, this.toPixels(d + this.tickmarkOffset)], h], this.grid.upperBorder || 0 === c % 1 || (this.grid.upperBorder = this.grid.renderBorder(f)), this.grid.upperBorder && (this.grid.upperBorder.attr({
                    stroke: b.lineColor,
                    "stroke-width": b.lineWidth
                  }), this.grid.upperBorder.animate({
                    d: f
                  })), this.grid.lowerBorder || 0 === d % 1 || (this.grid.lowerBorder = this.grid.renderBorder(g)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({
                    stroke: b.lineColor,
                    "stroke-width": b.lineWidth
                  }), this.grid.lowerBorder.animate({
                    d: g
                  })));
                  this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({
                    stroke: b.lineColor,
                    "stroke-width": b.lineWidth
                  }), this.grid.axisLineExtra.animate({
                    d: e
                  })) : this.grid.axisLineExtra = this.grid.renderBorder(e);
                  this.axisLine[this.showAxis ? "show" : "hide"]();
                }
              }

              (a && a.columns || []).forEach(function (a) {
                return a.render();
              });

              if (!this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar)) {
                a = this.tickmarkOffset;
                b = this.tickPositions[this.tickPositions.length - 1];
                e = this.tickPositions[0];

                for (f = g = void 0; (g = this.hiddenLabels.pop()) && g.element;) {
                  g.show();
                }

                for (; (f = this.hiddenMarks.pop()) && f.element;) {
                  f.show();
                }

                (g = this.ticks[e].label) && (c - e > a ? this.hiddenLabels.push(g.hide()) : g.show());
                (g = this.ticks[b].label) && (b - d > a ? this.hiddenLabels.push(g.hide()) : g.show());
                (c = this.ticks[b].mark) && b - d < a && 0 < b - d && this.ticks[b].isLast && this.hiddenMarks.push(c.hide());
              }
            }
          }

          function q() {
            var b = this.tickPositions && this.tickPositions.info,
                c = this.options,
                d = this.userOptions.labels || {};
            (c.grid || {}).enabled && (this.horiz ? (this.series.forEach(function (a) {
              a.options.pointRange = 0;
            }), b && c.dateTimeLabelFormats && c.labels && !a(d.align) && (!1 === c.dateTimeLabelFormats[b.unitName].range || 1 < b.count) && (c.labels.align = "left", a(d.x) || (c.labels.x = 3))) : "treegrid" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));
          }

          function c(b) {
            var c = this.options;
            b = b.userOptions;
            var d = c && H.isObject(c.grid, !0) ? c.grid : {};

            if (!0 === d.enabled) {
              var e = h(!0, {
                className: "highcharts-grid-axis " + (b.className || ""),
                dateTimeLabelFormats: {
                  hour: {
                    list: ["%H:%M", "%H"]
                  },
                  day: {
                    list: ["%A, %e. %B", "%a, %e. %b", "%E"]
                  },
                  week: {
                    list: ["Week %W", "W%W"]
                  },
                  month: {
                    list: ["%B", "%b", "%o"]
                  }
                },
                grid: {
                  borderWidth: 1
                },
                labels: {
                  padding: 2,
                  style: {
                    fontSize: "13px"
                  }
                },
                margin: 0,
                title: {
                  text: null,
                  reserveSpace: !1,
                  rotation: 0
                },
                units: [["millisecond", [1, 10, 100]], ["second", [1, 10]], ["minute", [1, 5, 15]], ["hour", [1, 6]], ["day", [1]], ["week", [1]], ["month", [1]], ["year", null]]
              }, b);
              "xAxis" === this.coll && (a(b.linkedTo) && !a(b.tickPixelInterval) && (e.tickPixelInterval = 350), a(b.tickPixelInterval) || !a(b.linkedTo) || a(b.tickPositioner) || a(b.tickInterval) || (e.tickPositioner = function (a, b) {
                var c = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;

                if (c) {
                  for (var d = e.units || [], f = void 0, g = 1, h = "year", m = 0; m < d.length; m++) {
                    var u = d[m];

                    if (u && u[0] === c.unitName) {
                      f = m;
                      break;
                    }
                  }

                  (d = k(f) && d[f + 1]) ? (h = d[0] || "year", g = (g = d[1]) && g[0] || 1) : "year" === c.unitName && (g = 10 * c.count);
                  c = P[h];
                  this.tickInterval = c * g;
                  return this.chart.time.getTimeTicks({
                    unitRange: c,
                    count: g,
                    unitName: h
                  }, a, b, this.options.startOfWeek);
                }
              }));
              h(!0, this.options, e);
              this.horiz && (c.minPadding = L(b.minPadding, 0), c.maxPadding = L(b.maxPadding, 0));
              k(c.grid.borderWidth) && (c.tickWidth = c.lineWidth = d.borderWidth);
            }
          }

          function g(a) {
            a = (a = a.userOptions) && a.grid || {};
            var b = a.columns;
            a.enabled && b && h(!0, this.options, b[b.length - 1]);
          }

          function l() {
            (this.grid.columns || []).forEach(function (a) {
              return a.setScale();
            });
          }

          function x(a) {
            var b = n.defaultLeftAxisOptions,
                c = this.horiz,
                d = this.maxLabelDimensions,
                e = this.options.grid;
            e = void 0 === e ? {} : e;
            e.enabled && d && (b = 2 * Math.abs(b.labels.x), c = c ? e.cellHeight || b + d.height : b + d.width, F(a.tickSize) ? a.tickSize[0] = c : a.tickSize = [c, 0]);
          }

          function f() {
            this.axes.forEach(function (a) {
              (a.grid && a.grid.columns || []).forEach(function (a) {
                a.setAxisSize();
                a.setAxisTranslation();
              });
            });
          }

          function b(a) {
            var b = this.grid;
            (b.columns || []).forEach(function (b) {
              return b.destroy(a.keepEvents);
            });
            b.columns = void 0;
          }

          function w(b) {
            b = b.userOptions || {};
            var c = b.grid || {};
            c.enabled && a(c.borderColor) && (b.tickColor = b.lineColor = c.borderColor);
            this.grid || (this.grid = new aa(this));
            this.hiddenLabels = [];
            this.hiddenMarks = [];
          }

          function J(a) {
            var b = this.label,
                c = this.axis,
                d = c.reversed,
                e = c.chart,
                f = c.options.grid || {},
                g = c.options.labels,
                h = g.align,
                m = A[c.side],
                u = a.tickmarkOffset,
                l = c.tickPositions,
                p = this.pos - u;
            l = k(l[a.index + 1]) ? l[a.index + 1] - u : (c.max || 0) + u;
            var v = c.tickSize("tick");
            u = v ? v[0] : 0;
            v = v ? v[1] / 2 : 0;

            if (!0 === f.enabled) {
              if ("top" === m) {
                f = c.top + c.offset;
                var w = f - u;
              } else "bottom" === m ? (w = e.chartHeight - c.bottom + c.offset, f = w + u) : (f = c.top + c.len - (c.translate(d ? l : p) || 0), w = c.top + c.len - (c.translate(d ? p : l) || 0));

              "right" === m ? (m = e.chartWidth - c.right + c.offset, d = m + u) : "left" === m ? (d = c.left + c.offset, m = d - u) : (m = Math.round(c.left + (c.translate(d ? l : p) || 0)) - v, d = Math.min(Math.round(c.left + (c.translate(d ? p : l) || 0)) - v, c.left + c.len));
              this.slotWidth = d - m;
              a.pos.x = "left" === h ? m : "right" === h ? d : m + (d - m) / 2;
              a.pos.y = w + (f - w) / 2;
              e = e.renderer.fontMetrics(g.style.fontSize, b && b.element);
              b = b ? b.getBBox().height : 0;
              g.useHTML ? a.pos.y += e.b + -(b / 2) : (b = Math.round(b / e.h), a.pos.y += (e.b - (e.h - e.f)) / 2 + -((b - 1) * e.h / 2));
              a.pos.x += c.horiz && g.x || 0;
            }
          }

          function C(a) {
            var b = a.axis,
                c = a.value;

            if (b.options.grid && b.options.grid.enabled) {
              var e = b.tickPositions,
                  f = (b.linkedParent || b).series[0],
                  g = c === e[0];
              e = c === e[e.length - 1];
              var k = f && d(f.options.data, function (a) {
                return a[b.isXAxis ? "x" : "y"] === c;
              }),
                  m = void 0;
              k && f.is("gantt") && (m = h(k), D.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(m));
              a.isFirst = g;
              a.isLast = e;
              a.point = m;
            }
          }

          function K() {
            var a = this.options,
                b = this.categories,
                c = this.tickPositions,
                d = c[0],
                e = c[c.length - 1],
                f = this.linkedParent && this.linkedParent.min || this.min,
                g = this.linkedParent && this.linkedParent.max || this.max,
                h = this.tickInterval;
            !0 !== (a.grid || {}).enabled || b || !this.horiz && !this.isLinked || (d < f && d + h > f && !a.startOnTick && (c[0] = f), e > g && e - h < g && !a.endOnTick && (c[c.length - 1] = g));
          }

          function p(a) {
            var b = this.options.grid;
            return !0 === (void 0 === b ? {} : b).enabled && this.categories ? this.tickInterval : a.apply(this, Array.prototype.slice.call(arguments, 1));
          }

          var m = D.dateFormats,
              t = H.addEvent,
              a = H.defined,
              z = H.erase,
              d = H.find,
              F = H.isArray,
              k = H.isNumber,
              h = H.merge,
              L = H.pick,
              P = H.timeUnits,
              u = H.wrap,
              A;

          (function (a) {
            a[a.top = 0] = "top";
            a[a.right = 1] = "right";
            a[a.bottom = 2] = "bottom";
            a[a.left = 3] = "left";
          })(A || (A = {}));

          var O = [],
              aa = function () {
            function a(a) {
              this.axis = a;
            }

            a.prototype.isOuterAxis = function () {
              var a = this.axis,
                  b = a.grid.columnIndex,
                  c = a.linkedParent && a.linkedParent.grid.columns || a.grid.columns,
                  d = b ? a.linkedParent : a,
                  e = -1,
                  f = 0;
              (a.chart[a.coll] || []).forEach(function (b, c) {
                b.side !== a.side || b.options.isInternal || (f = c, b === d && (e = c));
              });
              return f === e && (k(b) ? c.length === b : !0);
            };

            a.prototype.renderBorder = function (a) {
              var b = this.axis,
                  c = b.chart.renderer,
                  d = b.options;
              a = c.path(a).addClass("highcharts-axis-line").add(b.axisBorder);
              c.styledMode || a.attr({
                stroke: d.lineColor,
                "stroke-width": d.lineWidth,
                zIndex: 7
              });
              return a;
            };

            return a;
          }();

          m.E = function (a) {
            return this.dateFormat("%a", a, !0).charAt(0);
          };

          m.W = function (a) {
            var b = this,
                c = new this.Date(a);
            ["Hours", "Milliseconds", "Minutes", "Seconds"].forEach(function (a) {
              b.set(a, c, 0);
            });
            var d = (this.get("Day", c) + 6) % 7;
            a = new this.Date(c.valueOf());
            this.set("Date", a, this.get("Date", c) - d + 3);
            d = new this.Date(this.get("FullYear", a), 0, 1);
            4 !== this.get("Day", d) && (this.set("Month", c, 0), this.set("Date", c, 1 + (11 - this.get("Day", d)) % 7));
            return (1 + Math.floor((a.valueOf() - d.valueOf()) / 6048E5)).toString();
          };

          "";
          return {
            compose: function compose(a, d, e) {
              -1 === O.indexOf(a) && (O.push(a), a.keepProps.push("grid"), a.prototype.getMaxLabelDimensions = B, u(a.prototype, "unsquish", p), t(a, "init", w), t(a, "afterGetOffset", E), t(a, "afterGetTitlePosition", G), t(a, "afterInit", y), t(a, "afterRender", r), t(a, "afterSetAxisTranslation", q), t(a, "afterSetOptions", c), t(a, "afterSetOptions", g), t(a, "afterSetScale", l), t(a, "afterTickSize", x), t(a, "trimTicks", K), t(a, "destroy", b));
              -1 === O.indexOf(d) && t(d, "afterSetChartSize", f);
              -1 === O.indexOf(e) && (t(e, "afterGetLabelPosition", J), t(e, "labelFormat", C));
              return a;
            }
          };
        });
        N(e, "Gantt/Tree.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.extend,
              D = e.isNumber,
              G = e.pick,
              B = function B(e, n) {
            var r = e.reduce(function (e, c) {
              var g = G(c.parent, "");
              "undefined" === typeof e[g] && (e[g] = []);
              e[g].push(c);
              return e;
            }, {});
            Object.keys(r).forEach(function (e, c) {
              var g = r[e];
              "" !== e && -1 === n.indexOf(e) && (g.forEach(function (e) {
                c[""].push(e);
              }), delete c[e]);
            });
            return r;
          },
              E = function E(e, y, r, q, c, g) {
            var l = 0,
                x = 0,
                f = g && g.after,
                b = g && g.before;
            y = {
              data: q,
              depth: r - 1,
              id: e,
              level: r,
              parent: y
            };
            var w, J;
            "function" === typeof b && b(y, g);
            b = (c[e] || []).map(function (b) {
              var f = E(b.id, e, r + 1, b, c, g),
                  p = b.start;
              b = !0 === b.milestone ? p : b.end;
              w = !D(w) || p < w ? p : w;
              J = !D(J) || b > J ? b : J;
              l = l + 1 + f.descendants;
              x = Math.max(f.height + 1, x);
              return f;
            });
            q && (q.start = G(q.start, w), q.end = G(q.end, J));
            n(y, {
              children: b,
              descendants: l,
              height: x
            });
            "function" === typeof f && f(y, g);
            return y;
          };

          return {
            getListOfParents: B,
            getNode: E,
            getTree: function getTree(e, n) {
              var r = e.map(function (e) {
                return e.id;
              });
              e = B(e, r);
              return E("", null, 1, null, e, n);
            }
          };
        });
        N(e, "Core/Axis/TreeGridTick.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.addEvent,
              D = e.isObject,
              G = e.isNumber,
              B = e.pick,
              E = e.wrap,
              I;

          (function (e) {
            function r() {
              this.treeGrid || (this.treeGrid = new x(this));
            }

            function q(c, b) {
              c = c.treeGrid;
              var e = !c.labelIcon,
                  f = b.renderer,
                  g = b.xy,
                  l = b.options,
                  p = l.width || 0,
                  m = l.height || 0,
                  q = g.x - p / 2 - (l.padding || 0);
              g = g.y - m / 2;
              var a = b.collapsed ? 90 : 180,
                  n = b.show && G(g),
                  d = c.labelIcon;
              d || (c.labelIcon = d = f.path(f.symbols[l.type](l.x || 0, l.y || 0, p, m)).addClass("highcharts-label-icon").add(b.group));
              d[n ? "show" : "hide"]();
              f.styledMode || d.attr({
                cursor: "pointer",
                fill: B(b.color, "#666666"),
                "stroke-width": 1,
                stroke: l.lineColor,
                strokeWidth: l.lineWidth || 0
              });
              d[e ? "attr" : "animate"]({
                translateX: q,
                translateY: g,
                rotation: a
              });
            }

            function c(c, b, e, g, l, q, p, m, n) {
              var a = B(this.options && this.options.labels, q);
              q = this.pos;
              var f = this.axis,
                  d = "treegrid" === f.options.type;
              c = c.apply(this, [b, e, g, l, a, p, m, n]);
              d && (b = a && D(a.symbol, !0) ? a.symbol : {}, a = a && G(a.indentation) ? a.indentation : 0, q = (q = (f = f.treeGrid.mapOfPosToGridNode) && f[q]) && q.depth || 1, c.x += (b.width || 0) + 2 * (b.padding || 0) + (q - 1) * a);
              return c;
            }

            function g(c) {
              var b = this,
                  e = b.pos,
                  f = b.axis,
                  g = b.label,
                  l = f.treeGrid.mapOfPosToGridNode,
                  p = f.options,
                  m = B(b.options && b.options.labels, p && p.labels),
                  r = m && D(m.symbol, !0) ? m.symbol : {},
                  a = (l = l && l[e]) && l.depth;
              p = "treegrid" === p.type;
              var x = -1 < f.tickPositions.indexOf(e);
              e = f.chart.styledMode;
              p && l && g && g.element && g.addClass("highcharts-treegrid-node-level-" + a);
              c.apply(b, Array.prototype.slice.call(arguments, 1));
              p && g && g.element && l && l.descendants && 0 < l.descendants && (f = f.treeGrid.isCollapsed(l), q(b, {
                color: !e && g.styles && g.styles.color || "",
                collapsed: f,
                group: g.parentGroup,
                options: r,
                renderer: g.renderer,
                show: x,
                xy: g.xy
              }), r = "highcharts-treegrid-node-" + (f ? "expanded" : "collapsed"), g.addClass("highcharts-treegrid-node-" + (f ? "collapsed" : "expanded")).removeClass(r), e || g.css({
                cursor: "pointer"
              }), [g, b.treeGrid.labelIcon].forEach(function (a) {
                a && !a.attachedTreeGridEvents && (n(a.element, "mouseover", function () {
                  g.addClass("highcharts-treegrid-node-active");
                  g.renderer.styledMode || g.css({
                    textDecoration: "underline"
                  });
                }), n(a.element, "mouseout", function () {
                  var a = D(m.style) ? m.style : {};
                  g.removeClass("highcharts-treegrid-node-active");
                  g.renderer.styledMode || g.css({
                    textDecoration: a.textDecoration
                  });
                }), n(a.element, "click", function () {
                  b.treeGrid.toggleCollapse();
                }), a.attachedTreeGridEvents = !0);
              }));
            }

            var l = !1;

            e.compose = function (e) {
              l || (n(e, "init", r), E(e.prototype, "getLabelPosition", c), E(e.prototype, "renderLabel", g), e.prototype.collapse = function (b) {
                this.treeGrid.collapse(b);
              }, e.prototype.expand = function (b) {
                this.treeGrid.expand(b);
              }, e.prototype.toggleCollapse = function (b) {
                this.treeGrid.toggleCollapse(b);
              }, l = !0);
            };

            var x = function () {
              function c(b) {
                this.tick = b;
              }

              c.prototype.collapse = function (b) {
                var c = this.tick,
                    e = c.axis,
                    f = e.brokenAxis;
                f && e.treeGrid.mapOfPosToGridNode && (c = e.treeGrid.collapse(e.treeGrid.mapOfPosToGridNode[c.pos]), f.setBreaks(c, B(b, !0)));
              };

              c.prototype.destroy = function () {
                this.labelIcon && this.labelIcon.destroy();
              };

              c.prototype.expand = function (b) {
                var c = this.tick,
                    e = c.axis,
                    f = e.brokenAxis;
                f && e.treeGrid.mapOfPosToGridNode && (c = e.treeGrid.expand(e.treeGrid.mapOfPosToGridNode[c.pos]), f.setBreaks(c, B(b, !0)));
              };

              c.prototype.toggleCollapse = function (b) {
                var c = this.tick,
                    e = c.axis,
                    f = e.brokenAxis;
                f && e.treeGrid.mapOfPosToGridNode && (c = e.treeGrid.toggleCollapse(e.treeGrid.mapOfPosToGridNode[c.pos]), f.setBreaks(c, B(b, !0)));
              };

              return c;
            }();

            e.Additions = x;
          })(I || (I = {}));

          return I;
        });
        N(e, "Series/TreeUtilities.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function (e, n) {
          function D(e, c) {
            var g = c.before,
                l = c.idRoot,
                n = c.mapIdToNode[l],
                f = c.points[e.i],
                b = f && f.options || {},
                w = [],
                q = 0;
            e.levelDynamic = e.level - (!1 !== c.levelIsConstant ? 0 : n.level);
            e.name = r(f && f.name, "");
            e.visible = l === e.id || !0 === c.visible;
            "function" === typeof g && (e = g(e, c));
            e.children.forEach(function (b, f) {
              var g = G({}, c);
              G(g, {
                index: f,
                siblings: e.children.length,
                visible: e.visible
              });
              b = D(b, g);
              w.push(b);
              b.visible && (q += b.val);
            });
            g = r(b.value, q);
            e.visible = 0 <= g && (0 < q || e.visible);
            e.children = w;
            e.childrenTotal = q;
            e.isLeaf = e.visible && !q;
            e.val = g;
            return e;
          }

          var G = n.extend,
              B = n.isArray,
              E = n.isNumber,
              I = n.isObject,
              y = n.merge,
              r = n.pick;
          return {
            getColor: function getColor(n, c) {
              var g = c.index,
                  l = c.mapOptionsToLevel,
                  q = c.parentColor,
                  f = c.parentColorIndex,
                  b = c.series,
                  w = c.colors,
                  y = c.siblings,
                  C = b.points,
                  B = b.chart.options.chart,
                  p;

              if (n) {
                C = C[n.i];
                n = l[n.level] || {};

                if (l = C && n.colorByPoint) {
                  var m = C.index % (w ? w.length : B.colorCount);
                  var t = w && w[m];
                }

                if (!b.chart.styledMode) {
                  w = C && C.options.color;
                  B = n && n.color;
                  if (p = q) p = (p = n && n.colorVariation) && "brightness" === p.key && g && y ? e.parse(q).brighten(g / y * p.to).get() : q;
                  p = r(w, B, t, p, b.color);
                }

                var a = r(C && C.options.colorIndex, n && n.colorIndex, m, f, c.colorIndex);
              }

              return {
                color: p,
                colorIndex: a
              };
            },
            getLevelOptions: function getLevelOptions(e) {
              var c = null;

              if (I(e)) {
                c = {};
                var g = E(e.from) ? e.from : 1;
                var l = e.levels;
                var n = {};
                var f = I(e.defaults) ? e.defaults : {};
                B(l) && (n = l.reduce(function (b, c) {
                  if (I(c) && E(c.level)) {
                    var e = y({}, c);
                    var l = r(e.levelIsConstant, f.levelIsConstant);
                    delete e.levelIsConstant;
                    delete e.level;
                    c = c.level + (l ? 0 : g - 1);
                    I(b[c]) ? y(!0, b[c], e) : b[c] = e;
                  }

                  return b;
                }, {}));
                l = E(e.to) ? e.to : 1;

                for (e = 0; e <= l; e++) {
                  c[e] = y({}, f, I(n[e]) ? n[e] : {});
                }
              }

              return c;
            },
            setTreeValues: D,
            updateRootId: function updateRootId(e) {
              if (I(e)) {
                var c = I(e.options) ? e.options : {};
                c = r(e.rootNode, c.rootId, "");
                I(e.userOptions) && (e.userOptions.rootId = c);
                e.rootNode = c;
              }

              return c;
            }
          };
        });
        N(e, "Core/Axis/TreeGridAxis.js", [e["Core/Axis/BrokenAxis.js"], e["Core/Axis/GridAxis.js"], e["Gantt/Tree.js"], e["Core/Axis/TreeGridTick.js"], e["Series/TreeUtilities.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E) {
          var G = B.getLevelOptions,
              y = E.addEvent,
              r = E.find,
              q = E.fireEvent,
              c = E.isArray,
              g = E.isObject,
              l = E.isString,
              x = E.merge,
              f = E.pick,
              b = E.wrap,
              w;

          (function (w) {
            function C(a, b) {
              var c = a.collapseEnd || 0;
              a = a.collapseStart || 0;
              c >= b && (a -= .5);
              return {
                from: a,
                to: c,
                showPoints: !1
              };
            }

            function B(a, b, c) {
              var d = [],
                  e = [],
                  f = {},
                  h = "boolean" === typeof b ? b : !1,
                  k = {},
                  m = -1;
              a = D.getTree(a, {
                after: function after(a) {
                  a = k[a.pos];
                  var b = 0,
                      c = 0;
                  a.children.forEach(function (a) {
                    c += (a.descendants || 0) + 1;
                    b = Math.max((a.height || 0) + 1, b);
                  });
                  a.descendants = c;
                  a.height = b;
                  a.collapsed && e.push(a);
                },
                before: function before(a) {
                  var b = g(a.data, !0) ? a.data : {},
                      c = l(b.name) ? b.name : "",
                      e = f[a.parent];
                  e = g(e, !0) ? k[e.pos] : null;

                  var u = function u(a) {
                    return a.name === c;
                  },
                      p;

                  h && g(e, !0) && (p = r(e.children, u)) ? (u = p.pos, p.nodes.push(a)) : u = m++;
                  k[u] || (k[u] = p = {
                    depth: e ? e.depth + 1 : 0,
                    name: c,
                    id: b.id,
                    nodes: [a],
                    children: [],
                    pos: u
                  }, -1 !== u && d.push(c), g(e, !0) && e.children.push(p));
                  l(a.id) && (f[a.id] = a);
                  p && !0 === b.collapsed && (p.collapsed = !0);
                  a.pos = u;
                }
              });

              k = function (a, b) {
                var c = function c(a, d, e) {
                  var f = d + (-1 === d ? 0 : b - 1),
                      h = (f - d) / 2,
                      k = d + h;
                  a.nodes.forEach(function (a) {
                    var b = a.data;
                    g(b, !0) && (b.y = d + (b.seriesIndex || 0), delete b.seriesIndex);
                    a.pos = k;
                  });
                  e[k] = a;
                  a.pos = k;
                  a.tickmarkOffset = h + .5;
                  a.collapseStart = f + .5;
                  a.children.forEach(function (a) {
                    c(a, f + 1, e);
                    f = (a.collapseEnd || 0) - .5;
                  });
                  a.collapseEnd = f + .5;
                  return e;
                };

                return c(a["-1"], -1, {});
              }(k, c);

              return {
                categories: d,
                mapOfIdToNode: f,
                mapOfPosToGridNode: k,
                collapsedNodes: e,
                tree: a
              };
            }

            function p(a) {
              a.target.axes.filter(function (a) {
                return "treegrid" === a.options.type;
              }).forEach(function (b) {
                var d = b.options || {},
                    e = d.labels,
                    f = d.uniqueNames;
                d = d.max;
                var k = 0;

                if (!b.treeGrid.mapOfPosToGridNode || b.series.some(function (a) {
                  return !a.hasRendered || a.isDirtyData || a.isDirty;
                })) {
                  var m = b.series.reduce(function (a, b) {
                    b.visible && ((b.options.data || []).forEach(function (c) {
                      b.options.keys && b.options.keys.length && (c = b.pointClass.prototype.optionsToObject.call({
                        series: b
                      }, c), b.pointClass.setGanttPointAliases(c));
                      g(c, !0) && (c.seriesIndex = k, a.push(c));
                    }), !0 === f && k++);
                    return a;
                  }, []);
                  if (d && m.length < d) for (var l = m.length; l <= d; l++) {
                    m.push({
                      name: l + "\u200B"
                    });
                  }
                  d = B(m, f || !1, !0 === f ? k : 1);
                  b.categories = d.categories;
                  b.treeGrid.mapOfPosToGridNode = d.mapOfPosToGridNode;
                  b.hasNames = !0;
                  b.treeGrid.tree = d.tree;
                  b.series.forEach(function (a) {
                    var b = (a.options.data || []).map(function (b) {
                      c(b) && a.options.keys && a.options.keys.length && m.forEach(function (a) {
                        0 <= b.indexOf(a.x) && 0 <= b.indexOf(a.x2) && (b = a);
                      });
                      return g(b, !0) ? x(b) : b;
                    });
                    a.visible && a.setData(b, !1);
                  });
                  b.treeGrid.mapOptionsToLevel = G({
                    defaults: e,
                    from: 1,
                    levels: e && e.levels,
                    to: b.treeGrid.tree && b.treeGrid.tree.height
                  });
                  "beforeRender" === a.type && (b.treeGrid.collapsedNodes = d.collapsedNodes);
                }
              });
            }

            function m(a, b) {
              var c = this.treeGrid.mapOptionsToLevel || {},
                  d = this.ticks,
                  e = d[b],
                  f;

              if ("treegrid" === this.options.type && this.treeGrid.mapOfPosToGridNode) {
                var g = this.treeGrid.mapOfPosToGridNode[b];
                (c = c[g.depth]) && (f = {
                  labels: c
                });
                !e && z ? d[b] = new z(this, b, void 0, void 0, {
                  category: g.name,
                  tickmarkOffset: g.tickmarkOffset,
                  options: f
                }) : (e.parameters.category = g.name, e.options = f, e.addLabel());
              } else a.apply(this, Array.prototype.slice.call(arguments, 1));
            }

            function t(a, b, c) {
              var e = this,
                  f = "treegrid" === c.type;
              e.treeGrid || (e.treeGrid = new d(e));
              f && (y(b, "beforeRender", p), y(b, "beforeRedraw", p), y(b, "addSeries", function (a) {
                a.options.data && (a = B(a.options.data, c.uniqueNames || !1, 1), e.treeGrid.collapsedNodes = (e.treeGrid.collapsedNodes || []).concat(a.collapsedNodes));
              }), y(e, "foundExtremes", function () {
                e.treeGrid.collapsedNodes && e.treeGrid.collapsedNodes.forEach(function (a) {
                  var b = e.treeGrid.collapse(a);
                  e.brokenAxis && (e.brokenAxis.setBreaks(b, !1), e.treeGrid.collapsedNodes && (e.treeGrid.collapsedNodes = e.treeGrid.collapsedNodes.filter(function (b) {
                    return a.collapseStart !== b.collapseStart || a.collapseEnd !== b.collapseEnd;
                  })));
                });
              }), y(e, "afterBreaks", function () {
                "yAxis" === e.coll && !e.staticScale && e.chart.options.chart.height && (e.isDirty = !0);
              }), c = x({
                grid: {
                  enabled: !0
                },
                labels: {
                  align: "left",
                  levels: [{
                    level: void 0
                  }, {
                    level: 1,
                    style: {
                      fontWeight: "bold"
                    }
                  }],
                  symbol: {
                    type: "triangle",
                    x: -5,
                    y: -5,
                    height: 10,
                    width: 10,
                    padding: 5
                  }
                },
                uniqueNames: !1
              }, c, {
                reversed: !0,
                grid: {
                  columns: void 0
                }
              }));
              a.apply(e, [b, c]);
              f && (e.hasNames = !0, e.options.showLastLabel = !0);
            }

            function a(a) {
              var b = this.options;
              "treegrid" === b.type ? (this.min = f(this.userMin, b.min, this.dataMin), this.max = f(this.userMax, b.max, this.dataMax), q(this, "foundExtremes"), this.setAxisTranslation(), this.tickmarkOffset = .5, this.tickInterval = 1, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : []) : a.apply(this, Array.prototype.slice.call(arguments, 1));
            }

            var z;

            w.compose = function (c, d, f, g) {
              -1 === c.keepProps.indexOf("treeGrid") && (c.keepProps.push("treeGrid"), z = g, b(c.prototype, "generateTick", m), b(c.prototype, "init", t), b(c.prototype, "setTickInterval", a), c.prototype.utils = {
                getNode: D.getNode
              }, n.compose(c, d, g), e.compose(c, f), H.compose(g));
              return c;
            };

            var d = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.setCollapsedStatus = function (a) {
                var b = this.axis,
                    c = b.chart;
                b.series.forEach(function (b) {
                  var d = b.options.data;

                  if (a.id && d) {
                    var e = c.get(a.id);
                    b = d[b.data.indexOf(e)];
                    e && b && (e.collapsed = a.collapsed, b.collapsed = a.collapsed);
                  }
                });
              };

              a.prototype.collapse = function (a) {
                var b = this.axis,
                    c = b.options.breaks || [],
                    d = C(a, b.max);
                c.push(d);
                a.collapsed = !0;
                b.treeGrid.setCollapsedStatus(a);
                return c;
              };

              a.prototype.expand = function (a) {
                var b = this.axis,
                    c = b.options.breaks || [],
                    d = C(a, b.max);
                a.collapsed = !1;
                b.treeGrid.setCollapsedStatus(a);
                return c.reduce(function (a, b) {
                  b.to === d.to && b.from === d.from || a.push(b);
                  return a;
                }, []);
              };

              a.prototype.getTickPositions = function () {
                var a = this.axis,
                    b = Math.floor(a.min / a.tickInterval) * a.tickInterval,
                    c = Math.ceil(a.max / a.tickInterval) * a.tickInterval;
                return Object.keys(a.treeGrid.mapOfPosToGridNode || {}).reduce(function (d, e) {
                  e = +e;
                  !(e >= b && e <= c) || a.brokenAxis && a.brokenAxis.isInAnyBreak(e) || d.push(e);
                  return d;
                }, []);
              };

              a.prototype.isCollapsed = function (a) {
                var b = this.axis,
                    c = b.options.breaks || [],
                    d = C(a, b.max);
                return c.some(function (a) {
                  return a.from === d.from && a.to === d.to;
                });
              };

              a.prototype.toggleCollapse = function (a) {
                return this.isCollapsed(a) ? this.expand(a) : this.collapse(a);
              };

              return a;
            }();

            w.Additions = d;
          })(w || (w = {}));

          return w;
        });
        N(e, "Extensions/CurrentDateIndication.js", [e["Core/Axis/Axis.js"], e["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = D.addEvent,
              B = D.merge;
          D = D.wrap;
          var E = {
            color: "#ccd6eb",
            width: 2,
            label: {
              format: "%a, %b %d %Y, %H:%M",
              formatter: function formatter(e, n) {
                return this.axis.chart.time.dateFormat(n || "", e);
              },
              rotation: 0,
              style: {
                fontSize: "10px"
              }
            }
          };
          G(e, "afterSetOptions", function () {
            var e = this.options,
                n = e.currentDateIndicator;
            n && (n = "object" === typeof n ? B(E, n) : B(E), n.value = Date.now(), n.className = "highcharts-current-date-indicator", e.plotLines || (e.plotLines = []), e.plotLines.push(n));
          });
          G(n, "render", function () {
            this.label && this.label.attr({
              text: this.getLabelText(this.options.label)
            });
          });
          D(n.prototype, "getLabelText", function (e, n) {
            var r = this.options;
            return r && r.className && -1 !== r.className.indexOf("highcharts-current-date-indicator") && r.label && "function" === typeof r.label.formatter ? (r.value = Date.now(), r.label.formatter.call(this, r.value, r.label.format)) : e.call(this, n);
          });
        });
        N(e, "Extensions/StaticScale.js", [e["Core/Axis/Axis.js"], e["Core/Chart/Chart.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = D.addEvent,
              B = D.defined,
              E = D.isNumber,
              I = D.pick;
          G(e, "afterSetOptions", function () {
            var e = this.chart.options.chart;
            !this.horiz && E(this.options.staticScale) && (!e.height || e.scrollablePlotArea && e.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);
          });

          n.prototype.adjustHeight = function () {
            "adjustHeight" !== this.redrawTrigger && ((this.axes || []).forEach(function (e) {
              var n = e.chart,
                  q = !!n.initiatedScale && n.options.animation,
                  c = e.options.staticScale;

              if (e.staticScale && B(e.min)) {
                var g = I(e.brokenAxis && e.brokenAxis.unitLength, e.max + e.tickInterval - e.min) * c;
                g = Math.max(g, c);
                c = g - n.plotHeight;
                !n.scrollablePixelsY && 1 <= Math.abs(c) && (n.plotHeight = g, n.redrawTrigger = "adjustHeight", n.setSize(void 0, n.chartHeight + c, q));
                e.series.forEach(function (c) {
                  (c = c.sharedClipKey && n.sharedClips[c.sharedClipKey]) && c.attr(n.inverted ? {
                    width: n.plotHeight
                  } : {
                    height: n.plotHeight
                  });
                });
              }
            }), this.initiatedScale = !0);
            this.redrawTrigger = null;
          };

          G(n, "render", n.prototype.adjustHeight);
        });
        N(e, "Extensions/ArrowSymbols.js", [e["Core/Renderer/SVG/SVGRenderer.js"]], function (e) {
          function n(e, n, D, y) {
            return [["M", e, n + y / 2], ["L", e + D, n], ["L", e, n + y / 2], ["L", e + D, n + y]];
          }

          function D(e, n, D, y) {
            return [["M", e + D, n], ["L", e, n + y / 2], ["L", e + D, n + y], ["Z"]];
          }

          function G(e, n, G, y) {
            return D(e, n, G / 2, y);
          }

          e = e.prototype.symbols;
          e.arrow = n;
          e["arrow-filled"] = D;
          e["arrow-filled-half"] = G;

          e["arrow-half"] = function (e, D, G, y) {
            return n(e, D, G / 2, y);
          };

          e["triangle-left"] = D;
          e["triangle-left-half"] = G;
          return e;
        });
        N(e, "Gantt/Connection.js", [e["Core/Globals.js"], e["Core/DefaultOptions.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function (e, n, D, H) {
          function B(c) {
            var e = c.shapeArgs;
            return e ? {
              xMin: e.x || 0,
              xMax: (e.x || 0) + (e.width || 0),
              yMin: e.y || 0,
              yMax: (e.y || 0) + (e.height || 0)
            } : (e = c.graphic && c.graphic.getBBox()) ? {
              xMin: c.plotX - e.width / 2,
              xMax: c.plotX + e.width / 2,
              yMin: c.plotY - e.height / 2,
              yMax: c.plotY + e.height / 2
            } : null;
          }

          "";
          var E = H.defined,
              G = H.error,
              y = H.extend,
              r = H.merge,
              q = H.objectEach,
              c = e.deg2rad,
              g = Math.max,
              l = Math.min;
          y(n.defaultOptions, {
            connectors: {
              type: "straight",
              lineWidth: 1,
              marker: {
                enabled: !1,
                align: "center",
                verticalAlign: "middle",
                inside: !1,
                lineWidth: 1
              },
              startMarker: {
                symbol: "diamond"
              },
              endMarker: {
                symbol: "arrow-filled"
              }
            }
          });

          n = function () {
            function e(c, b, e) {
              this.toPoint = this.pathfinder = this.graphics = this.fromPoint = this.chart = void 0;
              this.init(c, b, e);
            }

            e.prototype.init = function (c, b, e) {
              this.fromPoint = c;
              this.toPoint = b;
              this.options = e;
              this.chart = c.series.chart;
              this.pathfinder = this.chart.pathfinder;
            };

            e.prototype.renderPath = function (c, b, e) {
              var f = this.chart,
                  g = f.styledMode,
                  l = f.pathfinder,
                  p = !f.options.chart.forExport && !1 !== e,
                  m = this.graphics && this.graphics.path;
              l.group || (l.group = f.renderer.g().addClass("highcharts-pathfinder-group").attr({
                zIndex: -1
              }).add(f.seriesGroup));
              l.group.translate(f.plotLeft, f.plotTop);
              m && m.renderer || (m = f.renderer.path().add(l.group), g || m.attr({
                opacity: 0
              }));
              m.attr(b);
              c = {
                d: c
              };
              g || (c.opacity = 1);
              m[p ? "animate" : "attr"](c, e);
              this.graphics = this.graphics || {};
              this.graphics.path = m;
            };

            e.prototype.addMarker = function (e, b, g) {
              var f = this.fromPoint.series.chart,
                  l = f.pathfinder;
              f = f.renderer;
              var n = "start" === e ? this.fromPoint : this.toPoint,
                  p = n.getPathfinderAnchorPoint(b);

              if (b.enabled && ((g = "start" === e ? g[1] : g[g.length - 2]) && "M" === g[0] || "L" === g[0])) {
                g = {
                  x: g[1],
                  y: g[2]
                };
                g = n.getRadiansToVector(g, p);
                p = n.getMarkerVector(g, b.radius, p);
                g = -g / c;

                if (b.width && b.height) {
                  var m = b.width;
                  var t = b.height;
                } else m = t = 2 * b.radius;

                this.graphics = this.graphics || {};
                p = {
                  x: p.x - m / 2,
                  y: p.y - t / 2,
                  width: m,
                  height: t,
                  rotation: g,
                  rotationOriginX: p.x,
                  rotationOriginY: p.y
                };
                this.graphics[e] ? this.graphics[e].animate(p) : (this.graphics[e] = f.symbol(b.symbol).addClass("highcharts-point-connecting-path-" + e + "-marker").attr(p).add(l.group), f.styledMode || this.graphics[e].attr({
                  fill: b.color || this.fromPoint.color,
                  stroke: b.lineColor,
                  "stroke-width": b.lineWidth,
                  opacity: 0
                }).animate({
                  opacity: 1
                }, n.series.options.animation));
              }
            };

            e.prototype.getPath = function (c) {
              var b = this.pathfinder,
                  e = this.chart,
                  f = b.algorithms[c.type],
                  g = b.chartObstacles;
              if ("function" !== typeof f) return G('"' + c.type + '" is not a Pathfinder algorithm.'), {
                path: [],
                obstacles: []
              };
              f.requiresObstacles && !g && (g = b.chartObstacles = b.getChartObstacles(c), e.options.connectors.algorithmMargin = c.algorithmMargin, b.chartObstacleMetrics = b.getObstacleMetrics(g));
              return f(this.fromPoint.getPathfinderAnchorPoint(c.startMarker), this.toPoint.getPathfinderAnchorPoint(c.endMarker), r({
                chartObstacles: g,
                lineObstacles: b.lineObstacles || [],
                obstacleMetrics: b.chartObstacleMetrics,
                hardBounds: {
                  xMin: 0,
                  xMax: e.plotWidth,
                  yMin: 0,
                  yMax: e.plotHeight
                },
                obstacleOptions: {
                  margin: c.algorithmMargin
                },
                startDirectionX: b.getAlgorithmStartDirection(c.startMarker)
              }, c));
            };

            e.prototype.render = function () {
              var c = this.fromPoint,
                  b = c.series,
                  e = b.chart,
                  n = e.pathfinder,
                  q = r(e.options.connectors, b.options.connectors, c.options.connectors, this.options),
                  x = {};
              e.styledMode || (x.stroke = q.lineColor || c.color, x["stroke-width"] = q.lineWidth, q.dashStyle && (x.dashstyle = q.dashStyle));
              x["class"] = "highcharts-point-connecting-path highcharts-color-" + c.colorIndex;
              q = r(x, q);
              E(q.marker.radius) || (q.marker.radius = l(g(Math.ceil((q.algorithmMargin || 8) / 2) - 1, 1), 5));
              c = this.getPath(q);
              e = c.path;
              c.obstacles && (n.lineObstacles = n.lineObstacles || [], n.lineObstacles = n.lineObstacles.concat(c.obstacles));
              this.renderPath(e, x, b.options.animation);
              this.addMarker("start", r(q.marker, q.startMarker), e);
              this.addMarker("end", r(q.marker, q.endMarker), e);
            };

            e.prototype.destroy = function () {
              this.graphics && (q(this.graphics, function (c) {
                c.destroy();
              }), delete this.graphics);
            };

            return e;
          }();

          e.Connection = n;
          y(D.prototype, {
            getPathfinderAnchorPoint: function getPathfinderAnchorPoint(c) {
              var e = B(this);

              switch (c.align) {
                case "right":
                  var b = "xMax";
                  break;

                case "left":
                  b = "xMin";
              }

              switch (c.verticalAlign) {
                case "top":
                  var g = "yMin";
                  break;

                case "bottom":
                  g = "yMax";
              }

              return {
                x: b ? e[b] : (e.xMin + e.xMax) / 2,
                y: g ? e[g] : (e.yMin + e.yMax) / 2
              };
            },
            getRadiansToVector: function getRadiansToVector(c, e) {
              var b;
              E(e) || (b = B(this)) && (e = {
                x: (b.xMin + b.xMax) / 2,
                y: (b.yMin + b.yMax) / 2
              });
              return Math.atan2(e.y - c.y, c.x - e.x);
            },
            getMarkerVector: function getMarkerVector(c, e, b) {
              var f = 2 * Math.PI,
                  g = B(this),
                  l = g.xMax - g.xMin,
                  n = g.yMax - g.yMin,
                  p = Math.atan2(n, l),
                  m = !1;
              l /= 2;
              var q = n / 2,
                  a = g.xMin + l;
              g = g.yMin + q;

              for (var r = a, d = g, x = 1, k = 1; c < -Math.PI;) {
                c += f;
              }

              for (; c > Math.PI;) {
                c -= f;
              }

              f = Math.tan(c);
              c > -p && c <= p ? (k = -1, m = !0) : c > p && c <= Math.PI - p ? k = -1 : c > Math.PI - p || c <= -(Math.PI - p) ? (x = -1, m = !0) : x = -1;
              m ? (r += x * l, d += k * l * f) : (r += n / (2 * f) * x, d += k * q);
              b.x !== a && (r = b.x);
              b.y !== g && (d = b.y);
              return {
                x: r + e * Math.cos(c),
                y: d - e * Math.sin(c)
              };
            }
          });
          return n;
        });
        N(e, "Gantt/PathfinderAlgorithms.js", [e["Core/Utilities.js"]], function (e) {
          function n(c, e, l) {
            l = l || 0;
            var g = c.length - 1;
            e -= 1e-7;

            for (var f, b; l <= g;) {
              if (f = g + l >> 1, b = e - c[f].xMin, 0 < b) l = f + 1;else if (0 > b) g = f - 1;else return f;
            }

            return 0 < l ? l - 1 : 0;
          }

          function D(c, e) {
            for (var g = n(c, e.x + 1) + 1; g--;) {
              var q;
              if (q = c[g].xMax >= e.x) q = c[g], q = e.x <= q.xMax && e.x >= q.xMin && e.y <= q.yMax && e.y >= q.yMin;
              if (q) return g;
            }

            return -1;
          }

          function G(c) {
            var e = [];

            if (c.length) {
              e.push(["M", c[0].start.x, c[0].start.y]);

              for (var l = 0; l < c.length; ++l) {
                e.push(["L", c[l].end.x, c[l].end.y]);
              }
            }

            return e;
          }

          function B(c, e) {
            c.yMin = y(c.yMin, e.yMin);
            c.yMax = I(c.yMax, e.yMax);
            c.xMin = y(c.xMin, e.xMin);
            c.xMax = I(c.xMax, e.xMax);
          }

          var E = e.pick,
              I = Math.min,
              y = Math.max,
              r = Math.abs;

          e = function e(c, _e11, l) {
            function g(b, c, a, e, d) {
              b = {
                x: b.x,
                y: b.y
              };
              b[c] = a[e || c] + (d || 0);
              return b;
            }

            function f(b, c, a) {
              var e = r(c[a] - b[a + "Min"]) > r(c[a] - b[a + "Max"]);
              return g(c, a, b, a + (e ? "Max" : "Min"), e ? 1 : -1);
            }

            var b = [],
                n = E(l.startDirectionX, r(_e11.x - c.x) > r(_e11.y - c.y)) ? "x" : "y",
                q = l.chartObstacles,
                y = D(q, c);
            l = D(q, _e11);

            if (-1 < l) {
              var B = q[l];
              l = f(B, _e11, n);
              B = {
                start: l,
                end: _e11
              };
              var p = l;
            } else p = _e11;

            -1 < y && (q = q[y], l = f(q, c, n), b.push({
              start: c,
              end: l
            }), l[n] >= c[n] === l[n] >= p[n] && (n = "y" === n ? "x" : "y", _e11 = c[n] < _e11[n], b.push({
              start: l,
              end: g(l, n, q, n + (_e11 ? "Max" : "Min"), _e11 ? 1 : -1)
            }), n = "y" === n ? "x" : "y"));
            c = b.length ? b[b.length - 1].end : c;
            l = g(c, n, p);
            b.push({
              start: c,
              end: l
            });
            n = g(l, "y" === n ? "x" : "y", p);
            b.push({
              start: l,
              end: n
            });
            b.push(B);
            return {
              path: G(b),
              obstacles: b
            };
          };

          e.requiresObstacles = !0;

          var q = function q(c, e, l) {
            function g(a, b, c) {
              var d,
                  e = a.x < b.x ? 1 : -1;

              if (a.x < b.x) {
                var f = a;
                var g = b;
              } else f = b, g = a;

              if (a.y < b.y) {
                var h = a;
                var k = b;
              } else h = b, k = a;

              for (d = 0 > e ? I(n(F, g.x), F.length - 1) : 0; F[d] && (0 < e && F[d].xMin <= g.x || 0 > e && F[d].xMax >= f.x);) {
                if (F[d].xMin <= g.x && F[d].xMax >= f.x && F[d].yMin <= k.y && F[d].yMax >= h.y) return c ? {
                  y: a.y,
                  x: a.x < b.x ? F[d].xMin - 1 : F[d].xMax + 1,
                  obstacle: F[d]
                } : {
                  x: a.x,
                  y: a.y < b.y ? F[d].yMin - 1 : F[d].yMax + 1,
                  obstacle: F[d]
                };
                d += e;
              }

              return b;
            }

            function f(a, b, c, d, e) {
              var f = e.soft,
                  h = e.hard,
                  k = d ? "x" : "y",
                  m = {
                x: b.x,
                y: b.y
              },
                  u = {
                x: b.x,
                y: b.y
              };
              e = a[k + "Max"] >= f[k + "Max"];
              f = a[k + "Min"] <= f[k + "Min"];
              var l = a[k + "Max"] >= h[k + "Max"];
              h = a[k + "Min"] <= h[k + "Min"];
              var p = r(a[k + "Min"] - b[k]),
                  n = r(a[k + "Max"] - b[k]);
              c = 10 > r(p - n) ? b[k] < c[k] : n < p;
              u[k] = a[k + "Min"];
              m[k] = a[k + "Max"];
              a = g(b, u, d)[k] !== u[k];
              b = g(b, m, d)[k] !== m[k];
              c = a ? b ? c : !0 : b ? !1 : c;
              c = f ? e ? c : !0 : e ? !1 : c;
              return h ? l ? c : !0 : l ? !1 : c;
            }

            function b(c, e, h) {
              if (c.x === e.x && c.y === e.y) return [];
              var k = h ? "x" : "y",
                  m = l.obstacleOptions.margin;
              var u = {
                soft: {
                  xMin: t,
                  xMax: a,
                  yMin: z,
                  yMax: d
                },
                hard: l.hardBounds
              };
              var n = D(F, c);

              if (-1 < n) {
                n = F[n];
                u = f(n, c, e, h, u);
                B(n, l.hardBounds);
                var q = h ? {
                  y: c.y,
                  x: n[u ? "xMax" : "xMin"] + (u ? 1 : -1)
                } : {
                  x: c.x,
                  y: n[u ? "yMax" : "yMin"] + (u ? 1 : -1)
                };
                var r = D(F, q);
                -1 < r && (r = F[r], B(r, l.hardBounds), q[k] = u ? y(n[k + "Max"] - m + 1, (r[k + "Min"] + n[k + "Max"]) / 2) : I(n[k + "Min"] + m - 1, (r[k + "Max"] + n[k + "Min"]) / 2), c.x === q.x && c.y === q.y ? (p && (q[k] = u ? y(n[k + "Max"], r[k + "Max"]) + 1 : I(n[k + "Min"], r[k + "Min"]) - 1), p = !p) : p = !1);
                c = [{
                  start: c,
                  end: q
                }];
              } else k = g(c, {
                x: h ? e.x : c.x,
                y: h ? c.y : e.y
              }, h), c = [{
                start: c,
                end: {
                  x: k.x,
                  y: k.y
                }
              }], k[h ? "x" : "y"] !== e[h ? "x" : "y"] && (u = f(k.obstacle, k, e, !h, u), B(k.obstacle, l.hardBounds), u = {
                x: h ? k.x : k.obstacle[u ? "xMax" : "xMin"] + (u ? 1 : -1),
                y: h ? k.obstacle[u ? "yMax" : "yMin"] + (u ? 1 : -1) : k.y
              }, h = !h, c = c.concat(b({
                x: k.x,
                y: k.y
              }, u, h)));

              return c = c.concat(b(c[c.length - 1].end, e, !h));
            }

            function q(a, b, c) {
              var d = I(a.xMax - b.x, b.x - a.xMin) < I(a.yMax - b.y, b.y - a.yMin);
              c = f(a, b, c, d, {
                soft: l.hardBounds,
                hard: l.hardBounds
              });
              return d ? {
                y: b.y,
                x: a[c ? "xMax" : "xMin"] + (c ? 1 : -1)
              } : {
                x: b.x,
                y: a[c ? "yMax" : "yMin"] + (c ? 1 : -1)
              };
            }

            var J = E(l.startDirectionX, r(e.x - c.x) > r(e.y - c.y)),
                C = J ? "x" : "y",
                H = [],
                p = !1,
                m = l.obstacleMetrics,
                t = I(c.x, e.x) - m.maxWidth - 10,
                a = y(c.x, e.x) + m.maxWidth + 10,
                z = I(c.y, e.y) - m.maxHeight - 10,
                d = y(c.y, e.y) + m.maxHeight + 10,
                F = l.chartObstacles;
            var k = n(F, t);
            m = n(F, a);
            F = F.slice(k, m + 1);

            if (-1 < (m = D(F, e))) {
              var h = q(F[m], e, c);
              H.push({
                end: e,
                start: h
              });
              e = h;
            }

            for (; -1 < (m = D(F, e));) {
              k = 0 > e[C] - c[C], h = {
                x: e.x,
                y: e.y
              }, h[C] = F[m][k ? C + "Max" : C + "Min"] + (k ? 1 : -1), H.push({
                end: e,
                start: h
              }), e = h;
            }

            c = b(c, e, J);
            c = c.concat(H.reverse());
            return {
              path: G(c),
              obstacles: c
            };
          };

          q.requiresObstacles = !0;
          return {
            fastAvoid: q,
            straight: function straight(c, e) {
              return {
                path: [["M", c.x, c.y], ["L", e.x, e.y]],
                obstacles: [{
                  start: c,
                  end: e
                }]
              };
            },
            simpleConnect: e
          };
        });
        N(e, "Gantt/Pathfinder.js", [e["Gantt/Connection.js"], e["Core/Chart/Chart.js"], e["Core/Globals.js"], e["Core/DefaultOptions.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"], e["Gantt/PathfinderAlgorithms.js"]], function (e, n, D, H, B, E, I) {
          function y(b) {
            var c = b.shapeArgs;
            return c ? {
              xMin: c.x || 0,
              xMax: (c.x || 0) + (c.width || 0),
              yMin: c.y || 0,
              yMax: (c.y || 0) + (c.height || 0)
            } : (c = b.graphic && b.graphic.getBBox()) ? {
              xMin: b.plotX - c.width / 2,
              xMax: b.plotX + c.width / 2,
              yMin: b.plotY - c.height / 2,
              yMax: b.plotY + c.height / 2
            } : null;
          }

          function r(c) {
            for (var e = c.length, f = 0, a, g, d = [], l = function l(a, c, d) {
              d = b(d, 10);
              var e = a.yMax + d > c.yMin - d && a.yMin - d < c.yMax + d,
                  f = a.xMax + d > c.xMin - d && a.xMin - d < c.xMax + d,
                  g = e ? a.xMin > c.xMax ? a.xMin - c.xMax : c.xMin - a.xMax : Infinity,
                  h = f ? a.yMin > c.yMax ? a.yMin - c.yMax : c.yMin - a.yMax : Infinity;
              return f && e ? d ? l(a, c, Math.floor(d / 2)) : Infinity : C(g, h);
            }; f < e; ++f) {
              for (a = f + 1; a < e; ++a) {
                g = l(c[f], c[a]), 80 > g && d.push(g);
              }
            }

            d.push(80);
            return J(Math.floor(d.sort(function (a, b) {
              return a - b;
            })[Math.floor(d.length / 10)] / 2 - 1), 1);
          }

          function q(b) {
            if (b.options.pathfinder || b.series.reduce(function (b, c) {
              c.options && f(!0, c.options.connectors = c.options.connectors || {}, c.options.pathfinder);
              return b || c.options && c.options.pathfinder;
            }, !1)) f(!0, b.options.connectors = b.options.connectors || {}, b.options.pathfinder), l('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.');
          }

          "";
          var c = E.addEvent,
              g = E.defined,
              l = E.error,
              x = E.extend,
              f = E.merge,
              b = E.pick,
              w = E.splat,
              J = Math.max,
              C = Math.min;
          x(H.defaultOptions, {
            connectors: {
              type: "straight",
              lineWidth: 1,
              marker: {
                enabled: !1,
                align: "center",
                verticalAlign: "middle",
                inside: !1,
                lineWidth: 1
              },
              startMarker: {
                symbol: "diamond"
              },
              endMarker: {
                symbol: "arrow-filled"
              }
            }
          });

          var G = function () {
            function f(b) {
              this.lineObstacles = this.group = this.connections = this.chartObstacleMetrics = this.chartObstacles = this.chart = void 0;
              this.init(b);
            }

            f.prototype.init = function (b) {
              this.chart = b;
              this.connections = [];
              c(b, "redraw", function () {
                this.pathfinder.update();
              });
            };

            f.prototype.update = function (b) {
              var c = this.chart,
                  a = this,
                  f = a.connections;
              a.connections = [];
              c.series.forEach(function (b) {
                b.visible && !b.options.isInternal && b.points.forEach(function (b) {
                  var d = b.options;
                  d && d.dependency && (d.connect = d.dependency);
                  var f;
                  d = b.options && b.options.connect && w(b.options.connect);
                  b.visible && !1 !== b.isInside && d && d.forEach(function (d) {
                    f = c.get("string" === typeof d ? d : d.to);
                    f instanceof B && f.series.visible && f.visible && !1 !== f.isInside && a.connections.push(new e(b, f, "string" === typeof d ? {} : d));
                  });
                });
              });

              for (var d = 0, g = void 0, k = void 0, h = f.length, m = a.connections.length; d < h; ++d) {
                k = !1;

                for (g = 0; g < m; ++g) {
                  if (f[d].fromPoint === a.connections[g].fromPoint && f[d].toPoint === a.connections[g].toPoint) {
                    a.connections[g].graphics = f[d].graphics;
                    k = !0;
                    break;
                  }
                }

                k || f[d].destroy();
              }

              delete this.chartObstacles;
              delete this.lineObstacles;
              a.renderConnections(b);
            };

            f.prototype.renderConnections = function (b) {
              b ? this.chart.series.forEach(function (b) {
                var a = function a() {
                  var a = b.chart.pathfinder;
                  (a && a.connections || []).forEach(function (a) {
                    a.fromPoint && a.fromPoint.series === b && a.render();
                  });
                  b.pathfinderRemoveRenderEvent && (b.pathfinderRemoveRenderEvent(), delete b.pathfinderRemoveRenderEvent);
                };

                !1 === b.options.animation ? a() : b.pathfinderRemoveRenderEvent = c(b, "afterAnimate", a);
              }) : this.connections.forEach(function (b) {
                b.render();
              });
            };

            f.prototype.getChartObstacles = function (c) {
              for (var e = [], a = this.chart.series, f = b(c.algorithmMargin, 0), d, m = 0, k = a.length; m < k; ++m) {
                if (a[m].visible && !a[m].options.isInternal) {
                  var h = 0,
                      l = a[m].points.length,
                      p = void 0;

                  for (p = void 0; h < l; ++h) {
                    p = a[m].points[h], p.visible && (p = y(p)) && e.push({
                      xMin: p.xMin - f,
                      xMax: p.xMax + f,
                      yMin: p.yMin - f,
                      yMax: p.yMax + f
                    });
                  }
                }
              }

              e = e.sort(function (a, b) {
                return a.xMin - b.xMin;
              });
              g(c.algorithmMargin) || (d = c.algorithmMargin = r(e), e.forEach(function (a) {
                a.xMin -= d;
                a.xMax += d;
                a.yMin -= d;
                a.yMax += d;
              }));
              return e;
            };

            f.prototype.getObstacleMetrics = function (b) {
              for (var c = 0, a = 0, e, d, f = b.length; f--;) {
                e = b[f].xMax - b[f].xMin, d = b[f].yMax - b[f].yMin, c < e && (c = e), a < d && (a = d);
              }

              return {
                maxHeight: a,
                maxWidth: c
              };
            };

            f.prototype.getAlgorithmStartDirection = function (b) {
              var c = "top" !== b.verticalAlign && "bottom" !== b.verticalAlign;
              return "left" !== b.align && "right" !== b.align ? c ? void 0 : !1 : c ? !0 : void 0;
            };

            return f;
          }();

          G.prototype.algorithms = I;
          D.Pathfinder = G;
          x(B.prototype, {
            getPathfinderAnchorPoint: function getPathfinderAnchorPoint(b) {
              var c = y(this);

              switch (b.align) {
                case "right":
                  var e = "xMax";
                  break;

                case "left":
                  e = "xMin";
              }

              switch (b.verticalAlign) {
                case "top":
                  var a = "yMin";
                  break;

                case "bottom":
                  a = "yMax";
              }

              return {
                x: e ? c[e] : (c.xMin + c.xMax) / 2,
                y: a ? c[a] : (c.yMin + c.yMax) / 2
              };
            },
            getRadiansToVector: function getRadiansToVector(b, c) {
              var e;
              g(c) || (e = y(this)) && (c = {
                x: (e.xMin + e.xMax) / 2,
                y: (e.yMin + e.yMax) / 2
              });
              return Math.atan2(c.y - b.y, b.x - c.x);
            },
            getMarkerVector: function getMarkerVector(b, c, e) {
              var a = 2 * Math.PI,
                  f = y(this),
                  d = f.xMax - f.xMin,
                  g = f.yMax - f.yMin,
                  k = Math.atan2(g, d),
                  h = !1;
              d /= 2;
              var m = g / 2,
                  l = f.xMin + d;
              f = f.yMin + m;

              for (var u = l, p = f, n = 1, q = 1; b < -Math.PI;) {
                b += a;
              }

              for (; b > Math.PI;) {
                b -= a;
              }

              a = Math.tan(b);
              b > -k && b <= k ? (q = -1, h = !0) : b > k && b <= Math.PI - k ? q = -1 : b > Math.PI - k || b <= -(Math.PI - k) ? (n = -1, h = !0) : n = -1;
              h ? (u += n * d, p += q * d * a) : (u += g / (2 * a) * n, p += q * m);
              e.x !== l && (u = e.x);
              e.y !== f && (p = e.y);
              return {
                x: u + c * Math.cos(b),
                y: p - c * Math.sin(b)
              };
            }
          });
          n.prototype.callbacks.push(function (b) {
            !1 !== b.options.connectors.enabled && (q(b), this.pathfinder = new G(this), this.pathfinder.update(!0));
          });
          return G;
        });
        N(e, "Series/Gantt/GanttSeries.js", [e["Core/Axis/Axis.js"], e["Core/Chart/Chart.js"], e["Series/Gantt/GanttPoint.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Axis/Tick.js"], e["Core/Utilities.js"], e["Core/Axis/TreeGridAxis.js"]], function (e, n, D, H, B, E, I) {
          var y = this && this.__extends || function () {
            var _c7 = function c(e, b) {
              _c7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (b[e] = c[e]);
                }
              };

              return _c7(e, b);
            };

            return function (e, b) {
              function f() {
                this.constructor = e;
              }

              _c7(e, b);

              e.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());
            };
          }(),
              r = H.series,
              q = H.seriesTypes.xrange,
              c = E.extend,
              g = E.isNumber,
              l = E.merge;

          I.compose(e, n, r, B);

          e = function (c) {
            function e() {
              var b = null !== c && c.apply(this, arguments) || this;
              b.data = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            y(e, c);

            e.prototype.drawPoint = function (b, c) {
              var e = this.options,
                  f = this.chart.renderer,
                  l = b.shapeArgs,
                  p = b.plotY,
                  m = b.graphic,
                  n = b.selected && "select",
                  a = e.stacking && !e.borderRadius;
              if (b.options.milestone) {
                if (g(p) && null !== b.y && !1 !== b.visible) {
                  l = f.symbols.diamond(l.x || 0, l.y || 0, l.width || 0, l.height || 0);
                  if (m) m[c]({
                    d: l
                  });else b.graphic = f.path(l).addClass(b.getClassName(), !0).add(b.group || this.group);
                  this.chart.styledMode || b.graphic.attr(this.pointAttribs(b, n)).shadow(e.shadow, null, a);
                } else m && (b.graphic = m.destroy());
              } else q.prototype.drawPoint.call(this, b, c);
            };

            e.prototype.translatePoint = function (b) {
              q.prototype.translatePoint.call(this, b);

              if (b.options.milestone) {
                var c = b.shapeArgs;
                var e = c.height || 0;
                b.shapeArgs = {
                  x: (c.x || 0) - e / 2,
                  y: c.y,
                  width: e,
                  height: e
                };
              }
            };

            e.defaultOptions = l(q.defaultOptions, {
              grouping: !1,
              dataLabels: {
                enabled: !0
              },
              tooltip: {
                headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>',
                pointFormat: null,
                pointFormatter: function pointFormatter() {
                  var b = this.series,
                      c = b.xAxis,
                      e = b.tooltipOptions.dateTimeLabelFormats,
                      f = c.options.startOfWeek,
                      l = b.tooltipOptions,
                      p = l.xDateFormat,
                      m = this.options.milestone,
                      n = "<b>" + (this.name || this.yCategory) + "</b>";
                  if (l.pointFormat) return this.tooltipFormatter(l.pointFormat);
                  !p && g(this.start) && (p = b.chart.time.getDateFormat(c.closestPointRange, this.start, f, e || {}));
                  c = b.chart.time.dateFormat(p, this.start);
                  b = b.chart.time.dateFormat(p, this.end);
                  n += "<br/>";
                  return m ? n + (c + "<br/>") : n + ("Start: " + c + "<br/>End: ") + (b + "<br/>");
                }
              },
              connectors: {
                type: "simpleConnect",
                animation: {
                  reversed: !0
                },
                startMarker: {
                  enabled: !0,
                  symbol: "arrow-filled",
                  radius: 4,
                  fill: "#fa0",
                  align: "left"
                },
                endMarker: {
                  enabled: !1,
                  align: "right"
                }
              }
            });
            return e;
          }(q);

          c(e.prototype, {
            pointArrayMap: ["start", "end", "y"],
            pointClass: D,
            setData: r.prototype.setData
          });
          H.registerSeriesType("gantt", e);
          "";
          return e;
        });
        N(e, "Core/Chart/GanttChart.js", [e["Core/Chart/Chart.js"], e["Core/DefaultOptions.js"], e["Core/Utilities.js"]], function (e, n, D) {
          var G = this && this.__extends || function () {
            var _e12 = function e(n, c) {
              _e12 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, e) {
                c.__proto__ = e;
              } || function (c, e) {
                for (var g in e) {
                  e.hasOwnProperty(g) && (c[g] = e[g]);
                }
              };

              return _e12(n, c);
            };

            return function (n, c) {
              function g() {
                this.constructor = n;
              }

              _e12(n, c);

              n.prototype = null === c ? Object.create(c) : (g.prototype = c.prototype, new g());
            };
          }(),
              B = n.getOptions,
              E = D.isArray,
              I = D.merge,
              y = D.splat;

          e = function (e) {
            function n() {
              return null !== e && e.apply(this, arguments) || this;
            }

            G(n, e);

            n.prototype.init = function (c, g) {
              var l = B(),
                  n = c.xAxis,
                  f = c.yAxis,
                  b;
              c.xAxis = c.yAxis = void 0;
              var q = I(!0, {
                chart: {
                  type: "gantt"
                },
                title: {
                  text: null
                },
                legend: {
                  enabled: !1
                },
                navigator: {
                  series: {
                    type: "gantt"
                  },
                  yAxis: {
                    type: "category"
                  }
                }
              }, c, {
                isGantt: !0
              });
              c.xAxis = n;
              c.yAxis = f;
              q.xAxis = (E(c.xAxis) ? c.xAxis : [c.xAxis || {}, {}]).map(function (c, e) {
                1 === e && (b = 0);
                return I(l.xAxis, {
                  grid: {
                    enabled: !0
                  },
                  opposite: !0,
                  linkedTo: b
                }, c, {
                  type: "datetime"
                });
              });
              q.yAxis = y(c.yAxis || {}).map(function (b) {
                return I(l.yAxis, {
                  grid: {
                    enabled: !0
                  },
                  staticScale: 50,
                  reversed: !0,
                  type: b.categories ? b.type : "treegrid"
                }, b);
              });
              e.prototype.init.call(this, q, g);
            };

            return n;
          }(e);

          (function (e) {
            e.ganttChart = function (n, c, g) {
              return new e(n, c, g);
            };
          })(e || (e = {}));

          return e;
        });
        N(e, "Core/Axis/ScrollbarAxis.js", [e["Core/Utilities.js"]], function (e) {
          var n = e.addEvent,
              D = e.defined,
              G = e.pick;
          return function () {
            function e() {}

            e.compose = function (B, I) {
              if (-1 === e.composed.indexOf(B)) e.composed.push(B);else return B;

              var y = function y(e) {
                var n = G(e.options && e.options.min, e.min),
                    c = G(e.options && e.options.max, e.max);
                return {
                  axisMin: n,
                  axisMax: c,
                  scrollMin: D(e.dataMin) ? Math.min(n, e.min, e.dataMin, G(e.threshold, Infinity)) : n,
                  scrollMax: D(e.dataMax) ? Math.max(c, e.max, e.dataMax, G(e.threshold, -Infinity)) : c
                };
              };

              n(B, "afterInit", function () {
                var e = this;
                e.options && e.options.scrollbar && e.options.scrollbar.enabled && (e.options.scrollbar.vertical = !e.horiz, e.options.startOnTick = e.options.endOnTick = !1, e.scrollbar = new I(e.chart.renderer, e.options.scrollbar, e.chart), n(e.scrollbar, "changed", function (n) {
                  var c = y(e),
                      g = c.axisMax,
                      l = c.scrollMin,
                      q = c.scrollMax - l;
                  D(c.axisMin) && D(g) && (e.horiz && !e.reversed || !e.horiz && e.reversed ? (c = l + q * this.to, l += q * this.from) : (c = l + q * (1 - this.from), l += q * (1 - this.to)), this.shouldUpdateExtremes(n.DOMType) ? e.setExtremes(l, c, !0, "mousemove" !== n.DOMType && "touchmove" !== n.DOMType, n) : this.setRange(this.from, this.to));
                }));
              });
              n(B, "afterRender", function () {
                var e = y(this),
                    n = e.scrollMin,
                    c = e.scrollMax;
                e = this.scrollbar;
                var g = this.axisTitleMargin + (this.titleOffset || 0),
                    l = this.chart.scrollbarsOffsets,
                    x = this.options.margin || 0;
                e && (this.horiz ? (this.opposite || (l[1] += g), e.position(this.left, this.top + this.height + 2 + l[1] - (this.opposite ? x : 0), this.width, this.height), this.opposite || (l[1] += x), g = 1) : (this.opposite && (l[0] += g), e.position(e.options.opposite ? this.left + this.width + 2 + l[0] - (this.opposite ? 0 : x) : this.opposite ? 0 : x, this.top, this.width, this.height), this.opposite && (l[0] += x), g = 0), l[g] += e.size + e.options.margin, isNaN(n) || isNaN(c) || !D(this.min) || !D(this.max) || this.min === this.max ? e.setRange(0, 1) : (l = (this.min - n) / (c - n), n = (this.max - n) / (c - n), this.horiz && !this.reversed || !this.horiz && this.reversed ? e.setRange(l, n) : e.setRange(1 - n, 1 - l)));
              });
              n(B, "afterGetOffset", function () {
                var e = this.scrollbar && !this.scrollbar.options.opposite;
                e = this.horiz ? 2 : e ? 3 : 1;
                var n = this.scrollbar;
                n && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[e] += n.size + n.options.margin);
              });
              return B;
            };

            e.composed = [];
            return e;
          }();
        });
        N(e, "Core/ScrollbarDefaults.js", [e["Core/Globals.js"]], function (e) {
          return {
            height: e.isTouchDevice ? 20 : 14,
            barBorderRadius: 0,
            buttonBorderRadius: 0,
            liveRedraw: void 0,
            margin: 10,
            minWidth: 6,
            opposite: !0,
            step: .2,
            zIndex: 3,
            barBackgroundColor: "#cccccc",
            barBorderWidth: 1,
            barBorderColor: "#cccccc",
            buttonArrowColor: "#333333",
            buttonBackgroundColor: "#e6e6e6",
            buttonBorderColor: "#cccccc",
            buttonBorderWidth: 1,
            rifleColor: "#333333",
            trackBackgroundColor: "#f2f2f2",
            trackBorderColor: "#f2f2f2",
            trackBorderWidth: 1
          };
        });
        N(e, "Core/Scrollbar.js", [e["Core/DefaultOptions.js"], e["Core/Globals.js"], e["Core/Axis/ScrollbarAxis.js"], e["Core/ScrollbarDefaults.js"], e["Core/Utilities.js"]], function (e, n, D, H, B) {
          var E = e.defaultOptions,
              G = B.addEvent,
              y = B.correctFloat,
              r = B.defined,
              q = B.destroyObjectProperties,
              c = B.fireEvent,
              g = B.merge,
              l = B.pick,
              x = B.removeEvent;

          e = function () {
            function e(b, c, e) {
              this._events = [];
              this.chart = void 0;
              this.from = this.chartY = this.chartX = 0;
              this.scrollbar = this.renderer = this.options = this.group = void 0;
              this.scrollbarButtons = [];
              this.scrollbarGroup = void 0;
              this.scrollbarLeft = 0;
              this.scrollbarRifles = void 0;
              this.scrollbarStrokeWidth = 1;
              this.to = this.size = this.scrollbarTop = 0;
              this.track = void 0;
              this.trackBorderWidth = 1;
              this.userOptions = void 0;
              this.y = this.x = 0;
              this.init(b, c, e);
            }

            e.compose = function (b) {
              D.compose(b, e);
            };

            e.swapXY = function (b, c) {
              c && b.forEach(function (b) {
                for (var c = b.length, e, f = 0; f < c; f += 2) {
                  e = b[f + 1], "number" === typeof e && (b[f + 1] = b[f + 2], b[f + 2] = e);
                }
              });
              return b;
            };

            e.prototype.addEvents = function () {
              var b = this.options.inverted ? [1, 0] : [0, 1],
                  c = this.scrollbarButtons,
                  e = this.scrollbarGroup.element,
                  f = this.track.element,
                  g = this.mouseDownHandler.bind(this),
                  l = this.mouseMoveHandler.bind(this),
                  m = this.mouseUpHandler.bind(this);
              b = [[c[b[0]].element, "click", this.buttonToMinClick.bind(this)], [c[b[1]].element, "click", this.buttonToMaxClick.bind(this)], [f, "click", this.trackClick.bind(this)], [e, "mousedown", g], [e.ownerDocument, "mousemove", l], [e.ownerDocument, "mouseup", m]];
              n.hasTouch && b.push([e, "touchstart", g], [e.ownerDocument, "touchmove", l], [e.ownerDocument, "touchend", m]);
              b.forEach(function (b) {
                G.apply(null, b);
              });
              this._events = b;
            };

            e.prototype.buttonToMaxClick = function (b) {
              var e = (this.to - this.from) * l(this.options.step, .2);
              this.updatePosition(this.from + e, this.to + e);
              c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: b
              });
            };

            e.prototype.buttonToMinClick = function (b) {
              var e = y(this.to - this.from) * l(this.options.step, .2);
              this.updatePosition(y(this.from - e), y(this.to - e));
              c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: b
              });
            };

            e.prototype.cursorToScrollbarPosition = function (b) {
              var c = this.options;
              c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;
              return {
                chartX: (b.chartX - this.x - this.xOffset) / (this.barWidth - c),
                chartY: (b.chartY - this.y - this.yOffset) / (this.barWidth - c)
              };
            };

            e.prototype.destroy = function () {
              var b = this,
                  c = b.chart.scroller;
              b.removeEvents();
              ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (c) {
                b[c] && b[c].destroy && (b[c] = b[c].destroy());
              });
              c && b === c.scrollbar && (c.scrollbar = null, q(c.scrollbarButtons));
            };

            e.prototype.drawScrollbarButton = function (b) {
              var c = this.renderer,
                  f = this.scrollbarButtons,
                  g = this.options,
                  l = this.size,
                  n = c.g().add(this.group);
              f.push(n);
              n = c.rect().addClass("highcharts-scrollbar-button").add(n);
              this.chart.styledMode || n.attr({
                stroke: g.buttonBorderColor,
                "stroke-width": g.buttonBorderWidth,
                fill: g.buttonBackgroundColor
              });
              n.attr(n.crisp({
                x: -.5,
                y: -.5,
                width: l + 1,
                height: l + 1,
                r: g.buttonBorderRadius
              }, n.strokeWidth()));
              n = c.path(e.swapXY([["M", l / 2 + (b ? -1 : 1), l / 2 - 3], ["L", l / 2 + (b ? -1 : 1), l / 2 + 3], ["L", l / 2 + (b ? 2 : -2), l / 2]], g.vertical)).addClass("highcharts-scrollbar-arrow").add(f[b]);
              this.chart.styledMode || n.attr({
                fill: g.buttonArrowColor
              });
            };

            e.prototype.init = function (b, c, e) {
              this.scrollbarButtons = [];
              this.renderer = b;
              this.userOptions = c;
              this.options = g(H, E.scrollbar, c);
              this.chart = e;
              this.size = l(this.options.size, this.options.height);
              c.enabled && (this.render(), this.addEvents());
            };

            e.prototype.mouseDownHandler = function (b) {
              b = this.chart.pointer.normalize(b);
              b = this.cursorToScrollbarPosition(b);
              this.chartX = b.chartX;
              this.chartY = b.chartY;
              this.initPositions = [this.from, this.to];
              this.grabbedCenter = !0;
            };

            e.prototype.mouseMoveHandler = function (b) {
              var e = this.chart.pointer.normalize(b),
                  f = this.options.vertical ? "chartY" : "chartX",
                  g = this.initPositions || [];
              !this.grabbedCenter || b.touches && 0 === b.touches[0][f] || (e = this.cursorToScrollbarPosition(e)[f], f = this[f], f = e - f, this.hasDragged = !0, this.updatePosition(g[0] + f, g[1] + f), this.hasDragged && c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: b.type,
                DOMEvent: b
              }));
            };

            e.prototype.mouseUpHandler = function (b) {
              this.hasDragged && c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: b.type,
                DOMEvent: b
              });
              this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
            };

            e.prototype.position = function (b, c, e, f) {
              var g = this.options.vertical,
                  l = this.rendered ? "animate" : "attr",
                  m = f,
                  n = 0;
              this.group.show();
              this.x = b;
              this.y = c + this.trackBorderWidth;
              this.width = e;
              this.height = f;
              this.xOffset = m;
              this.yOffset = n;
              g ? (this.width = this.yOffset = e = n = this.size, this.xOffset = m = 0, this.barWidth = f - 2 * e, this.x = b += this.options.margin) : (this.height = this.xOffset = f = m = this.size, this.barWidth = e - 2 * f, this.y += this.options.margin);
              this.group[l]({
                translateX: b,
                translateY: this.y
              });
              this.track[l]({
                width: e,
                height: f
              });
              this.scrollbarButtons[1][l]({
                translateX: g ? 0 : e - m,
                translateY: g ? f - n : 0
              });
            };

            e.prototype.removeEvents = function () {
              this._events.forEach(function (b) {
                x.apply(null, b);
              });

              this._events.length = 0;
            };

            e.prototype.render = function () {
              var b = this.renderer,
                  c = this.options,
                  f = this.size,
                  g = this.chart.styledMode,
                  l = b.g("scrollbar").attr({
                zIndex: c.zIndex
              }).hide().add();
              this.group = l;
              this.track = b.rect().addClass("highcharts-scrollbar-track").attr({
                x: 0,
                r: c.trackBorderRadius || 0,
                height: f,
                width: f
              }).add(l);
              g || this.track.attr({
                fill: c.trackBackgroundColor,
                stroke: c.trackBorderColor,
                "stroke-width": c.trackBorderWidth
              });
              this.trackBorderWidth = this.track.strokeWidth();
              this.track.attr({
                y: -this.trackBorderWidth % 2 / 2
              });
              this.scrollbarGroup = b.g().add(l);
              this.scrollbar = b.rect().addClass("highcharts-scrollbar-thumb").attr({
                height: f,
                width: f,
                r: c.barBorderRadius || 0
              }).add(this.scrollbarGroup);
              this.scrollbarRifles = b.path(e.swapXY([["M", -3, f / 4], ["L", -3, 2 * f / 3], ["M", 0, f / 4], ["L", 0, 2 * f / 3], ["M", 3, f / 4], ["L", 3, 2 * f / 3]], c.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
              g || (this.scrollbar.attr({
                fill: c.barBackgroundColor,
                stroke: c.barBorderColor,
                "stroke-width": c.barBorderWidth
              }), this.scrollbarRifles.attr({
                stroke: c.rifleColor,
                "stroke-width": 1
              }));
              this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
              this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
              this.drawScrollbarButton(0);
              this.drawScrollbarButton(1);
            };

            e.prototype.setRange = function (b, c) {
              var e = this.options,
                  f = e.vertical,
                  g = e.minWidth,
                  l = this.barWidth,
                  m = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";

              if (r(l)) {
                var n = l * Math.min(c, 1);
                b = Math.max(b, 0);
                var a = Math.ceil(l * b);
                this.calculatedWidth = n = y(n - a);
                n < g && (a = (l - g + n) * b, n = g);
                g = Math.floor(a + this.xOffset + this.yOffset);
                l = n / 2 - .5;
                this.from = b;
                this.to = c;
                f ? (this.scrollbarGroup[m]({
                  translateY: g
                }), this.scrollbar[m]({
                  height: n
                }), this.scrollbarRifles[m]({
                  translateY: l
                }), this.scrollbarTop = g, this.scrollbarLeft = 0) : (this.scrollbarGroup[m]({
                  translateX: g
                }), this.scrollbar[m]({
                  width: n
                }), this.scrollbarRifles[m]({
                  translateX: l
                }), this.scrollbarLeft = g, this.scrollbarTop = 0);
                12 >= n ? this.scrollbarRifles.hide() : this.scrollbarRifles.show();
                !1 === e.showFull && (0 >= b && 1 <= c ? this.group.hide() : this.group.show());
                this.rendered = !0;
              }
            };

            e.prototype.shouldUpdateExtremes = function (b) {
              return l(this.options.liveRedraw, n.svg && !n.isTouchDevice && !this.chart.isBoosting) || "mouseup" === b || "touchend" === b || !r(b);
            };

            e.prototype.trackClick = function (b) {
              var e = this.chart.pointer.normalize(b),
                  f = this.to - this.from,
                  g = this.y + this.scrollbarTop,
                  l = this.x + this.scrollbarLeft;
              this.options.vertical && e.chartY > g || !this.options.vertical && e.chartX > l ? this.updatePosition(this.from + f, this.to + f) : this.updatePosition(this.from - f, this.to - f);
              c(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: b
              });
            };

            e.prototype.update = function (b) {
              this.destroy();
              this.init(this.chart.renderer, g(!0, this.options, b), this.chart);
            };

            e.prototype.updatePosition = function (b, c) {
              1 < c && (b = y(1 - y(c - b)), c = 1);
              0 > b && (c = y(c - b), b = 0);
              this.from = b;
              this.to = c;
            };

            e.defaultOptions = H;
            return e;
          }();

          E.scrollbar = g(!0, e.defaultOptions, E.scrollbar);
          return e;
        });
        N(e, "Extensions/RangeSelector.js", [e["Core/Axis/Axis.js"], e["Core/Chart/Chart.js"], e["Core/Globals.js"], e["Core/DefaultOptions.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E) {
          function G(a) {
            if (-1 !== a.indexOf("%L")) return "text";
            var b = "aAdewbBmoyY".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            }),
                c = "HkIlMS".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            });
            return b && c ? "datetime-local" : b ? "date" : c ? "time" : "text";
          }

          var y = H.defaultOptions,
              r = E.addEvent,
              q = E.createElement,
              c = E.css,
              g = E.defined,
              l = E.destroyObjectProperties,
              x = E.discardElement,
              f = E.extend,
              b = E.find,
              w = E.fireEvent,
              J = E.isNumber,
              C = E.merge,
              K = E.objectEach,
              p = E.pad,
              m = E.pick,
              t = E.pInt,
              a = E.splat;
          f(y, {
            rangeSelector: {
              allButtonsEnabled: !1,
              buttons: void 0,
              buttonSpacing: 5,
              dropdown: "responsive",
              enabled: void 0,
              verticalAlign: "top",
              buttonTheme: {
                width: 28,
                height: 18,
                padding: 2,
                zIndex: 7
              },
              floating: !1,
              x: 0,
              y: 0,
              height: void 0,
              inputBoxBorderColor: "none",
              inputBoxHeight: 17,
              inputBoxWidth: void 0,
              inputDateFormat: "%b %e, %Y",
              inputDateParser: void 0,
              inputEditDateFormat: "%Y-%m-%d",
              inputEnabled: !0,
              inputPosition: {
                align: "right",
                x: 0,
                y: 0
              },
              inputSpacing: 5,
              selected: void 0,
              buttonPosition: {
                align: "left",
                x: 0,
                y: 0
              },
              inputStyle: {
                color: "#335cad",
                cursor: "pointer"
              },
              labelStyle: {
                color: "#666666"
              }
            }
          });
          f(y.lang, {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "\u2192"
          });

          var z = function () {
            function b(a) {
              this.buttons = void 0;
              this.buttonOptions = b.prototype.defaultButtons;
              this.initialButtonGroupWidth = 0;
              this.options = void 0;
              this.chart = a;
              this.init(a);
            }

            b.prototype.clickButton = function (b, c) {
              var d = this.chart,
                  f = this.buttonOptions[b],
                  h = d.xAxis[0],
                  k = d.scroller && d.scroller.getUnionExtremes() || h || {},
                  l = k.dataMin,
                  n = k.dataMax,
                  p = h && Math.round(Math.min(h.max, m(n, h.max))),
                  q = f.type;
              k = f._range;
              var t,
                  x = f.dataGrouping;
              var y = !0;

              if (null !== l && null !== n) {
                d.fixedRange = k;
                this.setSelected(b);
                x && (this.forcedDataGrouping = !0, e.prototype.setDataGrouping.call(h || {
                  chart: this.chart
                }, x, !1), this.frozenStates = f.preserveDataGrouping);
                if ("month" === q || "year" === q) {
                  if (h) {
                    y = {
                      range: f,
                      max: p,
                      chart: d,
                      dataMin: l,
                      dataMax: n
                    };
                    var z = h.minFromRange.call(y);
                    J(y.newMax) && (p = y.newMax);
                    y = !1;
                  } else k = f;
                } else if (k) z = Math.max(p - k, l), p = Math.min(z + k, n), y = !1;else if ("ytd" === q) {
                  if (h) {
                    if ("undefined" === typeof n || "undefined" === typeof l) l = Number.MAX_VALUE, n = Number.MIN_VALUE, d.series.forEach(function (a) {
                      if (a = a.xData) l = Math.min(a[0], l), n = Math.max(a[a.length - 1], n);
                    }), c = !1;
                    p = this.getYTDExtremes(n, l, d.time.useUTC);
                    z = t = p.min;
                    p = p.max;
                  } else {
                    this.deferredYTDClick = b;
                    return;
                  }
                } else "all" === q && h && (d.navigator && d.navigator.baseSeries[0] && (d.navigator.baseSeries[0].xAxis.options.range = void 0), z = l, p = n);
                y && f._offsetMin && g(z) && (z += f._offsetMin);
                f._offsetMax && g(p) && (p += f._offsetMax);
                this.dropdown && (this.dropdown.selectedIndex = b + 1);
                if (h) h.setExtremes(z, p, m(c, !0), void 0, {
                  trigger: "rangeSelectorButton",
                  rangeSelectorButton: f
                });else {
                  var B = a(d.options.xAxis)[0];
                  var C = B.range;
                  B.range = k;
                  var L = B.min;
                  B.min = t;
                  r(d, "load", function () {
                    B.range = C;
                    B.min = L;
                  });
                }
                w(this, "afterBtnClick");
              }
            };

            b.prototype.setSelected = function (a) {
              this.selected = this.options.selected = a;
            };

            b.prototype.init = function (a) {
              var b = this,
                  c = a.options.rangeSelector,
                  d = c.buttons || b.defaultButtons.slice(),
                  e = c.selected,
                  f = function f() {
                var a = b.minInput,
                    c = b.maxInput;
                a && a.blur && w(a, "blur");
                c && c.blur && w(c, "blur");
              };

              b.chart = a;
              b.options = c;
              b.buttons = [];
              b.buttonOptions = d;
              this.eventsToUnbind = [];
              this.eventsToUnbind.push(r(a.container, "mousedown", f));
              this.eventsToUnbind.push(r(a, "resize", f));
              d.forEach(b.computeButtonRange);
              "undefined" !== typeof e && d[e] && this.clickButton(e, !1);
              this.eventsToUnbind.push(r(a, "load", function () {
                a.xAxis && a.xAxis[0] && r(a.xAxis[0], "setExtremes", function (c) {
                  this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);
                });
              }));
            };

            b.prototype.updateButtonStates = function () {
              var a = this,
                  b = this.chart,
                  c = this.dropdown,
                  d = b.xAxis[0],
                  e = Math.round(d.max - d.min),
                  f = !d.hasVisibleSeries,
                  g = b.scroller && b.scroller.getUnionExtremes() || d,
                  k = g.dataMin,
                  m = g.dataMax;
              b = a.getYTDExtremes(m, k, b.time.useUTC);
              var l = b.min,
                  n = b.max,
                  p = a.selected,
                  q = J(p),
                  r = a.options.allButtonsEnabled,
                  t = a.buttons;
              a.buttonOptions.forEach(function (b, g) {
                var h = b._range,
                    u = b.type,
                    v = b.count || 1,
                    A = t[g],
                    w = 0,
                    x = b._offsetMax - b._offsetMin;
                b = g === p;
                var y = h > m - k,
                    z = h < d.minRange,
                    B = !1,
                    O = !1;
                h = h === e;
                ("month" === u || "year" === u) && e + 36E5 >= 864E5 * {
                  month: 28,
                  year: 365
                }[u] * v - x && e - 36E5 <= 864E5 * {
                  month: 31,
                  year: 366
                }[u] * v + x ? h = !0 : "ytd" === u ? (h = n - l + x === e, B = !b) : "all" === u && (h = d.max - d.min >= m - k, O = !b && q && h);
                u = !r && (y || z || O || f);
                v = b && h || h && !q && !B || b && a.frozenStates;
                u ? w = 3 : v && (q = !0, w = 2);
                A.state !== w && (A.setState(w), c && (c.options[g + 1].disabled = u, 2 === w && (c.selectedIndex = g + 1)), 0 === w && p === g && a.setSelected());
              });
            };

            b.prototype.computeButtonRange = function (a) {
              var b = a.type,
                  c = a.count || 1,
                  d = {
                millisecond: 1,
                second: 1E3,
                minute: 6E4,
                hour: 36E5,
                day: 864E5,
                week: 6048E5
              };
              if (d[b]) a._range = d[b] * c;else if ("month" === b || "year" === b) a._range = 864E5 * {
                month: 30,
                year: 365
              }[b] * c;
              a._offsetMin = m(a.offsetMin, 0);
              a._offsetMax = m(a.offsetMax, 0);
              a._range += a._offsetMax - a._offsetMin;
            };

            b.prototype.getInputValue = function (a) {
              a = "min" === a ? this.minInput : this.maxInput;
              var b = this.chart.options.rangeSelector,
                  c = this.chart.time;
              return a ? ("text" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;
            };

            b.prototype.setInputValue = function (a, b) {
              var c = this.options,
                  d = this.chart.time,
                  e = "min" === a ? this.minInput : this.maxInput;
              a = "min" === a ? this.minDateBox : this.maxDateBox;

              if (e) {
                var f = e.getAttribute("data-hc-time");
                f = g(f) ? Number(f) : void 0;
                g(b) && (g(f) && e.setAttribute("data-hc-time-previous", f), e.setAttribute("data-hc-time", b), f = b);
                e.value = d.dateFormat(this.inputTypeFormats[e.type] || c.inputEditDateFormat, f);
                a && a.attr({
                  text: d.dateFormat(c.inputDateFormat, f)
                });
              }
            };

            b.prototype.setInputExtremes = function (a, b, c) {
              if (a = "min" === a ? this.minInput : this.maxInput) {
                var d = this.inputTypeFormats[a.type],
                    e = this.chart.time;
                d && (b = e.dateFormat(d, b), a.min !== b && (a.min = b), c = e.dateFormat(d, c), a.max !== c && (a.max = c));
              }
            };

            b.prototype.showInput = function (a) {
              var b = "min" === a ? this.minDateBox : this.maxDateBox;

              if ((a = "min" === a ? this.minInput : this.maxInput) && b && this.inputGroup) {
                var d = "text" === a.type,
                    e = this.inputGroup,
                    f = e.translateX;
                e = e.translateY;
                var g = this.options.inputBoxWidth;
                c(a, {
                  width: d ? b.width + (g ? -2 : 20) + "px" : "auto",
                  height: d ? b.height - 2 + "px" : "auto",
                  border: "2px solid silver"
                });
                d && g ? c(a, {
                  left: f + b.x + "px",
                  top: e + "px"
                }) : c(a, {
                  left: Math.min(Math.round(b.x + f - (a.offsetWidth - b.width) / 2), this.chart.chartWidth - a.offsetWidth) + "px",
                  top: e - (a.offsetHeight - b.height) / 2 + "px"
                });
              }
            };

            b.prototype.hideInput = function (a) {
              (a = "min" === a ? this.minInput : this.maxInput) && c(a, {
                top: "-9999em",
                border: 0,
                width: "1px",
                height: "1px"
              });
            };

            b.prototype.defaultInputDateParser = function (a, b, c) {
              var d = a.split("/").join("-").split(" ").join("T");
              -1 === d.indexOf("T") && (d += "T00:00");
              if (b) d += "Z";else {
                var e;
                if (e = D.isSafari) e = d, e = !(6 < e.length && (e.lastIndexOf("-") === e.length - 6 || e.lastIndexOf("+") === e.length - 6));
                e && (e = new Date(d).getTimezoneOffset() / 60, d += 0 >= e ? "+".concat(p(-e), ":00") : "-".concat(p(e), ":00"));
              }
              d = Date.parse(d);
              J(d) || (a = a.split("-"), d = Date.UTC(t(a[0]), t(a[1]) - 1, t(a[2])));
              c && b && J(d) && (d += c.getTimezoneOffset(d));
              return d;
            };

            b.prototype.drawInput = function (a) {
              function b() {
                var b = h.getInputValue(a),
                    c = d.xAxis[0],
                    e = d.scroller && d.scroller.xAxis ? d.scroller.xAxis : c,
                    f = e.dataMin;
                e = e.dataMax;
                var g = h.maxInput,
                    k = h.minInput;
                b !== Number(r.getAttribute("data-hc-time-previous")) && J(b) && (r.setAttribute("data-hc-time-previous", b), n && g && J(f) ? b > Number(g.getAttribute("data-hc-time")) ? b = void 0 : b < f && (b = f) : k && J(e) && (b < Number(k.getAttribute("data-hc-time")) ? b = void 0 : b > e && (b = e)), "undefined" !== typeof b && c.setExtremes(n ? b : c.min, n ? c.max : b, void 0, void 0, {
                  trigger: "rangeSelectorInput"
                }));
              }

              var d = this.chart,
                  e = this.div,
                  g = this.inputGroup,
                  h = this,
                  k = d.renderer.style || {},
                  m = d.renderer,
                  l = d.options.rangeSelector,
                  n = "min" === a,
                  p = y.lang[n ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
              p = m.label(p, 0).addClass("highcharts-range-label").attr({
                padding: p ? 2 : 0,
                height: p ? l.inputBoxHeight : 0
              }).add(g);
              m = m.label("", 0).addClass("highcharts-range-input").attr({
                padding: 2,
                width: l.inputBoxWidth,
                height: l.inputBoxHeight,
                "text-align": "center"
              }).on("click", function () {
                h.showInput(a);
                h[a + "Input"].focus();
              });
              d.styledMode || m.attr({
                stroke: l.inputBoxBorderColor,
                "stroke-width": 1
              });
              m.add(g);
              var r = q("input", {
                name: a,
                className: "highcharts-range-selector"
              }, void 0, e);
              r.setAttribute("type", G(l.inputDateFormat || "%b %e, %Y"));
              d.styledMode || (p.css(C(k, l.labelStyle)), m.css(C({
                color: "#333333"
              }, k, l.inputStyle)), c(r, f({
                position: "absolute",
                border: 0,
                boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                width: "1px",
                height: "1px",
                padding: 0,
                textAlign: "center",
                fontSize: k.fontSize,
                fontFamily: k.fontFamily,
                top: "-9999em"
              }, l.inputStyle)));

              r.onfocus = function () {
                h.showInput(a);
              };

              r.onblur = function () {
                r === D.doc.activeElement && b();
                h.hideInput(a);
                h.setInputValue(a);
                r.blur();
              };

              var t = !1;

              r.onchange = function () {
                t || (b(), h.hideInput(a), r.blur());
              };

              r.onkeypress = function (a) {
                13 === a.keyCode && b();
              };

              r.onkeydown = function (a) {
                t = !0;
                38 !== a.keyCode && 40 !== a.keyCode || b();
              };

              r.onkeyup = function () {
                t = !1;
              };

              return {
                dateBox: m,
                input: r,
                label: p
              };
            };

            b.prototype.getPosition = function () {
              var a = this.chart,
                  b = a.options.rangeSelector;
              a = "top" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;
              return {
                buttonTop: a + b.buttonPosition.y,
                inputTop: a + b.inputPosition.y - 10
              };
            };

            b.prototype.getYTDExtremes = function (a, b, c) {
              var d = this.chart.time,
                  e = new d.Date(a),
                  f = d.get("FullYear", e);
              c = c ? d.Date.UTC(f, 0, 1) : +new d.Date(f, 0, 1);
              b = Math.max(b, c);
              e = e.getTime();
              return {
                max: Math.min(a || e, e),
                min: b
              };
            };

            b.prototype.render = function (a, b) {
              var c = this.chart,
                  d = c.renderer,
                  e = c.container,
                  f = c.options,
                  h = f.rangeSelector,
                  k = m(f.chart.style && f.chart.style.zIndex, 0) + 1;
              f = h.inputEnabled;

              if (!1 !== h.enabled) {
                this.rendered || (this.group = d.g("range-selector-group").attr({
                  zIndex: 7
                }).add(), this.div = q("div", void 0, {
                  position: "relative",
                  height: 0,
                  zIndex: k
                }), this.buttonOptions.length && this.renderButtons(), e.parentNode && e.parentNode.insertBefore(this.div, e), f && (this.inputGroup = d.g("input-group").add(this.group), d = this.drawInput("min"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput("max"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));

                if (f && (this.setInputValue("min", a), this.setInputValue("max", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, g(a.dataMin) && g(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes("min", a.dataMin, Math.min(a.dataMax, this.getInputValue("max")) - c), this.setInputExtremes("max", Math.max(a.dataMin, this.getInputValue("min")) + c, a.dataMax)), this.inputGroup)) {
                  var l = 0;
                  [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {
                    if (a) {
                      var b = a.getBBox().width;
                      b && (a.attr({
                        x: l
                      }), l += b + h.inputSpacing);
                    }
                  });
                }

                this.alignElements();
                this.rendered = !0;
              }
            };

            b.prototype.renderButtons = function () {
              var a = this,
                  b = this.buttons,
                  c = this.options,
                  d = y.lang,
                  e = this.chart.renderer,
                  f = C(c.buttonTheme),
                  g = f && f.states,
                  k = f.width || 28;
              delete f.width;
              delete f.states;
              this.buttonGroup = e.g("range-selector-buttons").add(this.group);
              var l = this.dropdown = q("select", void 0, {
                position: "absolute",
                width: "1px",
                height: "1px",
                padding: 0,
                border: 0,
                top: "-9999em",
                cursor: "pointer",
                opacity: .0001
              }, this.div);
              r(l, "touchstart", function () {
                l.style.fontSize = "16px";
              });
              [[D.isMS ? "mouseover" : "mouseenter"], [D.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(function (c) {
                var d = c[0],
                    e = c[1];
                r(l, d, function () {
                  var c = b[a.currentButtonIndex()];
                  c && w(c.element, e || d);
                });
              });
              this.zoomText = e.label(d && d.rangeSelectorZoom || "", 0).attr({
                padding: c.buttonTheme.padding,
                height: c.buttonTheme.height,
                paddingLeft: 0,
                paddingRight: 0
              }).add(this.buttonGroup);
              this.chart.styledMode || (this.zoomText.css(c.labelStyle), f["stroke-width"] = m(f["stroke-width"], 0));
              q("option", {
                textContent: this.zoomText.textStr,
                disabled: !0
              }, void 0, l);
              this.buttonOptions.forEach(function (c, d) {
                q("option", {
                  textContent: c.title || c.text
                }, void 0, l);
                b[d] = e.button(c.text, 0, 0, function (b) {
                  var e = c.events && c.events.click,
                      f;
                  e && (f = e.call(c, b));
                  !1 !== f && a.clickButton(d);
                  a.isActive = !0;
                }, f, g && g.hover, g && g.select, g && g.disabled).attr({
                  "text-align": "center",
                  width: k
                }).add(a.buttonGroup);
                c.title && b[d].attr("title", c.title);
              });
            };

            b.prototype.alignElements = function () {
              var a = this,
                  b = this.buttonGroup,
                  c = this.buttons,
                  d = this.chart,
                  e = this.group,
                  f = this.inputGroup,
                  g = this.options,
                  k = this.zoomText,
                  l = d.options,
                  n = l.exporting && !1 !== l.exporting.enabled && l.navigation && l.navigation.buttonOptions;
              l = g.buttonPosition;

              var p = g.inputPosition,
                  q = g.verticalAlign,
                  r = function r(b, c) {
                return n && a.titleCollision(d) && "top" === q && "right" === c.align && c.y - b.getBBox().height - 12 < (n.y || 0) + (n.height || 0) + d.spacing[0] ? -40 : 0;
              },
                  t = d.plotLeft;

              if (e && l && p) {
                var w = l.x - d.spacing[3];

                if (b) {
                  this.positionButtons();

                  if (!this.initialButtonGroupWidth) {
                    var x = 0;
                    k && (x += k.getBBox().width + 5);
                    c.forEach(function (a, b) {
                      x += a.width;
                      b !== c.length - 1 && (x += g.buttonSpacing);
                    });
                    this.initialButtonGroupWidth = x;
                  }

                  t -= d.spacing[3];
                  this.updateButtonStates();
                  k = r(b, l);
                  this.alignButtonGroup(k);
                  e.placed = b.placed = d.hasLoaded;
                }

                b = 0;
                f && (b = r(f, p), "left" === p.align ? w = t : "right" === p.align && (w = -Math.max(d.axisOffset[1], -b)), f.align({
                  y: p.y,
                  width: f.getBBox().width,
                  align: p.align,
                  x: p.x + w - 2
                }, !0, d.spacingBox), f.placed = d.hasLoaded);
                this.handleCollision(b);
                e.align({
                  verticalAlign: q
                }, !0, d.spacingBox);
                f = e.alignAttr.translateY;
                b = e.getBBox().height + 20;
                r = 0;
                "bottom" === q && (r = (r = d.legend && d.legend.options) && "bottom" === r.verticalAlign && r.enabled && !r.floating ? d.legend.legendHeight + m(r.margin, 10) : 0, b = b + r - 20, r = f - b - (g.floating ? 0 : g.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);
                if ("top" === q) g.floating && (r = 0), d.titleOffset && d.titleOffset[0] && (r = d.titleOffset[0]), r += d.margin[0] - d.spacing[0] || 0;else if ("middle" === q) if (p.y === l.y) r = f;else if (p.y || l.y) r = 0 > p.y || 0 > l.y ? r - Math.min(p.y, l.y) : f - b;
                e.translate(g.x, g.y + Math.floor(r));
                l = this.minInput;
                p = this.maxInput;
                f = this.dropdown;
                g.inputEnabled && l && p && (l.style.marginTop = e.translateY + "px", p.style.marginTop = e.translateY + "px");
                f && (f.style.marginTop = e.translateY + "px");
              }
            };

            b.prototype.alignButtonGroup = function (a, b) {
              var c = this.chart,
                  d = this.buttonGroup,
                  e = this.options.buttonPosition,
                  f = c.plotLeft - c.spacing[3],
                  g = e.x - c.spacing[3];
              "right" === e.align ? g += a - f : "center" === e.align && (g -= f / 2);
              d && d.align({
                y: e.y,
                width: m(b, this.initialButtonGroupWidth),
                align: e.align,
                x: g
              }, !0, c.spacingBox);
            };

            b.prototype.positionButtons = function () {
              var a = this.buttons,
                  b = this.chart,
                  c = this.options,
                  d = this.zoomText,
                  e = b.hasLoaded ? "animate" : "attr",
                  f = c.buttonPosition,
                  g = b.plotLeft,
                  k = g;
              d && "hidden" !== d.visibility && (d[e]({
                x: m(g + f.x, g)
              }), k += f.x + d.getBBox().width + 5);
              this.buttonOptions.forEach(function (b, d) {
                if ("hidden" !== a[d].visibility) a[d][e]({
                  x: k
                }), k += a[d].width + c.buttonSpacing;else a[d][e]({
                  x: g
                });
              });
            };

            b.prototype.handleCollision = function (a) {
              var b = this,
                  c = this.chart,
                  d = this.buttonGroup,
                  e = this.inputGroup,
                  f = this.options,
                  g = f.buttonPosition,
                  h = f.dropdown,
                  k = f.inputPosition;

              f = function f() {
                var a = 0;
                b.buttons.forEach(function (b) {
                  b = b.getBBox();
                  b.width > a && (a = b.width);
                });
                return a;
              };

              var m = function m(b) {
                if (e && d) {
                  var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,
                      f = e.alignOptions.width,
                      h = d.alignAttr.translateX + d.getBBox().x;
                  return h + b > c && c + f > h && g.y < k.y + e.getBBox().height;
                }

                return !1;
              },
                  l = function l() {
                e && d && e.attr({
                  translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),
                  translateY: e.alignAttr.translateY + d.getBBox().height + 10
                });
              };

              if (d) {
                if ("always" === h) {
                  this.collapseButtons(a);
                  m(f()) && l();
                  return;
                }

                "never" === h && this.expandButtons();
              }

              e && d ? k.align === g.align || m(this.initialButtonGroupWidth + 20) ? "responsive" === h ? (this.collapseButtons(a), m(f()) && l()) : l() : "responsive" === h && this.expandButtons() : d && "responsive" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());
            };

            b.prototype.collapseButtons = function (a) {
              var b = this.buttons,
                  c = this.buttonOptions,
                  d = this.chart,
                  e = this.dropdown,
                  f = this.options,
                  g = this.zoomText,
                  h = d.userOptions.rangeSelector && d.userOptions.rangeSelector.buttonTheme || {},
                  k = function k(a) {
                return {
                  text: a ? "" + a + " \u25BE" : "\u25BE",
                  width: "auto",
                  paddingLeft: m(f.buttonTheme.paddingLeft, h.padding, 8),
                  paddingRight: m(f.buttonTheme.paddingRight, h.padding, 8)
                };
              };

              g && g.hide();
              var l = !1;
              c.forEach(function (a, c) {
                c = b[c];
                2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), l = !0);
              });
              l || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));
              c = f.buttonPosition.align;
              this.positionButtons();
              "right" !== c && "center" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);
              this.showDropdown();
            };

            b.prototype.expandButtons = function () {
              var a = this.buttons,
                  b = this.buttonOptions,
                  c = this.options,
                  d = this.zoomText;
              this.hideDropdown();
              d && d.show();
              b.forEach(function (b, d) {
                d = a[d];
                d.show();
                d.attr({
                  text: b.text,
                  width: c.buttonTheme.width || 28,
                  paddingLeft: m(c.buttonTheme.paddingLeft, "unset"),
                  paddingRight: m(c.buttonTheme.paddingRight, "unset")
                });
                2 > d.state && d.setState(0);
              });
              this.positionButtons();
            };

            b.prototype.currentButtonIndex = function () {
              var a = this.dropdown;
              return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;
            };

            b.prototype.showDropdown = function () {
              var a = this.buttonGroup,
                  b = this.buttons,
                  d = this.chart,
                  e = this.dropdown;

              if (a && e) {
                var f = a.translateX;
                a = a.translateY;
                b = b[this.currentButtonIndex()].getBBox();
                c(e, {
                  left: d.plotLeft + f + "px",
                  top: a + .5 + "px",
                  width: b.width + "px",
                  height: b.height + "px"
                });
                this.hasVisibleDropdown = !0;
              }
            };

            b.prototype.hideDropdown = function () {
              var a = this.dropdown;
              a && (c(a, {
                top: "-9999em",
                width: "1px",
                height: "1px"
              }), this.hasVisibleDropdown = !1);
            };

            b.prototype.getHeight = function () {
              var a = this.options,
                  b = this.group,
                  c = a.y,
                  d = a.buttonPosition.y,
                  e = a.inputPosition.y;
              if (a.height) return a.height;
              this.alignElements();
              a = b ? b.getBBox(!0).height + 13 + c : 0;
              b = Math.min(e, d);
              if (0 > e && 0 > d || 0 < e && 0 < d) a += Math.abs(b);
              return a;
            };

            b.prototype.titleCollision = function (a) {
              return !(a.options.title.text || a.options.subtitle.text);
            };

            b.prototype.update = function (a) {
              var b = this.chart;
              C(!0, b.options.rangeSelector, a);
              this.destroy();
              this.init(b);
              this.render();
            };

            b.prototype.destroy = function () {
              var a = this,
                  c = a.minInput,
                  d = a.maxInput;
              a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {
                return a();
              }), a.eventsToUnbind = void 0);
              l(a.buttons);
              c && (c.onfocus = c.onblur = c.onchange = null);
              d && (d.onfocus = d.onblur = d.onchange = null);
              K(a, function (c, d) {
                c && "chart" !== d && (c instanceof B ? c.destroy() : c instanceof U.HTMLElement && x(c));
                c !== b.prototype[d] && (a[d] = null);
              }, this);
            };

            return b;
          }();

          z.prototype.defaultButtons = [{
            type: "month",
            count: 1,
            text: "1m",
            title: "View 1 month"
          }, {
            type: "month",
            count: 3,
            text: "3m",
            title: "View 3 months"
          }, {
            type: "month",
            count: 6,
            text: "6m",
            title: "View 6 months"
          }, {
            type: "ytd",
            text: "YTD",
            title: "View year to date"
          }, {
            type: "year",
            count: 1,
            text: "1y",
            title: "View 1 year"
          }, {
            type: "all",
            text: "All",
            title: "View all"
          }];
          z.prototype.inputTypeFormats = {
            "datetime-local": "%Y-%m-%dT%H:%M:%S",
            date: "%Y-%m-%d",
            time: "%H:%M:%S"
          };

          e.prototype.minFromRange = function () {
            var a = this.range,
                b = a.type,
                c = this.max,
                d = this.chart.time,
                e = function e(a, c) {
              var e = "year" === b ? "FullYear" : "Month",
                  f = new d.Date(a),
                  g = d.get(e, f);
              d.set(e, f, g + c);
              g === d.get(e, f) && d.set("Date", f, 0);
              return f.getTime() - a;
            };

            if (J(a)) {
              var f = c - a;
              var g = a;
            } else a && (f = c + e(c, -(a.count || 1)), this.chart && (this.chart.fixedRange = c - f));

            var l = m(this.dataMin, Number.MIN_VALUE);
            J(f) || (f = l);
            f <= l && (f = l, "undefined" === typeof g && (g = e(f, a.count)), this.newMax = Math.min(f + g, m(this.dataMax, Number.MAX_VALUE)));
            J(c) ? !J(a) && a && a._offsetMin && (f += a._offsetMin) : f = void 0;
            return f;
          };

          if (!D.RangeSelector) {
            var d = [],
                F = function F(a) {
              function c() {
                f && (e = a.xAxis[0].getExtremes(), g = a.legend, m = f && f.options.verticalAlign, J(e.min) && f.render(e.min, e.max), g.display && "top" === m && m === g.options.verticalAlign && (k = C(a.spacingBox), k.y = "vertical" === g.options.layout ? a.plotTop : k.y + f.getHeight(), g.group.placed = !1, g.align(k)));
              }

              var e,
                  f = a.rangeSelector,
                  g,
                  k,
                  m;
              f && (b(d, function (b) {
                return b[0] === a;
              }) || d.push([a, [r(a.xAxis[0], "afterSetExtremes", function (a) {
                f && f.render(a.min, a.max);
              }), r(a, "redraw", c)]]), c());
            };

            r(n, "afterGetContainer", function () {
              this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new z(this));
            });
            r(n, "beforeRender", function () {
              var a = this.axes,
                  b = this.rangeSelector;
              b && (J(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {
                a.updateNames();
                a.setScale();
              }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || ("bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0)));
            });
            r(n, "update", function (a) {
              var b = a.options.rangeSelector;
              a = this.rangeSelector;
              var c = this.extraBottomMargin,
                  d = this.extraTopMargin;
              b && b.enabled && !g(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new z(this));
              this.extraTopMargin = this.extraBottomMargin = !1;
              a && (F(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || ("bottom" === b ? this.extraBottomMargin = !0 : "middle" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== c || this.extraTopMargin !== d) && (this.isDirtyBox = !0);
            });
            r(n, "render", function () {
              var a = this.rangeSelector;
              a && !a.options.floating && (a.render(), a = a.options.verticalAlign, "bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0));
            });
            r(n, "getMargins", function () {
              var a = this.rangeSelector;
              a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));
            });
            n.prototype.callbacks.push(F);
            r(n, "destroy", function () {
              for (var a = 0; a < d.length; a++) {
                var b = d[a];

                if (b[0] === this) {
                  b[1].forEach(function (a) {
                    return a();
                  });
                  d.splice(a, 1);
                  break;
                }
              }
            });
            D.RangeSelector = z;
          }

          return z;
        });
        N(e, "Core/Axis/NavigatorAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function (e, n) {
          var D = e.isTouchDevice,
              G = n.addEvent,
              B = n.correctFloat,
              E = n.defined,
              I = n.isNumber,
              y = n.pick,
              r = function () {
            function e(c) {
              this.axis = c;
            }

            e.prototype.destroy = function () {
              this.axis = void 0;
            };

            e.prototype.toFixedRange = function (c, e, l, n) {
              var f = this.axis,
                  b = f.chart;
              b = b && b.fixedRange;
              var g = (f.pointRange || 0) / 2;
              c = y(l, f.translate(c, !0, !f.horiz));
              e = y(n, f.translate(e, !0, !f.horiz));
              f = b && (e - c) / b;
              E(l) || (c = B(c + g));
              E(n) || (e = B(e - g));
              .7 < f && 1.3 > f && (n ? c = e - b : e = c + b);
              I(c) && I(e) || (c = e = void 0);
              return {
                min: c,
                max: e
              };
            };

            return e;
          }();

          return function () {
            function e() {}

            e.compose = function (c) {
              c.keepProps.push("navigatorAxis");
              G(c, "init", function () {
                this.navigatorAxis || (this.navigatorAxis = new r(this));
              });
              G(c, "zoom", function (c) {
                var e = this.chart.options,
                    g = e.navigator,
                    f = this.navigatorAxis,
                    b = e.chart.pinchType,
                    n = e.rangeSelector;
                e = e.chart.zoomType;
                this.isXAxis && (g && g.enabled || n && n.enabled) && ("y" === e ? c.zoomed = !1 : (!D && "xy" === e || D && "xy" === b) && this.options.range && (g = f.previousZoom, E(c.newMin) ? f.previousZoom = [this.min, this.max] : g && (c.newMin = g[0], c.newMax = g[1], f.previousZoom = void 0)));
                "undefined" !== typeof c.zoomed && c.preventDefault();
              });
            };

            e.AdditionsClass = r;
            return e;
          }();
        });
        N(e, "Core/Navigator.js", [e["Core/Axis/Axis.js"], e["Core/Chart/Chart.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Axis/NavigatorAxis.js"], e["Core/DefaultOptions.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Scrollbar.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function (e, n, D, H, B, E, I, y, r, q, c) {
          D = D.parse;

          var g = H.hasTouch,
              l = H.isTouchDevice,
              x = E.defaultOptions,
              f = c.addEvent,
              b = c.clamp,
              w = c.correctFloat,
              G = c.defined,
              C = c.destroyObjectProperties,
              K = c.erase,
              p = c.extend,
              m = c.find,
              t = c.isArray,
              a = c.isNumber,
              z = c.merge,
              d = c.pick,
              F = c.removeEvent,
              k = c.splat,
              h = function h(b) {
            for (var c = [], d = 1; d < arguments.length; d++) {
              c[d - 1] = arguments[d];
            }

            c = [].filter.call(c, a);
            if (c.length) return Math[b].apply(0, c);
          };

          E = "undefined" === typeof q.seriesTypes.areaspline ? "line" : "areaspline";
          p(x, {
            navigator: {
              height: 40,
              margin: 25,
              maskInside: !0,
              handles: {
                width: 7,
                height: 15,
                symbols: ["navigator-handle", "navigator-handle"],
                enabled: !0,
                lineWidth: 1,
                backgroundColor: "#f2f2f2",
                borderColor: "#999999"
              },
              maskFill: D("#6685c2").setOpacity(.3).get(),
              outlineColor: "#cccccc",
              outlineWidth: 1,
              series: {
                type: E,
                fillOpacity: .05,
                lineWidth: 1,
                compare: null,
                dataGrouping: {
                  approximation: "average",
                  enabled: !0,
                  groupPixelWidth: 2,
                  firstAnchor: "firstPoint",
                  anchor: "middle",
                  lastAnchor: "lastPoint",
                  units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
                },
                dataLabels: {
                  enabled: !1,
                  zIndex: 2
                },
                id: "highcharts-navigator-series",
                className: "highcharts-navigator-series",
                lineColor: null,
                marker: {
                  enabled: !1
                },
                threshold: null
              },
              xAxis: {
                overscroll: 0,
                className: "highcharts-navigator-xaxis",
                tickLength: 0,
                lineWidth: 0,
                gridLineColor: "#e6e6e6",
                gridLineWidth: 1,
                tickPixelInterval: 200,
                labels: {
                  align: "left",
                  style: {
                    color: "#999999"
                  },
                  x: 3,
                  y: -4
                },
                crosshair: !1
              },
              yAxis: {
                className: "highcharts-navigator-yaxis",
                gridLineWidth: 0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: .1,
                maxPadding: .1,
                labels: {
                  enabled: !1
                },
                crosshair: !1,
                title: {
                  text: null
                },
                tickLength: 0,
                tickWidth: 0
              }
            }
          });

          I.getRendererType().prototype.symbols["navigator-handle"] = function (a, b, c, d, e) {
            a = (e && e.width || 0) / 2;
            b = Math.round(a / 3) + .5;
            e = e && e.height || 0;
            return [["M", -a - 1, .5], ["L", a, .5], ["L", a, e + .5], ["L", -a - 1, e + .5], ["L", -a - 1, .5], ["M", -b, 4], ["L", -b, e - 3], ["M", b - 1, 4], ["L", b - 1, e - 3]];
          };

          var L = function () {
            function c(a) {
              this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;
              this.init(a);
            }

            c.prototype.drawHandle = function (a, b, c, d) {
              var e = this.navigatorOptions.handles.height;
              this.handles[b][d](c ? {
                translateX: Math.round(this.left + this.height / 2),
                translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)
              } : {
                translateX: Math.round(this.left + parseInt(a, 10)),
                translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)
              });
            };

            c.prototype.drawOutline = function (a, b, c, d) {
              var e = this.navigatorOptions.maskInside,
                  f = this.outline.strokeWidth(),
                  g = f / 2,
                  h = f % 2 / 2;
              f = this.outlineHeight;
              var k = this.scrollbarHeight || 0,
                  m = this.size,
                  l = this.left - k,
                  n = this.top;
              c ? (l -= g, c = n + b + h, b = n + a + h, h = [["M", l + f, n - k - h], ["L", l + f, c], ["L", l, c], ["L", l, b], ["L", l + f, b], ["L", l + f, n + m + k]], e && h.push(["M", l + f, c - g], ["L", l + f, b + g])) : (a += l + k - h, b += l + k - h, n += g, h = [["M", l, n], ["L", a, n], ["L", a, n + f], ["L", b, n + f], ["L", b, n], ["L", l + m + 2 * k, n]], e && h.push(["M", a - g, n], ["L", b + g, n]));
              this.outline[d]({
                d: h
              });
            };

            c.prototype.drawMasks = function (a, b, c, d) {
              var e = this.left,
                  f = this.top,
                  g = this.height;

              if (c) {
                var h = [e, e, e];
                var k = [f, f + a, f + b];
                var m = [g, g, g];
                var l = [a, b - a, this.size - b];
              } else h = [e, e + a, e + b], k = [f, f, f], m = [a, b - a, this.size - b], l = [g, g, g];

              this.shades.forEach(function (a, b) {
                a[d]({
                  x: h[b],
                  y: k[b],
                  width: m[b],
                  height: l[b]
                });
              });
            };

            c.prototype.renderElements = function () {
              var a = this,
                  b = a.navigatorOptions,
                  c = b.maskInside,
                  d = a.chart,
                  e = d.renderer,
                  f,
                  g = {
                cursor: d.inverted ? "ns-resize" : "ew-resize"
              };
              a.navigatorGroup = f = e.g("navigator").attr({
                zIndex: 8,
                visibility: "hidden"
              }).add();
              [!c, c, !c].forEach(function (c, h) {
                var k = e.rect().addClass("highcharts-navigator-mask" + (1 === h ? "-inside" : "-outside")).add(f);
                d.styledMode || (k.attr({
                  fill: c ? b.maskFill : "rgba(0,0,0,0)"
                }), 1 === h && k.css(g));
                a.shades[h] = k;
              });
              a.outline = e.path().addClass("highcharts-navigator-outline").add(f);
              d.styledMode || a.outline.attr({
                "stroke-width": b.outlineWidth,
                stroke: b.outlineColor
              });
              b.handles.enabled && [0, 1].forEach(function (c) {
                b.handles.inverted = d.inverted;
                a.handles[c] = e.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);
                a.handles[c].attr({
                  zIndex: 7 - c
                }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][c]).add(f);

                if (!d.styledMode) {
                  var h = b.handles;
                  a.handles[c].attr({
                    fill: h.backgroundColor,
                    stroke: h.borderColor,
                    "stroke-width": h.lineWidth
                  }).css(g);
                }
              });
            };

            c.prototype.update = function (a) {
              (this.series || []).forEach(function (a) {
                a.baseSeries && delete a.baseSeries.navigatorSeries;
              });
              this.destroy();
              z(!0, this.chart.options.navigator, this.options, a);
              this.init(this.chart);
            };

            c.prototype.render = function (c, e, f, g) {
              var h = this.chart,
                  k = this.scrollbarHeight,
                  m,
                  l = this.xAxis,
                  n = l.pointRange || 0;
              var p = l.navigatorAxis.fake ? h.xAxis[0] : l;
              var u = this.navigatorEnabled,
                  q,
                  r = this.rendered;
              var t = h.inverted;
              var A = h.xAxis[0].minRange,
                  x = h.xAxis[0].options.maxRange;

              if (!this.hasDragged || G(f)) {
                c = w(c - n / 2);
                e = w(e + n / 2);
                if (!a(c) || !a(e)) if (r) f = 0, g = d(l.width, p.width);else return;
                this.left = d(l.left, h.plotLeft + k + (t ? h.plotWidth : 0));
                this.size = q = m = d(l.len, (t ? h.plotHeight : h.plotWidth) - 2 * k);
                h = t ? k : m + 2 * k;
                f = d(f, l.toPixels(c, !0));
                g = d(g, l.toPixels(e, !0));
                a(f) && Infinity !== Math.abs(f) || (f = 0, g = h);
                c = l.toValue(f, !0);
                e = l.toValue(g, !0);
                var y = Math.abs(w(e - c));
                y < A ? this.grabbedLeft ? f = l.toPixels(e - A - n, !0) : this.grabbedRight && (g = l.toPixels(c + A + n, !0)) : G(x) && w(y - n) > x && (this.grabbedLeft ? f = l.toPixels(e - x - n, !0) : this.grabbedRight && (g = l.toPixels(c + x + n, !0)));
                this.zoomedMax = b(Math.max(f, g), 0, q);
                this.zoomedMin = b(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(f, g), 0, q);
                this.range = this.zoomedMax - this.zoomedMin;
                q = Math.round(this.zoomedMax);
                f = Math.round(this.zoomedMin);
                u && (this.navigatorGroup.attr({
                  visibility: "inherit"
                }), r = r && !this.hasDragged ? "animate" : "attr", this.drawMasks(f, q, t, r), this.drawOutline(f, q, t, r), this.navigatorOptions.handles.enabled && (this.drawHandle(f, 0, t, r), this.drawHandle(q, 1, t, r)));
                this.scrollbar && (t ? (t = this.top - k, p = this.left - k + (u || !p.opposite ? 0 : (p.titleOffset || 0) + p.axisTitleMargin), k = m + 2 * k) : (t = this.top + (u ? this.height : -k), p = this.left - k), this.scrollbar.position(p, t, h, k), this.scrollbar.setRange(this.zoomedMin / (m || 1), this.zoomedMax / (m || 1)));
                this.rendered = !0;
              }
            };

            c.prototype.addMouseEvents = function () {
              var a = this,
                  b = a.chart,
                  c = b.container,
                  d = [],
                  e,
                  h;

              a.mouseMoveHandler = e = function e(b) {
                a.onMouseMove(b);
              };

              a.mouseUpHandler = h = function h(b) {
                a.onMouseUp(b);
              };

              d = a.getPartsEvents("mousedown");
              d.push(f(b.renderTo, "mousemove", e), f(c.ownerDocument, "mouseup", h));
              g && (d.push(f(b.renderTo, "touchmove", e), f(c.ownerDocument, "touchend", h)), d.concat(a.getPartsEvents("touchstart")));
              a.eventsToUnbind = d;
              a.series && a.series[0] && d.push(f(a.series[0].xAxis, "foundExtremes", function () {
                b.navigator.modifyNavigatorAxisExtremes();
              }));
            };

            c.prototype.getPartsEvents = function (a) {
              var b = this,
                  c = [];
              ["shades", "handles"].forEach(function (d) {
                b[d].forEach(function (e, g) {
                  c.push(f(e.element, a, function (a) {
                    b[d + "Mousedown"](a, g);
                  }));
                });
              });
              return c;
            };

            c.prototype.shadesMousedown = function (a, b) {
              a = this.chart.pointer.normalize(a);
              var c = this.chart,
                  d = this.xAxis,
                  e = this.zoomedMin,
                  f = this.left,
                  g = this.size,
                  h = this.range,
                  k = a.chartX;
              c.inverted && (k = a.chartY, f = this.top);
              if (1 === b) this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e;else {
                a = k - f - h / 2;
                if (0 === b) a = Math.max(0, a);else if (2 === b && a + h >= g) if (a = g - h, this.reversedExtremes) {
                  a -= h;
                  var l = this.getUnionExtremes().dataMin;
                } else var m = this.getUnionExtremes().dataMax;
                a !== e && (this.fixedWidth = h, b = d.navigatorAxis.toFixedRange(a, a + h, l, m), G(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {
                  trigger: "navigator"
                }));
              }
            };

            c.prototype.handlesMousedown = function (a, b) {
              this.chart.pointer.normalize(a);
              a = this.chart;
              var c = a.xAxis[0],
                  d = this.reversedExtremes;
              0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);
              a.fixedRange = null;
            };

            c.prototype.onMouseMove = function (a) {
              var b = this,
                  c = b.chart,
                  e = b.left,
                  f = b.navigatorSize,
                  g = b.range,
                  h = b.dragOffset,
                  k = c.inverted;
              a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, k && (e = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - e, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - e)) : b.grabbedCenter && (b.hasDragged = !0, c < h ? c = h : c > f + h - g && (c = f + h - g), b.render(0, 0, c - h, c - h + g)), b.hasDragged && b.scrollbar && d(b.scrollbar.options.liveRedraw, H.svg && !l && !this.chart.isBoosting) && (a.DOMType = a.type, setTimeout(function () {
                b.onMouseUp(a);
              }, 0)));
            };

            c.prototype.onMouseUp = function (b) {
              var c = this.chart,
                  d = this.xAxis,
                  e = this.scrollbar,
                  f = b.DOMEvent || b,
                  g = c.inverted,
                  h = this.rendered && !this.hasDragged ? "animate" : "attr";

              if (this.hasDragged && (!e || !e.hasDragged) || "scrollbar" === b.trigger) {
                e = this.getUnionExtremes();
                if (this.zoomedMin === this.otherHandlePos) var k = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var l = this.fixedExtreme;
                this.zoomedMax === this.size && (l = this.reversedExtremes ? e.dataMin : e.dataMax);
                0 === this.zoomedMin && (k = this.reversedExtremes ? e.dataMax : e.dataMin);
                d = d.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, k, l);
                G(d.min) && c.xAxis[0].setExtremes(Math.min(d.min, d.max), Math.max(d.min, d.max), !0, this.hasDragged ? !1 : null, {
                  trigger: "navigator",
                  triggerOp: "navigator-drag",
                  DOMEvent: f
                });
              }

              "mousemove" !== b.DOMType && "touchmove" !== b.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
              this.navigatorEnabled && a(this.zoomedMin) && a(this.zoomedMax) && (c = Math.round(this.zoomedMin), b = Math.round(this.zoomedMax), this.shades && this.drawMasks(c, b, g, h), this.outline && this.drawOutline(c, b, g, h), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(c, 0, g, h), this.drawHandle(b, 1, g, h)));
            };

            c.prototype.removeEvents = function () {
              this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {
                a();
              }), this.eventsToUnbind = void 0);
              this.removeBaseSeriesEvents();
            };

            c.prototype.removeBaseSeriesEvents = function () {
              var a = this.baseSeries || [];
              this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {
                F(a, "updatedData", this.updatedDataHandler);
              }, this), a[0].xAxis && F(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
            };

            c.prototype.init = function (a) {
              var b = a.options,
                  c = b.navigator,
                  g = c.enabled,
                  k = b.scrollbar,
                  l = k.enabled;
              b = g ? c.height : 0;
              var m = l ? k.height : 0;
              this.handles = [];
              this.shades = [];
              this.chart = a;
              this.setBaseSeries();
              this.height = b;
              this.scrollbarHeight = m;
              this.scrollbarEnabled = l;
              this.navigatorEnabled = g;
              this.navigatorOptions = c;
              this.scrollbarOptions = k;
              this.outlineHeight = b + m;
              this.opposite = d(c.opposite, !(g || !a.inverted));
              var n = this;
              g = n.baseSeries;
              k = a.xAxis.length;
              l = a.yAxis.length;
              var p = g && g[0] && g[0].xAxis || a.xAxis[0] || {
                options: {}
              };
              a.isDirtyBox = !0;
              n.navigatorEnabled ? (n.xAxis = new e(a, z({
                breaks: p.options.breaks,
                ordinal: p.options.ordinal
              }, c.xAxis, {
                id: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                isX: !0,
                type: "datetime",
                index: k,
                isInternal: !0,
                offset: 0,
                keepOrdinalPadding: !0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: 0,
                maxPadding: 0,
                zoomEnabled: !1
              }, a.inverted ? {
                offsets: [m, 0, -m, 0],
                width: b
              } : {
                offsets: [0, -m, 0, m],
                height: b
              })), n.yAxis = new e(a, z(c.yAxis, {
                id: "navigator-y-axis",
                alignTicks: !1,
                offset: 0,
                index: l,
                isInternal: !0,
                reversed: d(c.yAxis && c.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),
                zoomEnabled: !1
              }, a.inverted ? {
                width: b
              } : {
                height: b
              })), g || c.series.data ? n.updateNavigatorSeries(!1) : 0 === a.series.length && (n.unbindRedraw = f(a, "beforeRedraw", function () {
                0 < a.series.length && !n.series && (n.setBaseSeries(), n.unbindRedraw());
              })), n.reversedExtremes = a.inverted && !n.xAxis.reversed || !a.inverted && n.xAxis.reversed, n.renderElements(), n.addMouseEvents()) : (n.xAxis = {
                chart: a,
                navigatorAxis: {
                  fake: !0
                },
                translate: function translate(b, c) {
                  var d = a.xAxis[0],
                      e = d.getExtremes(),
                      f = d.len - 2 * m,
                      g = h("min", d.options.min, e.dataMin);
                  d = h("max", d.options.max, e.dataMax) - g;
                  return c ? b * d / f + g : f * (b - g) / d;
                },
                toPixels: function toPixels(a) {
                  return this.translate(a);
                },
                toValue: function toValue(a) {
                  return this.translate(a, !0);
                }
              }, n.xAxis.navigatorAxis.axis = n.xAxis, n.xAxis.navigatorAxis.toFixedRange = B.AdditionsClass.prototype.toFixedRange.bind(n.xAxis.navigatorAxis));
              a.options.scrollbar.enabled && (a.scrollbar = n.scrollbar = new y(a.renderer, z(a.options.scrollbar, {
                margin: n.navigatorEnabled ? 0 : 10,
                vertical: a.inverted
              }), a), f(n.scrollbar, "changed", function (a) {
                var b = n.size,
                    c = b * this.to;
                b *= this.from;
                n.hasDragged = n.scrollbar.hasDragged;
                n.render(0, 0, b, c);
                this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {
                  n.onMouseUp(a);
                });
              }));
              n.addBaseSeriesEvents();
              n.addChartEvents();
            };

            c.prototype.getUnionExtremes = function (a) {
              var b = this.chart.xAxis[0],
                  c = this.xAxis,
                  e = c.options,
                  f = b.options,
                  g;
              a && null === b.dataMin || (g = {
                dataMin: d(e && e.min, h("min", f.min, b.dataMin, c.dataMin, c.min)),
                dataMax: d(e && e.max, h("max", f.max, b.dataMax, c.dataMax, c.max))
              });
              return g;
            };

            c.prototype.setBaseSeries = function (a, b) {
              var c = this.chart,
                  d = this.baseSeries = [];
              a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? m(c.series, function (a) {
                return !a.options.isInternal;
              }).index : 0);
              (c.series || []).forEach(function (b, c) {
                b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);
              });
              this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);
            };

            c.prototype.updateNavigatorSeries = function (a, b) {
              var c = this,
                  e = c.chart,
                  f = c.baseSeries,
                  g,
                  h,
                  l = c.navigatorOptions.series,
                  m,
                  n = {
                enableMouseTracking: !1,
                index: null,
                linkedTo: null,
                group: "nav",
                padXAxis: !1,
                xAxis: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                showInLegend: !1,
                stacking: void 0,
                isInternal: !0,
                states: {
                  inactive: {
                    opacity: 1
                  }
                }
              },
                  q = c.series = (c.series || []).filter(function (a) {
                var b = a.baseSeries;
                return 0 > f.indexOf(b) ? (b && (F(b, "updatedData", c.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;
              });
              f && f.length && f.forEach(function (a) {
                var r = a.navigatorSeries,
                    u = p({
                  color: a.color,
                  visible: a.visible
                }, t(l) ? x.navigator.series : l);
                r && !1 === c.navigatorOptions.adaptToUpdatedData || (n.name = "Navigator " + f.length, g = a.options || {}, m = g.navigatorOptions || {}, u.dataLabels = k(u.dataLabels), h = z(g, n, u, m), h.pointRange = d(u.pointRange, m.pointRange, x.plotOptions[h.type || "line"].pointRange), u = m.data || u.data, c.hasNavigatorData = c.hasNavigatorData || !!u, h.data = u || g.data && g.data.slice(0), r && r.options ? r.update(h, b) : (a.navigatorSeries = e.initSeries(h), a.navigatorSeries.baseSeries = a, q.push(a.navigatorSeries)));
              });
              if (l.data && (!f || !f.length) || t(l)) c.hasNavigatorData = !1, l = k(l), l.forEach(function (a, b) {
                n.name = "Navigator " + (q.length + 1);
                h = z(x.navigator.series, {
                  color: e.series[b] && !e.series[b].options.isInternal && e.series[b].color || e.options.colors[b] || e.options.colors[0]
                }, n, a);
                h.data = a.data;
                h.data && (c.hasNavigatorData = !0, q.push(e.initSeries(h)));
              });
              a && this.addBaseSeriesEvents();
            };

            c.prototype.addBaseSeriesEvents = function () {
              var a = this,
                  b = a.baseSeries || [];
              b[0] && b[0].xAxis && b[0].eventsToUnbind.push(f(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
              b.forEach(function (b) {
                b.eventsToUnbind.push(f(b, "show", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);
                }));
                b.eventsToUnbind.push(f(b, "hide", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);
                }));
                !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(f(b, "updatedData", this.updatedDataHandler));
                b.eventsToUnbind.push(f(b, "remove", function () {
                  this.navigatorSeries && (K(a.series, this.navigatorSeries), G(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);
                }));
              }, this);
            };

            c.prototype.getBaseSeriesMin = function (a) {
              return this.baseSeries.reduce(function (a, b) {
                return Math.min(a, b.xData && b.xData.length ? b.xData[0] : a);
              }, a);
            };

            c.prototype.modifyNavigatorAxisExtremes = function () {
              var a = this.xAxis,
                  b;
              "undefined" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));
            };

            c.prototype.modifyBaseAxisExtremes = function () {
              var b = this.chart.navigator,
                  c = this.getExtremes(),
                  e = c.dataMin,
                  f = c.dataMax;
              c = c.max - c.min;
              var g = b.stickToMin,
                  h = b.stickToMax,
                  k = d(this.options.overscroll, 0),
                  l = b.series && b.series[0],
                  m = !!this.setExtremes;

              if (!this.eventArgs || "rangeSelectorButton" !== this.eventArgs.trigger) {
                if (g) {
                  var n = e;
                  var p = n + c;
                }

                h && (p = f + k, g || (n = Math.max(e, p - c, b.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE))));
                m && (g || h) && a(n) && (this.min = this.userMin = n, this.max = this.userMax = p);
              }

              b.stickToMin = b.stickToMax = null;
            };

            c.prototype.updatedDataHandler = function () {
              var a = this.chart.navigator,
                  b = this.navigatorSeries;
              a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);
              a.stickToMin = a.shouldStickToMin(this, a);
              b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));
            };

            c.prototype.shouldStickToMin = function (b, c) {
              c = c.getBaseSeriesMin(b.xData[0]);
              var d = b.xAxis;
              b = d.max;
              var e = d.min;
              d = d.options.range;
              return a(b) && a(e) ? d && 0 < b - c ? b - c < d : e <= c : !1;
            };

            c.prototype.addChartEvents = function () {
              this.eventsToUnbind || (this.eventsToUnbind = []);
              this.eventsToUnbind.push(f(this.chart, "redraw", function () {
                var a = this.navigator,
                    b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);
                b && a.render(b.min, b.max);
              }), f(this.chart, "getMargins", function () {
                var a = this.navigator,
                    b = a.opposite ? "plotTop" : "marginBottom";
                this.inverted && (b = a.opposite ? "marginRight" : "plotLeft");
                this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;
              }));
            };

            c.prototype.destroy = function () {
              this.removeEvents();
              this.xAxis && (K(this.chart.xAxis, this.xAxis), K(this.chart.axes, this.xAxis));
              this.yAxis && (K(this.chart.yAxis, this.yAxis), K(this.chart.axes, this.yAxis));
              (this.series || []).forEach(function (a) {
                a.destroy && a.destroy();
              });
              "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach(function (a) {
                this[a] && this[a].destroy && this[a].destroy();
                this[a] = null;
              }, this);
              [this.handles].forEach(function (a) {
                C(a);
              }, this);
            };

            return c;
          }();

          H.Navigator || (H.Navigator = L, B.compose(e), f(n, "beforeShowResetZoom", function () {
            var a = this.options,
                b = a.navigator,
                c = a.rangeSelector;
            if ((b && b.enabled || c && c.enabled) && (!l && "x" === a.chart.zoomType || l && "x" === a.chart.pinchType)) return !1;
          }), f(n, "beforeRender", function () {
            var a = this.options;
            if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new L(this);
          }), f(n, "afterSetChartSize", function () {
            var a = this.legend,
                b = this.navigator;

            if (b) {
              var c = a && a.options;
              var e = b.xAxis;
              var f = b.yAxis;
              var g = b.scrollbarHeight;
              this.inverted ? (b.left = b.opposite ? this.chartWidth - g - b.height : this.spacing[3] + g, b.top = this.plotTop + g) : (b.left = d(e.left, this.plotLeft + g), b.top = b.navigatorOptions.top || this.chartHeight - b.height - g - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && "bottom" === c.verticalAlign && "proximate" !== c.layout && c.enabled && !c.floating ? a.legendHeight + d(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));
              e && f && (this.inverted ? e.options.left = f.options.left = b.left : e.options.top = f.options.top = b.top, e.setAxisSize(), f.setAxisSize());
            }
          }), f(n, "update", function (a) {
            var b = a.options.navigator || {},
                c = a.options.scrollbar || {};
            this.navigator || this.scroller || !b.enabled && !c.enabled || (z(!0, this.options.navigator, b), z(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);
          }), f(n, "afterUpdate", function (a) {
            this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new L(this), d(a.redraw, !0) && this.redraw(a.animation));
          }), f(n, "afterAddSeries", function () {
            this.navigator && this.navigator.setBaseSeries(null, !1);
          }), f(r, "afterUpdate", function () {
            this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);
          }), n.prototype.callbacks.push(function (a) {
            var b = a.navigator;
            b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));
          }));
          H.Navigator = L;
          return H.Navigator;
        });
        N(e, "masters/modules/gantt.src.js", [e["Core/Globals.js"], e["Core/Chart/GanttChart.js"], e["Core/Scrollbar.js"]], function (e, n, D) {
          e.Scrollbar = D;
          e.GanttChart = n;
          e.ganttChart = n.ganttChart;
          D.compose(e.Axis);
        });
        N(e, "masters/highcharts-gantt.src.js", [e["masters/highcharts.src.js"]], function (e) {
          e.product = "Highcharts Gantt";
          return e;
        });
        e["masters/highcharts-gantt.src.js"]._modules = e;
        return e["masters/highcharts-gantt.src.js"];
      }); //# sourceMappingURL=highcharts-gantt.js.map

      /***/

    },

    /***/
    "a0Xn":
    /*!*************************************************************************************!*\
      !*** ./node_modules/angular-highcharts/__ivy_ngcc__/fesm2015/angular-highcharts.js ***!
      \*************************************************************************************/

    /*! exports provided: Chart, ChartDirective, ChartModule, HIGHCHARTS_MODULES, HighchartsGantt, MapChart, StockChart, ɵa */

    /***/
    function a0Xn(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "Chart", function () {
        return Chart;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "ChartDirective", function () {
        return ChartDirective;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "ChartModule", function () {
        return ChartModule;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "HIGHCHARTS_MODULES", function () {
        return HIGHCHARTS_MODULES;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "HighchartsGantt", function () {
        return HighchartsGantt;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "MapChart", function () {
        return MapChart;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "StockChart", function () {
        return StockChart;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "ɵa", function () {
        return ChartService;
      });
      /* harmony import */


      var highcharts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! highcharts */
      "6n/F");
      /* harmony import */


      var highcharts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(highcharts__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! rxjs */
      "qCKp");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/core */
      "fXoL");
      /* harmony import */


      var highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! highcharts/highmaps */
      "bIOw");
      /* harmony import */


      var highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__);
      /* harmony import */


      var highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! highcharts/highstock */
      "5ZEx");
      /* harmony import */


      var highcharts_highstock__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__);
      /* harmony import */


      var highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! highcharts/highcharts-gantt */
      "ZivX");
      /* harmony import */


      var highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__);
      /**
       * @fileoverview added by tsickle
       * Generated from: lib/chart.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */


      var Chart = /*#__PURE__*/function () {
        /**
         * @param {?=} options
         */
        function Chart() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, Chart);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }
        /**
         * Add Point
         * @param {?} point         Highcharts.DataPoint, number touple or number
         * @param {?=} serieIndex    Index position of series. This defaults to 0.
         * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
         * @param {?=} shift         Shift point to the start of series. This defaults to false.
         * @return {?}
         */


        _createClass(Chart, [{
          key: "addPoint",
          value: function addPoint(point) {
            var serieIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var redraw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var shift = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            this.ref$.subscribe(
            /**
            * @param {?} chart
            * @return {?}
            */
            function (chart) {
              if (chart.series.length > serieIndex) {
                chart.series[serieIndex].addPoint(point, redraw, shift);
              }
            });
          }
          /**
           * Add Series
           * @param {?} series        Series Configuration
           * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
           * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
           * @return {?}
           */

        }, {
          key: "addSeries",
          value: function addSeries(series) {
            var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var animation = arguments.length > 2 ? arguments[2] : undefined;
            this.ref$.subscribe(
            /**
            * @param {?} chart
            * @return {?}
            */
            function (chart) {
              chart.addSeries(series, redraw, animation);
            });
          }
          /**
           * Remove Point
           * @param {?} pointIndex    Index of Point
           * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
           * @return {?}
           */

        }, {
          key: "removePoint",
          value: function removePoint(pointIndex) {
            var serieIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            this.ref$.subscribe(
            /**
            * @param {?} chart
            * @return {?}
            */
            function (chart) {
              if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
                chart.series[serieIndex].removePoint(pointIndex, true);
              }
            });
          }
          /**
           * Remove Series
           * @param {?} seriesIndex    Index position of series to remove.
           * @return {?}
           */

        }, {
          key: "removeSeries",
          value: function removeSeries(seriesIndex) {
            this.ref$.subscribe(
            /**
            * @param {?} chart
            * @return {?}
            */
            function (chart) {
              if (chart.series.length > seriesIndex) {
                chart.series[seriesIndex].remove(true);
              }
            });
          }
          /**
           * @param {?} el
           * @return {?}
           */

        }, {
          key: "init",
          value: function init(el) {
            var _this = this;

            if (!this.ref) {
              Object(highcharts__WEBPACK_IMPORTED_MODULE_0__["chart"])(el.nativeElement, this.options,
              /**
              * @param {?} chart
              * @return {?}
              */
              function (chart) {
                if (!_this.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this.refSubject.next(chart);

                  _this.ref = chart;

                  _this.refSubject.complete();
                }
              });
            }
          }
          /**
           * @return {?}
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return Chart;
      }();

      if (false) {}
      /**
       * @fileoverview added by tsickle
       * Generated from: lib/mapchart.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       */


      var MapChart = /*#__PURE__*/function () {
        /**
         * @param {?=} options
         */
        function MapChart() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, MapChart);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }
        /**
         * @param {?} el
         * @return {?}
         */


        _createClass(MapChart, [{
          key: "init",
          value: function init(el) {
            var _this2 = this;

            if (!this.ref) {
              Object(highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__["mapChart"])(el.nativeElement, this.options,
              /**
              * @param {?} chart
              * @return {?}
              */
              function (chart) {
                if (!_this2.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this2.refSubject.next(chart);

                  _this2.ref = chart;

                  _this2.refSubject.complete();
                }
              });
            }
          }
          /**
           * @return {?}
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return MapChart;
      }();

      if (false) {}
      /**
       * @fileoverview added by tsickle
       * Generated from: lib/stockchart.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       *
       * @author Felix Itzenplitz
       * @author Timothy A. Perez (contributor)
       */


      var StockChart = /*#__PURE__*/function () {
        /**
         * @param {?=} options
         */
        function StockChart() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, StockChart);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }
        /**
         * @param {?} el
         * @return {?}
         */


        _createClass(StockChart, [{
          key: "init",
          value: function init(el) {
            var _this3 = this;

            if (!this.ref) {
              Object(highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__["stockChart"])(el.nativeElement, this.options,
              /**
              * @param {?} chart
              * @return {?}
              */
              function (chart) {
                if (!_this3.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this3.refSubject.next(chart);

                  _this3.ref = chart;

                  _this3.refSubject.complete();
                }
              });
            }
          }
          /**
           * @return {?}
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return StockChart;
      }();

      if (false) {}
      /**
       * @fileoverview added by tsickle
       * Generated from: lib/highcharts-gantt.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       */


      var HighchartsGantt = /*#__PURE__*/function () {
        /**
         * @param {?=} options
         */
        function HighchartsGantt() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, HighchartsGantt);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }
        /**
         * @param {?} el
         * @return {?}
         */


        _createClass(HighchartsGantt, [{
          key: "init",
          value: function init(el) {
            var _this4 = this;

            if (!this.ref) {
              Object(highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__["ganttChart"])(el.nativeElement, this.options,
              /**
              * @param {?} chart
              * @return {?}
              */
              function (chart) {
                if (!_this4.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this4.refSubject.next(chart);

                  _this4.ref = chart;

                  _this4.refSubject.complete();
                }
              });
            }
          }
          /**
           * @return {?}
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return HighchartsGantt;
      }();

      if (false) {}
      /**
       * @fileoverview added by tsickle
       * Generated from: lib/chart.directive.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */


      var ChartDirective = /*#__PURE__*/function () {
        /**
         * @param {?} el
         */
        function ChartDirective(el) {
          _classCallCheck(this, ChartDirective);

          this.el = el;
        }
        /**
         * @param {?} changes
         * @return {?}
         */


        _createClass(ChartDirective, [{
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            if (!changes.chart.isFirstChange()) {
              this.destroy();
              this.init();
            }
          }
          /**
           * @return {?}
           */

        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            this.init();
          }
          /**
           * @return {?}
           */

        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.destroy();
          }
          /**
           * @private
           * @return {?}
           */

        }, {
          key: "init",
          value: function init() {
            if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
              this.chart.init(this.el);
            }
          }
          /**
           * @private
           * @return {?}
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
              this.chart.destroy();
            }
          }
        }]);

        return ChartDirective;
      }();

      ChartDirective.ɵfac = function ChartDirective_Factory(t) {
        return new (t || ChartDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]));
      };

      ChartDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]({
        type: ChartDirective,
        selectors: [["", "chart", ""]],
        inputs: {
          chart: "chart"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      ChartDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]
        }];
      };

      ChartDirective.propDecorators = {
        chart: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }]
      };
      /*@__PURE__*/

      (function () {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](ChartDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"],
          args: [{
            selector: '[chart]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]
          }];
        }, {
          chart: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
          }]
        });
      })();

      if (false) {}
      /**
       * @fileoverview added by tsickle
       * Generated from: lib/chart.service.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /** @type {?} */


      var HIGHCHARTS_MODULES = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('HighchartsModules');

      var ChartService = /*#__PURE__*/function () {
        /**
         * @param {?} chartModules
         */
        function ChartService(chartModules) {
          _classCallCheck(this, ChartService);

          this.chartModules = chartModules;
        }
        /**
         * @return {?}
         */


        _createClass(ChartService, [{
          key: "initModules",
          value: function initModules() {
            this.chartModules.forEach(
            /**
            * @param {?} chartModule
            * @return {?}
            */
            function (chartModule) {
              [highcharts__WEBPACK_IMPORTED_MODULE_0__, highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__, highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__, highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__].forEach(chartModule);
            });
          }
        }]);

        return ChartService;
      }();

      ChartService.ɵfac = function ChartService_Factory(t) {
        return new (t || ChartService)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](HIGHCHARTS_MODULES));
      };

      ChartService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
        token: ChartService,
        factory: ChartService.ɵfac
      });
      /** @nocollapse */

      ChartService.ctorParameters = function () {
        return [{
          type: Array,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"],
            args: [HIGHCHARTS_MODULES]
          }]
        }];
      };
      /*@__PURE__*/


      (function () {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](ChartService, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Injectable"]
        }], function () {
          return [{
            type: Array,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"],
              args: [HIGHCHARTS_MODULES]
            }]
          }];
        }, null);
      })();

      if (false) {}
      /**
       * @fileoverview added by tsickle
       * Generated from: lib/chart.module.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */


      var ɵ0 = [];

      var ChartModule = /*#__PURE__*/_createClass(
      /**
       * @param {?} cs
       */
      function ChartModule(cs) {
        _classCallCheck(this, ChartModule);

        this.cs = cs;
        this.cs.initModules();
      });

      ChartModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
        type: ChartModule
      });
      ChartModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({
        factory: function ChartModule_Factory(t) {
          return new (t || ChartModule)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](ChartService));
        },
        providers: [{
          provide: HIGHCHARTS_MODULES,
          useValue: ɵ0
        }, ChartService]
      });
      /** @nocollapse */

      ChartModule.ctorParameters = function () {
        return [{
          type: ChartService
        }];
      };

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetNgModuleScope"](ChartModule, {
          declarations: [ChartDirective],
          exports: [ChartDirective]
        });
      })();
      /*@__PURE__*/


      (function () {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](ChartModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"],
          args: [{
            exports: [ChartDirective],
            declarations: [ChartDirective],
            providers: [{
              provide: HIGHCHARTS_MODULES,
              useValue: ɵ0
            }, ChartService]
          }]
        }], function () {
          return [{
            type: ChartService
          }];
        }, null);
      })();

      if (false) {}
      /**
       * @fileoverview added by tsickle
       * Generated from: public-api.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * @fileoverview added by tsickle
       * Generated from: angular-highcharts.ts
       * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */
      //# sourceMappingURL=angular-highcharts.js.map

      /***/

    },

    /***/
    "bIOw":
    /*!*********************************************!*\
      !*** ./node_modules/highcharts/highmaps.js ***!
      \*********************************************/

    /*! no static exports found */

    /***/
    function bIOw(module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*
      Highmaps JS v10.2.0 (2022-07-05)
      (c) 2011-2021 Torstein Honsi
      License: www.highcharts.com/license
      */


      (function (Y, H) {
        true && module.exports ? (H["default"] = H, module.exports = Y.document ? H(Y) : H) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return H(Y);
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
      })("undefined" !== typeof window ? window : this, function (Y) {
        function H(c, I, f, D) {
          c.hasOwnProperty(I) || (c[I] = D.apply(null, f), "function" === typeof CustomEvent && Y.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
            detail: {
              path: I,
              module: c[I]
            }
          })));
        }

        var f = {};
        H(f, "Core/Globals.js", [], function () {
          var c;

          (function (c) {
            c.SVG_NS = "http://www.w3.org/2000/svg";
            c.product = "Highcharts";
            c.version = "10.2.0";
            c.win = "undefined" !== typeof Y ? Y : {};
            c.doc = c.win.document;
            c.svg = c.doc && c.doc.createElementNS && !!c.doc.createElementNS(c.SVG_NS, "svg").createSVGRect;
            c.userAgent = c.win.navigator && c.win.navigator.userAgent || "";
            c.isChrome = -1 !== c.userAgent.indexOf("Chrome");
            c.isFirefox = -1 !== c.userAgent.indexOf("Firefox");
            c.isMS = /(edge|msie|trident)/i.test(c.userAgent) && !c.win.opera;
            c.isSafari = !c.isChrome && -1 !== c.userAgent.indexOf("Safari");
            c.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(c.userAgent);
            c.isWebKit = -1 !== c.userAgent.indexOf("AppleWebKit");
            c.deg2rad = 2 * Math.PI / 360;
            c.hasBidiBug = c.isFirefox && 4 > parseInt(c.userAgent.split("Firefox/")[1], 10);
            c.hasTouch = !!c.win.TouchEvent;
            c.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];

            c.noop = function () {};

            c.supportsPassiveEvents = function () {
              var f = !1;

              if (!c.isMS) {
                var I = Object.defineProperty({}, "passive", {
                  get: function get() {
                    f = !0;
                  }
                });
                c.win.addEventListener && c.win.removeEventListener && (c.win.addEventListener("testPassive", c.noop, I), c.win.removeEventListener("testPassive", c.noop, I));
              }

              return f;
            }();

            c.charts = [];
            c.dateFormats = {};
            c.seriesTypes = {};
            c.symbolSizes = {};
            c.chartCount = 0;
          })(c || (c = {}));

          "";
          return c;
        });
        H(f, "Core/Utilities.js", [f["Core/Globals.js"]], function (c) {
          function f(m, x, e, g) {
            var b = x ? "Highcharts error" : "Highcharts warning";
            32 === m && (m = "" + b + ": Deprecated member");
            var d = n(m),
                w = d ? "" + b + " #" + m + ": www.highcharts.com/errors/" + m + "/" : m.toString();

            if ("undefined" !== typeof g) {
              var q = "";
              d && (w += "?");
              t(g, function (m, a) {
                q += "\n - ".concat(a, ": ").concat(m);
                d && (w += encodeURI(a) + "=" + encodeURI(m));
              });
              w += q;
            }

            l(c, "displayError", {
              chart: e,
              code: m,
              message: w,
              params: g
            }, function () {
              if (x) throw Error(w);
              a.console && -1 === f.messages.indexOf(w) && console.warn(w);
            });
            f.messages.push(w);
          }

          function v(m, a) {
            var x = {};
            t(m, function (e, g) {
              if (F(m[g], !0) && !m.nodeType && a[g]) e = v(m[g], a[g]), Object.keys(e).length && (x[g] = e);else if (F(m[g]) || m[g] !== a[g] || g in m && !(g in a)) x[g] = m[g];
            });
            return x;
          }

          function D(m, a) {
            return parseInt(m, a || 10);
          }

          function r(m) {
            return "string" === typeof m;
          }

          function C(m) {
            m = Object.prototype.toString.call(m);
            return "[object Array]" === m || "[object Array Iterator]" === m;
          }

          function F(m, a) {
            return !!m && "object" === typeof m && (!a || !C(m));
          }

          function A(m) {
            return F(m) && "number" === typeof m.nodeType;
          }

          function u(m) {
            var a = m && m.constructor;
            return !(!F(m, !0) || A(m) || !a || !a.name || "Object" === a.name);
          }

          function n(m) {
            return "number" === typeof m && !isNaN(m) && Infinity > m && -Infinity < m;
          }

          function k(m) {
            return "undefined" !== typeof m && null !== m;
          }

          function d(m, a, e) {
            var x = r(a) && !k(e),
                g,
                l = function l(a, e) {
              k(a) ? m.setAttribute(e, a) : x ? (g = m.getAttribute(e)) || "class" !== e || (g = m.getAttribute(e + "Name")) : m.removeAttribute(e);
            };

            r(a) ? l(e, a) : t(a, l);
            return g;
          }

          function b(m, a) {
            var x;
            m || (m = {});

            for (x in a) {
              m[x] = a[x];
            }

            return m;
          }

          function h() {
            for (var m = arguments, a = m.length, e = 0; e < a; e++) {
              var g = m[e];
              if ("undefined" !== typeof g && null !== g) return g;
            }
          }

          function p(m, a) {
            c.isMS && !c.svg && a && k(a.opacity) && (a.filter = "alpha(opacity=".concat(100 * a.opacity, ")"));
            b(m.style, a);
          }

          function z(m) {
            return Math.pow(10, Math.floor(Math.log(m) / Math.LN10));
          }

          function E(m, a) {
            return 1E14 < m ? m : parseFloat(m.toPrecision(a || 14));
          }

          function y(m, e, g) {
            var x = c.getStyle || y;
            if ("width" === e) return e = Math.min(m.offsetWidth, m.scrollWidth), g = m.getBoundingClientRect && m.getBoundingClientRect().width, g < e && g >= e - 1 && (e = Math.floor(g)), Math.max(0, e - (x(m, "padding-left", !0) || 0) - (x(m, "padding-right", !0) || 0));
            if ("height" === e) return Math.max(0, Math.min(m.offsetHeight, m.scrollHeight) - (x(m, "padding-top", !0) || 0) - (x(m, "padding-bottom", !0) || 0));
            a.getComputedStyle || f(27, !0);

            if (m = a.getComputedStyle(m, void 0)) {
              var l = m.getPropertyValue(e);
              h(g, "opacity" !== e) && (l = D(l));
            }

            return l;
          }

          function t(m, a, e) {
            for (var g in m) {
              Object.hasOwnProperty.call(m, g) && a.call(e || m[g], m[g], g, m);
            }
          }

          function q(m, a, e) {
            function g(a, e) {
              var g = m.removeEventListener || c.removeEventListenerPolyfill;
              g && g.call(m, a, e, !1);
            }

            function x(e) {
              var x;

              if (m.nodeName) {
                if (a) {
                  var l = {};
                  l[a] = !0;
                } else l = e;

                t(l, function (m, a) {
                  if (e[a]) for (x = e[a].length; x--;) {
                    g(a, e[a][x].fn);
                  }
                });
              }
            }

            var l = "function" === typeof m && m.prototype || m;

            if (Object.hasOwnProperty.call(l, "hcEvents")) {
              var b = l.hcEvents;
              a ? (l = b[a] || [], e ? (b[a] = l.filter(function (m) {
                return e !== m.fn;
              }), g(a, e)) : (x(b), b[a] = [])) : (x(b), delete l.hcEvents);
            }
          }

          function l(m, a, e, g) {
            e = e || {};

            if (w.createEvent && (m.dispatchEvent || m.fireEvent && m !== c)) {
              var x = w.createEvent("Events");
              x.initEvent(a, !0, !0);
              e = b(x, e);
              m.dispatchEvent ? m.dispatchEvent(e) : m.fireEvent(a, e);
            } else if (m.hcEvents) {
              e.target || b(e, {
                preventDefault: function preventDefault() {
                  e.defaultPrevented = !0;
                },
                target: m,
                type: a
              });
              x = [];

              for (var l = m, d = !1; l.hcEvents;) {
                Object.hasOwnProperty.call(l, "hcEvents") && l.hcEvents[a] && (x.length && (d = !0), x.unshift.apply(x, l.hcEvents[a])), l = Object.getPrototypeOf(l);
              }

              d && x.sort(function (a, m) {
                return a.order - m.order;
              });
              x.forEach(function (a) {
                !1 === a.fn.call(m, e) && e.preventDefault();
              });
            }

            g && !e.defaultPrevented && g.call(m, e);
          }

          var g = c.charts,
              w = c.doc,
              a = c.win;
          (f || (f = {})).messages = [];

          Math.easeInOutSine = function (a) {
            return -.5 * (Math.cos(Math.PI * a) - 1);
          };

          var B = Array.prototype.find ? function (a, e) {
            return a.find(e);
          } : function (a, e) {
            var m,
                g = a.length;

            for (m = 0; m < g; m++) {
              if (e(a[m], m)) return a[m];
            }
          };
          t({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function (a, e) {
            c[e] = function (m) {
              var g;
              f(32, !1, void 0, (g = {}, g["Highcharts.".concat(e)] = "use Array.".concat(a), g));
              return Array.prototype[a].apply(m, [].slice.call(arguments, 1));
            };
          });

          var e,
              G = function () {
            var a = Math.random().toString(36).substring(2, 9) + "-",
                g = 0;
            return function () {
              return "highcharts-" + (e ? "" : a) + g++;
            };
          }();

          a.jQuery && (a.jQuery.fn.highcharts = function () {
            var a = [].slice.call(arguments);
            if (this[0]) return a[0] ? (new c[r(a[0]) ? a.shift() : "Chart"](this[0], a[0], a[1]), this) : g[d(this[0], "data-highcharts-chart")];
          });
          B = {
            addEvent: function addEvent(a, e, g, l) {
              void 0 === l && (l = {});
              var m = "function" === typeof a && a.prototype || a;
              Object.hasOwnProperty.call(m, "hcEvents") || (m.hcEvents = {});
              m = m.hcEvents;
              c.Point && a instanceof c.Point && a.series && a.series.chart && (a.series.chart.runTrackerClick = !0);
              var x = a.addEventListener || c.addEventListenerPolyfill;
              x && x.call(a, e, g, c.supportsPassiveEvents ? {
                passive: void 0 === l.passive ? -1 !== e.indexOf("touch") : l.passive,
                capture: !1
              } : !1);
              m[e] || (m[e] = []);
              m[e].push({
                fn: g,
                order: "number" === typeof l.order ? l.order : Infinity
              });
              m[e].sort(function (a, m) {
                return a.order - m.order;
              });
              return function () {
                q(a, e, g);
              };
            },
            arrayMax: function arrayMax(a) {
              for (var m = a.length, e = a[0]; m--;) {
                a[m] > e && (e = a[m]);
              }

              return e;
            },
            arrayMin: function arrayMin(a) {
              for (var m = a.length, e = a[0]; m--;) {
                a[m] < e && (e = a[m]);
              }

              return e;
            },
            attr: d,
            clamp: function clamp(a, e, g) {
              return a > e ? a < g ? a : g : e;
            },
            cleanRecursively: v,
            clearTimeout: function (_clearTimeout3) {
              function clearTimeout(_x3) {
                return _clearTimeout3.apply(this, arguments);
              }

              clearTimeout.toString = function () {
                return _clearTimeout3.toString();
              };

              return clearTimeout;
            }(function (a) {
              k(a) && clearTimeout(a);
            }),
            correctFloat: E,
            createElement: function createElement(a, e, g, l, d) {
              a = w.createElement(a);
              e && b(a, e);
              d && p(a, {
                padding: "0",
                border: "none",
                margin: "0"
              });
              g && p(a, g);
              l && l.appendChild(a);
              return a;
            },
            css: p,
            defined: k,
            destroyObjectProperties: function destroyObjectProperties(a, e) {
              t(a, function (m, g) {
                m && m !== e && m.destroy && m.destroy();
                delete a[g];
              });
            },
            discardElement: function discardElement(a) {
              a && a.parentElement && a.parentElement.removeChild(a);
            },
            erase: function erase(a, e) {
              for (var m = a.length; m--;) {
                if (a[m] === e) {
                  a.splice(m, 1);
                  break;
                }
              }
            },
            error: f,
            extend: b,
            extendClass: function extendClass(a, e) {
              var m = function m() {};

              m.prototype = new a();
              b(m.prototype, e);
              return m;
            },
            find: B,
            fireEvent: l,
            getMagnitude: z,
            getNestedProperty: function getNestedProperty(m, e) {
              for (m = m.split("."); m.length && k(e);) {
                var g = m.shift();
                if ("undefined" === typeof g || "__proto__" === g) return;
                e = e[g];
                if (!k(e) || "function" === typeof e || "number" === typeof e.nodeType || e === a) return;
              }

              return e;
            },
            getStyle: y,
            inArray: function inArray(a, e, g) {
              f(32, !1, void 0, {
                "Highcharts.inArray": "use Array.indexOf"
              });
              return e.indexOf(a, g);
            },
            isArray: C,
            isClass: u,
            isDOMElement: A,
            isFunction: function isFunction(a) {
              return "function" === typeof a;
            },
            isNumber: n,
            isObject: F,
            isString: r,
            keys: function keys(a) {
              f(32, !1, void 0, {
                "Highcharts.keys": "use Object.keys"
              });
              return Object.keys(a);
            },
            merge: function merge() {
              var a,
                  e = arguments,
                  g = {},
                  l = function l(a, e) {
                "object" !== typeof a && (a = {});
                t(e, function (m, g) {
                  "__proto__" !== g && "constructor" !== g && (!F(m, !0) || u(m) || A(m) ? a[g] = e[g] : a[g] = l(a[g] || {}, m));
                });
                return a;
              };

              !0 === e[0] && (g = e[1], e = Array.prototype.slice.call(e, 2));
              var b = e.length;

              for (a = 0; a < b; a++) {
                g = l(g, e[a]);
              }

              return g;
            },
            normalizeTickInterval: function normalizeTickInterval(a, e, g, l, b) {
              var m = a;
              g = h(g, z(a));
              var x = a / g;
              e || (e = b ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === l && (1 === g ? e = e.filter(function (a) {
                return 0 === a % 1;
              }) : .1 >= g && (e = [1 / g])));

              for (l = 0; l < e.length && !(m = e[l], b && m * g >= a || !b && x <= (e[l] + (e[l + 1] || e[l])) / 2); l++) {
                ;
              }

              return m = E(m * g, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: t,
            offset: function offset(e) {
              var m = w.documentElement;
              e = e.parentElement || e.parentNode ? e.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
              };
              return {
                top: e.top + (a.pageYOffset || m.scrollTop) - (m.clientTop || 0),
                left: e.left + (a.pageXOffset || m.scrollLeft) - (m.clientLeft || 0),
                width: e.width,
                height: e.height
              };
            },
            pad: function pad(a, e, g) {
              return Array((e || 2) + 1 - String(a).replace("-", "").length).join(g || "0") + a;
            },
            pick: h,
            pInt: D,
            relativeLength: function relativeLength(a, e, g) {
              return /%$/.test(a) ? e * parseFloat(a) / 100 + (g || 0) : parseFloat(a);
            },
            removeEvent: q,
            splat: function splat(a) {
              return C(a) ? a : [a];
            },
            stableSort: function stableSort(a, e) {
              var g = a.length,
                  m,
                  l;

              for (l = 0; l < g; l++) {
                a[l].safeI = l;
              }

              a.sort(function (a, g) {
                m = e(a, g);
                return 0 === m ? a.safeI - g.safeI : m;
              });

              for (l = 0; l < g; l++) {
                delete a[l].safeI;
              }
            },
            syncTimeout: function syncTimeout(a, e, g) {
              if (0 < e) return setTimeout(a, e, g);
              a.call(0, g);
              return -1;
            },
            timeUnits: {
              millisecond: 1,
              second: 1E3,
              minute: 6E4,
              hour: 36E5,
              day: 864E5,
              week: 6048E5,
              month: 24192E5,
              year: 314496E5
            },
            uniqueKey: G,
            useSerialIds: function useSerialIds(a) {
              return e = h(a, e);
            },
            wrap: function wrap(a, e, g) {
              var m = a[e];

              a[e] = function () {
                var a = Array.prototype.slice.call(arguments),
                    e = arguments,
                    l = this;

                l.proceed = function () {
                  m.apply(l, arguments.length ? arguments : e);
                };

                a.unshift(m);
                a = g.apply(this, a);
                l.proceed = null;
                return a;
              };
            }
          };
          "";
          return B;
        });
        H(f, "Core/Chart/ChartDefaults.js", [], function () {
          return {
            alignThresholds: !1,
            panning: {
              enabled: !1,
              type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            allowMutatingData: !0,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: "#335cad",
            backgroundColor: "#ffffff",
            plotBorderColor: "#cccccc"
          };
        });
        H(f, "Core/Color/Color.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f) {
          var I = f.isNumber,
              D = f.merge,
              r = f.pInt;

          f = function () {
            function f(F) {
              this.rgba = [NaN, NaN, NaN, NaN];
              this.input = F;
              var A = c.Color;
              if (A && A !== f) return new A(F);
              if (!(this instanceof f)) return new f(F);
              this.init(F);
            }

            f.parse = function (c) {
              return c ? new f(c) : f.None;
            };

            f.prototype.init = function (c) {
              var A;
              if ("object" === typeof c && "undefined" !== typeof c.stops) this.stops = c.stops.map(function (d) {
                return new f(d[1]);
              });else if ("string" === typeof c) {
                this.input = c = f.names[c.toLowerCase()] || c;

                if ("#" === c.charAt(0)) {
                  var u = c.length;
                  var n = parseInt(c.substr(1), 16);
                  7 === u ? A = [(n & 16711680) >> 16, (n & 65280) >> 8, n & 255, 1] : 4 === u && (A = [(n & 3840) >> 4 | (n & 3840) >> 8, (n & 240) >> 4 | n & 240, (n & 15) << 4 | n & 15, 1]);
                }

                if (!A) for (n = f.parsers.length; n-- && !A;) {
                  var k = f.parsers[n];
                  (u = k.regex.exec(c)) && (A = k.parse(u));
                }
              }
              A && (this.rgba = A);
            };

            f.prototype.get = function (c) {
              var A = this.input,
                  u = this.rgba;

              if ("object" === typeof A && "undefined" !== typeof this.stops) {
                var n = D(A);
                n.stops = [].slice.call(n.stops);
                this.stops.forEach(function (k, d) {
                  n.stops[d] = [n.stops[d][0], k.get(c)];
                });
                return n;
              }

              return u && I(u[0]) ? "rgb" === c || !c && 1 === u[3] ? "rgb(" + u[0] + "," + u[1] + "," + u[2] + ")" : "a" === c ? "".concat(u[3]) : "rgba(" + u.join(",") + ")" : A;
            };

            f.prototype.brighten = function (c) {
              var A = this.rgba;
              if (this.stops) this.stops.forEach(function (n) {
                n.brighten(c);
              });else if (I(c) && 0 !== c) for (var u = 0; 3 > u; u++) {
                A[u] += r(255 * c), 0 > A[u] && (A[u] = 0), 255 < A[u] && (A[u] = 255);
              }
              return this;
            };

            f.prototype.setOpacity = function (c) {
              this.rgba[3] = c;
              return this;
            };

            f.prototype.tweenTo = function (c, A) {
              var u = this.rgba,
                  n = c.rgba;
              if (!I(u[0]) || !I(n[0])) return c.input || "none";
              c = 1 !== n[3] || 1 !== u[3];
              return (c ? "rgba(" : "rgb(") + Math.round(n[0] + (u[0] - n[0]) * (1 - A)) + "," + Math.round(n[1] + (u[1] - n[1]) * (1 - A)) + "," + Math.round(n[2] + (u[2] - n[2]) * (1 - A)) + (c ? "," + (n[3] + (u[3] - n[3]) * (1 - A)) : "") + ")";
            };

            f.names = {
              white: "#ffffff",
              black: "#000000"
            };
            f.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(c) {
                return [r(c[1]), r(c[2]), r(c[3]), parseFloat(c[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(c) {
                return [r(c[1]), r(c[2]), r(c[3]), 1];
              }
            }];
            f.None = new f("");
            return f;
          }();

          "";
          return f;
        });
        H(f, "Core/Color/Palettes.js", [], function () {
          return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
          };
        });
        H(f, "Core/Time.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f) {
          var I = c.win,
              D = f.defined,
              r = f.error,
              C = f.extend,
              F = f.isObject,
              A = f.merge,
              u = f.objectEach,
              n = f.pad,
              k = f.pick,
              d = f.splat,
              b = f.timeUnits,
              h = c.isSafari && I.Intl && I.Intl.DateTimeFormat.prototype.formatRange,
              p = c.isSafari && I.Intl && !I.Intl.DateTimeFormat.prototype.formatRange;

          f = function () {
            function z(b) {
              this.options = {};
              this.variableTimezone = this.useUTC = !1;
              this.Date = I.Date;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.update(b);
            }

            z.prototype.get = function (b, d) {
              if (this.variableTimezone || this.timezoneOffset) {
                var h = d.getTime(),
                    q = h - this.getTimezoneOffset(d);
                d.setTime(q);
                b = d["getUTC" + b]();
                d.setTime(h);
                return b;
              }

              return this.useUTC ? d["getUTC" + b]() : d["get" + b]();
            };

            z.prototype.set = function (b, d, t) {
              if (this.variableTimezone || this.timezoneOffset) {
                if ("Milliseconds" === b || "Seconds" === b || "Minutes" === b && 0 === this.getTimezoneOffset(d) % 36E5) return d["setUTC" + b](t);
                var q = this.getTimezoneOffset(d);
                q = d.getTime() - q;
                d.setTime(q);
                d["setUTC" + b](t);
                b = this.getTimezoneOffset(d);
                q = d.getTime() + b;
                return d.setTime(q);
              }

              return this.useUTC || h && "FullYear" === b ? d["setUTC" + b](t) : d["set" + b](t);
            };

            z.prototype.update = function (b) {
              var d = k(b && b.useUTC, !0);
              this.options = b = A(!0, this.options || {}, b);
              this.Date = b.Date || I.Date || Date;
              this.timezoneOffset = (this.useUTC = d) && b.timezoneOffset || void 0;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.variableTimezone = d && !(!b.getTimezoneOffset && !b.timezone);
            };

            z.prototype.makeTime = function (b, d, h, q, l, g) {
              if (this.useUTC) {
                var w = this.Date.UTC.apply(0, arguments);
                var a = this.getTimezoneOffset(w);
                w += a;
                var B = this.getTimezoneOffset(w);
                a !== B ? w += B - a : a - 36E5 !== this.getTimezoneOffset(w - 36E5) || p || (w -= 36E5);
              } else w = new this.Date(b, d, k(h, 1), k(q, 0), k(l, 0), k(g, 0)).getTime();

              return w;
            };

            z.prototype.timezoneOffsetFunction = function () {
              var b = this,
                  d = this.options,
                  h = d.getTimezoneOffset,
                  q = d.moment || I.moment;
              if (!this.useUTC) return function (l) {
                return 6E4 * new Date(l.toString()).getTimezoneOffset();
              };

              if (d.timezone) {
                if (q) return function (l) {
                  return 6E4 * -q.tz(l, d.timezone).utcOffset();
                };
                r(25);
              }

              return this.useUTC && h ? function (l) {
                return 6E4 * h(l.valueOf());
              } : function () {
                return 6E4 * (b.timezoneOffset || 0);
              };
            };

            z.prototype.dateFormat = function (b, d, h) {
              if (!D(d) || isNaN(d)) return c.defaultOptions.lang && c.defaultOptions.lang.invalidDate || "";
              b = k(b, "%Y-%m-%d %H:%M:%S");
              var q = this,
                  l = new this.Date(d),
                  g = this.get("Hours", l),
                  w = this.get("Day", l),
                  a = this.get("Date", l),
                  B = this.get("Month", l),
                  e = this.get("FullYear", l),
                  t = c.defaultOptions.lang,
                  m = t && t.weekdays,
                  x = t && t.shortWeekdays;
              l = C({
                a: x ? x[w] : m[w].substr(0, 3),
                A: m[w],
                d: n(a),
                e: n(a, 2, " "),
                w: w,
                b: t.shortMonths[B],
                B: t.months[B],
                m: n(B + 1),
                o: B + 1,
                y: e.toString().substr(2, 2),
                Y: e,
                H: n(g),
                k: g,
                I: n(g % 12 || 12),
                l: g % 12 || 12,
                M: n(this.get("Minutes", l)),
                p: 12 > g ? "AM" : "PM",
                P: 12 > g ? "am" : "pm",
                S: n(l.getSeconds()),
                L: n(Math.floor(d % 1E3), 3)
              }, c.dateFormats);
              u(l, function (a, e) {
                for (; -1 !== b.indexOf("%" + e);) {
                  b = b.replace("%" + e, "function" === typeof a ? a.call(q, d) : a);
                }
              });
              return h ? b.substr(0, 1).toUpperCase() + b.substr(1) : b;
            };

            z.prototype.resolveDTLFormat = function (b) {
              return F(b, !0) ? b : (b = d(b), {
                main: b[0],
                from: b[1],
                to: b[2]
              });
            };

            z.prototype.getTimeTicks = function (d, h, t, q) {
              var l = this,
                  g = [],
                  w = {},
                  a = new l.Date(h),
                  B = d.unitRange,
                  e = d.count || 1,
                  p;
              q = k(q, 1);

              if (D(h)) {
                l.set("Milliseconds", a, B >= b.second ? 0 : e * Math.floor(l.get("Milliseconds", a) / e));
                B >= b.second && l.set("Seconds", a, B >= b.minute ? 0 : e * Math.floor(l.get("Seconds", a) / e));
                B >= b.minute && l.set("Minutes", a, B >= b.hour ? 0 : e * Math.floor(l.get("Minutes", a) / e));
                B >= b.hour && l.set("Hours", a, B >= b.day ? 0 : e * Math.floor(l.get("Hours", a) / e));
                B >= b.day && l.set("Date", a, B >= b.month ? 1 : Math.max(1, e * Math.floor(l.get("Date", a) / e)));

                if (B >= b.month) {
                  l.set("Month", a, B >= b.year ? 0 : e * Math.floor(l.get("Month", a) / e));
                  var m = l.get("FullYear", a);
                }

                B >= b.year && l.set("FullYear", a, m - m % e);
                B === b.week && (m = l.get("Day", a), l.set("Date", a, l.get("Date", a) - m + q + (m < q ? -7 : 0)));
                m = l.get("FullYear", a);
                q = l.get("Month", a);
                var x = l.get("Date", a),
                    z = l.get("Hours", a);
                h = a.getTime();
                !l.variableTimezone && l.useUTC || !D(t) || (p = t - h > 4 * b.month || l.getTimezoneOffset(h) !== l.getTimezoneOffset(t));
                h = a.getTime();

                for (a = 1; h < t;) {
                  g.push(h), h = B === b.year ? l.makeTime(m + a * e, 0) : B === b.month ? l.makeTime(m, q + a * e) : !p || B !== b.day && B !== b.week ? p && B === b.hour && 1 < e ? l.makeTime(m, q, x, z + a * e) : h + B * e : l.makeTime(m, q, x + a * e * (B === b.day ? 1 : 7)), a++;
                }

                g.push(h);
                B <= b.hour && 1E4 > g.length && g.forEach(function (a) {
                  0 === a % 18E5 && "000000000" === l.dateFormat("%H%M%S%L", a) && (w[a] = "day");
                });
              }

              g.info = C(d, {
                higherRanks: w,
                totalRange: B * e
              });
              return g;
            };

            z.prototype.getDateFormat = function (d, h, t, q) {
              var l = this.dateFormat("%m-%d %H:%M:%S.%L", h),
                  g = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
              },
                  w = "millisecond";

              for (a in b) {
                if (d === b.week && +this.dateFormat("%w", h) === t && "00:00:00.000" === l.substr(6)) {
                  var a = "week";
                  break;
                }

                if (b[a] > d) {
                  a = w;
                  break;
                }

                if (g[a] && l.substr(g[a]) !== "01-01 00:00:00.000".substr(g[a])) break;
                "week" !== a && (w = a);
              }

              return this.resolveDTLFormat(q[a]).main;
            };

            return z;
          }();

          "";
          return f;
        });
        H(f, "Core/DefaultOptions.js", [f["Core/Chart/ChartDefaults.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Color/Palettes.js"], f["Core/Time.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C) {
          f = f.parse;
          var I = C.merge,
              A = {
            colors: D.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
              loading: "Loading...",
              months: "January February March April May June July August September October November December".split(" "),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
              weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
              decimalPoint: ".",
              numericSymbols: "kMGTPE".split(""),
              resetZoom: "Reset zoom",
              resetZoomTitle: "Reset zoom level 1:1",
              thousandsSep: " "
            },
            global: {},
            time: {
              Date: void 0,
              getTimezoneOffset: void 0,
              timezone: void 0,
              timezoneOffset: 0,
              useUTC: !0
            },
            chart: c,
            title: {
              text: "Chart title",
              align: "center",
              margin: 15,
              widthAdjust: -44
            },
            subtitle: {
              text: "",
              align: "center",
              widthAdjust: -44
            },
            caption: {
              margin: 15,
              text: "",
              align: "left",
              verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
              style: {
                position: "absolute",
                color: "#333333"
              }
            },
            legend: {
              enabled: !0,
              align: "center",
              alignColumns: !0,
              className: "highcharts-no-tooltip",
              layout: "horizontal",
              labelFormatter: function labelFormatter() {
                return this.name;
              },
              borderColor: "#999999",
              borderRadius: 0,
              navigation: {
                activeColor: "#003399",
                inactiveColor: "#cccccc"
              },
              itemStyle: {
                color: "#333333",
                cursor: "pointer",
                fontSize: "12px",
                fontWeight: "bold",
                textOverflow: "ellipsis"
              },
              itemHoverStyle: {
                color: "#000000"
              },
              itemHiddenStyle: {
                color: "#cccccc"
              },
              shadow: !1,
              itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
              },
              squareSymbol: !0,
              symbolPadding: 5,
              verticalAlign: "bottom",
              x: 0,
              y: 0,
              title: {
                style: {
                  fontWeight: "bold"
                }
              }
            },
            loading: {
              labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
              },
              style: {
                position: "absolute",
                backgroundColor: "#ffffff",
                opacity: .5,
                textAlign: "center"
              }
            },
            tooltip: {
              enabled: !0,
              animation: v.svg,
              borderRadius: 3,
              dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
              },
              footerFormat: "",
              headerShape: "callout",
              hideDelay: 500,
              padding: 8,
              shape: "callout",
              shared: !1,
              snap: v.isTouchDevice ? 25 : 10,
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
              backgroundColor: f("#f7f7f7").setOpacity(.85).get(),
              borderWidth: 1,
              shadow: !0,
              stickOnContact: !1,
              style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                whiteSpace: "nowrap"
              },
              useHTML: !1
            },
            credits: {
              enabled: !0,
              href: "https://www.highcharts.com?credits",
              position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
              },
              style: {
                cursor: "pointer",
                color: "#999999",
                fontSize: "9px"
              },
              text: "Highcharts.com"
            }
          };
          A.chart.styledMode = !1;
          "";
          var u = new r(I(A.global, A.time));
          c = {
            defaultOptions: A,
            defaultTime: u,
            getOptions: function getOptions() {
              return A;
            },
            setOptions: function setOptions(n) {
              I(!0, A, n);
              if (n.time || n.global) v.time ? v.time.update(I(A.global, A.time, n.global, n.time)) : v.time = u;
              return A;
            }
          };
          "";
          return c;
        });
        H(f, "Core/Animation/Fx.js", [f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var I = c.parse,
              r = f.win,
              C = v.isNumber,
              F = v.objectEach;
          return function () {
            function c(c, n, k) {
              this.pos = NaN;
              this.options = n;
              this.elem = c;
              this.prop = k;
            }

            c.prototype.dSetter = function () {
              var c = this.paths,
                  n = c && c[0];
              c = c && c[1];
              var k = this.now || 0,
                  d = [];
              if (1 !== k && n && c) {
                if (n.length === c.length && 1 > k) for (var b = 0; b < c.length; b++) {
                  for (var h = n[b], p = c[b], z = [], E = 0; E < p.length; E++) {
                    var y = h[E],
                        t = p[E];
                    C(y) && C(t) && ("A" !== p[0] || 4 !== E && 5 !== E) ? z[E] = y + k * (t - y) : z[E] = t;
                  }

                  d.push(z);
                } else d = c;
              } else d = this.toD || [];
              this.elem.attr("d", d, void 0, !0);
            };

            c.prototype.update = function () {
              var c = this.elem,
                  n = this.prop,
                  k = this.now,
                  d = this.options.step;
              if (this[n + "Setter"]) this[n + "Setter"]();else c.attr ? c.element && c.attr(n, k, null, !0) : c.style[n] = k + this.unit;
              d && d.call(c, k, this);
            };

            c.prototype.run = function (u, n, k) {
              var d = this,
                  b = d.options,
                  h = function h(b) {
                return h.stopped ? !1 : d.step(b);
              },
                  p = r.requestAnimationFrame || function (b) {
                setTimeout(b, 13);
              },
                  z = function z() {
                for (var b = 0; b < c.timers.length; b++) {
                  c.timers[b]() || c.timers.splice(b--, 1);
                }

                c.timers.length && p(z);
              };

              u !== n || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = u, this.end = n, this.unit = k, this.now = this.start, this.pos = 0, h.elem = this.elem, h.prop = this.prop, h() && 1 === c.timers.push(h) && p(z)) : (delete b.curAnim[this.prop], b.complete && 0 === Object.keys(b.curAnim).length && b.complete.call(this.elem));
            };

            c.prototype.step = function (c) {
              var n = +new Date(),
                  k = this.options,
                  d = this.elem,
                  b = k.complete,
                  h = k.duration,
                  p = k.curAnim;
              if (d.attr && !d.element) c = !1;else if (c || n >= h + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                var z = p[this.prop] = !0;
                F(p, function (b) {
                  !0 !== b && (z = !1);
                });
                z && b && b.call(d);
                c = !1;
              } else this.pos = k.easing((n - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), c = !0;
              return c;
            };

            c.prototype.initPath = function (c, n, k) {
              function d(b, g) {
                for (; b.length < q;) {
                  var l = b[0],
                      a = g[q - b.length];
                  a && "M" === l[0] && (b[0] = "C" === a[0] ? ["C", l[1], l[2], l[1], l[2], l[1], l[2]] : ["L", l[1], l[2]]);
                  b.unshift(l);
                  z && (l = b.pop(), b.push(b[b.length - 1], l));
                }
              }

              function b(b, g) {
                for (; b.length < q;) {
                  if (g = b[Math.floor(b.length / E) - 1].slice(), "C" === g[0] && (g[1] = g[5], g[2] = g[6]), z) {
                    var l = b[Math.floor(b.length / E)].slice();
                    b.splice(b.length / 2, 0, g, l);
                  } else b.push(g);
                }
              }

              var h = c.startX,
                  p = c.endX;
              k = k.slice();
              var z = c.isArea,
                  E = z ? 2 : 1;
              n = n && n.slice();
              if (!n) return [k, k];

              if (h && p && p.length) {
                for (c = 0; c < h.length; c++) {
                  if (h[c] === p[0]) {
                    var y = c;
                    break;
                  } else if (h[0] === p[p.length - h.length + c]) {
                    y = c;
                    var t = !0;
                    break;
                  } else if (h[h.length - 1] === p[p.length - h.length + c]) {
                    y = h.length - c;
                    break;
                  }
                }

                "undefined" === typeof y && (n = []);
              }

              if (n.length && C(y)) {
                var q = k.length + y * E;
                t ? (d(n, k), b(k, n)) : (d(k, n), b(n, k));
              }

              return [n, k];
            };

            c.prototype.fillSetter = function () {
              c.prototype.strokeSetter.apply(this, arguments);
            };

            c.prototype.strokeSetter = function () {
              this.elem.attr(this.prop, I(this.start).tweenTo(I(this.end), this.pos), void 0, !0);
            };

            c.timers = [];
            return c;
          }();
        });
        H(f, "Core/Animation/AnimationUtilities.js", [f["Core/Animation/Fx.js"], f["Core/Utilities.js"]], function (c, f) {
          function I(b) {
            return u(b) ? n({
              duration: 500,
              defer: 0
            }, b) : {
              duration: b ? 500 : 0,
              defer: 0
            };
          }

          function D(b, d) {
            for (var h = c.timers.length; h--;) {
              c.timers[h].elem !== b || d && d !== c.timers[h].prop || (c.timers[h].stopped = !0);
            }
          }

          var r = f.defined,
              C = f.getStyle,
              F = f.isArray,
              A = f.isNumber,
              u = f.isObject,
              n = f.merge,
              k = f.objectEach,
              d = f.pick;
          return {
            animate: function animate(b, d, p) {
              var h,
                  E = "",
                  y,
                  t;

              if (!u(p)) {
                var q = arguments;
                p = {
                  duration: q[2],
                  easing: q[3],
                  complete: q[4]
                };
              }

              A(p.duration) || (p.duration = 400);
              p.easing = "function" === typeof p.easing ? p.easing : Math[p.easing] || Math.easeInOutSine;
              p.curAnim = n(d);
              k(d, function (l, g) {
                D(b, g);
                t = new c(b, p, g);
                y = void 0;
                "d" === g && F(d.d) ? (t.paths = t.initPath(b, b.pathArray, d.d), t.toD = d.d, h = 0, y = 1) : b.attr ? h = b.attr(g) : (h = parseFloat(C(b, g)) || 0, "opacity" !== g && (E = "px"));
                y || (y = l);
                "string" === typeof y && y.match("px") && (y = y.replace(/px/g, ""));
                t.run(h, y, E);
              });
            },
            animObject: I,
            getDeferredAnimation: function getDeferredAnimation(b, d, p) {
              var h = I(d),
                  k = 0,
                  y = 0;
              (p ? [p] : b.series).forEach(function (b) {
                b = I(b.options.animation);
                k = d && r(d.defer) ? h.defer : Math.max(k, b.duration + b.defer);
                y = Math.min(h.duration, b.duration);
              });
              b.renderer.forExport && (k = 0);
              return {
                defer: Math.max(0, k - y),
                duration: Math.min(k, y)
              };
            },
            setAnimation: function setAnimation(b, h) {
              h.renderer.globalAnimation = d(b, h.options.chart.animation, !0);
            },
            stop: D
          };
        });
        H(f, "Core/Renderer/HTML/AST.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f) {
          var I = c.SVG_NS,
              D = f.attr,
              r = f.createElement,
              C = f.css,
              F = f.error,
              A = f.isFunction,
              u = f.isString,
              n = f.objectEach,
              k = f.splat,
              d = (f = c.win.trustedTypes) && A(f.createPolicy) && f.createPolicy("highcharts", {
            createHTML: function createHTML(b) {
              return b;
            }
          }),
              b = d ? d.createHTML("") : "";

          try {
            var h = !!new DOMParser().parseFromString(b, "text/html");
          } catch (p) {
            h = !1;
          }

          A = function () {
            function p(b) {
              this.nodes = "string" === typeof b ? this.parseMarkup(b) : b;
            }

            p.filterUserAttributes = function (b) {
              n(b, function (d, h) {
                var t = !0;
                -1 === p.allowedAttributes.indexOf(h) && (t = !1);
                -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(h) && (t = u(d) && p.allowedReferences.some(function (b) {
                  return 0 === d.indexOf(b);
                }));
                t || (F(33, !1, void 0, {
                  "Invalid attribute in config": "".concat(h)
                }), delete b[h]);
              });
              return b;
            };

            p.parseStyle = function (b) {
              return b.split(";").reduce(function (b, d) {
                d = d.split(":").map(function (b) {
                  return b.trim();
                });
                var h = d.shift();
                h && d.length && (b[h.replace(/-([a-z])/g, function (b) {
                  return b[1].toUpperCase();
                })] = d.join(":"));
                return b;
              }, {});
            };

            p.setElementHTML = function (b, d) {
              b.innerHTML = p.emptyHTML;
              d && new p(d).addToDOM(b);
            };

            p.prototype.addToDOM = function (b) {
              function d(b, h) {
                var q;
                k(b).forEach(function (b) {
                  var g = b.tagName,
                      l = b.textContent ? c.doc.createTextNode(b.textContent) : void 0,
                      a = p.bypassHTMLFiltering;
                  if (g) if ("#text" === g) var B = l;else if (-1 !== p.allowedTags.indexOf(g) || a) {
                    g = c.doc.createElementNS("svg" === g ? I : h.namespaceURI || I, g);
                    var e = b.attributes || {};
                    n(b, function (a, g) {
                      "tagName" !== g && "attributes" !== g && "children" !== g && "style" !== g && "textContent" !== g && (e[g] = a);
                    });
                    D(g, a ? e : p.filterUserAttributes(e));
                    b.style && C(g, b.style);
                    l && g.appendChild(l);
                    d(b.children || [], g);
                    B = g;
                  } else F(33, !1, void 0, {
                    "Invalid tagName in config": g
                  });
                  B && h.appendChild(B);
                  q = B;
                });
                return q;
              }

              return d(this.nodes, b);
            };

            p.prototype.parseMarkup = function (b) {
              var k = [];
              b = b.trim().replace(/ style="/g, ' data-style="');
              if (h) b = new DOMParser().parseFromString(d ? d.createHTML(b) : b, "text/html");else {
                var z = r("div");
                z.innerHTML = b;
                b = {
                  body: z
                };
              }

              var t = function t(b, d) {
                var g = b.nodeName.toLowerCase(),
                    l = {
                  tagName: g
                };
                "#text" === g && (l.textContent = b.textContent || "");

                if (g = b.attributes) {
                  var a = {};
                  [].forEach.call(g, function (e) {
                    "data-style" === e.name ? l.style = p.parseStyle(e.value) : a[e.name] = e.value;
                  });
                  l.attributes = a;
                }

                if (b.childNodes.length) {
                  var h = [];
                  [].forEach.call(b.childNodes, function (a) {
                    t(a, h);
                  });
                  h.length && (l.children = h);
                }

                d.push(l);
              };

              [].forEach.call(b.body.childNodes, function (b) {
                return t(b, k);
              });
              return k;
            };

            p.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            p.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            p.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            p.emptyHTML = b;
            p.bypassHTMLFiltering = !1;
            return p;
          }();

          "";
          return A;
        });
        H(f, "Core/FormatUtilities.js", [f["Core/DefaultOptions.js"], f["Core/Utilities.js"]], function (c, f) {
          function I(n, k, d, b) {
            n = +n || 0;
            k = +k;
            var h = D.lang,
                p = (n.toString().split(".")[1] || "").split("e")[0].length,
                z = n.toString().split("e"),
                E = k;
            if (-1 === k) k = Math.min(p, 20);else if (!F(k)) k = 2;else if (k && z[1] && 0 > z[1]) {
              var y = k + +z[1];
              0 <= y ? (z[0] = (+z[0]).toExponential(y).split("e")[0], k = y) : (z[0] = z[0].split(".")[0] || 0, n = 20 > k ? (z[0] * Math.pow(10, z[1])).toFixed(k) : 0, z[1] = 0);
            }
            y = (Math.abs(z[1] ? z[0] : n) + Math.pow(10, -Math.max(k, p) - 1)).toFixed(k);
            p = String(u(y));
            var t = 3 < p.length ? p.length % 3 : 0;
            d = A(d, h.decimalPoint);
            b = A(b, h.thousandsSep);
            n = (0 > n ? "-" : "") + (t ? p.substr(0, t) + b : "");
            n = 0 > +z[1] && !E ? "0" : n + p.substr(t).replace(/(\d{3})(?=\d)/g, "$1" + b);
            k && (n += d + y.slice(-k));
            z[1] && 0 !== +n && (n += "e" + z[1]);
            return n;
          }

          var D = c.defaultOptions,
              r = c.defaultTime,
              C = f.getNestedProperty,
              F = f.isNumber,
              A = f.pick,
              u = f.pInt;
          return {
            dateFormat: function dateFormat(n, k, d) {
              return r.dateFormat(n, k, d);
            },
            format: function format(n, k, d) {
              var b = "{",
                  h = !1,
                  p = /f$/,
                  z = /\.([0-9])/,
                  E = D.lang,
                  y = d && d.time || r;
              d = d && d.numberFormatter || I;

              for (var t = []; n;) {
                var q = n.indexOf(b);
                if (-1 === q) break;
                var l = n.slice(0, q);

                if (h) {
                  l = l.split(":");
                  b = C(l.shift() || "", k);
                  if (l.length && "number" === typeof b) if (l = l.join(":"), p.test(l)) {
                    var g = parseInt((l.match(z) || ["", "-1"])[1], 10);
                    null !== b && (b = d(b, g, E.decimalPoint, -1 < l.indexOf(",") ? E.thousandsSep : ""));
                  } else b = y.dateFormat(l, b);
                  t.push(b);
                } else t.push(l);

                n = n.slice(q + 1);
                b = (h = !h) ? "}" : "{";
              }

              t.push(n);
              return t.join("");
            },
            numberFormat: I
          };
        });
        H(f, "Core/Renderer/RendererUtilities.js", [f["Core/Utilities.js"]], function (c) {
          var f = c.clamp,
              v = c.pick,
              D = c.stableSort,
              r;

          (function (c) {
            function r(c, u, n) {
              var k = c,
                  d = k.reducedLen || u,
                  b = function b(_b6, d) {
                return (d.rank || 0) - (_b6.rank || 0);
              },
                  h = function h(b, d) {
                return b.target - d.target;
              },
                  p,
                  z = !0,
                  E = [],
                  y = 0;

              for (p = c.length; p--;) {
                y += c[p].size;
              }

              if (y > d) {
                D(c, b);

                for (y = p = 0; y <= d;) {
                  y += c[p].size, p++;
                }

                E = c.splice(p - 1, c.length);
              }

              D(c, h);

              for (c = c.map(function (b) {
                return {
                  size: b.size,
                  targets: [b.target],
                  align: v(b.align, .5)
                };
              }); z;) {
                for (p = c.length; p--;) {
                  d = c[p], b = (Math.min.apply(0, d.targets) + Math.max.apply(0, d.targets)) / 2, d.pos = f(b - d.size * d.align, 0, u - d.size);
                }

                p = c.length;

                for (z = !1; p--;) {
                  0 < p && c[p - 1].pos + c[p - 1].size > c[p].pos && (c[p - 1].size += c[p].size, c[p - 1].targets = c[p - 1].targets.concat(c[p].targets), c[p - 1].align = .5, c[p - 1].pos + c[p - 1].size > u && (c[p - 1].pos = u - c[p - 1].size), c.splice(p, 1), z = !0);
                }
              }

              k.push.apply(k, E);
              p = 0;
              c.some(function (b) {
                var d = 0;
                return (b.targets || []).some(function () {
                  k[p].pos = b.pos + d;
                  if ("undefined" !== typeof n && Math.abs(k[p].pos - k[p].target) > n) return k.slice(0, p + 1).forEach(function (b) {
                    return delete b.pos;
                  }), k.reducedLen = (k.reducedLen || u) - .1 * u, k.reducedLen > .1 * u && r(k, u, n), !0;
                  d += k[p].size;
                  p++;
                  return !1;
                });
              });
              D(k, h);
              return k;
            }

            c.distribute = r;
          })(r || (r = {}));

          return r;
        });
        H(f, "Core/Renderer/SVG/SVGElement.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Renderer/HTML/AST.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f, v, D, r) {
          var I = c.animate,
              F = c.animObject,
              A = c.stop,
              u = D.deg2rad,
              n = D.doc,
              k = D.noop,
              d = D.svg,
              b = D.SVG_NS,
              h = D.win,
              p = r.addEvent,
              z = r.attr,
              E = r.createElement,
              y = r.css,
              t = r.defined,
              q = r.erase,
              l = r.extend,
              g = r.fireEvent,
              w = r.isArray,
              a = r.isFunction,
              B = r.isNumber,
              e = r.isString,
              G = r.merge,
              m = r.objectEach,
              x = r.pick,
              J = r.pInt,
              M = r.syncTimeout,
              P = r.uniqueKey;

          c = function () {
            function c() {
              this.element = void 0;
              this.onEvents = {};
              this.opacity = 1;
              this.renderer = void 0;
              this.SVG_NS = b;
              this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }

            c.prototype._defaultGetter = function (a) {
              a = x(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0);
              /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
              return a;
            };

            c.prototype._defaultSetter = function (a, e, b) {
              b.setAttribute(e, a);
            };

            c.prototype.add = function (a) {
              var e = this.renderer,
                  b = this.element;
              a && (this.parentGroup = a);
              this.parentInverted = a && a.inverted;
              "undefined" !== typeof this.textStr && "text" === this.element.nodeName && e.buildText(this);
              this.added = !0;
              if (!a || a.handleZ || this.zIndex) var g = this.zIndexSetter();
              g || (a ? a.element : e.box).appendChild(b);
              if (this.onAdd) this.onAdd();
              return this;
            };

            c.prototype.addClass = function (a, e) {
              var b = e ? "" : this.attr("class") || "";
              a = (a || "").split(/ /g).reduce(function (a, e) {
                -1 === b.indexOf(e) && a.push(e);
                return a;
              }, b ? [b] : []).join(" ");
              a !== b && this.attr("class", a);
              return this;
            };

            c.prototype.afterSetters = function () {
              this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };

            c.prototype.align = function (a, b, g) {
              var m = {},
                  d = this.renderer,
                  l = d.alignedObjects,
                  h,
                  w,
                  V;

              if (a) {
                if (this.alignOptions = a, this.alignByTranslate = b, !g || e(g)) this.alignTo = h = g || "renderer", q(l, this), l.push(this), g = void 0;
              } else a = this.alignOptions, b = this.alignByTranslate, h = this.alignTo;

              g = x(g, d[h], "scrollablePlotBox" === h ? d.plotBox : void 0, d);
              h = a.align;
              var B = a.verticalAlign;
              d = (g.x || 0) + (a.x || 0);
              l = (g.y || 0) + (a.y || 0);
              "right" === h ? w = 1 : "center" === h && (w = 2);
              w && (d += (g.width - (a.width || 0)) / w);
              m[b ? "translateX" : "x"] = Math.round(d);
              "bottom" === B ? V = 1 : "middle" === B && (V = 2);
              V && (l += (g.height - (a.height || 0)) / V);
              m[b ? "translateY" : "y"] = Math.round(l);
              this[this.placed ? "animate" : "attr"](m);
              this.placed = !0;
              this.alignAttr = m;
              return this;
            };

            c.prototype.alignSetter = function (a) {
              var e = {
                left: "start",
                center: "middle",
                right: "end"
              };
              e[a] && (this.alignValue = a, this.element.setAttribute("text-anchor", e[a]));
            };

            c.prototype.animate = function (a, e, b) {
              var g = this,
                  d = F(x(e, this.renderer.globalAnimation, !0));
              e = d.defer;
              x(n.hidden, n.msHidden, n.webkitHidden, !1) && (d.duration = 0);
              0 !== d.duration ? (b && (d.complete = b), M(function () {
                g.element && I(g, a, d);
              }, e)) : (this.attr(a, void 0, b || d.complete), m(a, function (a, e) {
                d.step && d.step.call(this, a, {
                  prop: e,
                  pos: 1,
                  elem: this
                });
              }, this));
              return this;
            };

            c.prototype.applyTextOutline = function (a) {
              var e = this.element;
              -1 !== a.indexOf("contrast") && (a = a.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));
              var g = a.split(" ");
              a = g[g.length - 1];

              if ((g = g[0]) && "none" !== g && D.svg) {
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                g = g.replace(/(^[\d\.]+)(.*?)$/g, function (a, e, g) {
                  return 2 * Number(e) + g;
                });
                this.removeTextOutline();
                var m = n.createElementNS(b, "tspan");
                z(m, {
                  "class": "highcharts-text-outline",
                  fill: a,
                  stroke: a,
                  "stroke-width": g,
                  "stroke-linejoin": "round"
                });
                [].forEach.call(e.childNodes, function (a) {
                  var e = a.cloneNode(!0);
                  e.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (a) {
                    return e.removeAttribute(a);
                  });
                  m.appendChild(e);
                });
                var d = n.createElementNS(b, "tspan");
                d.textContent = "\u200B";
                ["x", "y"].forEach(function (a) {
                  var g = e.getAttribute(a);
                  g && d.setAttribute(a, g);
                });
                m.appendChild(d);
                e.insertBefore(m, e.firstChild);
              }
            };

            c.prototype.attr = function (a, e, g, b) {
              var d = this.element,
                  l = this.symbolCustomAttribs,
                  x,
                  h = this,
                  w,
                  q;

              if ("string" === typeof a && "undefined" !== typeof e) {
                var B = a;
                a = {};
                a[B] = e;
              }

              "string" === typeof a ? h = (this[a + "Getter"] || this._defaultGetter).call(this, a, d) : (m(a, function (e, g) {
                w = !1;
                b || A(this, g);
                this.symbolName && -1 !== l.indexOf(g) && (x || (this.symbolAttr(a), x = !0), w = !0);
                !this.rotation || "x" !== g && "y" !== g || (this.doTransform = !0);
                w || (q = this[g + "Setter"] || this._defaultSetter, q.call(this, e, g, d), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(g) && this.updateShadows(g, e, q));
              }, this), this.afterSetters());
              g && g.call(this);
              return h;
            };

            c.prototype.clip = function (a) {
              return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
            };

            c.prototype.crisp = function (a, e) {
              e = e || a.strokeWidth || 0;
              var g = Math.round(e) % 2 / 2;
              a.x = Math.floor(a.x || this.x || 0) + g;
              a.y = Math.floor(a.y || this.y || 0) + g;
              a.width = Math.floor((a.width || this.width || 0) - 2 * g);
              a.height = Math.floor((a.height || this.height || 0) - 2 * g);
              t(a.strokeWidth) && (a.strokeWidth = e);
              return a;
            };

            c.prototype.complexColor = function (a, e, b) {
              var d = this.renderer,
                  l,
                  x,
                  h,
                  q,
                  B,
                  V,
                  p,
                  c,
                  k,
                  z,
                  y = [],
                  E;
              g(this.renderer, "complexColor", {
                args: arguments
              }, function () {
                a.radialGradient ? x = "radialGradient" : a.linearGradient && (x = "linearGradient");

                if (x) {
                  h = a[x];
                  B = d.gradients;
                  V = a.stops;
                  k = b.radialReference;
                  w(h) && (a[x] = h = {
                    x1: h[0],
                    y1: h[1],
                    x2: h[2],
                    y2: h[3],
                    gradientUnits: "userSpaceOnUse"
                  });
                  "radialGradient" === x && k && !t(h.gradientUnits) && (q = h, h = G(h, d.getRadialAttr(k, q), {
                    gradientUnits: "userSpaceOnUse"
                  }));
                  m(h, function (a, e) {
                    "id" !== e && y.push(e, a);
                  });
                  m(V, function (a) {
                    y.push(a);
                  });
                  y = y.join(",");
                  if (B[y]) z = B[y].attr("id");else {
                    h.id = z = P();
                    var g = B[y] = d.createElement(x).attr(h).add(d.defs);
                    g.radAttr = q;
                    g.stops = [];
                    V.forEach(function (a) {
                      0 === a[1].indexOf("rgba") ? (l = v.parse(a[1]), p = l.get("rgb"), c = l.get("a")) : (p = a[1], c = 1);
                      a = d.createElement("stop").attr({
                        offset: a[0],
                        "stop-color": p,
                        "stop-opacity": c
                      }).add(g);
                      g.stops.push(a);
                    });
                  }
                  E = "url(" + d.url + "#" + z + ")";
                  b.setAttribute(e, E);
                  b.gradient = y;

                  a.toString = function () {
                    return E;
                  };
                }
              });
            };

            c.prototype.css = function (a) {
              var e = this.styles,
                  g = {},
                  b = this.element,
                  h = !e;
              a.color && (a.fill = a.color);
              e && m(a, function (a, b) {
                e && e[b] !== a && (g[b] = a, h = !0);
              });

              if (h) {
                e && (a = l(e, g));
                if (null === a.width || "auto" === a.width) delete this.textWidth;else if ("text" === b.nodeName.toLowerCase() && a.width) var x = this.textWidth = J(a.width);
                this.styles = a;
                x && !d && this.renderer.forExport && delete a.width;
                var w = G(a);
                b.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach(function (a) {
                  return w && delete w[a];
                });
                y(b, w);
                this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), a.textOutline && this.applyTextOutline(a.textOutline));
              }

              return this;
            };

            c.prototype.dashstyleSetter = function (a) {
              var e = this["stroke-width"];
              "inherit" === e && (e = 1);

              if (a = a && a.toLowerCase()) {
                var g = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

                for (a = g.length; a--;) {
                  g[a] = "" + J(g[a]) * x(e, NaN);
                }

                a = g.join(",").replace(/NaN/g, "none");
                this.element.setAttribute("stroke-dasharray", a);
              }
            };

            c.prototype.destroy = function () {
              var a = this,
                  e = a.element || {},
                  g = a.renderer,
                  b = e.ownerSVGElement,
                  d = g.isSVG && "SPAN" === e.nodeName && a.parentGroup || void 0;
              e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null;
              A(a);

              if (a.clipPath && b) {
                var l = a.clipPath;
                [].forEach.call(b.querySelectorAll("[clip-path],[CLIP-PATH]"), function (a) {
                  -1 < a.getAttribute("clip-path").indexOf(l.element.id) && a.removeAttribute("clip-path");
                });
                a.clipPath = l.destroy();
              }

              if (a.stops) {
                for (b = 0; b < a.stops.length; b++) {
                  a.stops[b].destroy();
                }

                a.stops.length = 0;
                a.stops = void 0;
              }

              a.safeRemoveChild(e);

              for (g.styledMode || a.destroyShadows(); d && d.div && 0 === d.div.childNodes.length;) {
                e = d.parentGroup, a.safeRemoveChild(d.div), delete d.div, d = e;
              }

              a.alignTo && q(g.alignedObjects, a);
              m(a, function (e, g) {
                a[g] && a[g].parentGroup === a && a[g].destroy && a[g].destroy();
                delete a[g];
              });
            };

            c.prototype.destroyShadows = function () {
              (this.shadows || []).forEach(function (a) {
                this.safeRemoveChild(a);
              }, this);
              this.shadows = void 0;
            };

            c.prototype.destroyTextPath = function (a, e) {
              var g = a.getElementsByTagName("text")[0];

              if (g) {
                if (g.removeAttribute("dx"), g.removeAttribute("dy"), e.element.setAttribute("id", ""), this.textPathWrapper && g.getElementsByTagName("textPath").length) {
                  for (a = this.textPathWrapper.element.childNodes; a.length;) {
                    g.appendChild(a[0]);
                  }

                  g.removeChild(this.textPathWrapper.element);
                }
              } else if (a.getAttribute("dx") || a.getAttribute("dy")) a.removeAttribute("dx"), a.removeAttribute("dy");

              this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };

            c.prototype.dSetter = function (a, e, g) {
              w(a) && ("string" === typeof a[0] && (a = this.renderer.pathToSegments(a)), this.pathArray = a, a = a.reduce(function (a, e, g) {
                return e && e.join ? (g ? a + " " : "") + e.join(" ") : (e || "").toString();
              }, ""));
              /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
              this[e] !== a && (g.setAttribute(e, a), this[e] = a);
            };

            c.prototype.fadeOut = function (a) {
              var e = this;
              e.animate({
                opacity: 0
              }, {
                duration: x(a, 150),
                complete: function complete() {
                  e.hide();
                }
              });
            };

            c.prototype.fillSetter = function (a, e, g) {
              "string" === typeof a ? g.setAttribute(e, a) : a && this.complexColor(a, e, g);
            };

            c.prototype.getBBox = function (e, g) {
              var b = this.alignValue,
                  m = this.element,
                  d = this.renderer,
                  h = this.styles,
                  w = this.textStr,
                  q = d.cache,
                  B = d.cacheKeys,
                  p = m.namespaceURI === this.SVG_NS;
              g = x(g, this.rotation, 0);
              var k = d.styledMode ? m && c.prototype.getStyle.call(m, "font-size") : h && h.fontSize,
                  z;

              if (t(w)) {
                var G = w.toString();
                -1 === G.indexOf("<") && (G = G.replace(/[0-9]/g, "0"));
                G += ["", g, k, this.textWidth, b, h && h.textOverflow, h && h.fontWeight].join();
              }

              G && !e && (z = q[G]);

              if (!z) {
                if (p || d.forExport) {
                  try {
                    var E = this.fakeTS && function (a) {
                      var e = m.querySelector(".highcharts-text-outline");
                      e && y(e, {
                        display: a
                      });
                    };

                    a(E) && E("none");
                    z = m.getBBox ? l({}, m.getBBox()) : {
                      width: m.offsetWidth,
                      height: m.offsetHeight
                    };
                    a(E) && E("");
                  } catch (ca) {
                    "";
                  }

                  if (!z || 0 > z.width) z = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                } else z = this.htmlGetBBox();

                if (d.isSVG && (d = z.width, e = z.height, p && (z.height = e = {
                  "11px,17": 14,
                  "13px,20": 16
                }["" + (k || "") + ",".concat(Math.round(e))] || e), g)) {
                  p = Number(m.getAttribute("y") || 0) - z.y;
                  b = {
                    right: 1,
                    center: .5
                  }[b || 0] || 0;
                  h = g * u;
                  k = (g - 90) * u;
                  var n = d * Math.cos(h);
                  g = d * Math.sin(h);
                  E = Math.cos(k);
                  h = Math.sin(k);
                  d = z.x + b * (d - n) + p * E;
                  k = d + n;
                  E = k - e * E;
                  n = E - n;
                  p = z.y + p - b * g + p * h;
                  b = p + g;
                  e = b - e * h;
                  g = e - g;
                  z.x = Math.min(d, k, E, n);
                  z.y = Math.min(p, b, e, g);
                  z.width = Math.max(d, k, E, n) - z.x;
                  z.height = Math.max(p, b, e, g) - z.y;
                }

                if (G && ("" === w || 0 < z.height)) {
                  for (; 250 < B.length;) {
                    delete q[B.shift()];
                  }

                  q[G] || B.push(G);
                  q[G] = z;
                }
              }

              return z;
            };

            c.prototype.getStyle = function (a) {
              return h.getComputedStyle(this.element || this, "").getPropertyValue(a);
            };

            c.prototype.hasClass = function (a) {
              return -1 !== ("" + this.attr("class")).split(" ").indexOf(a);
            };

            c.prototype.hide = function () {
              return this.attr({
                visibility: "hidden"
              });
            };

            c.prototype.htmlGetBBox = function () {
              return {
                height: 0,
                width: 0,
                x: 0,
                y: 0
              };
            };

            c.prototype.init = function (a, e) {
              this.element = "span" === e ? E(e) : n.createElementNS(this.SVG_NS, e);
              this.renderer = a;
              g(this, "afterInit");
            };

            c.prototype.invert = function (a) {
              this.inverted = a;
              this.updateTransform();
              return this;
            };

            c.prototype.on = function (a, e) {
              var g = this.onEvents;
              if (g[a]) g[a]();
              g[a] = p(this.element, a, e);
              return this;
            };

            c.prototype.opacitySetter = function (a, e, g) {
              this.opacity = a = Number(Number(a).toFixed(3));
              g.setAttribute(e, a);
            };

            c.prototype.removeClass = function (a) {
              return this.attr("class", ("" + this.attr("class")).replace(e(a) ? new RegExp("(^| )".concat(a, "( |$)")) : a, " ").replace(/ +/g, " ").trim());
            };

            c.prototype.removeTextOutline = function () {
              var a = this.element.querySelector("tspan.highcharts-text-outline");
              a && this.safeRemoveChild(a);
            };

            c.prototype.safeRemoveChild = function (a) {
              var e = a.parentNode;
              e && e.removeChild(a);
            };

            c.prototype.setRadialReference = function (a) {
              var e = this.element.gradient && this.renderer.gradients[this.element.gradient];
              this.element.radialReference = a;
              e && e.radAttr && e.animate(this.renderer.getRadialAttr(a, e.radAttr));
              return this;
            };

            c.prototype.setTextPath = function (a, e) {
              var g = this.element,
                  b = this.text ? this.text.element : g,
                  d = {
                textAnchor: "text-anchor"
              },
                  l = !1,
                  x = this.textPathWrapper,
                  w = !x;
              e = G(!0, {
                enabled: !0,
                attributes: {
                  dy: -5,
                  startOffset: "50%",
                  textAnchor: "middle"
                }
              }, e);
              var q = f.filterUserAttributes(e.attributes);

              if (a && e && e.enabled) {
                x && null === x.element.parentNode ? (w = !0, x = x.destroy()) : x && this.removeTextOutline.call(x.parentGroup);
                this.options && this.options.padding && (q.dx = -this.options.padding);
                x || (this.textPathWrapper = x = this.renderer.createElement("textPath"), l = !0);
                var p = x.element;
                (e = a.element.getAttribute("id")) || a.element.setAttribute("id", e = P());
                if (w) for (b.setAttribute("y", 0), B(q.dx) && b.setAttribute("x", -q.dx), a = [].slice.call(b.childNodes), w = 0; w < a.length; w++) {
                  var z = a[w];
                  z.nodeType !== h.Node.TEXT_NODE && "tspan" !== z.nodeName || p.appendChild(z);
                }
                l && x && x.add({
                  element: b
                });
                p.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + e);
                t(q.dy) && (p.parentNode.setAttribute("dy", q.dy), delete q.dy);
                t(q.dx) && (p.parentNode.setAttribute("dx", q.dx), delete q.dx);
                m(q, function (a, e) {
                  p.setAttribute(d[e] || e, a);
                });
                g.removeAttribute("transform");
                this.removeTextOutline.call(x);
                this.text && !this.renderer.styledMode && this.attr({
                  fill: "none",
                  "stroke-width": 0
                });
                this.applyTextOutline = this.updateTransform = k;
              } else x && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(g, a), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

              return this;
            };

            c.prototype.shadow = function (a, e, g) {
              var b = [],
                  d = this.element,
                  h = this.oldShadowOptions,
                  x = {
                color: "#000000",
                offsetX: this.parentInverted ? -1 : 1,
                offsetY: this.parentInverted ? -1 : 1,
                opacity: .15,
                width: 3
              },
                  w = !1,
                  q;
              !0 === a ? q = x : "object" === typeof a && (q = l(x, a));
              q && (q && h && m(q, function (a, e) {
                a !== h[e] && (w = !0);
              }), w && this.destroyShadows(), this.oldShadowOptions = q);
              if (!q) this.destroyShadows();else if (!this.shadows) {
                var B = q.opacity / q.width;
                var p = this.parentInverted ? "translate(".concat(q.offsetY, ", ").concat(q.offsetX, ")") : "translate(".concat(q.offsetX, ", ").concat(q.offsetY, ")");

                for (x = 1; x <= q.width; x++) {
                  var t = d.cloneNode(!1);
                  var c = 2 * q.width + 1 - 2 * x;
                  z(t, {
                    stroke: a.color || "#000000",
                    "stroke-opacity": B * x,
                    "stroke-width": c,
                    transform: p,
                    fill: "none"
                  });
                  t.setAttribute("class", (t.getAttribute("class") || "") + " highcharts-shadow");
                  g && (z(t, "height", Math.max(z(t, "height") - c, 0)), t.cutHeight = c);
                  e ? e.element.appendChild(t) : d.parentNode && d.parentNode.insertBefore(t, d);
                  b.push(t);
                }

                this.shadows = b;
              }
              return this;
            };

            c.prototype.show = function (a) {
              void 0 === a && (a = !0);
              return this.attr({
                visibility: a ? "inherit" : "visible"
              });
            };

            c.prototype.strokeSetter = function (a, e, g) {
              this[e] = a;
              this.stroke && this["stroke-width"] ? (c.prototype.fillSetter.call(this, this.stroke, "stroke", g), g.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === e && 0 === a && this.hasStroke ? (g.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (g.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
            };

            c.prototype.strokeWidth = function () {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              var a = this.getStyle("stroke-width"),
                  e = 0;
              if (a.indexOf("px") === a.length - 2) e = J(a);else if ("" !== a) {
                var g = n.createElementNS(b, "rect");
                z(g, {
                  width: a,
                  "stroke-width": 0
                });
                this.element.parentNode.appendChild(g);
                e = g.getBBox().width;
                g.parentNode.removeChild(g);
              }
              return e;
            };

            c.prototype.symbolAttr = function (a) {
              var e = this;
              "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (g) {
                e[g] = x(a[g], e[g]);
              });
              e.attr({
                d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)
              });
            };

            c.prototype.textSetter = function (a) {
              a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));
            };

            c.prototype.titleSetter = function (a) {
              var e = this.element,
                  g = e.getElementsByTagName("title")[0] || n.createElementNS(this.SVG_NS, "title");
              e.insertBefore ? e.insertBefore(g, e.firstChild) : e.appendChild(g);
              g.textContent = String(x(a, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };

            c.prototype.toFront = function () {
              var a = this.element;
              a.parentNode.appendChild(a);
              return this;
            };

            c.prototype.translate = function (a, e) {
              return this.attr({
                translateX: a,
                translateY: e
              });
            };

            c.prototype.updateShadows = function (a, e, g) {
              var b = this.shadows;
              if (b) for (var m = b.length; m--;) {
                g.call(b[m], "height" === a ? Math.max(e - (b[m].cutHeight || 0), 0) : "d" === a ? this.d : e, a, b[m]);
              }
            };

            c.prototype.updateTransform = function () {
              var a = this.scaleX,
                  e = this.scaleY,
                  g = this.inverted,
                  b = this.rotation,
                  m = this.matrix,
                  d = this.element,
                  l = this.translateX || 0,
                  h = this.translateY || 0;
              g && (l += this.width, h += this.height);
              l = ["translate(" + l + "," + h + ")"];
              t(m) && l.push("matrix(" + m.join(",") + ")");
              g ? l.push("rotate(90) scale(-1,1)") : b && l.push("rotate(" + b + " " + x(this.rotationOriginX, d.getAttribute("x"), 0) + " " + x(this.rotationOriginY, d.getAttribute("y") || 0) + ")");
              (t(a) || t(e)) && l.push("scale(" + x(a, 1) + " " + x(e, 1) + ")");
              l.length && d.setAttribute("transform", l.join(" "));
            };

            c.prototype.visibilitySetter = function (a, e, g) {
              "inherit" === a ? g.removeAttribute(e) : this[e] !== a && g.setAttribute(e, a);
              this[e] = a;
            };

            c.prototype.xGetter = function (a) {
              "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
              return this._defaultGetter(a);
            };

            c.prototype.zIndexSetter = function (a, e) {
              var g = this.renderer,
                  b = this.parentGroup,
                  m = (b || g).element || g.box,
                  d = this.element;
              g = m === g.box;
              var l = !1;
              var h = this.added;
              var x;
              t(a) ? (d.setAttribute("data-z-index", a), a = +a, this[e] === a && (h = !1)) : t(this[e]) && d.removeAttribute("data-z-index");
              this[e] = a;

              if (h) {
                (a = this.zIndex) && b && (b.handleZ = !0);
                e = m.childNodes;

                for (x = e.length - 1; 0 <= x && !l; x--) {
                  b = e[x];
                  h = b.getAttribute("data-z-index");
                  var q = !t(h);
                  if (b !== d) if (0 > a && q && !g && !x) m.insertBefore(d, e[x]), l = !0;else if (J(h) <= a || q && (!t(a) || 0 <= a)) m.insertBefore(d, e[x + 1] || null), l = !0;
                }

                l || (m.insertBefore(d, e[g ? 3 : 0] || null), l = !0);
              }

              return l;
            };

            return c;
          }();

          c.prototype["stroke-widthSetter"] = c.prototype.strokeSetter;
          c.prototype.yGetter = c.prototype.xGetter;

          c.prototype.matrixSetter = c.prototype.rotationOriginXSetter = c.prototype.rotationOriginYSetter = c.prototype.rotationSetter = c.prototype.scaleXSetter = c.prototype.scaleYSetter = c.prototype.translateXSetter = c.prototype.translateYSetter = c.prototype.verticalAlignSetter = function (a, e) {
            this[e] = a;
            this.doTransform = !0;
          };

          "";
          return c;
        });
        H(f, "Core/Renderer/RendererRegistry.js", [f["Core/Globals.js"]], function (c) {
          var f;

          (function (f) {
            f.rendererTypes = {};
            var I;

            f.getRendererType = function (c) {
              void 0 === c && (c = I);
              return f.rendererTypes[c] || f.rendererTypes[I];
            };

            f.registerRendererType = function (r, C, F) {
              f.rendererTypes[r] = C;
              if (!I || F) I = r, c.Renderer = C;
            };
          })(f || (f = {}));

          return f;
        });
        H(f, "Core/Renderer/SVG/SVGLabel.js", [f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function (c, f) {
          var I = this && this.__extends || function () {
            var _c8 = function c(k, d) {
              _c8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, d) {
                b.__proto__ = d;
              } || function (b, d) {
                for (var h in d) {
                  d.hasOwnProperty(h) && (b[h] = d[h]);
                }
              };

              return _c8(k, d);
            };

            return function (k, d) {
              function b() {
                this.constructor = k;
              }

              _c8(k, d);

              k.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              D = f.defined,
              r = f.extend,
              C = f.isNumber,
              F = f.merge,
              A = f.pick,
              u = f.removeEvent;

          return function (n) {
            function k(d, b, h, p, c, E, y, t, q, l) {
              var g = n.call(this) || this;
              g.paddingLeftSetter = g.paddingSetter;
              g.paddingRightSetter = g.paddingSetter;
              g.init(d, "g");
              g.textStr = b;
              g.x = h;
              g.y = p;
              g.anchorX = E;
              g.anchorY = y;
              g.baseline = q;
              g.className = l;
              g.addClass("button" === l ? "highcharts-no-tooltip" : "highcharts-label");
              l && g.addClass("highcharts-" + l);
              g.text = d.text(void 0, 0, 0, t).attr({
                zIndex: 1
              });
              var w;
              "string" === typeof c && ((w = /^url\((.*?)\)$/.test(c)) || g.renderer.symbols[c]) && (g.symbolKey = c);
              g.bBox = k.emptyBBox;
              g.padding = 3;
              g.baselineOffset = 0;
              g.needsBox = d.styledMode || w;
              g.deferredAttr = {};
              g.alignFactor = 0;
              return g;
            }

            I(k, n);

            k.prototype.alignSetter = function (d) {
              d = {
                left: 0,
                center: .5,
                right: 1
              }[d];
              d !== this.alignFactor && (this.alignFactor = d, this.bBox && C(this.xSetting) && this.attr({
                x: this.xSetting
              }));
            };

            k.prototype.anchorXSetter = function (d, b) {
              this.anchorX = d;
              this.boxAttr(b, Math.round(d) - this.getCrispAdjust() - this.xSetting);
            };

            k.prototype.anchorYSetter = function (d, b) {
              this.anchorY = d;
              this.boxAttr(b, d - this.ySetting);
            };

            k.prototype.boxAttr = function (d, b) {
              this.box ? this.box.attr(d, b) : this.deferredAttr[d] = b;
            };

            k.prototype.css = function (d) {
              if (d) {
                var b = {};
                d = F(d);
                k.textProps.forEach(function (h) {
                  "undefined" !== typeof d[h] && (b[h] = d[h], delete d[h]);
                });
                this.text.css(b);
                var h = ("width" in b);
                "fontSize" in b || "fontWeight" in b ? this.updateTextPadding() : h && this.updateBoxSize();
              }

              return c.prototype.css.call(this, d);
            };

            k.prototype.destroy = function () {
              u(this.element, "mouseenter");
              u(this.element, "mouseleave");
              this.text && this.text.destroy();
              this.box && (this.box = this.box.destroy());
              c.prototype.destroy.call(this);
            };

            k.prototype.fillSetter = function (d, b) {
              d && (this.needsBox = !0);
              this.fill = d;
              this.boxAttr(b, d);
            };

            k.prototype.getBBox = function () {
              this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
              var d = this.padding,
                  b = A(this.paddingLeft, d);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - b,
                y: this.bBox.y - d
              };
            };

            k.prototype.getCrispAdjust = function () {
              return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };

            k.prototype.heightSetter = function (d) {
              this.heightSetting = d;
            };

            k.prototype.onAdd = function () {
              var d = this.textStr;
              this.text.add(this);
              this.attr({
                text: D(d) ? d : "",
                x: this.x,
                y: this.y
              });
              this.box && D(this.anchorX) && this.attr({
                anchorX: this.anchorX,
                anchorY: this.anchorY
              });
            };

            k.prototype.paddingSetter = function (d, b) {
              C(d) ? d !== this[b] && (this[b] = d, this.updateTextPadding()) : this[b] = void 0;
            };

            k.prototype.rSetter = function (d, b) {
              this.boxAttr(b, d);
            };

            k.prototype.shadow = function (d) {
              d && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(d));
              return this;
            };

            k.prototype.strokeSetter = function (d, b) {
              this.stroke = d;
              this.boxAttr(b, d);
            };

            k.prototype["stroke-widthSetter"] = function (d, b) {
              d && (this.needsBox = !0);
              this["stroke-width"] = d;
              this.boxAttr(b, d);
            };

            k.prototype["text-alignSetter"] = function (d) {
              this.textAlign = d;
            };

            k.prototype.textSetter = function (d) {
              "undefined" !== typeof d && this.text.attr({
                text: d
              });
              this.updateTextPadding();
            };

            k.prototype.updateBoxSize = function () {
              var d = this.text.element.style,
                  b = {},
                  h = this.padding,
                  p = this.bBox = C(this.widthSetting) && C(this.heightSetting) && !this.textAlign || !D(this.text.textStr) ? k.emptyBBox : this.text.getBBox();
              this.width = this.getPaddedWidth();
              this.height = (this.heightSetting || p.height || 0) + 2 * h;
              d = this.renderer.fontMetrics(d && d.fontSize, this.text);
              this.baselineOffset = h + Math.min((this.text.firstLineMetrics || d).b, p.height || Infinity);
              this.heightSetting && (this.baselineOffset += (this.heightSetting - d.h) / 2);
              this.needsBox && (this.box || (h = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), h.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), h.add(this)), h = this.getCrispAdjust(), b.x = h, b.y = (this.baseline ? -this.baselineOffset : 0) + h, b.width = Math.round(this.width), b.height = Math.round(this.height), this.box.attr(r(b, this.deferredAttr)), this.deferredAttr = {});
            };

            k.prototype.updateTextPadding = function () {
              var d = this.text;
              this.updateBoxSize();
              var b = this.baseline ? 0 : this.baselineOffset,
                  h = A(this.paddingLeft, this.padding);
              D(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (h += {
                center: .5,
                right: 1
              }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (h !== d.x || b !== d.y) d.attr("x", h), d.hasBoxWidthChanged && (this.bBox = d.getBBox(!0)), "undefined" !== typeof b && d.attr("y", b);
              d.x = h;
              d.y = b;
            };

            k.prototype.widthSetter = function (d) {
              this.widthSetting = C(d) ? d : void 0;
            };

            k.prototype.getPaddedWidth = function () {
              var d = this.padding,
                  b = A(this.paddingLeft, d);
              d = A(this.paddingRight, d);
              return (this.widthSetting || this.bBox.width || 0) + b + d;
            };

            k.prototype.xSetter = function (d) {
              this.x = d;
              this.alignFactor && (d -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
              this.xSetting = Math.round(d);
              this.attr("translateX", this.xSetting);
            };

            k.prototype.ySetter = function (d) {
              this.ySetting = this.y = Math.round(d);
              this.attr("translateY", this.ySetting);
            };

            k.emptyBBox = {
              width: 0,
              height: 0,
              x: 0,
              y: 0
            };
            k.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return k;
          }(c);
        });
        H(f, "Core/Renderer/SVG/Symbols.js", [f["Core/Utilities.js"]], function (c) {
          function f(c, f, n, k, d) {
            var b = [];

            if (d) {
              var h = d.start || 0,
                  p = F(d.r, n);
              n = F(d.r, k || n);
              var z = (d.end || 0) - .001;
              k = d.innerR;
              var E = F(d.open, .001 > Math.abs((d.end || 0) - h - 2 * Math.PI)),
                  y = Math.cos(h),
                  t = Math.sin(h),
                  q = Math.cos(z),
                  l = Math.sin(z);
              h = F(d.longArc, .001 > z - h - Math.PI ? 0 : 1);
              b.push(["M", c + p * y, f + n * t], ["A", p, n, 0, h, F(d.clockwise, 1), c + p * q, f + n * l]);
              r(k) && b.push(E ? ["M", c + k * q, f + k * l] : ["L", c + k * q, f + k * l], ["A", k, k, 0, h, r(d.clockwise) ? 1 - d.clockwise : 0, c + k * y, f + k * t]);
              E || b.push(["Z"]);
            }

            return b;
          }

          function v(c, f, n, k, d) {
            return d && d.r ? D(c, f, n, k, d) : [["M", c, f], ["L", c + n, f], ["L", c + n, f + k], ["L", c, f + k], ["Z"]];
          }

          function D(c, f, n, k, d) {
            d = d && d.r || 0;
            return [["M", c + d, f], ["L", c + n - d, f], ["C", c + n, f, c + n, f, c + n, f + d], ["L", c + n, f + k - d], ["C", c + n, f + k, c + n, f + k, c + n - d, f + k], ["L", c + d, f + k], ["C", c, f + k, c, f + k, c, f + k - d], ["L", c, f + d], ["C", c, f, c, f, c + d, f]];
          }

          var r = c.defined,
              C = c.isNumber,
              F = c.pick;
          return {
            arc: f,
            callout: function callout(c, f, n, k, d) {
              var b = Math.min(d && d.r || 0, n, k),
                  h = b + 6,
                  p = d && d.anchorX;
              d = d && d.anchorY || 0;
              var z = D(c, f, n, k, {
                r: b
              });
              if (!C(p)) return z;
              c + p >= n ? d > f + h && d < f + k - h ? z.splice(3, 1, ["L", c + n, d - 6], ["L", c + n + 6, d], ["L", c + n, d + 6], ["L", c + n, f + k - b]) : z.splice(3, 1, ["L", c + n, k / 2], ["L", p, d], ["L", c + n, k / 2], ["L", c + n, f + k - b]) : 0 >= c + p ? d > f + h && d < f + k - h ? z.splice(7, 1, ["L", c, d + 6], ["L", c - 6, d], ["L", c, d - 6], ["L", c, f + b]) : z.splice(7, 1, ["L", c, k / 2], ["L", p, d], ["L", c, k / 2], ["L", c, f + b]) : d && d > k && p > c + h && p < c + n - h ? z.splice(5, 1, ["L", p + 6, f + k], ["L", p, f + k + 6], ["L", p - 6, f + k], ["L", c + b, f + k]) : d && 0 > d && p > c + h && p < c + n - h && z.splice(1, 1, ["L", p - 6, f], ["L", p, f - 6], ["L", p + 6, f], ["L", n - b, f]);
              return z;
            },
            circle: function circle(c, u, n, k) {
              return f(c + n / 2, u + k / 2, n / 2, k / 2, {
                start: .5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1
              });
            },
            diamond: function diamond(c, f, n, k) {
              return [["M", c + n / 2, f], ["L", c + n, f + k / 2], ["L", c + n / 2, f + k], ["L", c, f + k / 2], ["Z"]];
            },
            rect: v,
            roundedRect: D,
            square: v,
            triangle: function triangle(c, f, n, k) {
              return [["M", c + n / 2, f], ["L", c + n, f + k], ["L", c, f + k], ["Z"]];
            },
            "triangle-down": function triangleDown(c, f, n, k) {
              return [["M", c, f], ["L", c + n, f], ["L", c + n / 2, f + k], ["Z"]];
            }
          };
        });
        H(f, "Core/Renderer/SVG/TextBuilder.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var I = f.doc,
              r = f.SVG_NS,
              C = f.win,
              F = v.attr,
              A = v.extend,
              u = v.isString,
              n = v.objectEach,
              k = v.pick;
          return function () {
            function d(b) {
              var d = b.styles;
              this.renderer = b.renderer;
              this.svgElement = b;
              this.width = b.textWidth;
              this.textLineHeight = d && d.lineHeight;
              this.textOutline = d && d.textOutline;
              this.ellipsis = !(!d || "ellipsis" !== d.textOverflow);
              this.noWrap = !(!d || "nowrap" !== d.whiteSpace);
              this.fontSize = d && d.fontSize;
            }

            d.prototype.buildSVG = function () {
              var b = this.svgElement,
                  d = b.element,
                  p = b.renderer,
                  z = k(b.textStr, "").toString(),
                  E = -1 !== z.indexOf("<"),
                  y = d.childNodes;
              p = this.width && !b.added && p.box;
              var t = /<br.*?>/g,
                  q = [z, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();

              if (q !== b.textCache) {
                b.textCache = q;
                delete b.actualWidth;

                for (q = y.length; q--;) {
                  d.removeChild(y[q]);
                }

                E || this.ellipsis || this.width || -1 !== z.indexOf(" ") && (!this.noWrap || t.test(z)) ? "" !== z && (p && p.appendChild(d), z = new c(z), this.modifyTree(z.nodes), z.addToDOM(b.element), this.modifyDOM(), this.ellipsis && -1 !== (d.textContent || "").indexOf("\u2026") && b.attr("title", this.unescapeEntities(b.textStr || "", ["&lt;", "&gt;"])), p && p.removeChild(d)) : d.appendChild(I.createTextNode(this.unescapeEntities(z)));
                u(this.textOutline) && b.applyTextOutline && b.applyTextOutline(this.textOutline);
              }
            };

            d.prototype.modifyDOM = function () {
              var b = this,
                  d = this.svgElement,
                  c = F(d.element, "x");
              d.firstLineMetrics = void 0;

              for (var z; z = d.element.firstChild;) {
                if (/^[\s\u200B]*$/.test(z.textContent || " ")) d.element.removeChild(z);else break;
              }

              [].forEach.call(d.element.querySelectorAll("tspan.highcharts-br"), function (h, l) {
                h.nextSibling && h.previousSibling && (0 === l && 1 === h.previousSibling.nodeType && (d.firstLineMetrics = d.renderer.fontMetrics(void 0, h.previousSibling)), F(h, {
                  dy: b.getLineHeight(h.nextSibling),
                  x: c
                }));
              });
              var k = this.width || 0;

              if (k) {
                var y = function y(h, l) {
                  var g = h.textContent || "",
                      w = g.replace(/([^\^])-/g, "$1- ").split(" "),
                      a = !b.noWrap && (1 < w.length || 1 < d.element.childNodes.length),
                      q = b.getLineHeight(l),
                      e = 0,
                      p = d.actualWidth;
                  if (b.ellipsis) g && b.truncate(h, g, void 0, 0, Math.max(0, k - parseInt(b.fontSize || 12, 10)), function (a, e) {
                    return a.substring(0, e) + "\u2026";
                  });else if (a) {
                    g = [];

                    for (a = []; l.firstChild && l.firstChild !== h;) {
                      a.push(l.firstChild), l.removeChild(l.firstChild);
                    }

                    for (; w.length;) {
                      w.length && !b.noWrap && 0 < e && (g.push(h.textContent || ""), h.textContent = w.join(" ").replace(/- /g, "-")), b.truncate(h, void 0, w, 0 === e ? p || 0 : 0, k, function (a, e) {
                        return w.slice(0, e).join(" ").replace(/- /g, "-");
                      }), p = d.actualWidth, e++;
                    }

                    a.forEach(function (a) {
                      l.insertBefore(a, h);
                    });
                    g.forEach(function (a) {
                      l.insertBefore(I.createTextNode(a), h);
                      a = I.createElementNS(r, "tspan");
                      a.textContent = "\u200B";
                      F(a, {
                        dy: q,
                        x: c
                      });
                      l.insertBefore(a, h);
                    });
                  }
                },
                    t = function t(b) {
                  [].slice.call(b.childNodes).forEach(function (l) {
                    l.nodeType === C.Node.TEXT_NODE ? y(l, b) : (-1 !== l.className.baseVal.indexOf("highcharts-br") && (d.actualWidth = 0), t(l));
                  });
                };

                t(d.element);
              }
            };

            d.prototype.getLineHeight = function (b) {
              var d;
              b = b.nodeType === C.Node.TEXT_NODE ? b.parentElement : b;
              this.renderer.styledMode || (d = b && /(px|em)$/.test(b.style.fontSize) ? b.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
              return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(d, b || this.svgElement.element).h;
            };

            d.prototype.modifyTree = function (b) {
              var d = this,
                  c = function c(h, p) {
                var k = h.attributes;
                k = void 0 === k ? {} : k;
                var t = h.children,
                    q = h.style;
                q = void 0 === q ? {} : q;
                var l = h.tagName,
                    g = d.renderer.styledMode;
                if ("b" === l || "strong" === l) g ? k["class"] = "highcharts-strong" : q.fontWeight = "bold";else if ("i" === l || "em" === l) g ? k["class"] = "highcharts-emphasized" : q.fontStyle = "italic";
                q && q.color && (q.fill = q.color);
                "br" === l ? (k["class"] = "highcharts-br", h.textContent = "\u200B", (p = b[p + 1]) && p.textContent && (p.textContent = p.textContent.replace(/^ +/gm, ""))) : "a" === l && t && t.some(function (g) {
                  return "#text" === g.tagName;
                }) && (h.children = [{
                  children: t,
                  tagName: "tspan"
                }]);
                "#text" !== l && "a" !== l && (h.tagName = "tspan");
                A(h, {
                  attributes: k,
                  style: q
                });
                t && t.filter(function (g) {
                  return "#text" !== g.tagName;
                }).forEach(c);
              };

              b.forEach(c);
            };

            d.prototype.truncate = function (b, d, c, k, E, y) {
              var h = this.svgElement,
                  q = h.renderer,
                  l = h.rotation,
                  g = [],
                  w = c ? 1 : 0,
                  a = (d || c || "").length,
                  B = a,
                  e,
                  p = function p(a, e) {
                e = e || a;
                var m = b.parentNode;
                if (m && "undefined" === typeof g[e]) if (m.getSubStringLength) try {
                  g[e] = k + m.getSubStringLength(0, c ? e + 1 : e);
                } catch (P) {
                  "";
                } else q.getSpanWidth && (b.textContent = y(d || c, a), g[e] = k + q.getSpanWidth(h, b));
                return g[e];
              };

              h.rotation = 0;
              var m = p(b.textContent.length);

              if (k + m > E) {
                for (; w <= a;) {
                  B = Math.ceil((w + a) / 2), c && (e = y(c, B)), m = p(B, e && e.length - 1), w === a ? w = a + 1 : m > E ? a = B - 1 : w = B;
                }

                0 === a ? b.textContent = "" : d && a === d.length - 1 || (b.textContent = e || y(d || c, B));
              }

              c && c.splice(0, B);
              h.actualWidth = m;
              h.rotation = l;
            };

            d.prototype.unescapeEntities = function (b, d) {
              n(this.renderer.escapes, function (h, c) {
                d && -1 !== d.indexOf(h) || (b = b.toString().replace(new RegExp(h, "g"), c));
              });
              return b;
            };

            return d;
          }();
        });
        H(f, "Core/Renderer/SVG/SVGRenderer.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGLabel.js"], f["Core/Renderer/SVG/Symbols.js"], f["Core/Renderer/SVG/TextBuilder.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F, A, u) {
          var n = v.charts,
              k = v.deg2rad,
              d = v.doc,
              b = v.isFirefox,
              h = v.isMS,
              p = v.isWebKit,
              z = v.noop,
              E = v.SVG_NS,
              y = v.symbolSizes,
              t = v.win,
              q = u.addEvent,
              l = u.attr,
              g = u.createElement,
              w = u.css,
              a = u.defined,
              B = u.destroyObjectProperties,
              e = u.extend,
              G = u.isArray,
              m = u.isNumber,
              x = u.isObject,
              J = u.isString,
              M = u.merge,
              P = u.pick,
              L = u.pInt,
              I = u.uniqueKey,
              X;

          v = function () {
            function z(a, e, g, b, d, m, l) {
              this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
              this.init(a, e, g, b, d, m, l);
            }

            z.prototype.init = function (a, e, g, m, h, x, c) {
              var B = this.createElement("svg").attr({
                version: "1.1",
                "class": "highcharts-root"
              }),
                  p = B.element;
              c || B.css(this.getStyle(m));
              a.appendChild(p);
              l(a, "dir", "ltr");
              -1 === a.innerHTML.indexOf("xmlns") && l(p, "xmlns", this.SVG_NS);
              this.isSVG = !0;
              this.box = p;
              this.boxWrapper = B;
              this.alignedObjects = [];
              this.url = this.getReferenceURL();
              this.createElement("desc").add().element.appendChild(d.createTextNode("Created with Highcharts 10.2.0"));
              this.defs = this.createElement("defs").add();
              this.allowHTML = x;
              this.forExport = h;
              this.styledMode = c;
              this.gradients = {};
              this.cache = {};
              this.cacheKeys = [];
              this.imgCount = 0;
              this.setSize(e, g, !1);
              var z;
              b && a.getBoundingClientRect && (e = function e() {
                w(a, {
                  left: 0,
                  top: 0
                });
                z = a.getBoundingClientRect();
                w(a, {
                  left: Math.ceil(z.left) - z.left + "px",
                  top: Math.ceil(z.top) - z.top + "px"
                });
              }, e(), this.unSubPixelFix = q(t, "resize", e));
            };

            z.prototype.definition = function (a) {
              return new c([a]).addToDOM(this.defs.element);
            };

            z.prototype.getReferenceURL = function () {
              if ((b || p) && d.getElementsByTagName("base").length) {
                if (!a(X)) {
                  var e = I();
                  e = new c([{
                    tagName: "svg",
                    attributes: {
                      width: 8,
                      height: 8
                    },
                    children: [{
                      tagName: "defs",
                      children: [{
                        tagName: "clipPath",
                        attributes: {
                          id: e
                        },
                        children: [{
                          tagName: "rect",
                          attributes: {
                            width: 4,
                            height: 4
                          }
                        }]
                      }]
                    }, {
                      tagName: "rect",
                      attributes: {
                        id: "hitme",
                        width: 8,
                        height: 8,
                        "clip-path": "url(#".concat(e, ")"),
                        fill: "rgba(0,0,0,0.001)"
                      }
                    }]
                  }]).addToDOM(d.body);
                  w(e, {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    zIndex: 9E5
                  });
                  var g = d.elementFromPoint(6, 6);
                  X = "hitme" === (g && g.id);
                  d.body.removeChild(e);
                }

                if (X) return t.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
              }

              return "";
            };

            z.prototype.getStyle = function (a) {
              return this.style = e({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
              }, a);
            };

            z.prototype.setStyle = function (a) {
              this.boxWrapper.css(this.getStyle(a));
            };

            z.prototype.isHidden = function () {
              return !this.boxWrapper.getBBox().width;
            };

            z.prototype.destroy = function () {
              var a = this.defs;
              this.box = null;
              this.boxWrapper = this.boxWrapper.destroy();
              B(this.gradients || {});
              this.gradients = null;
              a && (this.defs = a.destroy());
              this.unSubPixelFix && this.unSubPixelFix();
              return this.alignedObjects = null;
            };

            z.prototype.createElement = function (a) {
              var e = new this.Element();
              e.init(this, a);
              return e;
            };

            z.prototype.getRadialAttr = function (a, e) {
              return {
                cx: a[0] - a[2] / 2 + (e.cx || 0) * a[2],
                cy: a[1] - a[2] / 2 + (e.cy || 0) * a[2],
                r: (e.r || 0) * a[2]
              };
            };

            z.prototype.buildText = function (a) {
              new A(a).buildSVG();
            };

            z.prototype.getContrast = function (a) {
              a = f.parse(a).rgba.map(function (a) {
                a /= 255;
                return .03928 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4);
              });
              a = .2126 * a[0] + .7152 * a[1] + .0722 * a[2];
              return 1.05 / (a + .05) > (a + .05) / .05 ? "#FFFFFF" : "#000000";
            };

            z.prototype.button = function (a, g, b, d, m, l, w, B, p, z) {
              void 0 === m && (m = {});
              var t = this.label(a, g, b, p, void 0, void 0, z, void 0, "button"),
                  k = this.styledMode;
              a = m.states || {};
              var G = 0;
              m = M(m);
              delete m.states;
              var y = M({
                color: "#333333",
                cursor: "pointer",
                fontWeight: "normal"
              }, m.style);
              delete m.style;
              var E = c.filterUserAttributes(m);
              t.attr(M({
                padding: 8,
                r: 2
              }, E));

              if (!k) {
                E = M({
                  fill: "#f7f7f7",
                  stroke: "#cccccc",
                  "stroke-width": 1
                }, E);
                l = M(E, {
                  fill: "#e6e6e6"
                }, c.filterUserAttributes(l || a.hover || {}));
                var n = l.style;
                delete l.style;
                w = M(E, {
                  fill: "#e6ebf5",
                  style: {
                    color: "#000000",
                    fontWeight: "bold"
                  }
                }, c.filterUserAttributes(w || a.select || {}));
                var f = w.style;
                delete w.style;
                B = M(E, {
                  style: {
                    color: "#cccccc"
                  }
                }, c.filterUserAttributes(B || a.disabled || {}));
                var V = B.style;
                delete B.style;
              }

              q(t.element, h ? "mouseover" : "mouseenter", function () {
                3 !== G && t.setState(1);
              });
              q(t.element, h ? "mouseout" : "mouseleave", function () {
                3 !== G && t.setState(G);
              });

              t.setState = function (a) {
                1 !== a && (t.state = G = a);
                t.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]);
                k || (t.attr([E, l, w, B][a || 0]), a = [y, n, f, V][a || 0], x(a) && t.css(a));
              };

              k || t.attr(E).css(e({
                cursor: "default"
              }, y));
              return t.on("touchstart", function (a) {
                return a.stopPropagation();
              }).on("click", function (a) {
                3 !== G && d.call(t, a);
              });
            };

            z.prototype.crispLine = function (e, g, b) {
              void 0 === b && (b = "round");
              var d = e[0],
                  m = e[1];
              a(d[1]) && d[1] === m[1] && (d[1] = m[1] = Math[b](d[1]) - g % 2 / 2);
              a(d[2]) && d[2] === m[2] && (d[2] = m[2] = Math[b](d[2]) + g % 2 / 2);
              return e;
            };

            z.prototype.path = function (a) {
              var g = this.styledMode ? {} : {
                fill: "none"
              };
              G(a) ? g.d = a : x(a) && e(g, a);
              return this.createElement("path").attr(g);
            };

            z.prototype.circle = function (a, e, g) {
              a = x(a) ? a : "undefined" === typeof a ? {} : {
                x: a,
                y: e,
                r: g
              };
              e = this.createElement("circle");

              e.xSetter = e.ySetter = function (a, e, g) {
                g.setAttribute("c" + e, a);
              };

              return e.attr(a);
            };

            z.prototype.arc = function (a, e, g, b, d, m) {
              x(a) ? (b = a, e = b.y, g = b.r, a = b.x) : b = {
                innerR: b,
                start: d,
                end: m
              };
              a = this.symbol("arc", a, e, g, g, b);
              a.r = g;
              return a;
            };

            z.prototype.rect = function (a, e, g, b, d, m) {
              d = x(a) ? a.r : d;
              var h = this.createElement("rect");
              a = x(a) ? a : "undefined" === typeof a ? {} : {
                x: a,
                y: e,
                width: Math.max(g, 0),
                height: Math.max(b, 0)
              };
              this.styledMode || ("undefined" !== typeof m && (a["stroke-width"] = m, a = h.crisp(a)), a.fill = "none");
              d && (a.r = d);

              h.rSetter = function (a, e, g) {
                h.r = a;
                l(g, {
                  rx: a,
                  ry: a
                });
              };

              h.rGetter = function () {
                return h.r || 0;
              };

              return h.attr(a);
            };

            z.prototype.setSize = function (a, e, g) {
              this.width = a;
              this.height = e;
              this.boxWrapper.animate({
                width: a,
                height: e
              }, {
                step: function step() {
                  this.attr({
                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                  });
                },
                duration: P(g, !0) ? void 0 : 0
              });
              this.alignElements();
            };

            z.prototype.g = function (a) {
              var e = this.createElement("g");
              return a ? e.attr({
                "class": "highcharts-" + a
              }) : e;
            };

            z.prototype.image = function (a, e, g, b, d, l) {
              var h = {
                preserveAspectRatio: "none"
              },
                  x = function x(a, e) {
                a.setAttributeNS ? a.setAttributeNS("http://www.w3.org/1999/xlink", "href", e) : a.setAttribute("hc-svg-href", e);
              };

              m(e) && (h.x = e);
              m(g) && (h.y = g);
              m(b) && (h.width = b);
              m(d) && (h.height = d);
              var c = this.createElement("image").attr(h);

              e = function e(_e13) {
                x(c.element, a);
                l.call(c, _e13);
              };

              l ? (x(c.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), g = new t.Image(), q(g, "load", e), g.src = a, g.complete && e({})) : x(c.element, a);
              return c;
            };

            z.prototype.symbol = function (b, m, l, h, x, c) {
              var q = this,
                  B = /^url\((.*?)\)$/,
                  t = B.test(b),
                  p = !t && (this.symbols[b] ? b : "circle"),
                  z = p && this.symbols[p],
                  k;

              if (z) {
                "number" === typeof m && (k = z.call(this.symbols, Math.round(m || 0), Math.round(l || 0), h || 0, x || 0, c));
                var G = this.path(k);
                q.styledMode || G.attr("fill", "none");
                e(G, {
                  symbolName: p || void 0,
                  x: m,
                  y: l,
                  width: h,
                  height: x
                });
                c && e(G, c);
              } else if (t) {
                var E = b.match(B)[1];
                var f = G = this.image(E);
                f.imgwidth = P(y[E] && y[E].width, c && c.width);
                f.imgheight = P(y[E] && y[E].height, c && c.height);

                var V = function V(a) {
                  return a.attr({
                    width: a.width,
                    height: a.height
                  });
                };

                ["width", "height"].forEach(function (e) {
                  f[e + "Setter"] = function (e, g) {
                    var b = this["img" + g];
                    this[g] = e;
                    a(b) && (c && "within" === c.backgroundSize && this.width && this.height && (b = Math.round(b * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(g, b), this.alignByTranslate || (e = ((this[g] || 0) - b) / 2, this.attr("width" === g ? {
                      translateX: e
                    } : {
                      translateY: e
                    })));
                  };
                });
                a(m) && f.attr({
                  x: m,
                  y: l
                });
                f.isImg = !0;
                a(f.imgwidth) && a(f.imgheight) ? V(f) : (f.attr({
                  width: 0,
                  height: 0
                }), g("img", {
                  onload: function onload() {
                    var a = n[q.chartIndex];
                    0 === this.width && (w(this, {
                      position: "absolute",
                      top: "-999em"
                    }), d.body.appendChild(this));
                    y[E] = {
                      width: this.width,
                      height: this.height
                    };
                    f.imgwidth = this.width;
                    f.imgheight = this.height;
                    f.element && V(f);
                    this.parentNode && this.parentNode.removeChild(this);
                    q.imgCount--;
                    if (!q.imgCount && a && !a.hasLoaded) a.onload();
                  },
                  src: E
                }), this.imgCount++);
              }

              return G;
            };

            z.prototype.clipRect = function (a, e, g, b) {
              var d = I() + "-",
                  m = this.createElement("clipPath").attr({
                id: d
              }).add(this.defs);
              a = this.rect(a, e, g, b, 0).add(m);
              a.id = d;
              a.clipPath = m;
              a.count = 0;
              return a;
            };

            z.prototype.text = function (e, g, b, d) {
              var m = {};
              if (d && (this.allowHTML || !this.forExport)) return this.html(e, g, b);
              m.x = Math.round(g || 0);
              b && (m.y = Math.round(b));
              a(e) && (m.text = e);
              e = this.createElement("text").attr(m);
              if (!d || this.forExport && !this.allowHTML) e.xSetter = function (a, e, g) {
                for (var b = g.getElementsByTagName("tspan"), d = g.getAttribute(e), m = 0, l; m < b.length; m++) {
                  l = b[m], l.getAttribute(e) === d && l.setAttribute(e, a);
                }

                g.setAttribute(e, a);
              };
              return e;
            };

            z.prototype.fontMetrics = function (a, e) {
              a = !this.styledMode && /px/.test(a) || !t.getComputedStyle ? a || e && e.style && e.style.fontSize || this.style && this.style.fontSize : e && r.prototype.getStyle.call(e, "font-size");
              a = /px/.test(a) ? L(a) : 12;
              e = 24 > a ? a + 3 : Math.round(1.2 * a);
              return {
                h: e,
                b: Math.round(.8 * e),
                f: a
              };
            };

            z.prototype.rotCorr = function (a, e, g) {
              var b = a;
              e && g && (b = Math.max(b * Math.cos(e * k), 4));
              return {
                x: -a / 3 * Math.sin(e * k),
                y: b
              };
            };

            z.prototype.pathToSegments = function (a) {
              for (var e = [], g = [], b = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
              }, d = 0; d < a.length; d++) {
                J(g[0]) && m(a[d]) && g.length === b[g[0].toUpperCase()] && a.splice(d, 0, g[0].replace("M", "L").replace("m", "l")), "string" === typeof a[d] && (g.length && e.push(g.slice(0)), g.length = 0), g.push(a[d]);
              }

              e.push(g.slice(0));
              return e;
            };

            z.prototype.label = function (a, e, g, b, d, m, l, h, x) {
              return new C(this, a, e, g, b, d, m, l, h, x);
            };

            z.prototype.alignElements = function () {
              this.alignedObjects.forEach(function (a) {
                return a.align();
              });
            };

            return z;
          }();

          e(v.prototype, {
            Element: r,
            SVG_NS: E,
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            symbols: F,
            draw: z
          });
          D.registerRendererType("svg", v, !0);
          "";
          return v;
        });
        H(f, "Core/Renderer/HTML/HTMLElement.js", [f["Core/Globals.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var I = this && this.__extends || function () {
            var _b7 = function b(d, h) {
              _b7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, d) {
                b.__proto__ = d;
              } || function (b, d) {
                for (var h in d) {
                  d.hasOwnProperty(h) && (b[h] = d[h]);
                }
              };

              return _b7(d, h);
            };

            return function (d, h) {
              function c() {
                this.constructor = d;
              }

              _b7(d, h);

              d.prototype = null === h ? Object.create(h) : (c.prototype = h.prototype, new c());
            };
          }(),
              r = c.isFirefox,
              C = c.isMS,
              F = c.isWebKit,
              A = c.win,
              u = v.css,
              n = v.defined,
              k = v.extend,
              d = v.pick,
              b = v.pInt;

          return function (h) {
            function c() {
              return null !== h && h.apply(this, arguments) || this;
            }

            I(c, h);

            c.compose = function (b) {
              if (-1 === c.composedClasses.indexOf(b)) {
                c.composedClasses.push(b);
                var d = c.prototype,
                    h = b.prototype;
                h.getSpanCorrection = d.getSpanCorrection;
                h.htmlCss = d.htmlCss;
                h.htmlGetBBox = d.htmlGetBBox;
                h.htmlUpdateTransform = d.htmlUpdateTransform;
                h.setSpanRotation = d.setSpanRotation;
              }

              return b;
            };

            c.prototype.getSpanCorrection = function (b, d, h) {
              this.xCorr = -b * h;
              this.yCorr = -d;
            };

            c.prototype.htmlCss = function (b) {
              var h = "SPAN" === this.element.tagName && b && "width" in b,
                  c = d(h && b.width, void 0);

              if (h) {
                delete b.width;
                this.textWidth = c;
                var t = !0;
              }

              b && "ellipsis" === b.textOverflow && (b.whiteSpace = "nowrap", b.overflow = "hidden");
              this.styles = k(this.styles, b);
              u(this.element, b);
              t && this.htmlUpdateTransform();
              return this;
            };

            c.prototype.htmlGetBBox = function () {
              var b = this.element;
              return {
                x: b.offsetLeft,
                y: b.offsetTop,
                width: b.offsetWidth,
                height: b.offsetHeight
              };
            };

            c.prototype.htmlUpdateTransform = function () {
              if (this.added) {
                var d = this.renderer,
                    h = this.element,
                    c = this.translateX || 0,
                    t = this.translateY || 0,
                    q = this.x || 0,
                    l = this.y || 0,
                    g = this.textAlign || "left",
                    w = {
                  left: 0,
                  center: .5,
                  right: 1
                }[g],
                    a = this.styles;
                a = a && a.whiteSpace;
                u(h, {
                  marginLeft: c,
                  marginTop: t
                });
                !d.styledMode && this.shadows && this.shadows.forEach(function (a) {
                  u(a, {
                    marginLeft: c + 1,
                    marginTop: t + 1
                  });
                });
                this.inverted && [].forEach.call(h.childNodes, function (a) {
                  d.invertChild(a, h);
                });

                if ("SPAN" === h.tagName) {
                  var B = this.rotation,
                      e = this.textWidth && b(this.textWidth),
                      k = [B, g, h.innerHTML, this.textWidth, this.textAlign].join(),
                      m = void 0;
                  m = !1;

                  if (e !== this.oldTextWidth) {
                    if (this.textPxLength) var x = this.textPxLength;else u(h, {
                      width: "",
                      whiteSpace: a || "nowrap"
                    }), x = h.offsetWidth;
                    (e > this.oldTextWidth || x > e) && (/[ \-]/.test(h.textContent || h.innerText) || "ellipsis" === h.style.textOverflow) && (u(h, {
                      width: x > e || B ? e + "px" : "auto",
                      display: "block",
                      whiteSpace: a || "normal"
                    }), this.oldTextWidth = e, m = !0);
                  }

                  this.hasBoxWidthChanged = m;
                  k !== this.cTT && (m = d.fontMetrics(h.style.fontSize, h).b, !n(B) || B === (this.oldRotation || 0) && g === this.oldAlign || this.setSpanRotation(B, w, m), this.getSpanCorrection(!n(B) && this.textPxLength || h.offsetWidth, m, w, B, g));
                  u(h, {
                    left: q + (this.xCorr || 0) + "px",
                    top: l + (this.yCorr || 0) + "px"
                  });
                  this.cTT = k;
                  this.oldRotation = B;
                  this.oldAlign = g;
                }
              } else this.alignOnAdd = !0;
            };

            c.prototype.setSpanRotation = function (b, d, h) {
              var c = {},
                  q = C && !/Edge/.test(A.navigator.userAgent) ? "-ms-transform" : F ? "-webkit-transform" : r ? "MozTransform" : A.opera ? "-o-transform" : void 0;
              q && (c[q] = c.transform = "rotate(" + b + "deg)", c[q + (r ? "Origin" : "-origin")] = c.transformOrigin = 100 * d + "% " + h + "px", u(this.element, c));
            };

            c.composedClasses = [];
            return c;
          }(f);
        });
        H(f, "Core/Renderer/HTML/HTMLRenderer.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = this && this.__extends || function () {
            var _c9 = function c(k, d) {
              _c9 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, d) {
                b.__proto__ = d;
              } || function (b, d) {
                for (var h in d) {
                  d.hasOwnProperty(h) && (b[h] = d[h]);
                }
              };

              return _c9(k, d);
            };

            return function (k, d) {
              function b() {
                this.constructor = k;
              }

              _c9(k, d);

              k.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              I = D.attr,
              F = D.createElement,
              A = D.extend,
              u = D.pick;

          return function (n) {
            function k() {
              return null !== n && n.apply(this, arguments) || this;
            }

            r(k, n);

            k.compose = function (d) {
              -1 === k.composedClasses.indexOf(d) && (k.composedClasses.push(d), d.prototype.html = k.prototype.html);
              return d;
            };

            k.prototype.html = function (d, b, h) {
              var k = this.createElement("span"),
                  z = k.element,
                  n = k.renderer,
                  y = n.isSVG,
                  t = function t(b, d) {
                ["opacity", "visibility"].forEach(function (g) {
                  b[g + "Setter"] = function (l, a, h) {
                    var e = b.div ? b.div.style : d;
                    f.prototype[g + "Setter"].call(this, l, a, h);
                    e && (e[a] = l);
                  };
                });
                b.addedSetters = !0;
              };

              k.textSetter = function (b) {
                b !== this.textStr && (delete this.bBox, delete this.oldTextWidth, c.setElementHTML(this.element, u(b, "")), this.textStr = b, k.doTransform = !0);
              };

              y && t(k, k.element.style);

              k.xSetter = k.ySetter = k.alignSetter = k.rotationSetter = function (b, d) {
                "align" === d ? k.alignValue = k.textAlign = b : k[d] = b;
                k.doTransform = !0;
              };

              k.afterSetters = function () {
                this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
              };

              k.attr({
                text: d,
                x: Math.round(b),
                y: Math.round(h)
              }).css({
                position: "absolute"
              });
              n.styledMode || k.css({
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
              });
              z.style.whiteSpace = "nowrap";
              k.css = k.htmlCss;
              y && (k.add = function (b) {
                var d = n.box.parentNode,
                    g = [];

                if (this.parentGroup = b) {
                  var h = b.div;

                  if (!h) {
                    for (; b;) {
                      g.push(b), b = b.parentGroup;
                    }

                    g.reverse().forEach(function (a) {
                      function b(e, g) {
                        a[g] = e;
                        "translateX" === g ? m.left = e + "px" : m.top = e + "px";
                        a.doTransform = !0;
                      }

                      var e = I(a.element, "class"),
                          l = a.styles || {};
                      h = a.div = a.div || F("div", e ? {
                        className: e
                      } : void 0, {
                        position: "absolute",
                        left: (a.translateX || 0) + "px",
                        top: (a.translateY || 0) + "px",
                        display: a.display,
                        opacity: a.opacity,
                        cursor: l.cursor,
                        pointerEvents: l.pointerEvents,
                        visibility: a.visibility
                      }, h || d);
                      var m = h.style;
                      A(a, {
                        classSetter: function (a) {
                          return function (e) {
                            this.element.setAttribute("class", e);
                            a.className = e;
                          };
                        }(h),
                        on: function on() {
                          g[0].div && k.on.apply({
                            element: g[0].div,
                            onEvents: a.onEvents
                          }, arguments);
                          return a;
                        },
                        translateXSetter: b,
                        translateYSetter: b
                      });
                      a.addedSetters || t(a);
                    });
                  }
                } else h = d;

                h.appendChild(z);
                k.added = !0;
                k.alignOnAdd && k.htmlUpdateTransform();
                return k;
              });
              return k;
            };

            k.composedClasses = [];
            return k;
          }(v);
        });
        H(f, "Core/Axis/AxisDefaults.js", [], function () {
          var c;

          (function (c) {
            c.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: !1
                },
                second: {
                  main: "%H:%M:%S",
                  range: !1
                },
                minute: {
                  main: "%H:%M",
                  range: !1
                },
                hour: {
                  main: "%H:%M",
                  range: !1
                },
                day: {
                  main: "%e. %b"
                },
                week: {
                  main: "%e. %b"
                },
                month: {
                  main: "%b '%y"
                },
                year: {
                  main: "%Y"
                }
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: void 0,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                x: 0,
                zIndex: 7,
                style: {
                  color: "#666666",
                  cursor: "default",
                  fontSize: "11px"
                }
              },
              maxPadding: .01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minPadding: .01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                  color: "#666666"
                }
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: "#f2f2f2",
              minorGridLineWidth: 1,
              minorTickColor: "#999999",
              lineColor: "#ccd6eb",
              lineWidth: 1,
              gridLineColor: "#e6e6e6",
              gridLineWidth: void 0,
              tickColor: "#ccd6eb"
            };
            c.defaultYAxisOptions = {
              reversedStacks: !0,
              endOnTick: !0,
              maxPadding: .05,
              minPadding: .05,
              tickPixelInterval: 72,
              showLastLabel: !0,
              labels: {
                x: -8
              },
              startOnTick: !0,
              title: {
                rotation: 270,
                text: "Values"
              },
              stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function formatter() {
                  var c = this.axis.chart.numberFormatter;
                  return c(this.total, -1);
                },
                style: {
                  color: "#000000",
                  fontSize: "11px",
                  fontWeight: "bold",
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
            };
            c.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            c.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            c.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            c.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(c || (c = {}));

          return c;
        });
        H(f, "Core/Foundation.js", [f["Core/Utilities.js"]], function (c) {
          var f = c.addEvent,
              v = c.isFunction,
              D = c.objectEach,
              r = c.removeEvent,
              C;

          (function (c) {
            c.registerEventOptions = function (c, u) {
              c.eventOptions = c.eventOptions || {};
              D(u.events, function (n, k) {
                c.eventOptions[k] !== n && (c.eventOptions[k] && (r(c, k, c.eventOptions[k]), delete c.eventOptions[k]), v(n) && (c.eventOptions[k] = n, f(c, k, n)));
              });
            };
          })(C || (C = {}));

          return C;
        });
        H(f, "Core/Axis/Tick.js", [f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var I = f.deg2rad,
              r = v.clamp,
              C = v.correctFloat,
              F = v.defined,
              A = v.destroyObjectProperties,
              u = v.extend,
              n = v.fireEvent,
              k = v.isNumber,
              d = v.merge,
              b = v.objectEach,
              h = v.pick;

          f = function () {
            function p(b, d, h, c, q) {
              this.isNewLabel = this.isNew = !0;
              this.axis = b;
              this.pos = d;
              this.type = h || "";
              this.parameters = q || {};
              this.tickmarkOffset = this.parameters.tickmarkOffset;
              this.options = this.parameters.options;
              n(this, "init");
              h || c || this.addLabel();
            }

            p.prototype.addLabel = function () {
              var b = this,
                  d = b.axis,
                  p = d.options,
                  t = d.chart,
                  q = d.categories,
                  l = d.logarithmic,
                  g = d.names,
                  w = b.pos,
                  a = h(b.options && b.options.labels, p.labels),
                  B = d.tickPositions,
                  e = w === B[0],
                  G = w === B[B.length - 1],
                  m = (!a.step || 1 === a.step) && 1 === d.tickInterval;
              B = B.info;
              var x = b.label,
                  f;
              q = this.parameters.category || (q ? h(q[w], g[w], w) : w);
              l && k(q) && (q = C(l.lin2log(q)));
              if (d.dateTime) if (B) {
                var M = t.time.resolveDTLFormat(p.dateTimeLabelFormats[!p.grid && B.higherRanks[w] || B.unitName]);
                var P = M.main;
              } else k(q) && (P = d.dateTime.getXDateFormat(q, p.dateTimeLabelFormats || {}));
              b.isFirst = e;
              b.isLast = G;
              var L = {
                axis: d,
                chart: t,
                dateTimeLabelFormat: P,
                isFirst: e,
                isLast: G,
                pos: w,
                tick: b,
                tickPositionInfo: B,
                value: q
              };
              n(this, "labelFormat", L);

              var r = function r(e) {
                return a.formatter ? a.formatter.call(e, e) : a.format ? (e.text = d.defaultLabelFormatter.call(e), c.format(a.format, e, t)) : d.defaultLabelFormatter.call(e, e);
              };

              p = r.call(L, L);
              var A = M && M.list;
              b.shortenLabel = A ? function () {
                for (f = 0; f < A.length; f++) {
                  if (u(L, {
                    dateTimeLabelFormat: A[f]
                  }), x.attr({
                    text: r.call(L, L)
                  }), x.getBBox().width < d.getSlotWidth(b) - 2 * a.padding) return;
                }

                x.attr({
                  text: ""
                });
              } : void 0;
              m && d._addedPlotLB && b.moveLabel(p, a);
              F(x) || b.movedLabel ? x && x.textStr !== p && !m && (!x.textWidth || a.style.width || x.styles.width || x.css({
                width: null
              }), x.attr({
                text: p
              }), x.textPxLength = x.getBBox().width) : (b.label = x = b.createLabel({
                x: 0,
                y: 0
              }, p, a), b.rotation = 0);
            };

            p.prototype.createLabel = function (b, h, c) {
              var k = this.axis,
                  q = k.chart;
              if (b = F(h) && c.enabled ? q.renderer.text(h, b.x, b.y, c.useHTML).add(k.labelGroup) : null) q.styledMode || b.css(d(c.style)), b.textPxLength = b.getBBox().width;
              return b;
            };

            p.prototype.destroy = function () {
              A(this, this.axis);
            };

            p.prototype.getPosition = function (b, d, h, c) {
              var q = this.axis,
                  l = q.chart,
                  g = c && l.oldChartHeight || l.chartHeight;
              b = {
                x: b ? C(q.translate(d + h, void 0, void 0, c) + q.transB) : q.left + q.offset + (q.opposite ? (c && l.oldChartWidth || l.chartWidth) - q.right - q.left : 0),
                y: b ? g - q.bottom + q.offset - (q.opposite ? q.height : 0) : C(g - q.translate(d + h, void 0, void 0, c) - q.transB)
              };
              b.y = r(b.y, -1E5, 1E5);
              n(this, "afterGetPosition", {
                pos: b
              });
              return b;
            };

            p.prototype.getLabelPosition = function (b, d, h, c, q, l, g, w) {
              var a = this.axis,
                  B = a.transA,
                  e = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,
                  k = a.staggerLines,
                  m = a.tickRotCorr || {
                x: 0,
                y: 0
              },
                  x = c || a.reserveSpaceDefault ? 0 : -a.labelOffset * ("center" === a.labelAlign ? .5 : 1),
                  t = {};
              h = 0 === a.side ? h.rotation ? -8 : -h.getBBox().height : 2 === a.side ? m.y + 8 : Math.cos(h.rotation * I) * (m.y - h.getBBox(!1, 0).height / 2);
              F(q.y) && (h = 0 === a.side && a.horiz ? q.y + h : q.y);
              b = b + q.x + x + m.x - (l && c ? l * B * (e ? -1 : 1) : 0);
              d = d + h - (l && !c ? l * B * (e ? 1 : -1) : 0);
              k && (c = g / (w || 1) % k, a.opposite && (c = k - c - 1), d += a.labelOffset / k * c);
              t.x = b;
              t.y = Math.round(d);
              n(this, "afterGetLabelPosition", {
                pos: t,
                tickmarkOffset: l,
                index: g
              });
              return t;
            };

            p.prototype.getLabelSize = function () {
              return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };

            p.prototype.getMarkPath = function (b, d, h, c, q, l) {
              return l.crispLine([["M", b, d], ["L", b + (q ? 0 : -h), d + (q ? h : 0)]], c);
            };

            p.prototype.handleOverflow = function (b) {
              var d = this.axis,
                  c = d.options.labels,
                  k = b.x,
                  q = d.chart.chartWidth,
                  l = d.chart.spacing,
                  g = h(d.labelLeft, Math.min(d.pos, l[3]));
              l = h(d.labelRight, Math.max(d.isRadial ? 0 : d.pos + d.len, q - l[1]));
              var w = this.label,
                  a = this.rotation,
                  B = {
                left: 0,
                center: .5,
                right: 1
              }[d.labelAlign || w.attr("align")],
                  e = w.getBBox().width,
                  p = d.getSlotWidth(this),
                  m = {},
                  x = p,
                  f = 1,
                  z;
              if (a || "justify" !== c.overflow) 0 > a && k - B * e < g ? z = Math.round(k / Math.cos(a * I) - g) : 0 < a && k + B * e > l && (z = Math.round((q - k) / Math.cos(a * I)));else if (q = k + (1 - B) * e, k - B * e < g ? x = b.x + x * (1 - B) - g : q > l && (x = l - b.x + x * B, f = -1), x = Math.min(p, x), x < p && "center" === d.labelAlign && (b.x += f * (p - x - B * (p - Math.min(e, x)))), e > x || d.autoRotation && (w.styles || {}).width) z = x;
              z && (this.shortenLabel ? this.shortenLabel() : (m.width = Math.floor(z) + "px", (c.style || {}).textOverflow || (m.textOverflow = "ellipsis"), w.css(m)));
            };

            p.prototype.moveLabel = function (d, h) {
              var c = this,
                  k = c.label,
                  q = c.axis,
                  l = q.reversed,
                  g = !1;
              k && k.textStr === d ? (c.movedLabel = k, g = !0, delete c.label) : b(q.ticks, function (a) {
                g || a.isNew || a === c || !a.label || a.label.textStr !== d || (c.movedLabel = a.label, g = !0, a.labelPos = c.movedLabel.xy, delete a.label);
              });

              if (!g && (c.labelPos || k)) {
                var w = c.labelPos || k.xy;
                k = q.horiz ? l ? 0 : q.width + q.left : w.x;
                q = q.horiz ? w.y : l ? q.width + q.left : 0;
                c.movedLabel = c.createLabel({
                  x: k,
                  y: q
                }, d, h);
                c.movedLabel && c.movedLabel.attr({
                  opacity: 0
                });
              }
            };

            p.prototype.render = function (b, d, c) {
              var k = this.axis,
                  q = k.horiz,
                  l = this.pos,
                  g = h(this.tickmarkOffset, k.tickmarkOffset);
              l = this.getPosition(q, l, g, d);
              g = l.x;
              var w = l.y;
              k = q && g === k.pos + k.len || !q && w === k.pos ? -1 : 1;
              q = h(c, this.label && this.label.newOpacity, 1);
              c = h(c, 1);
              this.isActive = !0;
              this.renderGridLine(d, c, k);
              this.renderMark(l, c, k);
              this.renderLabel(l, d, q, b);
              this.isNew = !1;
              n(this, "afterRender");
            };

            p.prototype.renderGridLine = function (b, d, c) {
              var k = this.axis,
                  q = k.options,
                  l = {},
                  g = this.pos,
                  w = this.type,
                  a = h(this.tickmarkOffset, k.tickmarkOffset),
                  B = k.chart.renderer,
                  e = this.gridLine,
                  p = q.gridLineWidth,
                  m = q.gridLineColor,
                  x = q.gridLineDashStyle;
              "minor" === this.type && (p = q.minorGridLineWidth, m = q.minorGridLineColor, x = q.minorGridLineDashStyle);
              e || (k.chart.styledMode || (l.stroke = m, l["stroke-width"] = p || 0, l.dashstyle = x), w || (l.zIndex = 1), b && (d = 0), this.gridLine = e = B.path().attr(l).addClass("highcharts-" + (w ? w + "-" : "") + "grid-line").add(k.gridGroup));
              if (e && (c = k.getPlotLinePath({
                value: g + a,
                lineWidth: e.strokeWidth() * c,
                force: "pass",
                old: b
              }))) e[b || this.isNew ? "attr" : "animate"]({
                d: c,
                opacity: d
              });
            };

            p.prototype.renderMark = function (b, d, c) {
              var k = this.axis,
                  q = k.options,
                  l = k.chart.renderer,
                  g = this.type,
                  w = k.tickSize(g ? g + "Tick" : "tick"),
                  a = b.x;
              b = b.y;
              var B = h(q["minor" !== g ? "tickWidth" : "minorTickWidth"], !g && k.isXAxis ? 1 : 0);
              q = q["minor" !== g ? "tickColor" : "minorTickColor"];
              var e = this.mark,
                  p = !e;
              w && (k.opposite && (w[0] = -w[0]), e || (this.mark = e = l.path().addClass("highcharts-" + (g ? g + "-" : "") + "tick").add(k.axisGroup), k.chart.styledMode || e.attr({
                stroke: q,
                "stroke-width": B
              })), e[p ? "attr" : "animate"]({
                d: this.getMarkPath(a, b, w[0], e.strokeWidth() * c, k.horiz, l),
                opacity: d
              }));
            };

            p.prototype.renderLabel = function (b, d, c, p) {
              var q = this.axis,
                  l = q.horiz,
                  g = q.options,
                  w = this.label,
                  a = g.labels,
                  B = a.step;
              q = h(this.tickmarkOffset, q.tickmarkOffset);
              var e = b.x;
              b = b.y;
              var G = !0;
              w && k(e) && (w.xy = b = this.getLabelPosition(e, b, w, l, a, q, p, B), this.isFirst && !this.isLast && !g.showFirstLabel || this.isLast && !this.isFirst && !g.showLastLabel ? G = !1 : !l || a.step || a.rotation || d || 0 === c || this.handleOverflow(b), B && p % B && (G = !1), G && k(b.y) ? (b.opacity = c, w[this.isNewLabel ? "attr" : "animate"](b).show(!0), this.isNewLabel = !1) : (w.hide(), this.isNewLabel = !0));
            };

            p.prototype.replaceMovedLabel = function () {
              var b = this.label,
                  d = this.axis,
                  h = d.reversed;

              if (b && !this.isNew) {
                var c = d.horiz ? h ? d.left : d.width + d.left : b.xy.x;
                h = d.horiz ? b.xy.y : h ? d.width + d.top : d.top;
                b.animate({
                  x: c,
                  y: h,
                  opacity: 0
                }, void 0, b.destroy);
                delete this.label;
              }

              d.isDirty = !0;
              this.label = this.movedLabel;
              delete this.movedLabel;
            };

            return p;
          }();

          "";
          return f;
        });
        H(f, "Core/Axis/Axis.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/AxisDefaults.js"], f["Core/Color/Color.js"], f["Core/DefaultOptions.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Axis/Tick.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F, A) {
          var u = c.animObject,
              n = D.defaultOptions,
              k = r.registerEventOptions,
              d = C.deg2rad,
              b = A.arrayMax,
              h = A.arrayMin,
              p = A.clamp,
              z = A.correctFloat,
              E = A.defined,
              y = A.destroyObjectProperties,
              t = A.erase,
              q = A.error,
              l = A.extend,
              g = A.fireEvent,
              w = A.isArray,
              a = A.isNumber,
              B = A.isString,
              e = A.merge,
              G = A.normalizeTickInterval,
              m = A.objectEach,
              x = A.pick,
              J = A.relativeLength,
              M = A.removeEvent,
              P = A.splat,
              L = A.syncTimeout,
              I = function I(a, e) {
            return G(e, void 0, void 0, x(a.options.allowDecimals, .5 > e || void 0 !== a.tickAmount), !!a.tickAmount);
          };

          c = function () {
            function c(a, e) {
              this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
              this.init(a, e);
            }

            c.prototype.init = function (e, b) {
              var d = b.isX;
              this.chart = e;
              this.horiz = e.inverted && !this.isZAxis ? !d : d;
              this.isXAxis = d;
              this.coll = this.coll || (d ? "xAxis" : "yAxis");
              g(this, "init", {
                userOptions: b
              });
              this.opposite = x(b.opposite, this.opposite);
              this.side = x(b.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
              this.setOptions(b);
              var m = this.options,
                  c = m.labels,
                  h = m.type;
              this.userOptions = b;
              this.minPixelPadding = 0;
              this.reversed = x(m.reversed, this.reversed);
              this.visible = m.visible;
              this.zoomEnabled = m.zoomEnabled;
              this.hasNames = "category" === h || !0 === m.categories;
              this.categories = m.categories || (this.hasNames ? [] : void 0);
              this.names || (this.names = [], this.names.keys = {});
              this.plotLinesAndBandsGroups = {};
              this.positiveValuesOnly = !!this.logarithmic;
              this.isLinked = E(m.linkedTo);
              this.ticks = {};
              this.labelEdge = [];
              this.minorTicks = {};
              this.plotLinesAndBands = [];
              this.alternateBands = {};
              this.len = 0;
              this.minRange = this.userMinRange = m.minRange || m.maxZoom;
              this.range = m.range;
              this.offset = m.offset || 0;
              this.min = this.max = null;
              b = x(m.crosshair, P(e.options.tooltip.crosshairs)[d ? 0 : 1]);
              this.crosshair = !0 === b ? {} : b;
              -1 === e.axes.indexOf(this) && (d ? e.axes.splice(e.xAxis.length, 0, this) : e.axes.push(this), e[this.coll].push(this));
              this.series = this.series || [];
              e.inverted && !this.isZAxis && d && "undefined" === typeof this.reversed && (this.reversed = !0);
              this.labelRotation = a(c.rotation) ? c.rotation : void 0;
              k(this, m);
              g(this, "afterInit");
            };

            c.prototype.setOptions = function (a) {
              this.options = e(f.defaultXAxisOptions, "yAxis" === this.coll && f.defaultYAxisOptions, [f.defaultTopAxisOptions, f.defaultRightAxisOptions, f.defaultBottomAxisOptions, f.defaultLeftAxisOptions][this.side], e(n[this.coll], a));
              g(this, "afterSetOptions", {
                userOptions: a
              });
            };

            c.prototype.defaultLabelFormatter = function (e) {
              var b = this.axis;
              e = this.chart.numberFormatter;
              var g = a(this.value) ? this.value : NaN,
                  d = b.chart.time,
                  m = this.dateTimeLabelFormat,
                  c = n.lang,
                  h = c.numericSymbols;
              c = c.numericSymbolMagnitude || 1E3;
              var l = b.logarithmic ? Math.abs(g) : b.tickInterval,
                  x = h && h.length;
              if (b.categories) var k = "".concat(this.value);else if (m) k = d.dateFormat(m, g);else if (x && 1E3 <= l) for (; x-- && "undefined" === typeof k;) {
                b = Math.pow(c, x + 1), l >= b && 0 === 10 * g % b && null !== h[x] && 0 !== g && (k = e(g / b, -1) + h[x]);
              }
              "undefined" === typeof k && (k = 1E4 <= Math.abs(g) ? e(g, -1) : e(g, -1, void 0, ""));
              return k;
            };

            c.prototype.getSeriesExtremes = function () {
              var e = this,
                  b = e.chart,
                  d;
              g(this, "getSeriesExtremes", null, function () {
                e.hasVisibleSeries = !1;
                e.dataMin = e.dataMax = e.threshold = null;
                e.softThreshold = !e.isXAxis;
                e.stacking && e.stacking.buildStacks();
                e.series.forEach(function (g) {
                  if (g.visible || !b.options.chart.ignoreHiddenSeries) {
                    var m = g.options,
                        c = m.threshold;
                    e.hasVisibleSeries = !0;
                    e.positiveValuesOnly && 0 >= c && (c = null);

                    if (e.isXAxis) {
                      if (m = g.xData, m.length) {
                        m = e.logarithmic ? m.filter(e.validatePositiveValue) : m;
                        d = g.getXExtremes(m);
                        var h = d.min;
                        var l = d.max;
                        a(h) || h instanceof Date || (m = m.filter(a), d = g.getXExtremes(m), h = d.min, l = d.max);
                        m.length && (e.dataMin = Math.min(x(e.dataMin, h), h), e.dataMax = Math.max(x(e.dataMax, l), l));
                      }
                    } else if (g = g.applyExtremes(), a(g.dataMin) && (h = g.dataMin, e.dataMin = Math.min(x(e.dataMin, h), h)), a(g.dataMax) && (l = g.dataMax, e.dataMax = Math.max(x(e.dataMax, l), l)), E(c) && (e.threshold = c), !m.softThreshold || e.positiveValuesOnly) e.softThreshold = !1;
                  }
                });
              });
              g(this, "afterGetSeriesExtremes");
            };

            c.prototype.translate = function (e, b, g, d, m, c) {
              var h = this.linkedParent || this,
                  l = d && h.old ? h.old.min : h.min;
              if (!a(l)) return NaN;
              var x = h.minPixelPadding;
              m = (h.isOrdinal || h.brokenAxis && h.brokenAxis.hasBreaks || h.logarithmic && m) && h.lin2val;
              var k = 1,
                  w = 0;
              d = d && h.old ? h.old.transA : h.transA;
              d || (d = h.transA);
              g && (k *= -1, w = h.len);
              h.reversed && (k *= -1, w -= k * (h.sector || h.len));
              b ? (c = (e * k + w - x) / d + l, m && (c = h.lin2val(c))) : (m && (e = h.val2lin(e)), e = k * (e - l) * d, c = (h.isRadial ? e : z(e)) + w + k * x + (a(c) ? d * c : 0));
              return c;
            };

            c.prototype.toPixels = function (a, e) {
              return this.translate(a, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);
            };

            c.prototype.toValue = function (a, e) {
              return this.translate(a - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);
            };

            c.prototype.getPlotLinePath = function (e) {
              function b(a, e, b) {
                if ("pass" !== t && a < e || a > b) t ? a = p(a, e, b) : E = !0;
                return a;
              }

              var d = this,
                  m = d.chart,
                  c = d.left,
                  h = d.top,
                  l = e.old,
                  k = e.value,
                  w = e.lineWidth,
                  q = l && m.oldChartHeight || m.chartHeight,
                  B = l && m.oldChartWidth || m.chartWidth,
                  G = d.transB,
                  f = e.translatedValue,
                  t = e.force,
                  n,
                  z,
                  J,
                  y,
                  E;
              e = {
                value: k,
                lineWidth: w,
                old: l,
                force: t,
                acrossPanes: e.acrossPanes,
                translatedValue: f
              };
              g(this, "getPlotLinePath", e, function (e) {
                f = x(f, d.translate(k, void 0, void 0, l));
                f = p(f, -1E5, 1E5);
                n = J = Math.round(f + G);
                z = y = Math.round(q - f - G);
                a(f) ? d.horiz ? (z = h, y = q - d.bottom, n = J = b(n, c, c + d.width)) : (n = c, J = B - d.right, z = y = b(z, h, h + d.height)) : (E = !0, t = !1);
                e.path = E && !t ? null : m.renderer.crispLine([["M", n, z], ["L", J, y]], w || 1);
              });
              return e.path;
            };

            c.prototype.getLinearTickPositions = function (a, e, b) {
              var g = z(Math.floor(e / a) * a);
              b = z(Math.ceil(b / a) * a);
              var d = [],
                  m;
              z(g + a) === g && (m = 20);
              if (this.single) return [e];

              for (e = g; e <= b;) {
                d.push(e);
                e = z(e + a, m);
                if (e === c) break;
                var c = e;
              }

              return d;
            };

            c.prototype.getMinorTickInterval = function () {
              var a = this.options;
              return !0 === a.minorTicks ? x(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
            };

            c.prototype.getMinorTickPositions = function () {
              var a = this.options,
                  e = this.tickPositions,
                  b = this.minorTickInterval,
                  g = this.pointRangePadding || 0,
                  d = this.min - g;
              g = this.max + g;
              var m = g - d,
                  c = [];

              if (m && m / b < this.len / 3) {
                var h = this.logarithmic;
                if (h) this.paddedTicks.forEach(function (a, e, g) {
                  e && c.push.apply(c, h.getLogTickPositions(b, g[e - 1], g[e], !0));
                });else if (this.dateTime && "auto" === this.getMinorTickInterval()) c = c.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(b), d, g, a.startOfWeek));else for (a = d + (e[0] - d) % b; a <= g && a !== c[0]; a += b) {
                  c.push(a);
                }
              }

              0 !== c.length && this.trimTicks(c);
              return c;
            };

            c.prototype.adjustForMinRange = function () {
              var a = this.options,
                  e = this.logarithmic,
                  g = this.min,
                  d = this.max,
                  m = 0,
                  c,
                  l,
                  k,
                  w;
              this.isXAxis && "undefined" === typeof this.minRange && !e && (E(a.min) || E(a.max) || E(a.floor) || E(a.ceiling) ? this.minRange = null : (this.series.forEach(function (a) {
                k = a.xData;
                w = a.xIncrement ? 1 : k.length - 1;
                if (1 < k.length) for (c = w; 0 < c; c--) {
                  if (l = k[c] - k[c - 1], !m || l < m) m = l;
                }
              }), this.minRange = Math.min(5 * m, this.dataMax - this.dataMin)));

              if (d - g < this.minRange) {
                var q = this.dataMax - this.dataMin >= this.minRange;
                var B = this.minRange;
                var p = (B - d + g) / 2;
                p = [g - p, x(a.min, g - p)];
                q && (p[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                g = b(p);
                d = [g + B, x(a.max, g + B)];
                q && (d[2] = e ? e.log2lin(this.dataMax) : this.dataMax);
                d = h(d);
                d - g < B && (p[0] = d - B, p[1] = x(a.min, d - B), g = b(p));
              }

              this.min = g;
              this.max = d;
            };

            c.prototype.getClosest = function () {
              var a;
              this.categories ? a = 1 : this.series.forEach(function (e) {
                var b = e.closestPointRange,
                    g = e.visible || !e.chart.options.chart.ignoreHiddenSeries;
                !e.noSharedTooltip && E(b) && g && (a = E(a) ? Math.min(a, b) : b);
              });
              return a;
            };

            c.prototype.nameToX = function (a) {
              var e = w(this.options.categories),
                  b = e ? this.categories : this.names,
                  g = a.options.x;
              a.series.requireSorting = !1;
              E(g) || (g = this.options.uniqueNames && b ? e ? b.indexOf(a.name) : x(b.keys[a.name], -1) : a.series.autoIncrement());

              if (-1 === g) {
                if (!e && b) var d = b.length;
              } else d = g;

              "undefined" !== typeof d && (this.names[d] = a.name, this.names.keys[a.name] = d);
              return d;
            };

            c.prototype.updateNames = function () {
              var a = this,
                  e = this.names;
              0 < e.length && (Object.keys(e.keys).forEach(function (a) {
                delete e.keys[a];
              }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {
                e.xIncrement = null;
                if (!e.points || e.isDirtyData) a.max = Math.max(a.max, e.xData.length - 1), e.processData(), e.generatePoints();
                e.data.forEach(function (b, g) {
                  if (b && b.options && "undefined" !== typeof b.name) {
                    var d = a.nameToX(b);
                    "undefined" !== typeof d && d !== b.x && (b.x = d, e.xData[g] = d);
                  }
                });
              }));
            };

            c.prototype.setAxisTranslation = function () {
              var a = this,
                  e = a.max - a.min,
                  b = a.linkedParent,
                  d = !!a.categories,
                  m = a.isXAxis,
                  c = a.axisPointRange || 0,
                  h = 0,
                  l = 0,
                  k = a.transA;

              if (m || d || c) {
                var w = a.getClosest();
                b ? (h = b.minPointOffset, l = b.pointRangePadding) : a.series.forEach(function (e) {
                  var b = d ? 1 : m ? x(e.options.pointRange, w, 0) : a.axisPointRange || 0,
                      g = e.options.pointPlacement;
                  c = Math.max(c, b);
                  if (!a.single || d) e = e.is("xrange") ? !m : m, h = Math.max(h, e && B(g) ? 0 : b / 2), l = Math.max(l, e && "on" === g ? 0 : b);
                });
                b = a.ordinal && a.ordinal.slope && w ? a.ordinal.slope / w : 1;
                a.minPointOffset = h *= b;
                a.pointRangePadding = l *= b;
                a.pointRange = Math.min(c, a.single && d ? 1 : e);
                m && (a.closestPointRange = w);
              }

              a.translationSlope = a.transA = k = a.staticScale || a.len / (e + l || 1);
              a.transB = a.horiz ? a.left : a.bottom;
              a.minPixelPadding = k * h;
              g(this, "afterSetAxisTranslation");
            };

            c.prototype.minFromRange = function () {
              return this.max - this.range;
            };

            c.prototype.setTickInterval = function (e) {
              var b = this.chart,
                  d = this.logarithmic,
                  m = this.options,
                  c = this.isXAxis,
                  h = this.isLinked,
                  l = m.tickPixelInterval,
                  k = this.categories,
                  w = this.softThreshold,
                  B = m.maxPadding,
                  p = m.minPadding,
                  G = a(m.tickInterval) && 0 <= m.tickInterval ? m.tickInterval : void 0,
                  f = a(this.threshold) ? this.threshold : null;
              this.dateTime || k || h || this.getTickAmount();
              var t = x(this.userMin, m.min);
              var n = x(this.userMax, m.max);

              if (h) {
                this.linkedParent = b[this.coll][m.linkedTo];
                var J = this.linkedParent.getExtremes();
                this.min = x(J.min, J.dataMin);
                this.max = x(J.max, J.dataMax);
                m.type !== this.linkedParent.options.type && q(11, 1, b);
              } else {
                if (w && E(f)) if (this.dataMin >= f) J = f, p = 0;else if (this.dataMax <= f) {
                  var y = f;
                  B = 0;
                }
                this.min = x(t, J, this.dataMin);
                this.max = x(n, y, this.dataMax);
              }

              d && (this.positiveValuesOnly && !e && 0 >= Math.min(this.min, x(this.dataMin, this.min)) && q(10, 1, b), this.min = z(d.log2lin(this.min), 16), this.max = z(d.log2lin(this.max), 16));
              this.range && E(this.max) && (this.userMin = this.min = t = Math.max(this.dataMin, this.minFromRange()), this.userMax = n = this.max, this.range = null);
              g(this, "foundExtremes");
              this.beforePadding && this.beforePadding();
              this.adjustForMinRange();
              !(k || this.axisPointRange || this.stacking && this.stacking.usePercentage || h) && E(this.min) && E(this.max) && (b = this.max - this.min) && (!E(t) && p && (this.min -= b * p), !E(n) && B && (this.max += b * B));
              a(this.userMin) || (a(m.softMin) && m.softMin < this.min && (this.min = t = m.softMin), a(m.floor) && (this.min = Math.max(this.min, m.floor)));
              a(this.userMax) || (a(m.softMax) && m.softMax > this.max && (this.max = n = m.softMax), a(m.ceiling) && (this.max = Math.min(this.max, m.ceiling)));
              w && E(this.dataMin) && (f = f || 0, !E(t) && this.min < f && this.dataMin >= f ? this.min = this.options.minRange ? Math.min(f, this.max - this.minRange) : f : !E(n) && this.max > f && this.dataMax <= f && (this.max = this.options.minRange ? Math.max(f, this.min + this.minRange) : f));
              a(this.min) && a(this.max) && !this.chart.polar && this.min > this.max && (E(this.options.min) ? this.max = this.min : E(this.options.max) && (this.min = this.max));
              this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : h && this.linkedParent && !G && l === this.linkedParent.options.tickPixelInterval ? G = this.linkedParent.tickInterval : x(G, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, k ? 1 : (this.max - this.min) * l / Math.max(this.len, l));

              if (c && !e) {
                var M = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
                this.series.forEach(function (a) {
                  a.forceCrop = a.forceCropping && a.forceCropping();
                  a.processData(M);
                });
                g(this, "postProcessData", {
                  hasExtemesChanged: M
                });
              }

              this.setAxisTranslation();
              g(this, "initialAxisTranslation");
              this.pointRange && !G && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
              e = x(m.minTickInterval, this.dateTime && !this.series.some(function (a) {
                return a.noSharedTooltip;
              }) ? this.closestPointRange : 0);
              !G && this.tickInterval < e && (this.tickInterval = e);
              this.dateTime || this.logarithmic || G || (this.tickInterval = I(this, this.tickInterval));
              this.tickAmount || (this.tickInterval = this.unsquish());
              this.setTickPositions();
            };

            c.prototype.setTickPositions = function () {
              var a = this.options,
                  e = a.tickPositions,
                  b = this.getMinorTickInterval(),
                  d = this.hasVerticalPanning(),
                  m = "colorAxis" === this.coll,
                  c = (m || !d) && a.startOnTick;
              d = (m || !d) && a.endOnTick;
              m = a.tickPositioner;
              this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
              this.minorTickInterval = "auto" === b && this.tickInterval ? this.tickInterval / 5 : b;
              this.single = this.min === this.max && E(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
              this.tickPositions = b = e && e.slice();

              if (!b) {
                if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {
                  if (this.dateTime) b = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) b = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (var h = a = this.tickInterval; h <= 2 * a;) {
                    if (b = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && b.length > this.tickAmount) this.tickInterval = I(this, h *= 1.1);else break;
                  }
                } else b = [this.min, this.max], q(19, !1, this.chart);
                b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1));
                this.tickPositions = b;
                m && (m = m.apply(this, [this.min, this.max])) && (this.tickPositions = b = m);
              }

              this.paddedTicks = b.slice(0);
              this.trimTicks(b, c, d);
              this.isLinked || (this.single && 2 > b.length && !this.categories && !this.series.some(function (a) {
                return a.is("heatmap") && "between" === a.options.pointPlacement;
              }) && (this.min -= .5, this.max += .5), e || m || this.adjustTickAmount());
              g(this, "afterSetTickPositions");
            };

            c.prototype.trimTicks = function (a, e, b) {
              var d = a[0],
                  m = a[a.length - 1],
                  c = !this.isOrdinal && this.minPointOffset || 0;
              g(this, "trimTicks");

              if (!this.isLinked) {
                if (e && -Infinity !== d) this.min = d;else for (; this.min - c > a[0];) {
                  a.shift();
                }
                if (b) this.max = m;else for (; this.max + c < a[a.length - 1];) {
                  a.pop();
                }
                0 === a.length && E(d) && !this.options.tickPositions && a.push((m + d) / 2);
              }
            };

            c.prototype.alignToOthers = function () {
              var e = this,
                  b = [this],
                  g = e.options,
                  d = "yAxis" === this.coll && this.chart.options.chart.alignThresholds,
                  m = [],
                  c;
              e.thresholdAlignment = void 0;

              if ((!1 !== this.chart.options.chart.alignTicks && g.alignTicks || d) && !1 !== g.startOnTick && !1 !== g.endOnTick && !e.logarithmic) {
                var h = function h(a) {
                  var e = a.options;
                  return [a.horiz ? e.left : e.top, e.width, e.height, e.pane].join();
                },
                    l = h(this);

                this.chart[this.coll].forEach(function (a) {
                  var g = a.series;
                  g.length && g.some(function (a) {
                    return a.visible;
                  }) && a !== e && h(a) === l && (c = !0, b.push(a));
                });
              }

              if (c && d) {
                b.forEach(function (b) {
                  b = b.getThresholdAlignment(e);
                  a(b) && m.push(b);
                });
                var x = 1 < m.length ? m.reduce(function (a, e) {
                  return a + e;
                }, 0) / m.length : void 0;
                b.forEach(function (a) {
                  a.thresholdAlignment = x;
                });
              }

              return c;
            };

            c.prototype.getThresholdAlignment = function (e) {
              (!a(this.dataMin) || this !== e && this.series.some(function (a) {
                return a.isDirty || a.isDirtyData;
              })) && this.getSeriesExtremes();
              if (a(this.threshold)) return e = p((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (e = 1 - e), e;
            };

            c.prototype.getTickAmount = function () {
              var a = this.options,
                  e = a.tickPixelInterval,
                  b = a.tickAmount;
              !E(a.tickInterval) && !b && this.len < e && !this.isRadial && !this.logarithmic && a.startOnTick && a.endOnTick && (b = 2);
              !b && this.alignToOthers() && (b = Math.ceil(this.len / e) + 1);
              4 > b && (this.finalTickAmt = b, b = 5);
              this.tickAmount = b;
            };

            c.prototype.adjustTickAmount = function () {
              var e = this,
                  b = e.finalTickAmt,
                  g = e.max,
                  d = e.min,
                  m = e.options,
                  c = e.tickPositions,
                  h = e.tickAmount,
                  l = e.thresholdAlignment,
                  k = c && c.length,
                  w = x(e.threshold, e.softThreshold ? 0 : null);
              var B = e.tickInterval;

              if (a(l)) {
                var q = .5 > l ? Math.ceil(l * (h - 1)) : Math.floor(l * (h - 1));
                m.reversed && (q = h - 1 - q);
              }

              if (e.hasData() && a(d) && a(g)) {
                l = function l() {
                  e.transA *= (k - 1) / (h - 1);
                  e.min = m.startOnTick ? c[0] : Math.min(d, c[0]);
                  e.max = m.endOnTick ? c[c.length - 1] : Math.max(g, c[c.length - 1]);
                };

                if (a(q) && a(e.threshold)) {
                  for (; c[q] !== w || c.length !== h || c[0] > d || c[c.length - 1] < g;) {
                    c.length = 0;

                    for (c.push(e.threshold); c.length < h;) {
                      void 0 === c[q] || c[q] > e.threshold ? c.unshift(z(c[0] - B)) : c.push(z(c[c.length - 1] + B));
                    }

                    if (B > 8 * e.tickInterval) break;
                    B *= 2;
                  }

                  l();
                } else if (k < h) {
                  for (; c.length < h;) {
                    c.length % 2 || d === w ? c.push(z(c[c.length - 1] + B)) : c.unshift(z(c[0] - B));
                  }

                  l();
                }

                if (E(b)) {
                  for (B = w = c.length; B--;) {
                    (3 === b && 1 === B % 2 || 2 >= b && 0 < B && B < w - 1) && c.splice(B, 1);
                  }

                  e.finalTickAmt = void 0;
                }
              }
            };

            c.prototype.setScale = function () {
              var a = !1,
                  e = !1;
              this.series.forEach(function (b) {
                a = a || b.isDirtyData || b.isDirty;
                e = e || b.xAxis && b.xAxis.isDirty || !1;
              });
              this.setAxisSize();
              var b = this.len !== (this.old && this.old.len);
              b || a || e || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = b || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
              a && this.panningState && (this.panningState.isDirty = !0);
              g(this, "afterSetScale");
            };

            c.prototype.setExtremes = function (a, e, b, d, m) {
              var c = this,
                  h = c.chart;
              b = x(b, !0);
              c.series.forEach(function (a) {
                delete a.kdTree;
              });
              m = l(m, {
                min: a,
                max: e
              });
              g(c, "setExtremes", m, function () {
                c.userMin = a;
                c.userMax = e;
                c.eventArgs = m;
                b && h.redraw(d);
              });
            };

            c.prototype.zoom = function (a, e) {
              var b = this,
                  d = this.dataMin,
                  m = this.dataMax,
                  c = this.options,
                  h = Math.min(d, x(c.min, d)),
                  l = Math.max(m, x(c.max, m));
              a = {
                newMin: a,
                newMax: e
              };
              g(this, "zoom", a, function (a) {
                var e = a.newMin,
                    g = a.newMax;
                if (e !== b.min || g !== b.max) b.allowZoomOutside || (E(d) && (e < h && (e = h), e > l && (e = l)), E(m) && (g < h && (g = h), g > l && (g = l))), b.displayBtn = "undefined" !== typeof e || "undefined" !== typeof g, b.setExtremes(e, g, !1, void 0, {
                  trigger: "zoom"
                });
                a.zoomed = !0;
              });
              return a.zoomed;
            };

            c.prototype.setAxisSize = function () {
              var a = this.chart,
                  e = this.options,
                  b = e.offsets || [0, 0, 0, 0],
                  g = this.horiz,
                  d = this.width = Math.round(J(x(e.width, a.plotWidth - b[3] + b[1]), a.plotWidth)),
                  m = this.height = Math.round(J(x(e.height, a.plotHeight - b[0] + b[2]), a.plotHeight)),
                  c = this.top = Math.round(J(x(e.top, a.plotTop + b[0]), a.plotHeight, a.plotTop));
              e = this.left = Math.round(J(x(e.left, a.plotLeft + b[3]), a.plotWidth, a.plotLeft));
              this.bottom = a.chartHeight - m - c;
              this.right = a.chartWidth - d - e;
              this.len = Math.max(g ? d : m, 0);
              this.pos = g ? e : c;
            };

            c.prototype.getExtremes = function () {
              var a = this.logarithmic;
              return {
                min: a ? z(a.lin2log(this.min)) : this.min,
                max: a ? z(a.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
              };
            };

            c.prototype.getThreshold = function (a) {
              var e = this.logarithmic,
                  b = e ? e.lin2log(this.min) : this.min;
              e = e ? e.lin2log(this.max) : this.max;
              null === a || -Infinity === a ? a = b : Infinity === a ? a = e : b > a ? a = b : e < a && (a = e);
              return this.translate(a, 0, 1, 0, 1);
            };

            c.prototype.autoLabelAlign = function (a) {
              var e = (x(a, 0) - 90 * this.side + 720) % 360;
              a = {
                align: "center"
              };
              g(this, "autoLabelAlign", a, function (a) {
                15 < e && 165 > e ? a.align = "right" : 195 < e && 345 > e && (a.align = "left");
              });
              return a.align;
            };

            c.prototype.tickSize = function (a) {
              var e = this.options,
                  b = x(e["tick" === a ? "tickWidth" : "minorTickWidth"], "tick" === a && this.isXAxis && !this.categories ? 1 : 0),
                  d = e["tick" === a ? "tickLength" : "minorTickLength"];

              if (b && d) {
                "inside" === e[a + "Position"] && (d = -d);
                var m = [d, b];
              }

              a = {
                tickSize: m
              };
              g(this, "afterTickSize", a);
              return a.tickSize;
            };

            c.prototype.labelMetrics = function () {
              var a = this.tickPositions && this.tickPositions[0] || 0;
              return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
            };

            c.prototype.unsquish = function () {
              var e = this.options.labels,
                  b = this.horiz,
                  g = this.tickInterval,
                  m = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / g),
                  c = e.rotation,
                  h = this.labelMetrics(),
                  l = Math.max(this.max - this.min, 0),
                  k = function k(a) {
                var e = a / (m || 1);
                e = 1 < e ? Math.ceil(e) : 1;
                e * g > l && Infinity !== a && Infinity !== m && l && (e = Math.ceil(l / g));
                return z(e * g);
              },
                  w = g,
                  B,
                  q,
                  p = Number.MAX_VALUE;

              if (b) {
                if (!e.staggerLines && !e.step) if (a(c)) var f = [c];else m < e.autoRotationLimit && (f = e.autoRotation);
                f && f.forEach(function (a) {
                  if (a === c || a && -90 <= a && 90 >= a) {
                    q = k(Math.abs(h.h / Math.sin(d * a)));
                    var e = q + Math.abs(a / 360);
                    e < p && (p = e, B = a, w = q);
                  }
                });
              } else e.step || (w = k(h.h));

              this.autoRotation = f;
              this.labelRotation = x(B, a(c) ? c : 0);
              return w;
            };

            c.prototype.getSlotWidth = function (e) {
              var b = this.chart,
                  g = this.horiz,
                  d = this.options.labels,
                  m = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                  c = b.margin[3];
              if (e && a(e.slotWidth)) return e.slotWidth;
              if (g && 2 > d.step) return d.rotation ? 0 : (this.staggerLines || 1) * this.len / m;

              if (!g) {
                e = d.style.width;
                if (void 0 !== e) return parseInt(String(e), 10);
                if (c) return c - b.spacing[3];
              }

              return .33 * b.chartWidth;
            };

            c.prototype.renderUnsquish = function () {
              var a = this.chart,
                  e = a.renderer,
                  b = this.tickPositions,
                  g = this.ticks,
                  d = this.options.labels,
                  m = d.style,
                  c = this.horiz,
                  h = this.getSlotWidth(),
                  l = Math.max(1, Math.round(h - 2 * d.padding)),
                  x = {},
                  k = this.labelMetrics(),
                  w = m.textOverflow,
                  q = 0;
              B(d.rotation) || (x.rotation = d.rotation || 0);
              b.forEach(function (a) {
                a = g[a];
                a.movedLabel && a.replaceMovedLabel();
                a && a.label && a.label.textPxLength > q && (q = a.label.textPxLength);
              });
              this.maxLabelLength = q;
              if (this.autoRotation) q > l && q > k.h ? x.rotation = this.labelRotation : this.labelRotation = 0;else if (h) {
                var p = l;

                if (!w) {
                  var f = "clip";

                  for (l = b.length; !c && l--;) {
                    var G = b[l];
                    if (G = g[G].label) G.styles && "ellipsis" === G.styles.textOverflow ? G.css({
                      textOverflow: "clip"
                    }) : G.textPxLength > h && G.css({
                      width: h + "px"
                    }), G.getBBox().height > this.len / b.length - (k.h - k.f) && (G.specificTextOverflow = "ellipsis");
                  }
                }
              }
              x.rotation && (p = q > .5 * a.chartHeight ? .33 * a.chartHeight : q, w || (f = "ellipsis"));
              if (this.labelAlign = d.align || this.autoLabelAlign(this.labelRotation)) x.align = this.labelAlign;
              b.forEach(function (a) {
                var e = (a = g[a]) && a.label,
                    b = m.width,
                    d = {};
                e && (e.attr(x), a.shortenLabel ? a.shortenLabel() : p && !b && "nowrap" !== m.whiteSpace && (p < e.textPxLength || "SPAN" === e.element.tagName) ? (d.width = p + "px", w || (d.textOverflow = e.specificTextOverflow || f), e.css(d)) : e.styles && e.styles.width && !d.width && !b && e.css({
                  width: null
                }), delete e.specificTextOverflow, a.rotation = x.rotation);
              }, this);
              this.tickRotCorr = e.rotCorr(k.b, this.labelRotation || 0, 0 !== this.side);
            };

            c.prototype.hasData = function () {
              return this.series.some(function (a) {
                return a.hasData();
              }) || this.options.showEmpty && E(this.min) && E(this.max);
            };

            c.prototype.addTitle = function (a) {
              var b = this.chart.renderer,
                  g = this.horiz,
                  d = this.opposite,
                  m = this.options.title,
                  c = this.chart.styledMode,
                  h;
              this.axisTitle || ((h = m.textAlign) || (h = (g ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: d ? "right" : "left",
                middle: "center",
                high: d ? "left" : "right"
              })[m.align]), this.axisTitle = b.text(m.text || "", 0, 0, m.useHTML).attr({
                zIndex: 7,
                rotation: m.rotation,
                align: h
              }).addClass("highcharts-axis-title"), c || this.axisTitle.css(e(m.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
              c || m.style.width || this.isRadial || this.axisTitle.css({
                width: this.len + "px"
              });
              this.axisTitle[a ? "show" : "hide"](a);
            };

            c.prototype.generateTick = function (a) {
              var e = this.ticks;
              e[a] ? e[a].addLabel() : e[a] = new F(this, a);
            };

            c.prototype.getOffset = function () {
              var a = this,
                  e = this,
                  b = e.chart,
                  d = e.horiz,
                  c = e.options,
                  h = e.side,
                  l = e.ticks,
                  k = e.tickPositions,
                  w = e.coll,
                  B = e.axisParent,
                  q = b.renderer,
                  p = b.inverted && !e.isZAxis ? [1, 0, 3, 2][h] : h,
                  G = e.hasData(),
                  f = c.title,
                  t = c.labels,
                  n = b.axisOffset;
              b = b.clipOffset;
              var z = [-1, 1, 1, -1][h],
                  J = c.className,
                  y,
                  M = 0,
                  u = 0,
                  P = 0;
              e.showAxis = y = G || c.showEmpty;
              e.staggerLines = e.horiz && t.staggerLines || void 0;

              if (!e.axisGroup) {
                var L = function L(e, b, d) {
                  return q.g(e).attr({
                    zIndex: d
                  }).addClass("highcharts-".concat(w.toLowerCase()).concat(b, " ") + (a.isRadial ? "highcharts-radial-axis".concat(b, " ") : "") + (J || "")).add(B);
                };

                e.gridGroup = L("grid", "-grid", c.gridZIndex);
                e.axisGroup = L("axis", "", c.zIndex);
                e.labelGroup = L("axis-labels", "-labels", t.zIndex);
              }

              G || e.isLinked ? (k.forEach(function (a) {
                e.generateTick(a);
              }), e.renderUnsquish(), e.reserveSpaceDefault = 0 === h || 2 === h || {
                1: "left",
                3: "right"
              }[h] === e.labelAlign, x(t.reserveSpace, "center" === e.labelAlign ? !0 : null, e.reserveSpaceDefault) && k.forEach(function (a) {
                P = Math.max(l[a].getLabelSize(), P);
              }), e.staggerLines && (P *= e.staggerLines), e.labelOffset = P * (e.opposite ? -1 : 1)) : m(l, function (a, e) {
                a.destroy();
                delete l[e];
              });

              if (f && f.text && !1 !== f.enabled && (e.addTitle(y), y && !1 !== f.reserveSpace)) {
                e.titleOffset = M = e.axisTitle.getBBox()[d ? "height" : "width"];
                var r = f.offset;
                u = E(r) ? 0 : x(f.margin, d ? 5 : 10);
              }

              e.renderLine();
              e.offset = z * x(c.offset, n[h] ? n[h] + (c.margin || 0) : 0);
              e.tickRotCorr = e.tickRotCorr || {
                x: 0,
                y: 0
              };
              f = 0 === h ? -e.labelMetrics().h : 2 === h ? e.tickRotCorr.y : 0;
              G = Math.abs(P) + u;
              P && (G = G - f + z * (d ? x(t.y, e.tickRotCorr.y + 8 * z) : t.x));
              e.axisTitleMargin = x(r, G);
              e.getMaxLabelDimensions && (e.maxLabelDimensions = e.getMaxLabelDimensions(l, k));
              "colorAxis" !== w && (d = this.tickSize("tick"), n[h] = Math.max(n[h], (e.axisTitleMargin || 0) + M + z * e.offset, G, k && k.length && d ? d[0] + z * e.offset : 0), c = !e.axisLine || c.offset ? 0 : 2 * Math.floor(e.axisLine.strokeWidth() / 2), b[p] = Math.max(b[p], c));
              g(this, "afterGetOffset");
            };

            c.prototype.getLinePath = function (a) {
              var e = this.chart,
                  b = this.opposite,
                  d = this.offset,
                  g = this.horiz,
                  m = this.left + (b ? this.width : 0) + d;
              d = e.chartHeight - this.bottom - (b ? this.height : 0) + d;
              b && (a *= -1);
              return e.renderer.crispLine([["M", g ? this.left : m, g ? d : this.top], ["L", g ? e.chartWidth - this.right : m, g ? d : e.chartHeight - this.bottom]], a);
            };

            c.prototype.renderLine = function () {
              this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              }));
            };

            c.prototype.getTitlePosition = function () {
              var a = this.horiz,
                  e = this.left,
                  b = this.top,
                  d = this.len,
                  m = this.options.title,
                  c = a ? e : b,
                  h = this.opposite,
                  l = this.offset,
                  x = m.x,
                  k = m.y,
                  w = this.axisTitle,
                  B = this.chart.renderer.fontMetrics(m.style.fontSize, w);
              w = w ? Math.max(w.getBBox(!1, 0).height - B.h - 1, 0) : 0;
              d = {
                low: c + (a ? 0 : d),
                middle: c + d / 2,
                high: c + (a ? d : 0)
              }[m.align];
              e = (a ? b + this.height : e) + (a ? 1 : -1) * (h ? -1 : 1) * (this.axisTitleMargin || 0) + [-w, w, B.f, -w][this.side];
              a = {
                x: a ? d + x : e + (h ? this.width : 0) + l + x,
                y: a ? e + k - (h ? this.height : 0) + l : d + k
              };
              g(this, "afterGetTitlePosition", {
                titlePosition: a
              });
              return a;
            };

            c.prototype.renderMinorTick = function (a, e) {
              var b = this.minorTicks;
              b[a] || (b[a] = new F(this, a, "minor"));
              e && b[a].isNew && b[a].render(null, !0);
              b[a].render(null, !1, 1);
            };

            c.prototype.renderTick = function (a, e, b) {
              var d = this.ticks;
              if (!this.isLinked || a >= this.min && a <= this.max || this.grid && this.grid.isColumn) d[a] || (d[a] = new F(this, a)), b && d[a].isNew && d[a].render(e, !0, -1), d[a].render(e);
            };

            c.prototype.render = function () {
              var e = this,
                  b = e.chart,
                  d = e.logarithmic,
                  c = e.options,
                  h = e.isLinked,
                  l = e.tickPositions,
                  x = e.axisTitle,
                  k = e.ticks,
                  w = e.minorTicks,
                  B = e.alternateBands,
                  q = c.stackLabels,
                  p = c.alternateGridColor,
                  f = e.tickmarkOffset,
                  G = e.axisLine,
                  t = e.showAxis,
                  n = u(b.renderer.globalAnimation),
                  z,
                  J;
              e.labelEdge.length = 0;
              e.overlap = !1;
              [k, w, B].forEach(function (a) {
                m(a, function (a) {
                  a.isActive = !1;
                });
              });

              if (e.hasData() || h) {
                var y = e.chart.hasRendered && e.old && a(e.old.min);
                e.minorTickInterval && !e.categories && e.getMinorTickPositions().forEach(function (a) {
                  e.renderMinorTick(a, y);
                });
                l.length && (l.forEach(function (a, b) {
                  e.renderTick(a, b, y);
                }), f && (0 === e.min || e.single) && (k[-1] || (k[-1] = new F(e, -1, null, !0)), k[-1].render(-1)));
                p && l.forEach(function (a, g) {
                  J = "undefined" !== typeof l[g + 1] ? l[g + 1] + f : e.max - f;
                  0 === g % 2 && a < e.max && J <= e.max + (b.polar ? -f : f) && (B[a] || (B[a] = new C.PlotLineOrBand(e)), z = a + f, B[a].options = {
                    from: d ? d.lin2log(z) : z,
                    to: d ? d.lin2log(J) : J,
                    color: p,
                    className: "highcharts-alternate-grid"
                  }, B[a].render(), B[a].isActive = !0);
                });
                e._addedPlotLB || (e._addedPlotLB = !0, (c.plotLines || []).concat(c.plotBands || []).forEach(function (a) {
                  e.addPlotBandOrLine(a);
                }));
              }

              [k, w, B].forEach(function (a) {
                var e = [],
                    d = n.duration;
                m(a, function (a, b) {
                  a.isActive || (a.render(b, !1, 0), a.isActive = !1, e.push(b));
                });
                L(function () {
                  for (var b = e.length; b--;) {
                    a[e[b]] && !a[e[b]].isActive && (a[e[b]].destroy(), delete a[e[b]]);
                  }
                }, a !== B && b.hasRendered && d ? d : 0);
              });
              G && (G[G.isPlaced ? "animate" : "attr"]({
                d: this.getLinePath(G.strokeWidth())
              }), G.isPlaced = !0, G[t ? "show" : "hide"](t));
              x && t && (c = e.getTitlePosition(), x[x.isNew ? "attr" : "animate"](c), x.isNew = !1);
              q && q.enabled && e.stacking && e.stacking.renderStackTotals();
              e.old = {
                len: e.len,
                max: e.max,
                min: e.min,
                transA: e.transA,
                userMax: e.userMax,
                userMin: e.userMin
              };
              e.isDirty = !1;
              g(this, "afterRender");
            };

            c.prototype.redraw = function () {
              this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {
                a.render();
              }));
              this.series.forEach(function (a) {
                a.isDirty = !0;
              });
            };

            c.prototype.getKeepProps = function () {
              return this.keepProps || c.keepProps;
            };

            c.prototype.destroy = function (a) {
              var e = this,
                  b = e.plotLinesAndBands,
                  d = this.eventOptions;
              g(this, "destroy", {
                keepEvents: a
              });
              a || M(e);
              [e.ticks, e.minorTicks, e.alternateBands].forEach(function (a) {
                y(a);
              });
              if (b) for (a = b.length; a--;) {
                b[a].destroy();
              }
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (a) {
                e[a] && (e[a] = e[a].destroy());
              });

              for (var c in e.plotLinesAndBandsGroups) {
                e.plotLinesAndBandsGroups[c] = e.plotLinesAndBandsGroups[c].destroy();
              }

              m(e, function (a, b) {
                -1 === e.getKeepProps().indexOf(b) && delete e[b];
              });
              this.eventOptions = d;
            };

            c.prototype.drawCrosshair = function (a, e) {
              var b = this.crosshair,
                  d = x(b && b.snap, !0),
                  m = this.chart,
                  c,
                  h = this.cross;
              g(this, "drawCrosshair", {
                e: a,
                point: e
              });
              a || (a = this.cross && this.cross.e);

              if (b && !1 !== (E(e) || !d)) {
                d ? E(e) && (c = x("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : c = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);

                if (E(c)) {
                  var k = {
                    value: e && (this.isXAxis ? e.x : x(e.stackY, e.y)),
                    translatedValue: c
                  };
                  m.polar && l(k, {
                    isCrosshair: !0,
                    chartX: a && a.chartX,
                    chartY: a && a.chartY,
                    point: e
                  });
                  k = this.getPlotLinePath(k) || null;
                }

                if (!E(k)) {
                  this.hideCrosshair();
                  return;
                }

                d = this.categories && !this.isRadial;
                h || (this.cross = h = m.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (d ? "category " : "thin ") + (b.className || "")).attr({
                  zIndex: x(b.zIndex, 2)
                }).add(), m.styledMode || (h.attr({
                  stroke: b.color || (d ? v.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                  "stroke-width": x(b.width, 1)
                }).css({
                  "pointer-events": "none"
                }), b.dashStyle && h.attr({
                  dashstyle: b.dashStyle
                })));
                h.show().attr({
                  d: k
                });
                d && !b.width && h.attr({
                  "stroke-width": this.transA
                });
                this.cross.e = a;
              } else this.hideCrosshair();

              g(this, "afterDrawCrosshair", {
                e: a,
                point: e
              });
            };

            c.prototype.hideCrosshair = function () {
              this.cross && this.cross.hide();
              g(this, "afterHideCrosshair");
            };

            c.prototype.hasVerticalPanning = function () {
              var a = this.chart.options.chart.panning;
              return !!(a && a.enabled && /y/.test(a.type));
            };

            c.prototype.validatePositiveValue = function (e) {
              return a(e) && 0 < e;
            };

            c.prototype.update = function (a, b) {
              var d = this.chart;
              a = e(this.userOptions, a);
              this.destroy(!0);
              this.init(d, a);
              d.isDirtyBox = !0;
              x(b, !0) && d.redraw();
            };

            c.prototype.remove = function (a) {
              for (var e = this.chart, b = this.coll, d = this.series, g = d.length; g--;) {
                d[g] && d[g].remove(!1);
              }

              t(e.axes, this);
              t(e[b], this);
              e[b].forEach(function (a, e) {
                a.options.index = a.userOptions.index = e;
              });
              this.destroy();
              e.isDirtyBox = !0;
              x(a, !0) && e.redraw();
            };

            c.prototype.setTitle = function (a, e) {
              this.update({
                title: a
              }, e);
            };

            c.prototype.setCategories = function (a, e) {
              this.update({
                categories: a
              }, e);
            };

            c.defaultOptions = f.defaultXAxisOptions;
            c.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return c;
          }();

          "";
          return c;
        });
        H(f, "Core/Axis/DateTimeAxis.js", [f["Core/Utilities.js"]], function (c) {
          var f = c.addEvent,
              v = c.getMagnitude,
              D = c.normalizeTickInterval,
              r = c.timeUnits,
              C;

          (function (c) {
            function A() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }

            function u(d) {
              "datetime" !== d.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new k(this));
            }

            var n = [];

            c.compose = function (d) {
              -1 === n.indexOf(d) && (n.push(d), d.keepProps.push("dateTime"), d.prototype.getTimeTicks = A, f(d, "init", u));
              return d;
            };

            var k = function () {
              function d(b) {
                this.axis = b;
              }

              d.prototype.normalizeTimeTickInterval = function (b, d) {
                var c = d || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                d = c[c.length - 1];
                var h = r[d[0]],
                    k = d[1],
                    f;

                for (f = 0; f < c.length && !(d = c[f], h = r[d[0]], k = d[1], c[f + 1] && b <= (h * k[k.length - 1] + r[c[f + 1][0]]) / 2); f++) {
                  ;
                }

                h === r.year && b < 5 * h && (k = [1, 2, 5]);
                b = D(b / h, k, "year" === d[0] ? Math.max(v(b / h), 1) : 1);
                return {
                  unitRange: h,
                  count: b,
                  unitName: d[0]
                };
              };

              d.prototype.getXDateFormat = function (b, d) {
                var c = this.axis,
                    h = c.chart.time;
                return c.closestPointRange ? h.getDateFormat(c.closestPointRange, b, c.options.startOfWeek, d) || h.resolveDTLFormat(d.year).main : h.resolveDTLFormat(d.day).main;
              };

              return d;
            }();

            c.Additions = k;
          })(C || (C = {}));

          return C;
        });
        H(f, "Core/Axis/LogarithmicAxis.js", [f["Core/Utilities.js"]], function (c) {
          var f = c.addEvent,
              v = c.normalizeTickInterval,
              D = c.pick,
              r;

          (function (c) {
            function r(c) {
              var d = this.logarithmic;
              "logarithmic" !== c.userOptions.type ? this.logarithmic = void 0 : d || (this.logarithmic = new n(this));
            }

            function A() {
              var c = this.logarithmic;
              c && (this.lin2val = function (d) {
                return c.lin2log(d);
              }, this.val2lin = function (d) {
                return c.log2lin(d);
              });
            }

            var u = [];

            c.compose = function (c) {
              -1 === u.indexOf(c) && (u.push(c), c.keepProps.push("logarithmic"), f(c, "init", r), f(c, "afterInit", A));
              return c;
            };

            var n = function () {
              function c(d) {
                this.axis = d;
              }

              c.prototype.getLogTickPositions = function (d, b, c, k) {
                var h = this.axis,
                    f = h.len,
                    p = h.options,
                    t = [];
                k || (this.minorAutoInterval = void 0);
                if (.5 <= d) d = Math.round(d), t = h.getLinearTickPositions(d, b, c);else if (.08 <= d) {
                  var q = Math.floor(b),
                      l,
                      g = p = void 0;

                  for (f = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; q < c + 1 && !g; q++) {
                    var w = f.length;

                    for (l = 0; l < w && !g; l++) {
                      var a = this.log2lin(this.lin2log(q) * f[l]);
                      a > b && (!k || p <= c) && "undefined" !== typeof p && t.push(p);
                      p > c && (g = !0);
                      p = a;
                    }
                  }
                } else b = this.lin2log(b), c = this.lin2log(c), d = k ? h.getMinorTickInterval() : p.tickInterval, d = D("auto" === d ? null : d, this.minorAutoInterval, p.tickPixelInterval / (k ? 5 : 1) * (c - b) / ((k ? f / h.tickPositions.length : f) || 1)), d = v(d), t = h.getLinearTickPositions(d, b, c).map(this.log2lin), k || (this.minorAutoInterval = d / 5);
                k || (h.tickInterval = d);
                return t;
              };

              c.prototype.lin2log = function (d) {
                return Math.pow(10, d);
              };

              c.prototype.log2lin = function (d) {
                return Math.log(d) / Math.LN10;
              };

              return c;
            }();

            c.Additions = n;
          })(r || (r = {}));

          return r;
        });
        H(f, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [f["Core/Utilities.js"]], function (c) {
          var f = c.erase,
              v = c.extend,
              D = c.isNumber,
              r;

          (function (c) {
            var r = [],
                A;

            c.compose = function (c, k) {
              A || (A = c);
              -1 === r.indexOf(k) && (r.push(k), v(k.prototype, u.prototype));
              return k;
            };

            var u = function () {
              function c() {}

              c.prototype.getPlotBandPath = function (c, d, b) {
                void 0 === b && (b = this.options);
                var h = this.getPlotLinePath({
                  value: d,
                  force: !0,
                  acrossPanes: b.acrossPanes
                }),
                    k = [],
                    f = this.horiz;
                d = !D(this.min) || !D(this.max) || c < this.min && d < this.min || c > this.max && d > this.max;
                c = this.getPlotLinePath({
                  value: c,
                  force: !0,
                  acrossPanes: b.acrossPanes
                });
                b = 1;

                if (c && h) {
                  if (d) {
                    var n = c.toString() === h.toString();
                    b = 0;
                  }

                  for (d = 0; d < c.length; d += 2) {
                    var y = c[d],
                        t = c[d + 1],
                        q = h[d],
                        l = h[d + 1];
                    "M" !== y[0] && "L" !== y[0] || "M" !== t[0] && "L" !== t[0] || "M" !== q[0] && "L" !== q[0] || "M" !== l[0] && "L" !== l[0] || (f && q[1] === y[1] ? (q[1] += b, l[1] += b) : f || q[2] !== y[2] || (q[2] += b, l[2] += b), k.push(["M", y[1], y[2]], ["L", t[1], t[2]], ["L", l[1], l[2]], ["L", q[1], q[2]], ["Z"]));
                    k.isFlat = n;
                  }
                }

                return k;
              };

              c.prototype.addPlotBand = function (c) {
                return this.addPlotBandOrLine(c, "plotBands");
              };

              c.prototype.addPlotLine = function (c) {
                return this.addPlotBandOrLine(c, "plotLines");
              };

              c.prototype.addPlotBandOrLine = function (c, d) {
                var b = this,
                    h = this.userOptions,
                    k = new A(this, c);
                this.visible && (k = k.render());

                if (k) {
                  this._addedPlotLB || (this._addedPlotLB = !0, (h.plotLines || []).concat(h.plotBands || []).forEach(function (d) {
                    b.addPlotBandOrLine(d);
                  }));

                  if (d) {
                    var f = h[d] || [];
                    f.push(c);
                    h[d] = f;
                  }

                  this.plotLinesAndBands.push(k);
                }

                return k;
              };

              c.prototype.removePlotBandOrLine = function (c) {
                var d = this.plotLinesAndBands,
                    b = this.options,
                    h = this.userOptions;

                if (d) {
                  for (var k = d.length; k--;) {
                    d[k].id === c && d[k].destroy();
                  }

                  [b.plotLines || [], h.plotLines || [], b.plotBands || [], h.plotBands || []].forEach(function (b) {
                    for (k = b.length; k--;) {
                      (b[k] || {}).id === c && f(b, b[k]);
                    }
                  });
                }
              };

              c.prototype.removePlotBand = function (c) {
                this.removePlotBandOrLine(c);
              };

              c.prototype.removePlotLine = function (c) {
                this.removePlotBandOrLine(c);
              };

              return c;
            }();
          })(r || (r = {}));

          return r;
        });
        H(f, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [f["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = f.arrayMax,
              I = f.arrayMin,
              r = f.defined,
              C = f.destroyObjectProperties,
              F = f.erase,
              A = f.fireEvent,
              u = f.merge,
              n = f.objectEach,
              k = f.pick;

          f = function () {
            function d(b, d) {
              this.axis = b;
              d && (this.options = d, this.id = d.id);
            }

            d.compose = function (b) {
              return c.compose(d, b);
            };

            d.prototype.render = function () {
              A(this, "render");
              var b = this,
                  d = b.axis,
                  c = d.horiz,
                  f = d.logarithmic,
                  E = b.options,
                  y = E.color,
                  t = k(E.zIndex, 0),
                  q = E.events,
                  l = {},
                  g = d.chart.renderer,
                  w = E.label,
                  a = b.label,
                  B = E.to,
                  e = E.from,
                  G = E.value,
                  m = b.svgElem,
                  x = [],
                  J = r(e) && r(B);
              x = r(G);
              var M = !m,
                  P = {
                "class": "highcharts-plot-" + (J ? "band " : "line ") + (E.className || "")
              },
                  L = J ? "bands" : "lines";
              f && (e = f.log2lin(e), B = f.log2lin(B), G = f.log2lin(G));
              d.chart.styledMode || (x ? (P.stroke = y || "#999999", P["stroke-width"] = k(E.width, 1), E.dashStyle && (P.dashstyle = E.dashStyle)) : J && (P.fill = y || "#e6ebf5", E.borderWidth && (P.stroke = E.borderColor, P["stroke-width"] = E.borderWidth)));
              l.zIndex = t;
              L += "-" + t;
              (f = d.plotLinesAndBandsGroups[L]) || (d.plotLinesAndBandsGroups[L] = f = g.g("plot-" + L).attr(l).add());
              M && (b.svgElem = m = g.path().attr(P).add(f));
              if (x) x = d.getPlotLinePath({
                value: G,
                lineWidth: m.strokeWidth(),
                acrossPanes: E.acrossPanes
              });else if (J) x = d.getPlotBandPath(e, B, E);else return;
              !b.eventsAdded && q && (n(q, function (a, e) {
                m.on(e, function (a) {
                  q[e].apply(b, [a]);
                });
              }), b.eventsAdded = !0);
              (M || !m.d) && x && x.length ? m.attr({
                d: x
              }) : m && (x ? (m.show(), m.animate({
                d: x
              })) : m.d && (m.hide(), a && (b.label = a = a.destroy())));
              w && (r(w.text) || r(w.formatter)) && x && x.length && 0 < d.width && 0 < d.height && !x.isFlat ? (w = u({
                align: c && J && "center",
                x: c ? !J && 4 : 10,
                verticalAlign: !c && J && "middle",
                y: c ? J ? 16 : 10 : J ? 6 : -4,
                rotation: c && !J && 90
              }, w), this.renderLabel(w, x, J, t)) : a && a.hide();
              return b;
            };

            d.prototype.renderLabel = function (b, d, c, k) {
              var h = this.axis,
                  f = h.chart.renderer,
                  p = this.label;
              p || (this.label = p = f.text(this.getLabelText(b), 0, 0, b.useHTML).attr({
                align: b.textAlign || b.align,
                rotation: b.rotation,
                "class": "highcharts-plot-" + (c ? "band" : "line") + "-label " + (b.className || ""),
                zIndex: k
              }).add(), h.chart.styledMode || p.css(u({
                textOverflow: "ellipsis"
              }, b.style)));
              k = d.xBounds || [d[0][1], d[1][1], c ? d[2][1] : d[0][1]];
              d = d.yBounds || [d[0][2], d[1][2], c ? d[2][2] : d[0][2]];
              c = I(k);
              f = I(d);
              p.align(b, !1, {
                x: c,
                y: f,
                width: v(k) - c,
                height: v(d) - f
              });
              p.alignValue && "left" !== p.alignValue || p.css({
                width: (90 === p.rotation ? h.height - (p.alignAttr.y - h.top) : h.width - (p.alignAttr.x - h.left)) + "px"
              });
              p.show(!0);
            };

            d.prototype.getLabelText = function (b) {
              return r(b.formatter) ? b.formatter.call(this) : b.text;
            };

            d.prototype.destroy = function () {
              F(this.axis.plotLinesAndBands, this);
              delete this.axis;
              C(this);
            };

            return d;
          }();

          "";
          "";
          return f;
        });
        H(f, "Core/Tooltip.js", [f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D, r) {
          var C = c.format,
              F = f.doc,
              A = v.distribute,
              u = r.addEvent,
              n = r.clamp,
              k = r.css,
              d = r.defined,
              b = r.discardElement,
              h = r.extend,
              p = r.fireEvent,
              z = r.isArray,
              E = r.isNumber,
              y = r.isString,
              t = r.merge,
              q = r.pick,
              l = r.splat,
              g = r.syncTimeout;

          c = function () {
            function c(a, b) {
              this.allowShared = !0;
              this.container = void 0;
              this.crosshairs = [];
              this.distance = 0;
              this.isHidden = !0;
              this.isSticky = !1;
              this.now = {};
              this.options = {};
              this.outside = !1;
              this.chart = a;
              this.init(a, b);
            }

            c.prototype.applyFilter = function () {
              var a = this.chart;
              a.renderer.definition({
                tagName: "filter",
                attributes: {
                  id: "drop-shadow-" + a.index,
                  opacity: .5
                },
                children: [{
                  tagName: "feGaussianBlur",
                  attributes: {
                    "in": "SourceAlpha",
                    stdDeviation: 1
                  }
                }, {
                  tagName: "feOffset",
                  attributes: {
                    dx: 1,
                    dy: 1
                  }
                }, {
                  tagName: "feComponentTransfer",
                  children: [{
                    tagName: "feFuncA",
                    attributes: {
                      type: "linear",
                      slope: .3
                    }
                  }]
                }, {
                  tagName: "feMerge",
                  children: [{
                    tagName: "feMergeNode"
                  }, {
                    tagName: "feMergeNode",
                    attributes: {
                      "in": "SourceGraphic"
                    }
                  }]
                }]
              });
            };

            c.prototype.bodyFormatter = function (a) {
              return a.map(function (a) {
                var e = a.series.tooltipOptions;
                return (e[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, e[(a.point.formatPrefix || "point") + "Format"] || "");
              });
            };

            c.prototype.cleanSplit = function (a) {
              this.chart.series.forEach(function (b) {
                var e = b && b.tt;
                e && (!e.isActive || a ? b.tt = e.destroy() : e.isActive = !1);
              });
            };

            c.prototype.defaultFormatter = function (a) {
              var b = this.points || l(this);
              var e = [a.tooltipFooterHeaderFormatter(b[0])];
              e = e.concat(a.bodyFormatter(b));
              e.push(a.tooltipFooterHeaderFormatter(b[0], !0));
              return e;
            };

            c.prototype.destroy = function () {
              this.label && (this.label = this.label.destroy());
              this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
              this.renderer && (this.renderer = this.renderer.destroy(), b(this.container));
              r.clearTimeout(this.hideTimer);
              r.clearTimeout(this.tooltipTimeout);
            };

            c.prototype.getAnchor = function (a, b) {
              var e = this.chart,
                  d = e.pointer,
                  g = e.inverted,
                  c = e.plotTop,
                  h = e.plotLeft,
                  k,
                  w,
                  q = 0,
                  B = 0;
              a = l(a);
              this.followPointer && b ? ("undefined" === typeof b.chartX && (b = d.normalize(b)), d = [b.chartX - h, b.chartY - c]) : a[0].tooltipPos ? d = a[0].tooltipPos : (a.forEach(function (a) {
                k = a.series.yAxis;
                w = a.series.xAxis;
                q += a.plotX || 0;
                B += a.plotLow ? (a.plotLow + (a.plotHigh || 0)) / 2 : a.plotY || 0;
                w && k && (g ? (q += c + e.plotHeight - w.len - w.pos, B += h + e.plotWidth - k.len - k.pos) : (q += w.pos - h, B += k.pos - c));
              }), q /= a.length, B /= a.length, d = [g ? e.plotWidth - B : q, g ? e.plotHeight - q : B], this.shared && 1 < a.length && b && (g ? d[0] = b.chartX - h : d[1] = b.chartY - c));
              return d.map(Math.round);
            };

            c.prototype.getLabel = function () {
              var a = this,
                  b = this.chart.styledMode,
                  e = this.options,
                  g = this.split && this.allowShared,
                  c = "tooltip" + (d(e.className) ? " " + e.className : ""),
                  h = e.style.pointerEvents || (!this.followPointer && e.stickOnContact ? "auto" : "none"),
                  l = function l() {
                a.inContact = !0;
              },
                  w = function w(e) {
                var b = a.chart.hoverSeries;
                a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(e.relatedTarget, "highcharts-tooltip");
                if (!a.inContact && b && b.onMouseOut) b.onMouseOut();
              },
                  q,
                  p = this.chart.renderer;

              if (a.label) {
                var t = !a.label.hasClass("highcharts-label");
                (g && !t || !g && t) && a.destroy();
              }

              if (!this.label) {
                if (this.outside) {
                  t = this.chart.options.chart.style;
                  var n = D.getRendererType();
                  this.container = q = f.doc.createElement("div");
                  q.className = "highcharts-tooltip-container";
                  k(q, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: h,
                    zIndex: Math.max(this.options.style.zIndex || 0, (t && t.zIndex || 0) + 3)
                  });
                  u(q, "mouseenter", l);
                  u(q, "mouseleave", w);
                  f.doc.body.appendChild(q);
                  this.renderer = p = new n(q, 0, 0, t, void 0, void 0, p.styledMode);
                }

                g ? this.label = p.g(c) : (this.label = p.label("", 0, 0, e.shape, void 0, void 0, e.useHTML, void 0, c).attr({
                  padding: e.padding,
                  r: e.borderRadius
                }), b || this.label.attr({
                  fill: e.backgroundColor,
                  "stroke-width": e.borderWidth
                }).css(e.style).css({
                  pointerEvents: h
                }).shadow(e.shadow));
                b && e.shadow && (this.applyFilter(), this.label.attr({
                  filter: "url(#drop-shadow-" + this.chart.index + ")"
                }));

                if (a.outside && !a.split) {
                  var z = this.label,
                      y = z.xSetter,
                      E = z.ySetter;

                  z.xSetter = function (e) {
                    y.call(z, a.distance);
                    q.style.left = e + "px";
                  };

                  z.ySetter = function (e) {
                    E.call(z, a.distance);
                    q.style.top = e + "px";
                  };
                }

                this.label.on("mouseenter", l).on("mouseleave", w).attr({
                  zIndex: 8
                }).add();
              }

              return this.label;
            };

            c.prototype.getPosition = function (a, b, e) {
              var d = this.chart,
                  g = this.distance,
                  c = {},
                  h = d.inverted && e.h || 0,
                  l = this.outside,
                  k = l ? F.documentElement.clientWidth - 2 * g : d.chartWidth,
                  w = l ? Math.max(F.body.scrollHeight, F.documentElement.scrollHeight, F.body.offsetHeight, F.documentElement.offsetHeight, F.documentElement.clientHeight) : d.chartHeight,
                  B = d.pointer.getChartPosition(),
                  f = function f(c) {
                var m = "x" === c;
                return [c, m ? k : w, m ? a : b].concat(l ? [m ? a * B.scaleX : b * B.scaleY, m ? B.left - g + (e.plotX + d.plotLeft) * B.scaleX : B.top - g + (e.plotY + d.plotTop) * B.scaleY, 0, m ? k : w] : [m ? a : b, m ? e.plotX + d.plotLeft : e.plotY + d.plotTop, m ? d.plotLeft : d.plotTop, m ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);
              },
                  p = f("y"),
                  t = f("x"),
                  n;

              f = !!e.negative;
              !d.polar && d.hoverSeries && d.hoverSeries.yAxis && d.hoverSeries.yAxis.reversed && (f = !f);

              var z = !this.followPointer && q(e.ttBelow, !d.inverted === f),
                  y = function y(a, e, b, d, m, x, k) {
                var w = l ? "y" === a ? g * B.scaleY : g * B.scaleX : g,
                    q = (b - d) / 2,
                    f = d < m - g,
                    p = m + g + d < e,
                    t = m - w - b + q;
                m = m + w - q;
                if (z && p) c[a] = m;else if (!z && f) c[a] = t;else if (f) c[a] = Math.min(k - d, 0 > t - h ? t : t - h);else if (p) c[a] = Math.max(x, m + h + b > e ? m : m + h);else return !1;
              },
                  E = function E(a, e, b, d, m) {
                var h;
                m < g || m > e - g ? h = !1 : c[a] = m < b / 2 ? 1 : m > e - d / 2 ? e - d - 2 : m - b / 2;
                return h;
              },
                  u = function u(a) {
                var e = p;
                p = t;
                t = e;
                n = a;
              },
                  r = function r() {
                !1 !== y.apply(0, p) ? !1 !== E.apply(0, t) || n || (u(!0), r()) : n ? c.x = c.y = 0 : (u(!0), r());
              };

              (d.inverted || 1 < this.len) && u();
              r();
              return c;
            };

            c.prototype.hide = function (a) {
              var b = this;
              r.clearTimeout(this.hideTimer);
              a = q(a, this.options.hideDelay);
              this.isHidden || (this.hideTimer = g(function () {
                b.getLabel().fadeOut(a ? void 0 : a);
                b.isHidden = !0;
              }, a));
            };

            c.prototype.init = function (a, b) {
              this.chart = a;
              this.options = b;
              this.crosshairs = [];
              this.now = {
                x: 0,
                y: 0
              };
              this.isHidden = !0;
              this.split = b.split && !a.inverted && !a.polar;
              this.shared = b.shared || this.split;
              this.outside = q(b.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));
            };

            c.prototype.shouldStickOnContact = function () {
              return !(this.followPointer || !this.options.stickOnContact);
            };

            c.prototype.isStickyOnContact = function () {
              return !(!this.shouldStickOnContact() || !this.inContact);
            };

            c.prototype.move = function (a, b, e, d) {
              var g = this,
                  c = g.now,
                  l = !1 !== g.options.animation && !g.isHidden && (1 < Math.abs(a - c.x) || 1 < Math.abs(b - c.y)),
                  k = g.followPointer || 1 < g.len;
              h(c, {
                x: l ? (2 * c.x + a) / 3 : a,
                y: l ? (c.y + b) / 2 : b,
                anchorX: k ? void 0 : l ? (2 * c.anchorX + e) / 3 : e,
                anchorY: k ? void 0 : l ? (c.anchorY + d) / 2 : d
              });
              g.getLabel().attr(c);
              g.drawTracker();
              l && (r.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                g && g.move(a, b, e, d);
              }, 32));
            };

            c.prototype.refresh = function (a, b) {
              var e = this.chart,
                  d = this.options,
                  g = l(a),
                  c = g[0],
                  h = [],
                  k = d.formatter || this.defaultFormatter,
                  w = this.shared,
                  f = e.styledMode,
                  B = {};

              if (d.enabled && c.series) {
                r.clearTimeout(this.hideTimer);
                this.allowShared = !(!z(a) && a.series && a.series.noSharedTooltip);
                this.followPointer = !this.split && c.series.tooltipOptions.followPointer;
                a = this.getAnchor(a, b);
                var t = a[0],
                    n = a[1];
                w && this.allowShared ? (e.pointer.applyInactiveState(g), g.forEach(function (a) {
                  a.setState("hover");
                  h.push(a.getLabelConfig());
                }), B = {
                  x: c.category,
                  y: c.y
                }, B.points = h) : B = c.getLabelConfig();
                this.len = h.length;
                k = k.call(B, this);
                w = c.series;
                this.distance = q(w.tooltipOptions.distance, 16);
                if (!1 === k) this.hide();else {
                  if (this.split && this.allowShared) this.renderSplit(k, g);else {
                    var y = t,
                        E = n;
                    b && e.pointer.isDirectTouch && (y = b.chartX - e.plotLeft, E = b.chartY - e.plotTop);
                    if (e.polar || !1 === w.options.clip || g.some(function (a) {
                      return a.series.shouldShowTooltip(y, E);
                    })) b = this.getLabel(), d.style.width && !f || b.css({
                      width: this.chart.spacingBox.width + "px"
                    }), b.attr({
                      text: k && k.join ? k.join("") : k
                    }), b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + q(c.colorIndex, w.colorIndex)), f || b.attr({
                      stroke: d.borderColor || c.color || w.color || "#666666"
                    }), this.updatePosition({
                      plotX: t,
                      plotY: n,
                      negative: c.negative,
                      ttBelow: c.ttBelow,
                      h: a[2] || 0
                    });else {
                      this.hide();
                      return;
                    }
                  }
                  this.isHidden && this.label && this.label.attr({
                    opacity: 1
                  }).show();
                  this.isHidden = !1;
                }
                p(this, "refresh");
              }
            };

            c.prototype.renderSplit = function (a, b) {
              function e(a, e, b, g, c) {
                void 0 === c && (c = !0);
                b ? (e = W ? 0 : H, a = n(a - g / 2, Q.left, Q.right - g - (d.outside ? O : 0))) : (e -= ca, a = c ? a - g - C : a + C, a = n(a, c ? a : Q.left, Q.right));
                return {
                  x: a,
                  y: e
                };
              }

              var d = this,
                  g = d.chart,
                  c = d.chart,
                  l = c.chartWidth,
                  k = c.chartHeight,
                  w = c.plotHeight,
                  f = c.plotLeft,
                  B = c.plotTop,
                  p = c.pointer,
                  t = c.scrollablePixelsY;
              t = void 0 === t ? 0 : t;
              var z = c.scrollablePixelsX,
                  E = c.scrollingContainer;
              E = void 0 === E ? {
                scrollLeft: 0,
                scrollTop: 0
              } : E;
              var u = E.scrollLeft;
              E = E.scrollTop;
              var r = c.styledMode,
                  C = d.distance,
                  R = d.options,
                  v = d.options.positioner,
                  Q = d.outside && "number" !== typeof z ? F.documentElement.getBoundingClientRect() : {
                left: u,
                right: u + l,
                top: E,
                bottom: E + k
              },
                  I = d.getLabel(),
                  D = this.renderer || g.renderer,
                  W = !(!g.xAxis[0] || !g.xAxis[0].opposite);
              g = p.getChartPosition();
              var O = g.left;
              g = g.top;
              var ca = B + E,
                  da = 0,
                  H = w - t;
              y(a) && (a = [!1, a]);
              a = a.slice(0, b.length + 1).reduce(function (a, g, c) {
                if (!1 !== g && "" !== g) {
                  c = b[c - 1] || {
                    isHeader: !0,
                    plotX: b[0].plotX,
                    plotY: w,
                    series: {}
                  };
                  var m = c.isHeader,
                      h = m ? d : c.series;
                  g = g.toString();
                  var l = h.tt,
                      k = c.isHeader;
                  var x = c.series;
                  var p = "highcharts-color-" + q(c.colorIndex, x.colorIndex, "none");
                  l || (l = {
                    padding: R.padding,
                    r: R.borderRadius
                  }, r || (l.fill = R.backgroundColor, l["stroke-width"] = R.borderWidth), l = D.label("", 0, 0, R[k ? "headerShape" : "shape"], void 0, void 0, R.useHTML).addClass((k ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + p).attr(l).add(I));
                  l.isActive = !0;
                  l.attr({
                    text: g
                  });
                  r || l.css(R.style).shadow(R.shadow).attr({
                    stroke: R.borderColor || c.color || x.color || "#333333"
                  });
                  h = h.tt = l;
                  k = h.getBBox();
                  g = k.width + h.strokeWidth();
                  m && (da = k.height, H += da, W && (ca -= da));
                  x = c.plotX;
                  x = void 0 === x ? 0 : x;
                  p = c.plotY;
                  p = void 0 === p ? 0 : p;
                  l = c.series;

                  if (c.isHeader) {
                    x = f + x;
                    var t = B + w / 2;
                  } else {
                    var G = l.xAxis,
                        z = l.yAxis;
                    x = G.pos + n(x, -C, G.len + C);
                    l.shouldShowTooltip(0, z.pos - B + p, {
                      ignoreX: !0
                    }) && (t = z.pos + p);
                  }

                  x = n(x, Q.left - C, Q.right + C);
                  "number" === typeof t ? (k = k.height + 1, p = v ? v.call(d, g, k, c) : e(x, t, m, g), a.push({
                    align: v ? 0 : void 0,
                    anchorX: x,
                    anchorY: t,
                    boxWidth: g,
                    point: c,
                    rank: q(p.rank, m ? 1 : 0),
                    size: k,
                    target: p.y,
                    tt: h,
                    x: p.x
                  })) : h.isActive = !1;
                }

                return a;
              }, []);
              !v && a.some(function (a) {
                var e = (d.outside ? O : 0) + a.anchorX;
                return e < Q.left && e + a.boxWidth < Q.right ? !0 : e < O - Q.left + a.boxWidth && Q.right - e > e;
              }) && (a = a.map(function (a) {
                var b = e(a.anchorX, a.anchorY, a.point.isHeader, a.boxWidth, !1);
                return h(a, {
                  target: b.y,
                  x: b.x
                });
              }));
              d.cleanSplit();
              A(a, H);
              var aa = O,
                  ea = O;
              a.forEach(function (a) {
                var e = a.x,
                    b = a.boxWidth;
                a = a.isHeader;
                a || (d.outside && O + e < aa && (aa = O + e), !a && d.outside && aa + b > ea && (ea = O + e));
              });
              a.forEach(function (a) {
                var e = a.x,
                    b = a.anchorX,
                    g = a.pos,
                    c = a.point.isHeader;
                g = {
                  visibility: "undefined" === typeof g ? "hidden" : "inherit",
                  x: e,
                  y: g + ca,
                  anchorX: b,
                  anchorY: a.anchorY
                };

                if (d.outside && e < b) {
                  var m = O - aa;
                  0 < m && (c || (g.x = e + m, g.anchorX = b + m), c && (g.x = (ea - aa) / 2, g.anchorX = b + m));
                }

                a.tt.attr(g);
              });
              a = d.container;
              t = d.renderer;
              d.outside && a && t && (c = I.getBBox(), t.setSize(c.width + c.x, c.height + c.y, !1), a.style.left = aa + "px", a.style.top = g + "px");
            };

            c.prototype.drawTracker = function () {
              if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
                var a = this.chart,
                    b = this.label,
                    e = this.shared ? a.hoverPoints : a.hoverPoint;

                if (b && e) {
                  var d = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                  e = this.getAnchor(e);
                  var g = b.getBBox();
                  e[0] += a.plotLeft - b.translateX;
                  e[1] += a.plotTop - b.translateY;
                  d.x = Math.min(0, e[0]);
                  d.y = Math.min(0, e[1]);
                  d.width = 0 > e[0] ? Math.max(Math.abs(e[0]), g.width - e[0]) : Math.max(Math.abs(e[0]), g.width);
                  d.height = 0 > e[1] ? Math.max(Math.abs(e[1]), g.height - Math.abs(e[1])) : Math.max(Math.abs(e[1]), g.height);
                  this.tracker ? this.tracker.attr(d) : (this.tracker = b.renderer.rect(d).addClass("highcharts-tracker").add(b), a.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                  }));
                }
              }
            };

            c.prototype.styledModeFormat = function (a) {
              return a.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };

            c.prototype.tooltipFooterHeaderFormatter = function (a, b) {
              var e = a.series,
                  d = e.tooltipOptions,
                  g = e.xAxis,
                  c = g && g.dateTime;
              g = {
                isFooter: b,
                labelConfig: a
              };
              var h = d.xDateFormat,
                  l = d[b ? "footerFormat" : "headerFormat"];
              p(this, "headerFormatter", g, function (b) {
                c && !h && E(a.key) && (h = c.getXDateFormat(a.key, d.dateTimeLabelFormats));
                c && h && (a.point && a.point.tooltipDateKeys || ["key"]).forEach(function (a) {
                  l = l.replace("{point." + a + "}", "{point." + a + ":" + h + "}");
                });
                e.chart.styledMode && (l = this.styledModeFormat(l));
                b.text = C(l, {
                  point: a,
                  series: e
                }, this.chart);
              });
              return g.text;
            };

            c.prototype.update = function (a) {
              this.destroy();
              t(!0, this.chart.options.tooltip.userOptions, a);
              this.init(this.chart, t(!0, this.options, a));
            };

            c.prototype.updatePosition = function (a) {
              var b = this.chart,
                  e = this.options,
                  d = b.pointer,
                  g = this.getLabel();
              d = d.getChartPosition();
              var c = (e.positioner || this.getPosition).call(this, g.width, g.height, a),
                  h = a.plotX + b.plotLeft;
              a = a.plotY + b.plotTop;

              if (this.outside) {
                e = e.borderWidth + 2 * this.distance;
                this.renderer.setSize(g.width + e, g.height + e, !1);
                if (1 !== d.scaleX || 1 !== d.scaleY) k(this.container, {
                  transform: "scale(".concat(d.scaleX, ", ").concat(d.scaleY, ")")
                }), h *= d.scaleX, a *= d.scaleY;
                h += d.left - c.x;
                a += d.top - c.y;
              }

              this.move(Math.round(c.x), Math.round(c.y || 0), h, a);
            };

            return c;
          }();

          "";
          return c;
        });
        H(f, "Core/Series/Point.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Animation/AnimationUtilities.js"], f["Core/DefaultOptions.js"], f["Core/FormatUtilities.js"], f["Core/Utilities.js"]], function (c, f, v, D, r) {
          var C = f.animObject,
              F = v.defaultOptions,
              A = D.format,
              u = r.addEvent,
              n = r.defined,
              k = r.erase,
              d = r.extend,
              b = r.fireEvent,
              h = r.getNestedProperty,
              p = r.isArray,
              z = r.isFunction,
              E = r.isNumber,
              y = r.isObject,
              t = r.merge,
              q = r.objectEach,
              l = r.pick,
              g = r.syncTimeout,
              w = r.removeEvent,
              a = r.uniqueKey;

          f = function () {
            function f() {
              this.colorIndex = this.category = void 0;
              this.formatPrefix = "point";
              this.id = void 0;
              this.isNull = !1;
              this.percentage = this.options = this.name = void 0;
              this.selected = !1;
              this.total = this.shapeArgs = this.series = void 0;
              this.visible = !0;
              this.x = void 0;
            }

            f.prototype.animateBeforeDestroy = function () {
              var a = this,
                  b = {
                x: a.startXPos,
                opacity: 0
              },
                  g = a.getGraphicalProps();
              g.singular.forEach(function (e) {
                a[e] = a[e].animate("dataLabel" === e ? {
                  x: a[e].startXPos,
                  y: a[e].startYPos,
                  opacity: 0
                } : b);
              });
              g.plural.forEach(function (e) {
                a[e].forEach(function (e) {
                  e.element && e.animate(d({
                    x: a.startXPos
                  }, e.startYPos ? {
                    x: e.startXPos,
                    y: e.startYPos
                  } : {}));
                });
              });
            };

            f.prototype.applyOptions = function (a, b) {
              var e = this.series,
                  g = e.options.pointValKey || e.pointValKey;
              a = f.prototype.optionsToObject.call(this, a);
              d(this, a);
              this.options = this.options ? d(this.options, a) : a;
              a.group && delete this.group;
              a.dataLabels && delete this.dataLabels;
              g && (this.y = f.prototype.getNestedProperty.call(this, g));
              this.formatPrefix = (this.isNull = l(this.isValid && !this.isValid(), null === this.x || !E(this.y))) ? "null" : "point";
              this.selected && (this.state = "select");
              "name" in this && "undefined" === typeof b && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));
              "undefined" === typeof this.x && e ? this.x = "undefined" === typeof b ? e.autoIncrement() : b : E(a.x) && e.options.relativeXValue && (this.x = e.autoIncrement(a.x));
              return this;
            };

            f.prototype.destroy = function () {
              function a() {
                if (b.graphic || b.dataLabel || b.dataLabels) w(b), b.destroyElements();

                for (f in b) {
                  b[f] = null;
                }
              }

              var b = this,
                  d = b.series,
                  c = d.chart;
              d = d.options.dataSorting;
              var h = c.hoverPoints,
                  l = C(b.series.chart.renderer.globalAnimation),
                  f;
              b.legendItem && c.legend.destroyItem(b);
              h && (b.setState(), k(h, b), h.length || (c.hoverPoints = null));
              if (b === c.hoverPoint) b.onMouseOut();
              d && d.enabled ? (this.animateBeforeDestroy(), g(a, l.duration)) : a();
              c.pointCount--;
            };

            f.prototype.destroyElements = function (a) {
              var e = this;
              a = e.getGraphicalProps(a);
              a.singular.forEach(function (a) {
                e[a] = e[a].destroy();
              });
              a.plural.forEach(function (a) {
                e[a].forEach(function (a) {
                  a.element && a.destroy();
                });
                delete e[a];
              });
            };

            f.prototype.firePointEvent = function (a, d, g) {
              var e = this,
                  c = this.series.options;
              (c.point.events[a] || e.options && e.options.events && e.options.events[a]) && e.importEvents();
              "click" === a && c.allowPointSelect && (g = function g(a) {
                e.select && e.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
              });
              b(e, a, d, g);
            };

            f.prototype.getClassName = function () {
              return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };

            f.prototype.getGraphicalProps = function (a) {
              var e = this,
                  b = [],
                  d = {
                singular: [],
                plural: []
              },
                  g;
              a = a || {
                graphic: 1,
                dataLabel: 1
              };
              a.graphic && b.push("graphic", "upperGraphic", "shadowGroup");
              a.dataLabel && b.push("dataLabel", "dataLabelUpper", "connector");

              for (g = b.length; g--;) {
                var c = b[g];
                e[c] && d.singular.push(c);
              }

              ["dataLabel", "connector"].forEach(function (b) {
                var g = b + "s";
                a[b] && e[g] && d.plural.push(g);
              });
              return d;
            };

            f.prototype.getLabelConfig = function () {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
              };
            };

            f.prototype.getNestedProperty = function (a) {
              if (a) return 0 === a.indexOf("custom.") ? h(a, this.options) : this[a];
            };

            f.prototype.getZone = function () {
              var a = this.series,
                  b = a.zones;
              a = a.zoneAxis || "y";
              var d,
                  g = 0;

              for (d = b[g]; this[a] >= d.value;) {
                d = b[++g];
              }

              this.nonZonedColor || (this.nonZonedColor = this.color);
              this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;
              return d;
            };

            f.prototype.hasNewShapeType = function () {
              return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };

            f.prototype.init = function (e, d, g) {
              this.series = e;
              this.applyOptions(d, g);
              this.id = n(this.id) ? this.id : a();
              this.resolveColor();
              e.chart.pointCount++;
              b(this, "afterInit");
              return this;
            };

            f.prototype.optionsToObject = function (a) {
              var e = this.series,
                  b = e.options.keys,
                  d = b || e.pointArrayMap || ["y"],
                  g = d.length,
                  c = {},
                  h = 0,
                  l = 0;
              if (E(a) || null === a) c[d[0]] = a;else if (p(a)) for (!b && a.length > g && (e = typeof a[0], "string" === e ? c.name = a[0] : "number" === e && (c.x = a[0]), h++); l < g;) {
                b && "undefined" === typeof a[h] || (0 < d[l].indexOf(".") ? f.prototype.setNestedProperty(c, a[h], d[l]) : c[d[l]] = a[h]), h++, l++;
              } else "object" === typeof a && (c = a, a.dataLabels && (e._hasPointLabels = !0), a.marker && (e._hasPointMarkers = !0));
              return c;
            };

            f.prototype.resolveColor = function () {
              var a = this.series,
                  b = a.chart.styledMode;
              var d = a.chart.options.chart.colorCount;
              delete this.nonZonedColor;

              if (a.options.colorByPoint) {
                if (!b) {
                  d = a.options.colors || a.chart.options.colors;
                  var g = d[a.colorCounter];
                  d = d.length;
                }

                b = a.colorCounter;
                a.colorCounter++;
                a.colorCounter === d && (a.colorCounter = 0);
              } else b || (g = a.color), b = a.colorIndex;

              this.colorIndex = l(this.options.colorIndex, b);
              this.color = l(this.options.color, g);
            };

            f.prototype.setNestedProperty = function (a, b, d) {
              d.split(".").reduce(function (a, e, d, g) {
                a[e] = g.length - 1 === d ? b : y(a[e], !0) ? a[e] : {};
                return a[e];
              }, a);
              return a;
            };

            f.prototype.tooltipFormatter = function (a) {
              var e = this.series,
                  b = e.tooltipOptions,
                  d = l(b.valueDecimals, ""),
                  g = b.valuePrefix || "",
                  c = b.valueSuffix || "";
              e.chart.styledMode && (a = e.chart.tooltip.styledModeFormat(a));
              (e.pointArrayMap || ["y"]).forEach(function (e) {
                e = "{point." + e;
                if (g || c) a = a.replace(RegExp(e + "}", "g"), g + e + "}" + c);
                a = a.replace(RegExp(e + "}", "g"), e + ":,." + d + "f}");
              });
              return A(a, {
                point: this,
                series: this.series
              }, e.chart);
            };

            f.prototype.update = function (a, b, d, g) {
              function e() {
                c.applyOptions(a);
                var e = h && c.hasDummyGraphic;
                e = null === c.y ? !e : e;
                h && e && (c.graphic = h.destroy(), delete c.hasDummyGraphic);
                y(a, !0) && (h && h.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (c.graphic = h.destroy()), a && a.dataLabels && c.dataLabel && (c.dataLabel = c.dataLabel.destroy()), c.connector && (c.connector = c.connector.destroy()));
                f = c.index;
                m.updateParallelArrays(c, f);
                w.data[f] = y(w.data[f], !0) || y(a, !0) ? c.options : l(a, w.data[f]);
                m.isDirty = m.isDirtyData = !0;
                !m.fixedBox && m.hasCartesianSeries && (k.isDirtyBox = !0);
                "point" === w.legendType && (k.isDirtyLegend = !0);
                b && k.redraw(d);
              }

              var c = this,
                  m = c.series,
                  h = c.graphic,
                  k = m.chart,
                  w = m.options,
                  f;
              b = l(b, !0);
              !1 === g ? e() : c.firePointEvent("update", {
                options: a
              }, e);
            };

            f.prototype.remove = function (a, b) {
              this.series.removePoint(this.series.data.indexOf(this), a, b);
            };

            f.prototype.select = function (a, b) {
              var e = this,
                  d = e.series,
                  g = d.chart;
              this.selectedStaging = a = l(a, !e.selected);
              e.firePointEvent(a ? "select" : "unselect", {
                accumulate: b
              }, function () {
                e.selected = e.options.selected = a;
                d.options.data[d.data.indexOf(e)] = e.options;
                e.setState(a && "select");
                b || g.getSelectedPoints().forEach(function (a) {
                  var b = a.series;
                  a.selected && a !== e && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options, a.setState(g.hoverPoints && b.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
                });
              });
              delete this.selectedStaging;
            };

            f.prototype.onMouseOver = function (a) {
              var e = this.series.chart,
                  b = e.pointer;
              a = a ? b.normalize(a) : b.getChartCoordinatesFromPoint(this, e.inverted);
              b.runPointActions(a, this);
            };

            f.prototype.onMouseOut = function () {
              var a = this.series.chart;
              this.firePointEvent("mouseOut");
              this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {
                a.setState();
              });
              a.hoverPoints = a.hoverPoint = null;
            };

            f.prototype.importEvents = function () {
              if (!this.hasImportedEvents) {
                var a = this,
                    b = t(a.series.options.point, a.options).events;
                a.events = b;
                q(b, function (e, b) {
                  z(e) && u(a, b, e);
                });
                this.hasImportedEvents = !0;
              }
            };

            f.prototype.setState = function (a, g) {
              var e = this.series,
                  h = this.state,
                  k = e.options.states[a || "normal"] || {},
                  w = F.plotOptions[e.type].marker && e.options.marker,
                  f = w && !1 === w.enabled,
                  q = w && w.states && w.states[a || "normal"] || {},
                  p = !1 === q.enabled,
                  B = this.marker || {},
                  t = e.chart,
                  n = w && e.markerAttribs,
                  z = e.halo,
                  y,
                  G = e.stateMarkerGraphic;
              a = a || "";

              if (!(a === this.state && !g || this.selected && "select" !== a || !1 === k.enabled || a && (p || f && !1 === q.enabled) || a && B.states && B.states[a] && !1 === B.states[a].enabled)) {
                this.state = a;
                n && (y = e.markerAttribs(this, a));

                if (this.graphic && !this.hasDummyGraphic) {
                  h && this.graphic.removeClass("highcharts-point-" + h);
                  a && this.graphic.addClass("highcharts-point-" + a);

                  if (!t.styledMode) {
                    var u = e.pointAttribs(this, a);
                    var R = l(t.options.chart.animation, k.animation);
                    e.options.inactiveOtherPoints && E(u.opacity) && ((this.dataLabels || []).forEach(function (a) {
                      a && a.animate({
                        opacity: u.opacity
                      }, R);
                    }), this.connector && this.connector.animate({
                      opacity: u.opacity
                    }, R));
                    this.graphic.animate(u, R);
                  }

                  y && this.graphic.animate(y, l(t.options.chart.animation, q.animation, w.animation));
                  G && G.hide();
                } else {
                  if (a && q) {
                    h = B.symbol || e.symbol;
                    G && G.currentSymbol !== h && (G = G.destroy());
                    if (y) if (G) G[g ? "animate" : "attr"]({
                      x: y.x,
                      y: y.y
                    });else h && (e.stateMarkerGraphic = G = t.renderer.symbol(h, y.x, y.y, y.width, y.height).add(e.markerGroup), G.currentSymbol = h);
                    !t.styledMode && G && "inactive" !== this.state && G.attr(e.pointAttribs(this, a));
                  }

                  G && (G[a && this.isInside ? "show" : "hide"](), G.element.point = this, G.addClass(this.getClassName(), !0));
                }

                k = k.halo;
                y = (G = this.graphic || G) && G.visibility || "inherit";
                k && k.size && G && "hidden" !== y && !this.isCluster ? (z || (e.halo = z = t.renderer.path().add(G.parentGroup)), z.show()[g ? "animate" : "attr"]({
                  d: this.haloPath(k.size)
                }), z.attr({
                  "class": "highcharts-halo highcharts-color-" + l(this.colorIndex, e.colorIndex) + (this.className ? " " + this.className : ""),
                  visibility: y,
                  zIndex: -1
                }), z.point = this, t.styledMode || z.attr(d({
                  fill: this.color || e.color,
                  "fill-opacity": k.opacity
                }, c.filterUserAttributes(k.attributes || {})))) : z && z.point && z.point.haloPath && z.animate({
                  d: z.point.haloPath(0)
                }, null, z.hide);
                b(this, "afterSetState", {
                  state: a
                });
              }
            };

            f.prototype.haloPath = function (a) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
            };

            return f;
          }();

          "";
          return f;
        });
        H(f, "Core/Pointer.js", [f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Tooltip.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = c.parse,
              C = f.charts,
              F = f.noop,
              A = D.addEvent,
              u = D.attr,
              n = D.css,
              k = D.defined,
              d = D.extend,
              b = D.find,
              h = D.fireEvent,
              p = D.isNumber,
              z = D.isObject,
              E = D.objectEach,
              y = D.offset,
              t = D.pick,
              q = D.splat;

          c = function () {
            function c(b, d) {
              this.lastValidTouch = {};
              this.pinchDown = [];
              this.runChartClick = !1;
              this.eventsToUnbind = [];
              this.chart = b;
              this.hasDragged = !1;
              this.options = d;
              this.init(b, d);
            }

            c.prototype.applyInactiveState = function (b) {
              var d = [],
                  a;
              (b || []).forEach(function (b) {
                a = b.series;
                d.push(a);
                a.linkedParent && d.push(a.linkedParent);
                a.linkedSeries && (d = d.concat(a.linkedSeries));
                a.navigatorSeries && d.push(a.navigatorSeries);
              });
              this.chart.series.forEach(function (a) {
                -1 === d.indexOf(a) ? a.setState("inactive", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState("inactive");
              });
            };

            c.prototype.destroy = function () {
              var b = this;
              this.eventsToUnbind.forEach(function (b) {
                return b();
              });
              this.eventsToUnbind = [];
              f.chartCount || (c.unbindDocumentMouseUp && (c.unbindDocumentMouseUp = c.unbindDocumentMouseUp()), c.unbindDocumentTouchEnd && (c.unbindDocumentTouchEnd = c.unbindDocumentTouchEnd()));
              clearInterval(b.tooltipTimeout);
              E(b, function (d, a) {
                b[a] = void 0;
              });
            };

            c.prototype.drag = function (b) {
              var d = this.chart,
                  a = d.options.chart,
                  c = this.zoomHor,
                  e = this.zoomVert,
                  g = d.plotLeft,
                  h = d.plotTop,
                  l = d.plotWidth,
                  k = d.plotHeight,
                  f = this.mouseDownX || 0,
                  q = this.mouseDownY || 0,
                  p = z(a.panning) ? a.panning && a.panning.enabled : a.panning,
                  t = a.panKey && b[a.panKey + "Key"],
                  n = b.chartX,
                  y = b.chartY,
                  E = this.selectionMarker;
              if (!E || !E.touch) if (n < g ? n = g : n > g + l && (n = g + l), y < h ? y = h : y > h + k && (y = h + k), this.hasDragged = Math.sqrt(Math.pow(f - n, 2) + Math.pow(q - y, 2)), 10 < this.hasDragged) {
                var u = d.isInsidePlot(f - g, q - h, {
                  visiblePlotOnly: !0
                });
                !d.hasCartesianSeries && !d.mapView || !this.zoomX && !this.zoomY || !u || t || E || (this.selectionMarker = E = d.renderer.rect(g, h, c ? 1 : l, e ? 1 : k, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add(), d.styledMode || E.attr({
                  fill: a.selectionMarkerFill || r("#335cad").setOpacity(.25).get()
                }));
                E && c && (c = n - f, E.attr({
                  width: Math.abs(c),
                  x: (0 < c ? 0 : c) + f
                }));
                E && e && (c = y - q, E.attr({
                  height: Math.abs(c),
                  y: (0 < c ? 0 : c) + q
                }));
                u && !E && p && d.pan(b, a.panning);
              }
            };

            c.prototype.dragStart = function (b) {
              var d = this.chart;
              d.mouseIsDown = b.type;
              d.cancelClick = !1;
              d.mouseDownX = this.mouseDownX = b.chartX;
              d.mouseDownY = this.mouseDownY = b.chartY;
            };

            c.prototype.drop = function (b) {
              var c = this,
                  a = this.chart,
                  g = this.hasPinched;

              if (this.selectionMarker) {
                var e = this.selectionMarker,
                    l = e.attr ? e.attr("x") : e.x,
                    m = e.attr ? e.attr("y") : e.y,
                    f = e.attr ? e.attr("width") : e.width,
                    q = e.attr ? e.attr("height") : e.height,
                    t = {
                  originalEvent: b,
                  xAxis: [],
                  yAxis: [],
                  x: l,
                  y: m,
                  width: f,
                  height: q
                },
                    z = !!a.mapView;
                if (this.hasDragged || g) a.axes.forEach(function (a) {
                  if (a.zoomEnabled && k(a.min) && (g || c[{
                    xAxis: "zoomX",
                    yAxis: "zoomY"
                  }[a.coll]]) && p(l) && p(m)) {
                    var e = a.horiz,
                        d = "touchend" === b.type ? a.minPixelPadding : 0,
                        h = a.toValue((e ? l : m) + d);
                    e = a.toValue((e ? l + f : m + q) - d);
                    t[a.coll].push({
                      axis: a,
                      min: Math.min(h, e),
                      max: Math.max(h, e)
                    });
                    z = !0;
                  }
                }), z && h(a, "selection", t, function (e) {
                  a.zoom(d(e, g ? {
                    animation: !1
                  } : null));
                });
                p(a.index) && (this.selectionMarker = this.selectionMarker.destroy());
                g && this.scaleGroups();
              }

              a && p(a.index) && (n(a.container, {
                cursor: a._cursor
              }), a.cancelClick = 10 < this.hasDragged, a.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
            };

            c.prototype.findNearestKDPoint = function (b, d, a) {
              var c = this.chart,
                  e = c.hoverPoint;
              c = c.tooltip;
              if (e && c && c.isStickyOnContact()) return e;
              var g;
              b.forEach(function (e) {
                var b = !(e.noSharedTooltip && d) && 0 > e.options.findNearestPointBy.indexOf("y");
                e = e.searchPoint(a, b);

                if ((b = z(e, !0) && e.series) && !(b = !z(g, !0))) {
                  b = g.distX - e.distX;
                  var c = g.dist - e.dist,
                      h = (e.series.group && e.series.group.zIndex) - (g.series.group && g.series.group.zIndex);
                  b = 0 < (0 !== b && d ? b : 0 !== c ? c : 0 !== h ? h : g.series.index > e.series.index ? -1 : 1);
                }

                b && (g = e);
              });
              return g;
            };

            c.prototype.getChartCoordinatesFromPoint = function (b, d) {
              var a = b.series,
                  c = a.xAxis;
              a = a.yAxis;
              var e = b.shapeArgs;

              if (c && a) {
                var g = t(b.clientX, b.plotX),
                    h = b.plotY || 0;
                b.isNode && e && p(e.x) && p(e.y) && (g = e.x, h = e.y);
                return d ? {
                  chartX: a.len + a.pos - h,
                  chartY: c.len + c.pos - g
                } : {
                  chartX: g + c.pos,
                  chartY: h + a.pos
                };
              }

              if (e && e.x && e.y) return {
                chartX: e.x,
                chartY: e.y
              };
            };

            c.prototype.getChartPosition = function () {
              if (this.chartPosition) return this.chartPosition;
              var b = this.chart.container,
                  d = y(b);
              this.chartPosition = {
                left: d.left,
                top: d.top,
                scaleX: 1,
                scaleY: 1
              };
              var a = b.offsetWidth;
              b = b.offsetHeight;
              2 < a && 2 < b && (this.chartPosition.scaleX = d.width / a, this.chartPosition.scaleY = d.height / b);
              return this.chartPosition;
            };

            c.prototype.getCoordinates = function (b) {
              var d = {
                xAxis: [],
                yAxis: []
              };
              this.chart.axes.forEach(function (a) {
                d[a.isXAxis ? "xAxis" : "yAxis"].push({
                  axis: a,
                  value: a.toValue(b[a.horiz ? "chartX" : "chartY"])
                });
              });
              return d;
            };

            c.prototype.getHoverData = function (d, c, a, l, e, k) {
              var g = [];
              l = !(!l || !d);
              var f = {
                chartX: k ? k.chartX : void 0,
                chartY: k ? k.chartY : void 0,
                shared: e
              };
              h(this, "beforeGetHoverData", f);
              var q = c && !c.stickyTracking ? [c] : a.filter(function (a) {
                return f.filter ? f.filter(a) : a.visible && !(!e && a.directTouch) && t(a.options.enableMouseTracking, !0) && a.stickyTracking;
              });
              var w = l || !k ? d : this.findNearestKDPoint(q, e, k);
              c = w && w.series;
              w && (e && !c.noSharedTooltip ? (q = a.filter(function (a) {
                return f.filter ? f.filter(a) : a.visible && !(!e && a.directTouch) && t(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
              }), q.forEach(function (a) {
                var e = b(a.points, function (a) {
                  return a.x === w.x && !a.isNull;
                });
                z(e) && (a.chart.isBoosting && (e = a.getPoint(e)), g.push(e));
              })) : g.push(w));
              f = {
                hoverPoint: w
              };
              h(this, "afterGetHoverData", f);
              return {
                hoverPoint: f.hoverPoint,
                hoverSeries: c,
                hoverPoints: g
              };
            };

            c.prototype.getPointFromEvent = function (b) {
              b = b.target;

              for (var d; b && !d;) {
                d = b.point, b = b.parentNode;
              }

              return d;
            };

            c.prototype.onTrackerMouseOut = function (b) {
              b = b.relatedTarget || b.toElement;
              var d = this.chart.hoverSeries;
              this.isDirectTouch = !1;
              if (!(!d || !b || d.stickyTracking || this.inClass(b, "highcharts-tooltip") || this.inClass(b, "highcharts-series-" + d.index) && this.inClass(b, "highcharts-tracker"))) d.onMouseOut();
            };

            c.prototype.inClass = function (b, d) {
              for (var a; b;) {
                if (a = u(b, "class")) {
                  if (-1 !== a.indexOf(d)) return !0;
                  if (-1 !== a.indexOf("highcharts-container")) return !1;
                }

                b = b.parentElement;
              }
            };

            c.prototype.init = function (b, d) {
              this.options = d;
              this.chart = b;
              this.runChartClick = !(!d.chart.events || !d.chart.events.click);
              this.pinchDown = [];
              this.lastValidTouch = {};
              v && (b.tooltip = new v(b, d.tooltip), this.followTouchMove = t(d.tooltip.followTouchMove, !0));
              this.setDOMEvents();
            };

            c.prototype.normalize = function (b, c) {
              var a = b.touches,
                  g = a ? a.length ? a.item(0) : t(a.changedTouches, b.changedTouches)[0] : b;
              c || (c = this.getChartPosition());
              a = g.pageX - c.left;
              g = g.pageY - c.top;
              a /= c.scaleX;
              g /= c.scaleY;
              return d(b, {
                chartX: Math.round(a),
                chartY: Math.round(g)
              });
            };

            c.prototype.onContainerClick = function (b) {
              var c = this.chart,
                  a = c.hoverPoint;
              b = this.normalize(b);
              var g = c.plotLeft,
                  e = c.plotTop;
              c.cancelClick || (a && this.inClass(b.target, "highcharts-tracker") ? (h(a.series, "click", d(b, {
                point: a
              })), c.hoverPoint && a.firePointEvent("click", b)) : (d(b, this.getCoordinates(b)), c.isInsidePlot(b.chartX - g, b.chartY - e, {
                visiblePlotOnly: !0
              }) && h(c, "click", b)));
            };

            c.prototype.onContainerMouseDown = function (b) {
              var d = 1 === ((b.buttons || b.button) & 1);
              b = this.normalize(b);
              if (f.isFirefox && 0 !== b.button) this.onContainerMouseMove(b);
              if ("undefined" === typeof b.button || d) this.zoomOption(b), d && b.preventDefault && b.preventDefault(), this.dragStart(b);
            };

            c.prototype.onContainerMouseLeave = function (b) {
              var d = C[t(c.hoverChartIndex, -1)],
                  a = this.chart.tooltip;
              a && a.shouldStickOnContact() && this.inClass(b.relatedTarget, "highcharts-tooltip-container") || (b = this.normalize(b), d && (b.relatedTarget || b.toElement) && (d.pointer.reset(), d.pointer.chartPosition = void 0), a && !a.isHidden && this.reset());
            };

            c.prototype.onContainerMouseEnter = function (b) {
              delete this.chartPosition;
            };

            c.prototype.onContainerMouseMove = function (b) {
              var d = this.chart;
              b = this.normalize(b);
              this.setHoverChartIndex();
              b.preventDefault || (b.returnValue = !1);
              ("mousedown" === d.mouseIsDown || this.touchSelect(b)) && this.drag(b);
              d.openMenu || !this.inClass(b.target, "highcharts-tracker") && !d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop, {
                visiblePlotOnly: !0
              }) || (this.inClass(b.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(b));
            };

            c.prototype.onDocumentTouchEnd = function (b) {
              var d = C[t(c.hoverChartIndex, -1)];
              d && d.pointer.drop(b);
            };

            c.prototype.onContainerTouchMove = function (b) {
              if (this.touchSelect(b)) this.onContainerMouseMove(b);else this.touch(b);
            };

            c.prototype.onContainerTouchStart = function (b) {
              if (this.touchSelect(b)) this.onContainerMouseDown(b);else this.zoomOption(b), this.touch(b, !0);
            };

            c.prototype.onDocumentMouseMove = function (b) {
              var d = this.chart,
                  a = this.chartPosition;
              b = this.normalize(b, a);
              var c = d.tooltip;
              !a || c && c.isStickyOnContact() || d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop, {
                visiblePlotOnly: !0
              }) || this.inClass(b.target, "highcharts-tracker") || this.reset();
            };

            c.prototype.onDocumentMouseUp = function (b) {
              var d = C[t(c.hoverChartIndex, -1)];
              d && d.pointer.drop(b);
            };

            c.prototype.pinch = function (b) {
              var c = this,
                  a = c.chart,
                  g = c.pinchDown,
                  e = b.touches || [],
                  l = e.length,
                  m = c.lastValidTouch,
                  k = c.hasZoom,
                  f = {},
                  q = 1 === l && (c.inClass(b.target, "highcharts-tracker") && a.runTrackerClick || c.runChartClick),
                  p = {},
                  n = c.selectionMarker;
              1 < l ? c.initiated = !0 : 1 === l && this.followTouchMove && (c.initiated = !1);
              k && c.initiated && !q && !1 !== b.cancelable && b.preventDefault();
              [].map.call(e, function (a) {
                return c.normalize(a);
              });
              "touchstart" === b.type ? ([].forEach.call(e, function (a, e) {
                g[e] = {
                  chartX: a.chartX,
                  chartY: a.chartY
                };
              }), m.x = [g[0].chartX, g[1] && g[1].chartX], m.y = [g[0].chartY, g[1] && g[1].chartY], a.axes.forEach(function (e) {
                if (e.zoomEnabled) {
                  var b = a.bounds[e.horiz ? "h" : "v"],
                      d = e.minPixelPadding,
                      c = e.toPixels(Math.min(t(e.options.min, e.dataMin), e.dataMin)),
                      g = e.toPixels(Math.max(t(e.options.max, e.dataMax), e.dataMax)),
                      h = Math.max(c, g);
                  b.min = Math.min(e.pos, Math.min(c, g) - d);
                  b.max = Math.max(e.pos + e.len, h + d);
                }
              }), c.res = !0) : c.followTouchMove && 1 === l ? this.runPointActions(c.normalize(b)) : g.length && (h(a, "touchpan", {
                originalEvent: b
              }, function () {
                n || (c.selectionMarker = n = d({
                  destroy: F,
                  touch: !0
                }, a.plotBox));
                c.pinchTranslate(g, e, f, n, p, m);
                c.hasPinched = k;
                c.scaleGroups(f, p);
              }), c.res && (c.res = !1, this.reset(!1, 0)));
            };

            c.prototype.pinchTranslate = function (b, d, a, c, e, h) {
              this.zoomHor && this.pinchTranslateDirection(!0, b, d, a, c, e, h);
              this.zoomVert && this.pinchTranslateDirection(!1, b, d, a, c, e, h);
            };

            c.prototype.pinchTranslateDirection = function (b, d, a, c, e, h, m, l) {
              var g = this.chart,
                  k = b ? "x" : "y",
                  f = b ? "X" : "Y",
                  q = "chart" + f,
                  x = b ? "width" : "height",
                  p = g["plot" + (b ? "Left" : "Top")],
                  t = g.inverted,
                  w = g.bounds[b ? "h" : "v"],
                  B = 1 === d.length,
                  n = d[0][q],
                  z = !B && d[1][q];

              d = function d() {
                "number" === typeof r && 20 < Math.abs(n - z) && (G = l || Math.abs(u - r) / Math.abs(n - z));
                E = (p - u) / G + n;
                y = g["plot" + (b ? "Width" : "Height")] / G;
              };

              var y,
                  E,
                  G = l || 1,
                  u = a[0][q],
                  r = !B && a[1][q];
              d();
              a = E;

              if (a < w.min) {
                a = w.min;
                var A = !0;
              } else a + y > w.max && (a = w.max - y, A = !0);

              A ? (u -= .8 * (u - m[k][0]), "number" === typeof r && (r -= .8 * (r - m[k][1])), d()) : m[k] = [u, r];
              t || (h[k] = E - p, h[x] = y);
              h = t ? 1 / G : G;
              e[x] = y;
              e[k] = a;
              c[t ? b ? "scaleY" : "scaleX" : "scale" + f] = G;
              c["translate" + f] = h * p + (u - h * n);
            };

            c.prototype.reset = function (b, d) {
              var a = this.chart,
                  c = a.hoverSeries,
                  e = a.hoverPoint,
                  g = a.hoverPoints,
                  h = a.tooltip,
                  l = h && h.shared ? g : e;
              b && l && q(l).forEach(function (a) {
                a.series.isCartesian && "undefined" === typeof a.plotX && (b = !1);
              });
              if (b) h && l && q(l).length && (h.refresh(l), h.shared && g ? g.forEach(function (a) {
                a.setState(a.state, !0);
                a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
              }) : e && (e.setState(e.state, !0), a.axes.forEach(function (a) {
                a.crosshair && e.series[a.coll] === a && a.drawCrosshair(null, e);
              })));else {
                if (e) e.onMouseOut();
                g && g.forEach(function (a) {
                  a.setState();
                });
                if (c) c.onMouseOut();
                h && h.hide(d);
                this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                a.axes.forEach(function (a) {
                  a.hideCrosshair();
                });
                this.hoverX = a.hoverPoints = a.hoverPoint = null;
              }
            };

            c.prototype.runPointActions = function (d, h) {
              var a = this.chart,
                  g = a.tooltip && a.tooltip.options.enabled ? a.tooltip : void 0,
                  e = g ? g.shared : !1,
                  l = h || a.hoverPoint,
                  m = l && l.series || a.hoverSeries;
              h = this.getHoverData(l, m, a.series, (!d || "touchmove" !== d.type) && (!!h || m && m.directTouch && this.isDirectTouch), e, d);
              l = h.hoverPoint;
              m = h.hoverSeries;
              var k = h.hoverPoints;
              h = m && m.tooltipOptions.followPointer && !m.tooltipOptions.split;
              var f = e && m && !m.noSharedTooltip;

              if (l && (l !== a.hoverPoint || g && g.isHidden)) {
                (a.hoverPoints || []).forEach(function (a) {
                  -1 === k.indexOf(a) && a.setState();
                });
                if (a.hoverSeries !== m) m.onMouseOver();
                this.applyInactiveState(k);
                (k || []).forEach(function (a) {
                  a.setState("hover");
                });
                a.hoverPoint && a.hoverPoint.firePointEvent("mouseOut");
                if (!l.series) return;
                a.hoverPoints = k;
                a.hoverPoint = l;
                l.firePointEvent("mouseOver", void 0, function () {
                  g && l && g.refresh(f ? k : l, d);
                });
              } else h && g && !g.isHidden && (e = g.getAnchor([{}], d), a.isInsidePlot(e[0], e[1], {
                visiblePlotOnly: !0
              }) && g.updatePosition({
                plotX: e[0],
                plotY: e[1]
              }));

              this.unDocMouseMove || (this.unDocMouseMove = A(a.container.ownerDocument, "mousemove", function (a) {
                var e = C[c.hoverChartIndex];
                if (e) e.pointer.onDocumentMouseMove(a);
              }), this.eventsToUnbind.push(this.unDocMouseMove));
              a.axes.forEach(function (e) {
                var c = t((e.crosshair || {}).snap, !0),
                    g;
                c && ((g = a.hoverPoint) && g.series[e.coll] === e || (g = b(k, function (a) {
                  return a.series && a.series[e.coll] === e;
                })));
                g || !c ? e.drawCrosshair(d, g) : e.hideCrosshair();
              });
            };

            c.prototype.scaleGroups = function (b, d) {
              var a = this.chart;
              a.series.forEach(function (c) {
                var e = b || c.getPlotBox();
                c.group && (c.xAxis && c.xAxis.zoomEnabled || a.mapView) && (c.group.attr(e), c.markerGroup && (c.markerGroup.attr(e), c.markerGroup.clip(d ? a.clipRect : null)), c.dataLabelsGroup && c.dataLabelsGroup.attr(e));
              });
              a.clipRect.attr(d || a.clipBox);
            };

            c.prototype.setDOMEvents = function () {
              var b = this,
                  d = this.chart.container,
                  a = d.ownerDocument;
              d.onmousedown = this.onContainerMouseDown.bind(this);
              d.onmousemove = this.onContainerMouseMove.bind(this);
              d.onclick = this.onContainerClick.bind(this);
              this.eventsToUnbind.push(A(d, "mouseenter", this.onContainerMouseEnter.bind(this)));
              this.eventsToUnbind.push(A(d, "mouseleave", this.onContainerMouseLeave.bind(this)));
              c.unbindDocumentMouseUp || (c.unbindDocumentMouseUp = A(a, "mouseup", this.onDocumentMouseUp.bind(this)));

              for (var h = this.chart.renderTo.parentElement; h && "BODY" !== h.tagName;) {
                this.eventsToUnbind.push(A(h, "scroll", function () {
                  delete b.chartPosition;
                })), h = h.parentElement;
              }

              f.hasTouch && (this.eventsToUnbind.push(A(d, "touchstart", this.onContainerTouchStart.bind(this), {
                passive: !1
              })), this.eventsToUnbind.push(A(d, "touchmove", this.onContainerTouchMove.bind(this), {
                passive: !1
              })), c.unbindDocumentTouchEnd || (c.unbindDocumentTouchEnd = A(a, "touchend", this.onDocumentTouchEnd.bind(this), {
                passive: !1
              })));
            };

            c.prototype.setHoverChartIndex = function () {
              var b = this.chart,
                  d = f.charts[t(c.hoverChartIndex, -1)];
              if (d && d !== b) d.pointer.onContainerMouseLeave({
                relatedTarget: b.container
              });
              d && d.mouseIsDown || (c.hoverChartIndex = b.index);
            };

            c.prototype.touch = function (b, d) {
              var a = this.chart,
                  c;
              this.setHoverChartIndex();
              if (1 === b.touches.length) {
                if (b = this.normalize(b), (c = a.isInsidePlot(b.chartX - a.plotLeft, b.chartY - a.plotTop, {
                  visiblePlotOnly: !0
                })) && !a.openMenu) {
                  d && this.runPointActions(b);

                  if ("touchmove" === b.type) {
                    d = this.pinchDown;
                    var e = d[0] ? 4 <= Math.sqrt(Math.pow(d[0].chartX - b.chartX, 2) + Math.pow(d[0].chartY - b.chartY, 2)) : !1;
                  }

                  t(e, !0) && this.pinch(b);
                } else d && this.reset();
              } else 2 === b.touches.length && this.pinch(b);
            };

            c.prototype.touchSelect = function (b) {
              return !(!this.chart.options.chart.zoomBySingleTouch || !b.touches || 1 !== b.touches.length);
            };

            c.prototype.zoomOption = function (b) {
              var d = this.chart,
                  a = d.options.chart;
              d = d.inverted;
              var c = a.zoomType || "";
              /touch/.test(b.type) && (c = t(a.pinchType, c));
              this.zoomX = b = /x/.test(c);
              this.zoomY = a = /y/.test(c);
              this.zoomHor = b && !d || a && d;
              this.zoomVert = a && !d || b && d;
              this.hasZoom = b || a;
            };

            return c;
          }();

          "";
          return c;
        });
        H(f, "Core/MSPointer.js", [f["Core/Globals.js"], f["Core/Pointer.js"], f["Core/Utilities.js"]], function (c, f, v) {
          function D() {
            var d = [];

            d.item = function (b) {
              return this[b];
            };

            b(p, function (b) {
              d.push({
                pageX: b.pageX,
                pageY: b.pageY,
                target: b.target
              });
            });
            return d;
          }

          function r(b, d, c, h) {
            var l = F[f.hoverChartIndex || NaN];
            "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !l || (l = l.pointer, h(b), l[d]({
              type: c,
              target: b.currentTarget,
              preventDefault: u,
              touches: D()
            }));
          }

          var C = this && this.__extends || function () {
            var _b8 = function b(d, c) {
              _b8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, d) {
                b.__proto__ = d;
              } || function (b, d) {
                for (var c in d) {
                  d.hasOwnProperty(c) && (b[c] = d[c]);
                }
              };

              return _b8(d, c);
            };

            return function (d, c) {
              function h() {
                this.constructor = d;
              }

              _b8(d, c);

              d.prototype = null === c ? Object.create(c) : (h.prototype = c.prototype, new h());
            };
          }(),
              F = c.charts,
              A = c.doc,
              u = c.noop,
              n = c.win,
              k = v.addEvent,
              d = v.css,
              b = v.objectEach,
              h = v.removeEvent,
              p = {},
              z = !!n.PointerEvent;

          return function (b) {
            function f() {
              return null !== b && b.apply(this, arguments) || this;
            }

            C(f, b);

            f.isRequired = function () {
              return !(c.hasTouch || !n.PointerEvent && !n.MSPointerEvent);
            };

            f.prototype.batchMSEvents = function (b) {
              b(this.chart.container, z ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              b(this.chart.container, z ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              b(A, z ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };

            f.prototype.destroy = function () {
              this.batchMSEvents(h);
              b.prototype.destroy.call(this);
            };

            f.prototype.init = function (c, h) {
              b.prototype.init.call(this, c, h);
              this.hasZoom && d(c.container, {
                "-ms-touch-action": "none",
                "touch-action": "none"
              });
            };

            f.prototype.onContainerPointerDown = function (b) {
              r(b, "onContainerTouchStart", "touchstart", function (b) {
                p[b.pointerId] = {
                  pageX: b.pageX,
                  pageY: b.pageY,
                  target: b.currentTarget
                };
              });
            };

            f.prototype.onContainerPointerMove = function (b) {
              r(b, "onContainerTouchMove", "touchmove", function (b) {
                p[b.pointerId] = {
                  pageX: b.pageX,
                  pageY: b.pageY
                };
                p[b.pointerId].target || (p[b.pointerId].target = b.currentTarget);
              });
            };

            f.prototype.onDocumentPointerUp = function (b) {
              r(b, "onDocumentTouchEnd", "touchend", function (b) {
                delete p[b.pointerId];
              });
            };

            f.prototype.setDOMEvents = function () {
              b.prototype.setDOMEvents.call(this);
              (this.hasZoom || this.followTouchMove) && this.batchMSEvents(k);
            };

            return f;
          }(f);
        });
        H(f, "Core/Legend/Legend.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Series/Point.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C) {
          var F = c.animObject,
              A = c.setAnimation,
              u = f.format;
          c = v.isFirefox;
          var n = v.marginNames;
          v = v.win;
          var k = r.distribute,
              d = C.addEvent,
              b = C.createElement,
              h = C.css,
              p = C.defined,
              z = C.discardElement,
              E = C.find,
              y = C.fireEvent,
              t = C.isNumber,
              q = C.merge,
              l = C.pick,
              g = C.relativeLength,
              w = C.stableSort,
              a = C.syncTimeout;
          r = C.wrap;

          C = function () {
            function c(a, b) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = !1;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = void 0;
              this.padding = 0;
              this.pages = [];
              this.proximate = !1;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = a;
              this.init(a, b);
            }

            c.prototype.init = function (a, b) {
              this.chart = a;
              this.setOptions(b);
              b.enabled && (this.render(), d(this.chart, "endResize", function () {
                this.legend.positionCheckboxes();
              }), this.proximate ? this.unchartrender = d(this.chart, "render", function () {
                this.legend.proximatePositions();
                this.legend.positionItems();
              }) : this.unchartrender && this.unchartrender());
            };

            c.prototype.setOptions = function (a) {
              var b = l(a.padding, 8);
              this.options = a;
              this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = q(this.itemStyle, a.itemHiddenStyle));
              this.itemMarginTop = a.itemMarginTop || 0;
              this.itemMarginBottom = a.itemMarginBottom || 0;
              this.padding = b;
              this.initialItemY = b - 5;
              this.symbolWidth = l(a.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === a.layout && !this.chart.inverted;
              this.baseline = void 0;
            };

            c.prototype.update = function (a, b) {
              var e = this.chart;
              this.setOptions(q(!0, this.options, a));
              this.destroy();
              e.isDirtyLegend = e.isDirtyBox = !0;
              l(b, !0) && e.redraw();
              y(this, "afterUpdate");
            };

            c.prototype.colorizeItem = function (a, b) {
              a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

              if (!this.chart.styledMode) {
                var e = this.options,
                    d = a.legendItem,
                    c = a.legendLine,
                    g = a.legendSymbol,
                    h = this.itemHiddenStyle.color;
                e = b ? e.itemStyle.color : h;
                var l = b ? a.color || h : h,
                    k = a.options && a.options.marker,
                    f = {
                  fill: l
                };
                d && d.css({
                  fill: e,
                  color: e
                });
                c && c.attr({
                  stroke: l
                });
                g && (k && g.isMarker && (f = a.pointAttribs(), b || (f.stroke = f.fill = h)), g.attr(f));
              }

              y(this, "afterColorizeItem", {
                item: a,
                visible: b
              });
            };

            c.prototype.positionItems = function () {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            };

            c.prototype.positionItem = function (a) {
              var b = this,
                  e = this.options,
                  d = e.symbolPadding,
                  c = !e.rtl,
                  g = a._legendItemPos;
              e = g[0];
              g = g[1];
              var h = a.checkbox,
                  l = a.legendGroup;
              l && l.element && (d = {
                translateX: c ? e : this.legendWidth - e - 2 * d - 4,
                translateY: g
              }, c = function c() {
                y(b, "afterPositionItem", {
                  item: a
                });
              }, p(l.translateY) ? l.animate(d, void 0, c) : (l.attr(d), c()));
              h && (h.x = e, h.y = g);
            };

            c.prototype.destroyItem = function (a) {
              var b = a.checkbox;
              ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (b) {
                a[b] && (a[b] = a[b].destroy());
              });
              b && z(a.checkbox);
            };

            c.prototype.destroy = function () {
              function a(a) {
                this[a] && (this[a] = this[a].destroy());
              }

              this.getAllItems().forEach(function (b) {
                ["legendItem", "legendGroup"].forEach(a, b);
              });
              "clipRect up down pager nav box title group".split(" ").forEach(a, this);
              this.display = null;
            };

            c.prototype.positionCheckboxes = function () {
              var a = this.group && this.group.alignAttr,
                  b = this.clipHeight || this.legendHeight,
                  d = this.titleHeight;

              if (a) {
                var c = a.translateY;
                this.allItems.forEach(function (e) {
                  var g = e.checkbox;

                  if (g) {
                    var l = c + d + g.y + (this.scrollOffset || 0) + 3;
                    h(g, {
                      left: a.translateX + e.checkboxOffset + g.x - 20 + "px",
                      top: l + "px",
                      display: this.proximate || l > c - 6 && l < c + b - 6 ? "" : "none"
                    });
                  }
                }, this);
              }
            };

            c.prototype.renderTitle = function () {
              var a = this.options,
                  b = this.padding,
                  d = a.title,
                  c = 0;
              d.text && (this.title || (this.title = this.chart.renderer.label(d.text, b - 3, b - 4, void 0, void 0, void 0, a.useHTML, void 0, "legend-title").attr({
                zIndex: 1
              }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({
                width: this.maxLegendWidth + "px"
              }), a = this.title.getBBox(), c = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
                translateY: c
              }));
              this.titleHeight = c;
            };

            c.prototype.setText = function (a) {
              var b = this.options;
              a.legendItem.attr({
                text: b.labelFormat ? u(b.labelFormat, a, this.chart) : b.labelFormatter.call(a)
              });
            };

            c.prototype.renderItem = function (a) {
              var b = this.chart,
                  e = b.renderer,
                  d = this.options,
                  c = this.symbolWidth,
                  g = d.symbolPadding || 0,
                  h = this.itemStyle,
                  k = this.itemHiddenStyle,
                  f = "horizontal" === d.layout ? l(d.itemDistance, 20) : 0,
                  p = !d.rtl,
                  t = !a.series,
                  w = !t && a.series.drawLegendSymbol ? a.series : a,
                  n = w.options,
                  z = this.createCheckboxForItem && n && n.showCheckbox,
                  B = d.useHTML,
                  y = a.options.className,
                  E = a.legendItem;
              n = c + g + f + (z ? 20 : 0);
              E || (a.legendGroup = e.g("legend-item").addClass("highcharts-" + w.type + "-series highcharts-color-" + a.colorIndex + (y ? " " + y : "") + (t ? " highcharts-series-" + a.index : "")).attr({
                zIndex: 1
              }).add(this.scrollGroup), a.legendItem = E = e.text("", p ? c + g : -g, this.baseline || 0, B), b.styledMode || E.css(q(a.visible ? h : k)), E.attr({
                align: p ? "left" : "right",
                zIndex: 2
              }).add(a.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(b.styledMode ? 12 : h.fontSize, E), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, E.attr("y", this.baseline), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, d.squareSymbol && (this.symbolWidth = l(d.symbolWidth, Math.max(this.symbolHeight, 16)), n = this.symbolWidth + g + f + (z ? 20 : 0), p && E.attr("x", this.symbolWidth + g))), w.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, E, B));
              z && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);
              this.colorizeItem(a, a.visible);
              !b.styledMode && h.width || E.css({
                width: (d.itemWidth || this.widthOption || b.spacingBox.width) - n + "px"
              });
              this.setText(a);
              b = E.getBBox();
              e = this.fontMetrics && this.fontMetrics.h || 0;
              a.itemWidth = a.checkboxOffset = d.itemWidth || a.legendItemWidth || b.width + n;
              this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
              this.totalItemWidth += a.itemWidth;
              this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || (b.height > 1.5 * e ? b.height : e));
            };

            c.prototype.layoutItem = function (a) {
              var b = this.options,
                  e = this.padding,
                  d = "horizontal" === b.layout,
                  c = a.itemHeight,
                  g = this.itemMarginBottom,
                  h = this.itemMarginTop,
                  k = d ? l(b.itemDistance, 20) : 0,
                  f = this.maxLegendWidth;
              b = b.alignColumns && this.totalItemWidth > f ? this.maxItemWidth : a.itemWidth;
              d && this.itemX - e + b > f && (this.itemX = e, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + g), this.lastLineHeight = 0);
              this.lastItemY = h + this.itemY + g;
              this.lastLineHeight = Math.max(c, this.lastLineHeight);
              a._legendItemPos = [this.itemX, this.itemY];
              d ? this.itemX += b : (this.itemY += h + c + g, this.lastLineHeight = c);
              this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - e - (a.checkbox ? 0 : k) : b) + e, this.offsetWidth);
            };

            c.prototype.getAllItems = function () {
              var a = [];
              this.chart.series.forEach(function (b) {
                var e = b && b.options;
                b && l(e.showInLegend, p(e.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === e.legendType ? b.data : b)));
              });
              y(this, "afterGetAllItems", {
                allItems: a
              });
              return a;
            };

            c.prototype.getAlignment = function () {
              var a = this.options;
              return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
            };

            c.prototype.adjustMargins = function (a, b) {
              var e = this.chart,
                  d = this.options,
                  c = this.getAlignment();
              c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, h) {
                g.test(c) && !p(a[h]) && (e[n[h]] = Math.max(e[n[h]], e.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * d[h % 2 ? "x" : "y"] + l(d.margin, 12) + b[h] + (e.titleOffset[h] || 0)));
              });
            };

            c.prototype.proximatePositions = function () {
              var a = this.chart,
                  b = [],
                  d = "left" === this.options.align;
              this.allItems.forEach(function (e) {
                var c;
                var g = d;

                if (e.yAxis) {
                  e.xAxis.options.reversed && (g = !g);
                  e.points && (c = E(g ? e.points : e.points.slice(0).reverse(), function (a) {
                    return t(a.plotY);
                  }));
                  g = this.itemMarginTop + e.legendItem.getBBox().height + this.itemMarginBottom;
                  var h = e.yAxis.top - a.plotTop;
                  e.visible ? (c = c ? c.plotY : e.yAxis.height, c += h - .3 * g) : c = h + e.yAxis.height;
                  b.push({
                    target: c,
                    size: g,
                    item: e
                  });
                }
              }, this);
              k(b, a.plotHeight).forEach(function (b) {
                b.item._legendItemPos && b.pos && (b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos);
              });
            };

            c.prototype.render = function () {
              var a = this.chart,
                  b = a.renderer,
                  d = this.options,
                  c = this.padding,
                  h = this.getAllItems(),
                  l = this.group,
                  k = this.box;
              this.itemX = c;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = g(d.width, a.spacingBox.width - c);
              var f = a.spacingBox.width - 2 * c - d.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (f /= 2);
              this.maxLegendWidth = this.widthOption || f;
              l || (this.group = l = b.g("legend").addClass(d.className || "").attr({
                zIndex: 7
              }).add(), this.contentGroup = b.g().attr({
                zIndex: 1
              }).add(l), this.scrollGroup = b.g().add(this.contentGroup));
              this.renderTitle();
              w(h, function (a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
              });
              d.reversed && h.reverse();
              this.allItems = h;
              this.display = f = !!h.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              h.forEach(this.renderItem, this);
              h.forEach(this.layoutItem, this);
              h = (this.widthOption || this.offsetWidth) + c;
              var q = this.lastItemY + this.lastLineHeight + this.titleHeight;
              q = this.handleOverflow(q);
              q += c;
              k || (this.box = k = b.rect().addClass("highcharts-legend-box").attr({
                r: d.borderRadius
              }).add(l));
              a.styledMode || k.attr({
                stroke: d.borderColor,
                "stroke-width": d.borderWidth || 0,
                fill: d.backgroundColor || "none"
              }).shadow(d.shadow);
              if (0 < h && 0 < q) k[k.placed ? "animate" : "attr"](k.crisp.call({}, {
                x: 0,
                y: 0,
                width: h,
                height: q
              }, k.strokeWidth()));
              l[f ? "show" : "hide"]();
              a.styledMode && "none" === l.getStyle("display") && (h = q = 0);
              this.legendWidth = h;
              this.legendHeight = q;
              f && this.align();
              this.proximate || this.positionItems();
              y(this, "afterRender");
            };

            c.prototype.align = function (a) {
              void 0 === a && (a = this.chart.spacingBox);
              var b = this.chart,
                  e = this.options,
                  d = a.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? d += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (d -= b.titleOffset[2]);
              d !== a.y && (a = q(a, {
                y: d
              }));
              b.hasRendered || (this.group.placed = !1);
              this.group.align(q(e, {
                width: this.legendWidth,
                height: this.legendHeight,
                verticalAlign: this.proximate ? "top" : e.verticalAlign
              }), !0, a);
            };

            c.prototype.handleOverflow = function (a) {
              var b = this,
                  e = this.chart,
                  d = e.renderer,
                  c = this.options,
                  g = c.y,
                  h = "top" === c.verticalAlign,
                  k = this.padding,
                  f = c.maxHeight,
                  q = c.navigation,
                  p = l(q.animation, !0),
                  t = q.arrowSize || 12,
                  n = this.pages,
                  w = this.allItems,
                  z = function z(a) {
                "number" === typeof a ? r.attr({
                  height: a
                }) : r && (b.clipRect = r.destroy(), b.contentGroup.clip());
                b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + k + "px,9999px," + (k + a) + "px,0)" : "auto");
              },
                  B = function B(a) {
                b[a] = d.circle(0, 0, 1.3 * t).translate(t / 2, t / 2).add(u);
                e.styledMode || b[a].attr("fill", "rgba(0,0,0,0.0001)");
                return b[a];
              },
                  y,
                  E;

              g = e.spacingBox.height + (h ? -g : g) - k;
              var u = this.nav,
                  r = this.clipRect;
              "horizontal" !== c.layout || "middle" === c.verticalAlign || c.floating || (g /= 2);
              f && (g = Math.min(g, f));
              n.length = 0;
              a && 0 < g && a > g && !1 !== q.enabled ? (this.clipHeight = y = Math.max(g - 20 - this.titleHeight - k, 0), this.currentPage = l(this.currentPage, 1), this.fullHeight = a, w.forEach(function (a, b) {
                var e = a._legendItemPos[1],
                    d = Math.round(a.legendItem.getBBox().height),
                    c = n.length;
                if (!c || e - n[c - 1] > y && (E || e) !== n[c - 1]) n.push(E || e), c++;
                a.pageIx = c - 1;
                E && (w[b - 1].pageIx = c - 1);
                b === w.length - 1 && e + d - n[c - 1] > y && d <= y && (n.push(e), a.pageIx = c);
                e !== E && (E = e);
              }), r || (r = b.clipRect = d.clipRect(0, k, 9999, 0), b.contentGroup.clip(r)), z(y), u || (this.nav = u = d.g().attr({
                zIndex: 1
              }).add(this.group), this.up = d.symbol("triangle", 0, 0, t, t).add(u), B("upTracker").on("click", function () {
                b.scroll(-1, p);
              }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), !e.styledMode && q.style && this.pager.css(q.style), this.pager.add(u), this.down = d.symbol("triangle-down", 0, 0, t, t).add(u), B("downTracker").on("click", function () {
                b.scroll(1, p);
              })), b.scroll(0), a = g) : u && (z(), this.nav = u.destroy(), this.scrollGroup.attr({
                translateY: 1
              }), this.clipHeight = 0);
              return a;
            };

            c.prototype.scroll = function (b, d) {
              var e = this,
                  c = this.chart,
                  g = this.pages,
                  h = g.length,
                  k = this.clipHeight,
                  f = this.options.navigation,
                  q = this.pager,
                  p = this.padding,
                  t = this.currentPage + b;
              t > h && (t = h);
              0 < t && ("undefined" !== typeof d && A(d, c), this.nav.attr({
                translateX: p,
                translateY: k + this.padding + 7 + this.titleHeight,
                visibility: "inherit"
              }), [this.up, this.upTracker].forEach(function (a) {
                a.attr({
                  "class": 1 === t ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }), q.attr({
                text: t + "/" + h
              }), [this.down, this.downTracker].forEach(function (a) {
                a.attr({
                  x: 18 + this.pager.getBBox().width,
                  "class": t === h ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }, this), c.styledMode || (this.up.attr({
                fill: 1 === t ? f.inactiveColor : f.activeColor
              }), this.upTracker.css({
                cursor: 1 === t ? "default" : "pointer"
              }), this.down.attr({
                fill: t === h ? f.inactiveColor : f.activeColor
              }), this.downTracker.css({
                cursor: t === h ? "default" : "pointer"
              })), this.scrollOffset = -g[t - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: this.scrollOffset
              }), this.currentPage = t, this.positionCheckboxes(), b = F(l(d, c.renderer.globalAnimation, !0)), a(function () {
                y(e, "afterScroll", {
                  currentPage: t
                });
              }, b.duration));
            };

            c.prototype.setItemEvents = function (a, b, d) {
              var e = this,
                  c = e.chart.renderer.boxWrapper,
                  g = a instanceof D,
                  h = "highcharts-legend-" + (g ? "point" : "series") + "-active",
                  l = e.chart.styledMode,
                  m = function m(b) {
                e.allItems.forEach(function (e) {
                  a !== e && [e].concat(e.linkedSeries || []).forEach(function (a) {
                    a.setState(b, !g);
                  });
                });
              };

              (d ? [b, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {
                if (d) d.on("mouseover", function () {
                  a.visible && m("inactive");
                  a.setState("hover");
                  a.visible && c.addClass(h);
                  l || b.css(e.options.itemHoverStyle);
                }).on("mouseout", function () {
                  e.chart.styledMode || b.css(q(a.visible ? e.itemStyle : e.itemHiddenStyle));
                  m("");
                  c.removeClass(h);
                  a.setState();
                }).on("click", function (b) {
                  var e = function e() {
                    a.setVisible && a.setVisible();
                    m(a.visible ? "inactive" : "");
                  };

                  c.removeClass(h);
                  b = {
                    browserEvent: b
                  };
                  a.firePointEvent ? a.firePointEvent("legendItemClick", b, e) : y(a, "legendItemClick", b, e);
                });
              });
            };

            c.prototype.createCheckboxForItem = function (a) {
              a.checkbox = b("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: a.selected,
                defaultChecked: a.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              d(a.checkbox, "click", function (b) {
                y(a.series || a, "checkboxClick", {
                  checked: b.target.checked,
                  item: a
                }, function () {
                  a.select();
                });
              });
            };

            return c;
          }();

          (/Trident\/7\.0/.test(v.navigator && v.navigator.userAgent) || c) && r(C.prototype, "positionItem", function (a, b) {
            var d = this,
                e = function e() {
              b._legendItemPos && a.call(d, b);
            };

            e();
            d.bubbleLegend || setTimeout(e);
          });
          "";
          return C;
        });
        H(f, "Core/Series/SeriesRegistry.js", [f["Core/Globals.js"], f["Core/DefaultOptions.js"], f["Core/Series/Point.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = f.defaultOptions,
              C = D.error,
              F = D.extendClass,
              A = D.merge,
              u;

          (function (f) {
            function k(d, b) {
              var c = r.plotOptions || {},
                  k = b.defaultOptions;
              b.prototype.pointClass || (b.prototype.pointClass = v);
              b.prototype.type = d;
              k && (c[d] = k);
              f.seriesTypes[d] = b;
            }

            f.seriesTypes = c.seriesTypes;

            f.getSeries = function (d, b) {
              void 0 === b && (b = {});
              var c = d.options.chart;
              c = b.type || c.type || c.defaultSeriesType || "";
              var k = f.seriesTypes[c];
              f || C(17, !0, d, {
                missingModuleFor: c
              });
              c = new k();
              "function" === typeof c.init && c.init(d, b);
              return c;
            };

            f.registerSeriesType = k;

            f.seriesType = function (d, b, c, p, n) {
              var h = r.plotOptions || {};
              b = b || "";
              h[d] = A(h[b], c);
              k(d, F(f.seriesTypes[b] || function () {}, p));
              f.seriesTypes[d].prototype.type = d;
              n && (f.seriesTypes[d].prototype.pointClass = F(v, n));
              return f.seriesTypes[d];
            };
          })(u || (u = {}));

          return u;
        });
        H(f, "Core/Chart/Chart.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/FormatUtilities.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Legend/Legend.js"], f["Core/MSPointer.js"], f["Core/DefaultOptions.js"], f["Core/Pointer.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Time.js"], f["Core/Utilities.js"], f["Core/Renderer/HTML/AST.js"]], function (c, f, v, D, r, C, F, A, u, n, k, d, b, h, p) {
          var z = c.animate,
              E = c.animObject,
              y = c.setAnimation,
              t = v.numberFormat,
              q = D.registerEventOptions,
              l = r.charts,
              g = r.doc,
              w = r.marginNames,
              a = r.svg,
              B = r.win,
              e = A.defaultOptions,
              G = A.defaultTime,
              m = k.seriesTypes,
              x = h.addEvent,
              J = h.attr,
              M = h.cleanRecursively,
              I = h.createElement,
              L = h.css,
              U = h.defined,
              X = h.discardElement,
              H = h.erase,
              K = h.error,
              ba = h.extend,
              fa = h.find,
              N = h.fireEvent,
              ha = h.getStyle,
              R = h.isArray,
              Z = h.isNumber,
              Q = h.isObject,
              T = h.isString,
              S = h.merge,
              W = h.objectEach,
              O = h.pick,
              ca = h.pInt,
              da = h.relativeLength,
              ia = h.removeEvent,
              aa = h.splat,
              ea = h.syncTimeout,
              ja = h.uniqueKey;

          c = function () {
            function c(a, b, d) {
              this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
              this.sharedClips = {};
              this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
              this.getArgs(a, b, d);
            }

            c.chart = function (a, b, d) {
              return new c(a, b, d);
            };

            c.prototype.getArgs = function (a, b, d) {
              T(a) || a.nodeName ? (this.renderTo = a, this.init(b, d)) : this.init(a, b);
            };

            c.prototype.init = function (a, d) {
              var c = a.plotOptions || {};
              N(this, "init", {
                args: arguments
              }, function () {
                var g = S(e, a),
                    h = g.chart;
                W(g.plotOptions, function (a, b) {
                  Q(a) && (a.tooltip = c[b] && S(c[b].tooltip) || void 0);
                });
                g.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;
                this.userOptions = a;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                  h: {},
                  v: {}
                };
                this.labelCollectors = [];
                this.callback = d;
                this.isResizing = 0;
                this.options = g;
                this.axes = [];
                this.series = [];
                this.time = a.time && Object.keys(a.time).length ? new b(a.time) : r.time;
                this.numberFormatter = h.numberFormatter || t;
                this.styledMode = h.styledMode;
                this.hasCartesianSeries = h.showAxes;
                this.index = l.length;
                l.push(this);
                r.chartCount++;
                q(this, h);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                N(this, "afterInit");
                this.firstRender();
              });
            };

            c.prototype.initSeries = function (a) {
              var b = this.options.chart;
              b = a.type || b.type || b.defaultSeriesType;
              var d = m[b];
              d || K(17, !0, this, {
                missingModuleFor: b
              });
              b = new d();
              "function" === typeof b.init && b.init(this, a);
              return b;
            };

            c.prototype.setSeriesData = function () {
              this.getSeriesOrderByLinks().forEach(function (a) {
                a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);
              });
            };

            c.prototype.getSeriesOrderByLinks = function () {
              return this.series.concat().sort(function (a, b) {
                return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;
              });
            };

            c.prototype.orderSeries = function (a) {
              var b = this.series;
              a = a || 0;

              for (var d = b.length; a < d; ++a) {
                b[a] && (b[a].index = a, b[a].name = b[a].getName());
              }
            };

            c.prototype.isInsidePlot = function (a, b, d) {
              void 0 === d && (d = {});
              var e = this.inverted,
                  c = this.plotBox,
                  g = this.plotLeft,
                  h = this.plotTop,
                  l = this.scrollablePlotBox,
                  k = 0;
              var m = 0;
              d.visiblePlotOnly && this.scrollingContainer && (m = this.scrollingContainer, k = m.scrollLeft, m = m.scrollTop);
              var f = d.series;
              c = d.visiblePlotOnly && l || c;
              l = d.inverted ? b : a;
              b = d.inverted ? a : b;
              a = {
                x: l,
                y: b,
                isInsidePlot: !0
              };

              if (!d.ignoreX) {
                var q = f && (e ? f.yAxis : f.xAxis) || {
                  pos: g,
                  len: Infinity
                };
                l = d.paneCoordinates ? q.pos + l : g + l;
                l >= Math.max(k + g, q.pos) && l <= Math.min(k + g + c.width, q.pos + q.len) || (a.isInsidePlot = !1);
              }

              !d.ignoreY && a.isInsidePlot && (e = f && (e ? f.xAxis : f.yAxis) || {
                pos: h,
                len: Infinity
              }, d = d.paneCoordinates ? e.pos + b : h + b, d >= Math.max(m + h, e.pos) && d <= Math.min(m + h + c.height, e.pos + e.len) || (a.isInsidePlot = !1));
              N(this, "afterIsInsidePlot", a);
              return a.isInsidePlot;
            };

            c.prototype.redraw = function (a) {
              N(this, "beforeRedraw");
              var b = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                  d = this.series,
                  e = this.pointer,
                  c = this.legend,
                  g = this.userOptions.legend,
                  h = this.renderer,
                  l = h.isHidden(),
                  m = [],
                  k = this.isDirtyBox,
                  f = this.isDirtyLegend;
              this.setResponsive && this.setResponsive(!1);
              y(this.hasRendered ? a : !1, this);
              l && this.temporaryDisplay();
              this.layOutTitles();

              for (a = d.length; a--;) {
                var q = d[a];

                if (q.options.stacking || q.options.centerInCategory) {
                  var p = !0;

                  if (q.isDirty) {
                    var t = !0;
                    break;
                  }
                }
              }

              if (t) for (a = d.length; a--;) {
                q = d[a], q.options.stacking && (q.isDirty = !0);
              }
              d.forEach(function (a) {
                a.isDirty && ("point" === a.options.legendType ? ("function" === typeof a.updateTotals && a.updateTotals(), f = !0) : g && (g.labelFormatter || g.labelFormat) && (f = !0));
                a.isDirtyData && N(a, "updatedData");
              });
              f && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);
              p && this.getStacks();
              b.forEach(function (a) {
                a.updateNames();
                a.setScale();
              });
              this.getMargins();
              b.forEach(function (a) {
                a.isDirty && (k = !0);
              });
              b.forEach(function (a) {
                var b = a.min + "," + a.max;
                a.extKey !== b && (a.extKey = b, m.push(function () {
                  N(a, "afterSetExtremes", ba(a.eventArgs, a.getExtremes()));
                  delete a.eventArgs;
                }));
                (k || p) && a.redraw();
              });
              k && this.drawChartBox();
              N(this, "predraw");
              d.forEach(function (a) {
                (k || a.isDirty) && a.visible && a.redraw();
                a.isDirtyData = !1;
              });
              e && e.reset(!0);
              h.draw();
              N(this, "redraw");
              N(this, "render");
              l && this.temporaryDisplay(!0);
              m.forEach(function (a) {
                a.call();
              });
            };

            c.prototype.get = function (a) {
              function b(b) {
                return b.id === a || b.options && b.options.id === a;
              }

              for (var d = this.series, e = fa(this.axes, b) || fa(this.series, b), c = 0; !e && c < d.length; c++) {
                e = fa(d[c].points || [], b);
              }

              return e;
            };

            c.prototype.getAxes = function () {
              var a = this,
                  b = this.options,
                  d = b.xAxis = aa(b.xAxis || {});
              b = b.yAxis = aa(b.yAxis || {});
              N(this, "getAxes");
              d.forEach(function (a, b) {
                a.index = b;
                a.isX = !0;
              });
              b.forEach(function (a, b) {
                a.index = b;
              });
              d.concat(b).forEach(function (b) {
                new f(a, b);
              });
              N(this, "afterGetAxes");
            };

            c.prototype.getSelectedPoints = function () {
              return this.series.reduce(function (a, b) {
                b.getPointsCollection().forEach(function (b) {
                  O(b.selectedStaging, b.selected) && a.push(b);
                });
                return a;
              }, []);
            };

            c.prototype.getSelectedSeries = function () {
              return this.series.filter(function (a) {
                return a.selected;
              });
            };

            c.prototype.setTitle = function (a, b, d) {
              this.applyDescription("title", a);
              this.applyDescription("subtitle", b);
              this.applyDescription("caption", void 0);
              this.layOutTitles(d);
            };

            c.prototype.applyDescription = function (a, b) {
              var d = this,
                  e = "title" === a ? {
                color: "#333333",
                fontSize: this.options.isStock ? "16px" : "18px"
              } : {
                color: "#666666"
              };
              e = this.options[a] = S(!this.styledMode && {
                style: e
              }, this.options[a], b);
              var c = this[a];
              c && b && (this[a] = c = c.destroy());
              e && !c && (c = this.renderer.text(e.text, 0, 0, e.useHTML).attr({
                align: e.align,
                "class": "highcharts-" + a,
                zIndex: e.zIndex || 4
              }).add(), c.update = function (b) {
                d[{
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }[a]](b);
              }, this.styledMode || c.css(e.style), this[a] = c);
            };

            c.prototype.layOutTitles = function (a) {
              var b = [0, 0, 0],
                  d = this.renderer,
                  e = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (a) {
                var c = this[a],
                    g = this.options[a],
                    h = g.verticalAlign || "top";
                a = "title" === a ? "top" === h ? -3 : 0 : "top" === h ? b[0] + 2 : 0;
                var l;

                if (c) {
                  this.styledMode || (l = g.style && g.style.fontSize);
                  l = d.fontMetrics(l, c).b;
                  c.css({
                    width: (g.width || e.width + (g.widthAdjust || 0)) + "px"
                  });
                  var k = Math.round(c.getBBox(g.useHTML).height);
                  c.align(ba({
                    y: "bottom" === h ? l : a + l,
                    height: k
                  }, g), !1, "spacingBox");
                  g.floating || ("top" === h ? b[0] = Math.ceil(b[0] + k) : "bottom" === h && (b[2] = Math.ceil(b[2] + k)));
                }
              }, this);
              b[0] && "top" === (this.options.title.verticalAlign || "top") && (b[0] += this.options.title.margin);
              b[2] && "bottom" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);
              var c = !this.titleOffset || this.titleOffset.join(",") !== b.join(",");
              this.titleOffset = b;
              N(this, "afterLayOutTitles");
              !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && O(a, !0) && this.isDirtyBox && this.redraw());
            };

            c.prototype.getChartSize = function () {
              var a = this.options.chart,
                  b = a.width;
              a = a.height;
              var d = this.renderTo;
              U(b) || (this.containerWidth = ha(d, "width"));
              U(a) || (this.containerHeight = ha(d, "height"));
              this.chartWidth = Math.max(0, b || this.containerWidth || 600);
              this.chartHeight = Math.max(0, da(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };

            c.prototype.temporaryDisplay = function (a) {
              var b = this.renderTo;
              if (a) for (; b && b.style;) {
                b.hcOrigStyle && (L(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (g.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;
              } else for (; b && b.style;) {
                g.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, g.body.appendChild(b));
                if ("none" === ha(b, "display", !1) || b.hcOricDetached) b.hcOrigStyle = {
                  display: b.style.display,
                  height: b.style.height,
                  overflow: b.style.overflow
                }, a = {
                  display: "block",
                  overflow: "hidden"
                }, b !== this.renderTo && (a.height = 0), L(b, a), b.offsetWidth || b.style.setProperty("display", "block", "important");
                b = b.parentNode;
                if (b === g.body) break;
              }
            };

            c.prototype.setClassName = function (a) {
              this.container.className = "highcharts-container " + (a || "");
            };

            c.prototype.getContainer = function () {
              var b = this.options,
                  e = b.chart,
                  c = ja(),
                  h,
                  k = this.renderTo;
              k || (this.renderTo = k = e.renderTo);
              T(k) && (this.renderTo = k = g.getElementById(k));
              k || K(13, !0, this);
              var m = ca(J(k, "data-highcharts-chart"));
              Z(m) && l[m] && l[m].hasRendered && l[m].destroy();
              J(k, "data-highcharts-chart", this.index);
              k.innerHTML = p.emptyHTML;
              e.skipClone || k.offsetWidth || this.temporaryDisplay();
              this.getChartSize();
              m = this.chartWidth;
              var f = this.chartHeight;
              L(k, {
                overflow: "hidden"
              });
              this.styledMode || (h = ba({
                position: "relative",
                overflow: "hidden",
                width: m + "px",
                height: f + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                userSelect: "none",
                "touch-action": "manipulation",
                outline: "none"
              }, e.style || {}));
              this.container = c = I("div", {
                id: c
              }, h, k);
              this._cursor = c.style.cursor;
              this.renderer = new (e.renderer || !a ? n.getRendererType(e.renderer) : d)(c, m, f, void 0, e.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
              y(void 0, this);
              this.setClassName(e.className);
              if (this.styledMode) for (var q in b.defs) {
                this.renderer.definition(b.defs[q]);
              } else this.renderer.setStyle(e.style);
              this.renderer.chartIndex = this.index;
              N(this, "afterGetContainer");
            };

            c.prototype.getMargins = function (a) {
              var b = this.spacing,
                  d = this.margin,
                  e = this.titleOffset;
              this.resetMargins();
              e[0] && !U(d[0]) && (this.plotTop = Math.max(this.plotTop, e[0] + b[0]));
              e[2] && !U(d[2]) && (this.marginBottom = Math.max(this.marginBottom, e[2] + b[2]));
              this.legend && this.legend.display && this.legend.adjustMargins(d, b);
              N(this, "getMargins");
              a || this.getAxisMargins();
            };

            c.prototype.getAxisMargins = function () {
              var a = this,
                  b = a.axisOffset = [0, 0, 0, 0],
                  d = a.colorAxis,
                  e = a.margin,
                  c = function c(a) {
                a.forEach(function (a) {
                  a.visible && a.getOffset();
                });
              };

              a.hasCartesianSeries ? c(a.axes) : d && d.length && c(d);
              w.forEach(function (d, c) {
                U(e[c]) || (a[d] += b[c]);
              });
              a.setChartSize();
            };

            c.prototype.reflow = function (a) {
              var b = this,
                  d = b.options.chart,
                  e = b.renderTo,
                  c = U(d.width) && U(d.height),
                  l = d.width || ha(e, "width");
              d = d.height || ha(e, "height");
              e = a ? a.target : B;
              delete b.pointer.chartPosition;

              if (!c && !b.isPrinting && l && d && (e === B || e === g)) {
                if (l !== b.containerWidth || d !== b.containerHeight) h.clearTimeout(b.reflowTimeout), b.reflowTimeout = ea(function () {
                  b.container && b.setSize(void 0, void 0, !1);
                }, a ? 100 : 0);
                b.containerWidth = l;
                b.containerHeight = d;
              }
            };

            c.prototype.setReflow = function (a) {
              var b = this;
              !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = x(B, "resize", function (a) {
                b.options && b.reflow(a);
              }), x(this, "destroy", this.unbindReflow));
            };

            c.prototype.setSize = function (a, b, d) {
              var e = this,
                  c = e.renderer;
              e.isResizing += 1;
              y(d, e);
              d = c.globalAnimation;
              e.oldChartHeight = e.chartHeight;
              e.oldChartWidth = e.chartWidth;
              "undefined" !== typeof a && (e.options.chart.width = a);
              "undefined" !== typeof b && (e.options.chart.height = b);
              e.getChartSize();
              e.styledMode || (d ? z : L)(e.container, {
                width: e.chartWidth + "px",
                height: e.chartHeight + "px"
              }, d);
              e.setChartSize(!0);
              c.setSize(e.chartWidth, e.chartHeight, d);
              e.axes.forEach(function (a) {
                a.isDirty = !0;
                a.setScale();
              });
              e.isDirtyLegend = !0;
              e.isDirtyBox = !0;
              e.layOutTitles();
              e.getMargins();
              e.redraw(d);
              e.oldChartHeight = null;
              N(e, "resize");
              ea(function () {
                e && N(e, "endResize", null, function () {
                  --e.isResizing;
                });
              }, E(d).duration);
            };

            c.prototype.setChartSize = function (a) {
              var b = this.inverted,
                  d = this.renderer,
                  e = this.chartWidth,
                  c = this.chartHeight,
                  g = this.options.chart,
                  h = this.spacing,
                  l = this.clipOffset,
                  k,
                  m,
                  f,
                  q;
              this.plotLeft = k = Math.round(this.plotLeft);
              this.plotTop = m = Math.round(this.plotTop);
              this.plotWidth = f = Math.max(0, Math.round(e - k - this.marginRight));
              this.plotHeight = q = Math.max(0, Math.round(c - m - this.marginBottom));
              this.plotSizeX = b ? q : f;
              this.plotSizeY = b ? f : q;
              this.plotBorderWidth = g.plotBorderWidth || 0;
              this.spacingBox = d.spacingBox = {
                x: h[3],
                y: h[0],
                width: e - h[3] - h[1],
                height: c - h[0] - h[2]
              };
              this.plotBox = d.plotBox = {
                x: k,
                y: m,
                width: f,
                height: q
              };
              b = 2 * Math.floor(this.plotBorderWidth / 2);
              e = Math.ceil(Math.max(b, l[3]) / 2);
              c = Math.ceil(Math.max(b, l[0]) / 2);
              this.clipBox = {
                x: e,
                y: c,
                width: Math.floor(this.plotSizeX - Math.max(b, l[1]) / 2 - e),
                height: Math.max(0, Math.floor(this.plotSizeY - Math.max(b, l[2]) / 2 - c))
              };
              a || (this.axes.forEach(function (a) {
                a.setAxisSize();
                a.setAxisTranslation();
              }), d.alignElements());
              N(this, "afterSetChartSize", {
                skipAxes: a
              });
            };

            c.prototype.resetMargins = function () {
              N(this, "resetMargins");
              var a = this,
                  b = a.options.chart;
              ["margin", "spacing"].forEach(function (d) {
                var e = b[d],
                    c = Q(e) ? e : [e, e, e, e];
                ["Top", "Right", "Bottom", "Left"].forEach(function (e, g) {
                  a[d][g] = O(b[d + e], c[g]);
                });
              });
              w.forEach(function (b, e) {
                a[b] = O(a.margin[e], a.spacing[e]);
              });
              a.axisOffset = [0, 0, 0, 0];
              a.clipOffset = [0, 0, 0, 0];
            };

            c.prototype.drawChartBox = function () {
              var a = this.options.chart,
                  b = this.renderer,
                  e = this.chartWidth,
                  d = this.chartHeight,
                  c = this.styledMode,
                  g = this.plotBGImage,
                  h = a.backgroundColor,
                  l = a.plotBackgroundColor,
                  k = a.plotBackgroundImage,
                  m = this.plotLeft,
                  f = this.plotTop,
                  q = this.plotWidth,
                  p = this.plotHeight,
                  t = this.plotBox,
                  w = this.clipRect,
                  n = this.clipBox,
                  x = this.chartBackground,
                  z = this.plotBackground,
                  B = this.plotBorder,
                  y,
                  E = "animate";
              x || (this.chartBackground = x = b.rect().addClass("highcharts-background").add(), E = "attr");
              if (c) var u = y = x.strokeWidth();else {
                u = a.borderWidth || 0;
                y = u + (a.shadow ? 8 : 0);
                h = {
                  fill: h || "none"
                };
                if (u || x["stroke-width"]) h.stroke = a.borderColor, h["stroke-width"] = u;
                x.attr(h).shadow(a.shadow);
              }
              x[E]({
                x: y / 2,
                y: y / 2,
                width: e - y - u % 2,
                height: d - y - u % 2,
                r: a.borderRadius
              });
              E = "animate";
              z || (E = "attr", this.plotBackground = z = b.rect().addClass("highcharts-plot-background").add());
              z[E](t);
              c || (z.attr({
                fill: l || "none"
              }).shadow(a.plotShadow), k && (g ? (k !== g.attr("href") && g.attr("href", k), g.animate(t)) : this.plotBGImage = b.image(k, m, f, q, p).add()));
              w ? w.animate({
                width: n.width,
                height: n.height
              }) : this.clipRect = b.clipRect(n);
              E = "animate";
              B || (E = "attr", this.plotBorder = B = b.rect().addClass("highcharts-plot-border").attr({
                zIndex: 1
              }).add());
              c || B.attr({
                stroke: a.plotBorderColor,
                "stroke-width": a.plotBorderWidth || 0,
                fill: "none"
              });
              B[E](B.crisp({
                x: m,
                y: f,
                width: q,
                height: p
              }, -B.strokeWidth()));
              this.isDirtyBox = !1;
              N(this, "afterDrawChartBox");
            };

            c.prototype.propFromSeries = function () {
              var a = this,
                  b = a.options.chart,
                  e = a.options.series,
                  d,
                  c,
                  g;
              ["inverted", "angular", "polar"].forEach(function (h) {
                c = m[b.type || b.defaultSeriesType];
                g = b[h] || c && c.prototype[h];

                for (d = e && e.length; !g && d--;) {
                  (c = m[e[d].type]) && c.prototype[h] && (g = !0);
                }

                a[h] = g;
              });
            };

            c.prototype.linkSeries = function () {
              var a = this,
                  b = a.series;
              b.forEach(function (a) {
                a.linkedSeries.length = 0;
              });
              b.forEach(function (b) {
                var e = b.options.linkedTo;
                T(e) && (e = ":previous" === e ? a.series[b.index - 1] : a.get(e)) && e.linkedParent !== b && (e.linkedSeries.push(b), b.linkedParent = e, e.enabledDataSorting && b.setDataSortingOptions(), b.visible = O(b.options.visible, e.options.visible, b.visible));
              });
              N(this, "afterLinkSeries");
            };

            c.prototype.renderSeries = function () {
              this.series.forEach(function (a) {
                a.translate();
                a.render();
              });
            };

            c.prototype.renderLabels = function () {
              var a = this,
                  b = a.options.labels;
              b.items && b.items.forEach(function (e) {
                var d = ba(b.style, e.style),
                    c = ca(d.left) + a.plotLeft,
                    g = ca(d.top) + a.plotTop + 12;
                delete d.left;
                delete d.top;
                a.renderer.text(e.html, c, g).attr({
                  zIndex: 2
                }).css(d).add();
              });
            };

            c.prototype.render = function () {
              var a = this.axes,
                  b = this.colorAxis,
                  e = this.renderer,
                  d = this.options,
                  c = function c(a) {
                a.forEach(function (a) {
                  a.visible && a.render();
                });
              },
                  g = 0;

              this.setTitle();
              this.legend = new C(this, d.legend);
              this.getStacks && this.getStacks();
              this.getMargins(!0);
              this.setChartSize();
              d = this.plotWidth;
              a.some(function (a) {
                if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return g = 21, !0;
              });
              var h = this.plotHeight = Math.max(this.plotHeight - g, 0);
              a.forEach(function (a) {
                a.setScale();
              });
              this.getAxisMargins();
              var l = 1.1 < d / this.plotWidth,
                  k = 1.05 < h / this.plotHeight;
              if (l || k) a.forEach(function (a) {
                (a.horiz && l || !a.horiz && k) && a.setTickInterval(!0);
              }), this.getMargins();
              this.drawChartBox();
              this.hasCartesianSeries ? c(a) : b && b.length && c(b);
              this.seriesGroup || (this.seriesGroup = e.g("series-group").attr({
                zIndex: 3
              }).add());
              this.renderSeries();
              this.renderLabels();
              this.addCredits();
              this.setResponsive && this.setResponsive();
              this.hasRendered = !0;
            };

            c.prototype.addCredits = function (a) {
              var b = this,
                  e = S(!0, this.options.credits, a);
              e.enabled && !this.credits && (this.credits = this.renderer.text(e.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                e.href && (B.location.href = e.href);
              }).attr({
                align: e.position.align,
                zIndex: 8
              }), b.styledMode || this.credits.css(e.style), this.credits.add().align(e.position), this.credits.update = function (a) {
                b.credits = b.credits.destroy();
                b.addCredits(a);
              });
            };

            c.prototype.destroy = function () {
              var a = this,
                  b = a.axes,
                  e = a.series,
                  d = a.container,
                  c = d && d.parentNode,
                  g;
              N(a, "destroy");
              a.renderer.forExport ? H(l, a) : l[a.index] = void 0;
              r.chartCount--;
              a.renderTo.removeAttribute("data-highcharts-chart");
              ia(a);

              for (g = b.length; g--;) {
                b[g] = b[g].destroy();
              }

              this.scroller && this.scroller.destroy && this.scroller.destroy();

              for (g = e.length; g--;) {
                e[g] = e[g].destroy();
              }

              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (b) {
                var e = a[b];
                e && e.destroy && (a[b] = e.destroy());
              });
              d && (d.innerHTML = p.emptyHTML, ia(d), c && X(d));
              W(a, function (b, e) {
                delete a[e];
              });
            };

            c.prototype.firstRender = function () {
              var a = this,
                  b = a.options;

              if (!a.isReadyToRender || a.isReadyToRender()) {
                a.getContainer();
                a.resetMargins();
                a.setChartSize();
                a.propFromSeries();
                a.getAxes();
                (R(b.series) ? b.series : []).forEach(function (b) {
                  a.initSeries(b);
                });
                a.linkSeries();
                a.setSeriesData();
                N(a, "beforeRender");
                u && (F.isRequired() ? a.pointer = new F(a, b) : a.pointer = new u(a, b));
                a.render();
                a.pointer.getChartPosition();
                if (!a.renderer.imgCount && !a.hasLoaded) a.onload();
                a.temporaryDisplay(!0);
              }
            };

            c.prototype.onload = function () {
              this.callbacks.concat([this.callback]).forEach(function (a) {
                a && "undefined" !== typeof this.index && a.apply(this, [this]);
              }, this);
              N(this, "load");
              N(this, "render");
              U(this.index) && this.setReflow(this.options.chart.reflow);
              this.warnIfA11yModuleNotLoaded();
              this.hasLoaded = !0;
            };

            c.prototype.warnIfA11yModuleNotLoaded = function () {
              var a = this.options,
                  b = this.title;
              a && !this.accessibility && (this.renderer.boxWrapper.attr({
                role: "img",
                "aria-label": b && b.element.textContent || ""
              }), a.accessibility && !1 === a.accessibility.enabled || K('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
            };

            c.prototype.addSeries = function (a, b, e) {
              var d = this,
                  c;
              a && (b = O(b, !0), N(d, "addSeries", {
                options: a
              }, function () {
                c = d.initSeries(a);
                d.isDirtyLegend = !0;
                d.linkSeries();
                c.enabledDataSorting && c.setData(a.data, !1);
                N(d, "afterAddSeries", {
                  series: c
                });
                b && d.redraw(e);
              }));
              return c;
            };

            c.prototype.addAxis = function (a, b, e, d) {
              return this.createAxis(b ? "xAxis" : "yAxis", {
                axis: a,
                redraw: e,
                animation: d
              });
            };

            c.prototype.addColorAxis = function (a, b, e) {
              return this.createAxis("colorAxis", {
                axis: a,
                redraw: b,
                animation: e
              });
            };

            c.prototype.createAxis = function (a, b) {
              a = new f(this, S(b.axis, {
                index: this[a].length,
                isX: "xAxis" === a
              }));
              O(b.redraw, !0) && this.redraw(b.animation);
              return a;
            };

            c.prototype.showLoading = function (a) {
              var b = this,
                  e = b.options,
                  d = e.loading,
                  c = function c() {
                g && L(g, {
                  left: b.plotLeft + "px",
                  top: b.plotTop + "px",
                  width: b.plotWidth + "px",
                  height: b.plotHeight + "px"
                });
              },
                  g = b.loadingDiv,
                  h = b.loadingSpan;

              g || (b.loadingDiv = g = I("div", {
                className: "highcharts-loading highcharts-loading-hidden"
              }, null, b.container));
              h || (b.loadingSpan = h = I("span", {
                className: "highcharts-loading-inner"
              }, null, g), x(b, "redraw", c));
              g.className = "highcharts-loading";
              p.setElementHTML(h, O(a, e.lang.loading, ""));
              b.styledMode || (L(g, ba(d.style, {
                zIndex: 10
              })), L(h, d.labelStyle), b.loadingShown || (L(g, {
                opacity: 0,
                display: ""
              }), z(g, {
                opacity: d.style.opacity || .5
              }, {
                duration: d.showDuration || 0
              })));
              b.loadingShown = !0;
              c();
            };

            c.prototype.hideLoading = function () {
              var a = this.options,
                  b = this.loadingDiv;
              b && (b.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || z(b, {
                opacity: 0
              }, {
                duration: a.loading.hideDuration || 100,
                complete: function complete() {
                  L(b, {
                    display: "none"
                  });
                }
              }));
              this.loadingShown = !1;
            };

            c.prototype.update = function (a, e, d, c) {
              var g = this,
                  h = {
                credits: "addCredits",
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              },
                  l = a.isResponsiveOptions,
                  k = [],
                  m,
                  f;
              N(g, "update", {
                options: a
              });
              l || g.setResponsive(!1, !0);
              a = M(a, g.options);
              g.userOptions = S(g.userOptions, a);
              var p = a.chart;

              if (p) {
                S(!0, g.options.chart, p);
                "className" in p && g.setClassName(p.className);
                "reflow" in p && g.setReflow(p.reflow);

                if ("inverted" in p || "polar" in p || "type" in p) {
                  g.propFromSeries();
                  var t = !0;
                }

                "alignTicks" in p && (t = !0);
                "events" in p && q(this, p);
                W(p, function (a, b) {
                  -1 !== g.propsRequireUpdateSeries.indexOf("chart." + b) && (m = !0);
                  -1 !== g.propsRequireDirtyBox.indexOf(b) && (g.isDirtyBox = !0);
                  -1 !== g.propsRequireReflow.indexOf(b) && (l ? g.isDirtyBox = !0 : f = !0);
                });
                !g.styledMode && p.style && g.renderer.setStyle(g.options.chart.style || {});
              }

              !g.styledMode && a.colors && (this.options.colors = a.colors);
              a.time && (this.time === G && (this.time = new b(a.time)), S(!0, g.options.time, a.time));
              W(a, function (b, e) {
                if (g[e] && "function" === typeof g[e].update) g[e].update(b, !1);else if ("function" === typeof g[h[e]]) g[h[e]](b);else "colors" !== e && -1 === g.collectionsWithUpdate.indexOf(e) && S(!0, g.options[e], a[e]);
                "chart" !== e && -1 !== g.propsRequireUpdateSeries.indexOf(e) && (m = !0);
              });
              this.collectionsWithUpdate.forEach(function (b) {
                if (a[b]) {
                  var e = [];
                  g[b].forEach(function (a, b) {
                    a.options.isInternal || e.push(O(a.options.index, b));
                  });
                  aa(a[b]).forEach(function (a, c) {
                    var h = U(a.id),
                        l;
                    h && (l = g.get(a.id));
                    !l && g[b] && (l = g[b][e ? e[c] : c]) && h && U(l.options.id) && (l = void 0);
                    l && l.coll === b && (l.update(a, !1), d && (l.touched = !0));
                    !l && d && g.collectionsWithInit[b] && (g.collectionsWithInit[b][0].apply(g, [a].concat(g.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);
                  });
                  d && g[b].forEach(function (a) {
                    a.touched || a.options.isInternal ? delete a.touched : k.push(a);
                  });
                }
              });
              k.forEach(function (a) {
                a.chart && a.remove && a.remove(!1);
              });
              t && g.axes.forEach(function (a) {
                a.update({}, !1);
              });
              m && g.getSeriesOrderByLinks().forEach(function (a) {
                a.chart && a.update({}, !1);
              }, this);
              t = p && p.width;
              p = p && (T(p.height) ? da(p.height, t || g.chartWidth) : p.height);
              f || Z(t) && t !== g.chartWidth || Z(p) && p !== g.chartHeight ? g.setSize(t, p, c) : O(e, !0) && g.redraw(c);
              N(g, "afterUpdate", {
                options: a,
                redraw: e,
                animation: c
              });
            };

            c.prototype.setSubtitle = function (a, b) {
              this.applyDescription("subtitle", a);
              this.layOutTitles(b);
            };

            c.prototype.setCaption = function (a, b) {
              this.applyDescription("caption", a);
              this.layOutTitles(b);
            };

            c.prototype.showResetZoom = function () {
              function a() {
                b.zoomOut();
              }

              var b = this,
                  d = e.lang,
                  c = b.options.chart.resetZoomButton,
                  g = c.theme,
                  h = "chart" === c.relativeTo || "spacingBox" === c.relativeTo ? null : "scrollablePlotBox";
              N(this, "beforeShowResetZoom", null, function () {
                b.resetZoomButton = b.renderer.button(d.resetZoom, null, null, a, g).attr({
                  align: c.position.align,
                  title: d.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(c.position, !1, h);
              });
              N(this, "afterShowResetZoom");
            };

            c.prototype.zoomOut = function () {
              N(this, "selection", {
                resetSelection: !0
              }, this.zoom);
            };

            c.prototype.zoom = function (a) {
              var b = this,
                  e = b.pointer,
                  d = b.inverted ? e.mouseDownX : e.mouseDownY,
                  c = !1,
                  g;
              !a || a.resetSelection ? (b.axes.forEach(function (a) {
                g = a.zoom();
              }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
                var h = a.axis,
                    l = b.inverted ? h.left : h.top,
                    k = b.inverted ? l + h.width : l + h.height,
                    m = h.isXAxis,
                    f = !1;
                if (!m && d >= l && d <= k || m || !U(d)) f = !0;
                e[m ? "zoomX" : "zoomY"] && f && (g = h.zoom(a.min, a.max), h.displayBtn && (c = !0));
              });
              var h = b.resetZoomButton;
              c && !h ? b.showResetZoom() : !c && Q(h) && (b.resetZoomButton = h.destroy());
              g && b.redraw(O(b.options.chart.animation, a && a.animation, 100 > b.pointCount));
            };

            c.prototype.pan = function (a, b) {
              var e = this,
                  d = e.hoverPoints;
              b = "object" === typeof b ? b : {
                enabled: b,
                type: "x"
              };
              var c = e.options.chart;
              c && c.panning && (c.panning = b);
              var g = b.type,
                  h;
              N(this, "pan", {
                originalEvent: a
              }, function () {
                d && d.forEach(function (a) {
                  a.setState();
                });
                var b = e.xAxis;
                "xy" === g ? b = b.concat(e.yAxis) : "y" === g && (b = e.yAxis);
                var c = {};
                b.forEach(function (b) {
                  if (b.options.panningEnabled && !b.options.isInternal) {
                    var d = b.horiz,
                        l = a[d ? "chartX" : "chartY"];
                    d = d ? "mouseDownX" : "mouseDownY";
                    var k = e[d],
                        m = b.minPointOffset || 0,
                        f = b.reversed && !e.inverted || !b.reversed && e.inverted ? -1 : 1,
                        q = b.getExtremes(),
                        p = b.toValue(k - l, !0) + m * f,
                        t = b.toValue(k + b.len - l, !0) - (m * f || b.isXAxis && b.pointRangePadding || 0),
                        w = t < p;
                    f = b.hasVerticalPanning();
                    k = w ? t : p;
                    p = w ? p : t;
                    var n = b.panningState;
                    !f || b.isXAxis || n && !n.isDirty || b.series.forEach(function (a) {
                      var b = a.getProcessedData(!0);
                      b = a.getExtremes(b.yData, !0);
                      n || (n = {
                        startMin: Number.MAX_VALUE,
                        startMax: -Number.MAX_VALUE
                      });
                      Z(b.dataMin) && Z(b.dataMax) && (n.startMin = Math.min(O(a.options.threshold, Infinity), b.dataMin, n.startMin), n.startMax = Math.max(O(a.options.threshold, -Infinity), b.dataMax, n.startMax));
                    });
                    f = Math.min(O(n && n.startMin, q.dataMin), m ? q.min : b.toValue(b.toPixels(q.min) - b.minPixelPadding));
                    t = Math.max(O(n && n.startMax, q.dataMax), m ? q.max : b.toValue(b.toPixels(q.max) + b.minPixelPadding));
                    b.panningState = n;
                    b.isOrdinal || (m = f - k, 0 < m && (p += m, k = f), m = p - t, 0 < m && (p = t, k -= m), b.series.length && k !== q.min && p !== q.max && k >= f && p <= t && (b.setExtremes(k, p, !1, !1, {
                      trigger: "pan"
                    }), !e.resetZoomButton && k !== f && p !== t && g.match("y") && (e.showResetZoom(), b.displayBtn = !1), h = !0), c[d] = l);
                  }
                });
                W(c, function (a, b) {
                  e[b] = a;
                });
                h && e.redraw(!1);
                L(e.container, {
                  cursor: "move"
                });
              });
            };

            return c;
          }();

          ba(c.prototype, {
            callbacks: [],
            collectionsWithInit: {
              xAxis: [c.prototype.addAxis, [!0]],
              yAxis: [c.prototype.addAxis, [!1]],
              series: [c.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
          });
          "";
          return c;
        });
        H(f, "Core/Legend/LegendSymbol.js", [f["Core/Utilities.js"]], function (c) {
          var f = c.merge,
              v = c.pick,
              D;

          (function (c) {
            c.drawLineMarker = function (c) {
              var r = this.options,
                  A = c.symbolWidth,
                  u = c.symbolHeight,
                  n = u / 2,
                  k = this.chart.renderer,
                  d = this.legendGroup;
              c = c.baseline - Math.round(.3 * c.fontMetrics.b);
              var b = {},
                  h = r.marker;
              this.chart.styledMode || (b = {
                "stroke-width": r.lineWidth || 0
              }, r.dashStyle && (b.dashstyle = r.dashStyle));
              this.legendLine = k.path([["M", 0, c], ["L", A, c]]).addClass("highcharts-graph").attr(b).add(d);
              h && !1 !== h.enabled && A && (r = Math.min(v(h.radius, n), n), 0 === this.symbol.indexOf("url") && (h = f(h, {
                width: u,
                height: u
              }), r = 0), this.legendSymbol = A = k.symbol(this.symbol, A / 2 - r, c - r, 2 * r, 2 * r, h).addClass("highcharts-point").add(d), A.isMarker = !0);
            };

            c.drawRectangle = function (c, f) {
              var r = c.symbolHeight,
                  u = c.options.squareSymbol;
              f.legendSymbol = this.chart.renderer.rect(u ? (c.symbolWidth - r) / 2 : 0, c.baseline - r + 1, u ? r : c.symbolWidth, r, v(c.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(f.legendGroup);
            };
          })(D || (D = {}));

          return D;
        });
        H(f, "Core/Series/SeriesDefaults.js", [], function () {
          return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
              duration: 1E3
            },
            events: {},
            marker: {
              enabledThreshold: 2,
              lineColor: "#ffffff",
              lineWidth: 0,
              radius: 4,
              states: {
                normal: {
                  animation: !0
                },
                hover: {
                  animation: {
                    duration: 50
                  },
                  enabled: !0,
                  radiusPlus: 2,
                  lineWidthPlus: 1
                },
                select: {
                  fillColor: "#cccccc",
                  lineColor: "#000000",
                  lineWidth: 2
                }
              }
            },
            point: {
              events: {}
            },
            dataLabels: {
              animation: {},
              align: "center",
              defer: !0,
              formatter: function formatter() {
                var c = this.series.chart.numberFormatter;
                return "number" !== typeof this.y ? "" : c(this.y, -1);
              },
              padding: 5,
              style: {
                fontSize: "11px",
                fontWeight: "bold",
                color: "contrast",
                textOutline: "1px contrast"
              },
              verticalAlign: "bottom",
              x: 0,
              y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                lineWidthPlus: 1,
                marker: {},
                halo: {
                  size: 10,
                  opacity: .25
                }
              },
              select: {
                animation: {
                  duration: 0
                }
              },
              inactive: {
                animation: {
                  duration: 50
                },
                opacity: .2
              }
            },
            stickyTracking: !0,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
          };
        });
        H(f, "Core/Series/Series.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/DefaultOptions.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/Point.js"], f["Core/Series/SeriesDefaults.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F, A, u, n) {
          var k = c.animObject,
              d = c.setAnimation,
              b = f.defaultOptions,
              h = v.registerEventOptions,
              p = D.hasTouch,
              z = D.svg,
              E = D.win,
              y = A.seriesTypes,
              t = n.addEvent,
              q = n.arrayMax,
              l = n.arrayMin,
              g = n.clamp,
              w = n.cleanRecursively,
              a = n.correctFloat,
              B = n.defined,
              e = n.erase,
              G = n.error,
              m = n.extend,
              x = n.find,
              J = n.fireEvent,
              M = n.getNestedProperty,
              I = n.isArray,
              L = n.isNumber,
              U = n.isString,
              X = n.merge,
              H = n.objectEach,
              K = n.pick,
              ba = n.removeEvent,
              fa = n.splat,
              N = n.syncTimeout;

          c = function () {
            function c() {
              this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }

            c.prototype.init = function (a, b) {
              J(this, "init", {
                options: b
              });
              var e = this,
                  c = a.series;
              this.eventsToUnbind = [];
              e.chart = a;
              e.options = e.setOptions(b);
              b = e.options;
              e.linkedSeries = [];
              e.bindAxes();
              m(e, {
                name: b.name,
                state: "",
                visible: !1 !== b.visible,
                selected: !0 === b.selected
              });
              h(this, b);
              var d = b.events;
              if (d && d.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;
              e.getColor();
              e.getSymbol();
              e.parallelArrays.forEach(function (a) {
                e[a + "Data"] || (e[a + "Data"] = []);
              });
              e.isCartesian && (a.hasCartesianSeries = !0);
              var g;
              c.length && (g = c[c.length - 1]);
              e._i = K(g && g._i, -1) + 1;
              e.opacity = e.options.opacity;
              a.orderSeries(this.insert(c));
              b.dataSorting && b.dataSorting.enabled ? e.setDataSortingOptions() : e.points || e.data || e.setData(b.data, !1);
              J(this, "afterInit");
            };

            c.prototype.is = function (a) {
              return y[a] && this instanceof y[a];
            };

            c.prototype.insert = function (a) {
              var b = this.options.index,
                  e;

              if (L(b)) {
                for (e = a.length; e--;) {
                  if (b >= K(a[e].options.index, a[e]._i)) {
                    a.splice(e + 1, 0, this);
                    break;
                  }
                }

                -1 === e && a.unshift(this);
                e += 1;
              } else a.push(this);

              return K(e, a.length - 1);
            };

            c.prototype.bindAxes = function () {
              var a = this,
                  b = a.options,
                  e = a.chart,
                  c;
              J(this, "bindAxes", null, function () {
                (a.axisTypes || []).forEach(function (d) {
                  var g = 0;
                  e[d].forEach(function (e) {
                    c = e.options;
                    if (b[d] === g && !c.isInternal || "undefined" !== typeof b[d] && b[d] === c.id || "undefined" === typeof b[d] && 0 === c.index) a.insert(e.series), a[d] = e, e.isDirty = !0;
                    c.isInternal || g++;
                  });
                  a[d] || a.optionalAxis === d || G(18, !0, e);
                });
              });
              J(this, "afterBindAxes");
            };

            c.prototype.updateParallelArrays = function (a, b) {
              var e = a.series,
                  c = arguments,
                  d = L(b) ? function (c) {
                var d = "y" === c && e.toYData ? e.toYData(a) : a[c];
                e[c + "Data"][b] = d;
              } : function (a) {
                Array.prototype[b].apply(e[a + "Data"], Array.prototype.slice.call(c, 2));
              };
              e.parallelArrays.forEach(d);
            };

            c.prototype.hasData = function () {
              return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };

            c.prototype.autoIncrement = function (a) {
              var b = this.options,
                  e = b.pointIntervalUnit,
                  c = b.relativeXValue,
                  d = this.chart.time,
                  g = this.xIncrement,
                  h;
              g = K(g, b.pointStart, 0);
              this.pointInterval = h = K(this.pointInterval, b.pointInterval, 1);
              c && L(a) && (h *= a);
              e && (b = new d.Date(g), "day" === e ? d.set("Date", b, d.get("Date", b) + h) : "month" === e ? d.set("Month", b, d.get("Month", b) + h) : "year" === e && d.set("FullYear", b, d.get("FullYear", b) + h), h = b.getTime() - g);
              if (c && L(a)) return g + h;
              this.xIncrement = g + h;
              return g;
            };

            c.prototype.setDataSortingOptions = function () {
              var a = this.options;
              m(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1
              });
              B(a.pointRange) || (a.pointRange = 1);
            };

            c.prototype.setOptions = function (a) {
              var e = this.chart,
                  c = e.options,
                  d = c.plotOptions,
                  g = e.userOptions || {};
              a = X(a);
              e = e.styledMode;
              var h = {
                plotOptions: d,
                userOptions: a
              };
              J(this, "setOptions", h);
              var l = h.plotOptions[this.type],
                  k = g.plotOptions || {};
              this.userOptions = h.userOptions;
              g = X(l, d.series, g.plotOptions && g.plotOptions[this.type], a);
              this.tooltipOptions = X(b.tooltip, b.plotOptions.series && b.plotOptions.series.tooltip, b.plotOptions[this.type].tooltip, c.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);
              this.stickyTracking = K(a.stickyTracking, k[this.type] && k[this.type].stickyTracking, k.series && k.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : g.stickyTracking);
              null === l.marker && delete g.marker;
              this.zoneAxis = g.zoneAxis;
              d = this.zones = (g.zones || []).slice();
              !g.negativeColor && !g.negativeFillColor || g.zones || (c = {
                value: g[this.zoneAxis + "Threshold"] || g.threshold || 0,
                className: "highcharts-negative"
              }, e || (c.color = g.negativeColor, c.fillColor = g.negativeFillColor), d.push(c));
              d.length && B(d[d.length - 1].value) && d.push(e ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
              J(this, "afterSetOptions", {
                options: g
              });
              return g;
            };

            c.prototype.getName = function () {
              return K(this.options.name, "Series " + (this.index + 1));
            };

            c.prototype.getCyclic = function (a, b, e) {
              var c = this.chart,
                  d = this.userOptions,
                  g = a + "Index",
                  h = a + "Counter",
                  l = e ? e.length : K(c.options.chart[a + "Count"], c[a + "Count"]);

              if (!b) {
                var k = K(d[g], d["_" + g]);
                B(k) || (c.series.length || (c[h] = 0), d["_" + g] = k = c[h] % l, c[h] += 1);
                e && (b = e[k]);
              }

              "undefined" !== typeof k && (this[g] = k);
              this[a] = b;
            };

            c.prototype.getColor = function () {
              this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || b.plotOptions[this.type].color, this.chart.options.colors);
            };

            c.prototype.getPointsCollection = function () {
              return (this.hasGroupedData ? this.points : this.data) || [];
            };

            c.prototype.getSymbol = function () {
              this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };

            c.prototype.findPointIndex = function (a, b) {
              var e = a.id,
                  c = a.x,
                  d = this.points,
                  g = this.options.dataSorting,
                  h,
                  l;
              if (e) g = this.chart.get(e), g instanceof C && (h = g);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (h = function h(b) {
                return !b.touched && b.index === a.index;
              }, g && g.matchByName ? h = function h(b) {
                return !b.touched && b.name === a.name;
              } : this.options.relativeXValue && (h = function h(b) {
                return !b.touched && b.options.x === a.x;
              }), h = x(d, h), !h) return;

              if (h) {
                var k = h && h.index;
                "undefined" !== typeof k && (l = !0);
              }

              "undefined" === typeof k && L(c) && (k = this.xData.indexOf(c, b));
              -1 !== k && "undefined" !== typeof k && this.cropped && (k = k >= this.cropStart ? k - this.cropStart : k);
              !l && L(k) && d[k] && d[k].touched && (k = void 0);
              return k;
            };

            c.prototype.updateData = function (a, b) {
              var e = this.options,
                  c = e.dataSorting,
                  d = this.points,
                  g = [],
                  h = this.requireSorting,
                  l = a.length === d.length,
                  k,
                  m,
                  f,
                  p = !0;
              this.xIncrement = null;
              a.forEach(function (a, b) {
                var m = B(a) && this.pointClass.prototype.optionsToObject.call({
                  series: this
                }, a) || {},
                    q = m.x;

                if (m.id || L(q)) {
                  if (m = this.findPointIndex(m, f), -1 === m || "undefined" === typeof m ? g.push(a) : d[m] && a !== e.data[m] ? (d[m].update(a, !1, null, !1), d[m].touched = !0, h && (f = m + 1)) : d[m] && (d[m].touched = !0), !l || b !== m || c && c.enabled || this.hasDerivedData) k = !0;
                } else g.push(a);
              }, this);
              if (k) for (a = d.length; a--;) {
                (m = d[a]) && !m.touched && m.remove && m.remove(!1, b);
              } else !l || c && c.enabled ? p = !1 : (a.forEach(function (a, b) {
                a !== d[b].y && d[b].update && d[b].update(a, !1, null, !1);
              }), g.length = 0);
              d.forEach(function (a) {
                a && (a.touched = !1);
              });
              if (!p) return !1;
              g.forEach(function (a) {
                this.addPoint(a, !1, null, null, !1);
              }, this);
              null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = q(this.xData), this.autoIncrement());
              return !0;
            };

            c.prototype.setData = function (a, b, e, c) {
              var d = this,
                  g = d.points,
                  h = g && g.length || 0,
                  l = d.options,
                  k = d.chart,
                  m = l.dataSorting,
                  f = d.xAxis,
                  q = l.turboThreshold,
                  p = this.xData,
                  t = this.yData,
                  n = d.pointArrayMap;
              n = n && n.length;
              var w = l.keys,
                  x,
                  z = 0,
                  B = 1,
                  y = null;

              if (!k.options.chart.allowMutatingData) {
                l.data && delete d.options.data;
                d.userOptions.data && delete d.userOptions.data;
                var E = X(!0, a);
              }

              a = E || a || [];
              E = a.length;
              b = K(b, !0);
              m && m.enabled && (a = this.sortData(a));
              k.options.chart.allowMutatingData && !1 !== c && E && h && !d.cropped && !d.hasGroupedData && d.visible && !d.isSeriesBoosting && (x = this.updateData(a, e));

              if (!x) {
                d.xIncrement = null;
                d.colorCounter = 0;
                this.parallelArrays.forEach(function (a) {
                  d[a + "Data"].length = 0;
                });
                if (q && E > q) {
                  if (y = d.getFirstValidPoint(a), L(y)) for (e = 0; e < E; e++) {
                    p[e] = this.autoIncrement(), t[e] = a[e];
                  } else if (I(y)) {
                    if (n) {
                      if (y.length === n) for (e = 0; e < E; e++) {
                        p[e] = this.autoIncrement(), t[e] = a[e];
                      } else for (e = 0; e < E; e++) {
                        c = a[e], p[e] = c[0], t[e] = c.slice(1, n + 1);
                      }
                    } else if (w && (z = w.indexOf("x"), B = w.indexOf("y"), z = 0 <= z ? z : 0, B = 0 <= B ? B : 1), 1 === y.length && (B = 0), z === B) for (e = 0; e < E; e++) {
                      p[e] = this.autoIncrement(), t[e] = a[e][B];
                    } else for (e = 0; e < E; e++) {
                      c = a[e], p[e] = c[z], t[e] = c[B];
                    }
                  } else G(12, !1, k);
                } else for (e = 0; e < E; e++) {
                  "undefined" !== typeof a[e] && (c = {
                    series: d
                  }, d.pointClass.prototype.applyOptions.apply(c, [a[e]]), d.updateParallelArrays(c, e));
                }
                t && U(t[0]) && G(14, !0, k);
                d.data = [];
                d.options.data = d.userOptions.data = a;

                for (e = h; e--;) {
                  g[e] && g[e].destroy && g[e].destroy();
                }

                f && (f.minRange = f.userMinRange);
                d.isDirty = k.isDirtyBox = !0;
                d.isDirtyData = !!g;
                e = !1;
              }

              "point" === l.legendType && (this.processData(), this.generatePoints());
              b && k.redraw(e);
            };

            c.prototype.sortData = function (a) {
              var b = this,
                  e = b.options.dataSorting.sortKey || "y",
                  d = function d(a, b) {
                return B(b) && a.pointClass.prototype.optionsToObject.call({
                  series: a
                }, b) || {};
              };

              a.forEach(function (e, c) {
                a[c] = d(b, e);
                a[c].index = c;
              }, this);
              a.concat().sort(function (a, b) {
                a = M(e, a);
                b = M(e, b);
                return b < a ? -1 : b > a ? 1 : 0;
              }).forEach(function (a, b) {
                a.x = b;
              }, this);
              b.linkedSeries && b.linkedSeries.forEach(function (b) {
                var e = b.options,
                    c = e.data;
                e.dataSorting && e.dataSorting.enabled || !c || (c.forEach(function (e, g) {
                  c[g] = d(b, e);
                  a[g] && (c[g].x = a[g].x, c[g].index = g);
                }), b.setData(c, !1));
              });
              return a;
            };

            c.prototype.getProcessedData = function (a) {
              var b = this.xAxis,
                  e = this.options,
                  d = e.cropThreshold,
                  c = a || this.getExtremesFromAll || e.getExtremesFromAll,
                  g = this.isCartesian;
              a = b && b.val2lin;
              e = !(!b || !b.logarithmic);
              var h = 0,
                  l = this.xData,
                  k = this.yData,
                  m = this.requireSorting;
              var f = !1;
              var q = l.length;

              if (b) {
                f = b.getExtremes();
                var p = f.min;
                var t = f.max;
                f = !(!b.categories || b.names.length);
              }

              if (g && this.sorted && !c && (!d || q > d || this.forceCrop)) if (l[q - 1] < p || l[0] > t) l = [], k = [];else if (this.yData && (l[0] < p || l[q - 1] > t)) {
                var n = this.cropData(this.xData, this.yData, p, t);
                l = n.xData;
                k = n.yData;
                h = n.start;
                n = !0;
              }

              for (d = l.length || 1; --d;) {
                if (b = e ? a(l[d]) - a(l[d - 1]) : l[d] - l[d - 1], 0 < b && ("undefined" === typeof w || b < w)) var w = b;else 0 > b && m && !f && (G(15, !1, this.chart), m = !1);
              }

              return {
                xData: l,
                yData: k,
                cropped: n,
                cropStart: h,
                closestPointRange: w
              };
            };

            c.prototype.processData = function (a) {
              var b = this.xAxis;
              if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;
              a = this.getProcessedData();
              this.cropped = a.cropped;
              this.cropStart = a.cropStart;
              this.processedXData = a.xData;
              this.processedYData = a.yData;
              this.closestPointRange = this.basePointRange = a.closestPointRange;
              J(this, "afterProcessData");
            };

            c.prototype.cropData = function (a, b, e, d, c) {
              var g = a.length,
                  h,
                  l = 0,
                  k = g;
              c = K(c, this.cropShoulder);

              for (h = 0; h < g; h++) {
                if (a[h] >= e) {
                  l = Math.max(0, h - c);
                  break;
                }
              }

              for (e = h; e < g; e++) {
                if (a[e] > d) {
                  k = e + c;
                  break;
                }
              }

              return {
                xData: a.slice(l, k),
                yData: b.slice(l, k),
                start: l,
                end: k
              };
            };

            c.prototype.generatePoints = function () {
              var a = this.options,
                  b = this.processedData || a.data,
                  e = this.processedXData,
                  d = this.processedYData,
                  c = this.pointClass,
                  g = e.length,
                  h = this.cropStart || 0,
                  l = this.hasGroupedData,
                  k = a.keys,
                  f = [];
              a = a.dataGrouping && a.dataGrouping.groupAll ? h : 0;
              var q,
                  p,
                  t = this.data;

              if (!t && !l) {
                var n = [];
                n.length = b.length;
                t = this.data = n;
              }

              k && l && (this.options.keys = !1);

              for (p = 0; p < g; p++) {
                n = h + p;

                if (l) {
                  var w = new c().init(this, [e[p]].concat(fa(d[p])));
                  w.dataGroup = this.groupMap[a + p];
                  w.dataGroup.options && (w.options = w.dataGroup.options, m(w, w.dataGroup.options), delete w.dataLabels);
                } else (w = t[n]) || "undefined" === typeof b[n] || (t[n] = w = new c().init(this, b[n], e[p]));

                w && (w.index = l ? a + p : n, f[p] = w);
              }

              this.options.keys = k;
              if (t && (g !== (q = t.length) || l)) for (p = 0; p < q; p++) {
                p !== h || l || (p += g), t[p] && (t[p].destroyElements(), t[p].plotX = void 0);
              }
              this.data = t;
              this.points = f;
              J(this, "afterGeneratePoints");
            };

            c.prototype.getXExtremes = function (a) {
              return {
                min: l(a),
                max: q(a)
              };
            };

            c.prototype.getExtremes = function (a, b) {
              var e = this.xAxis,
                  d = this.yAxis,
                  c = this.processedXData || this.xData,
                  g = [],
                  h = this.requireSorting ? this.cropShoulder : 0;
              d = d ? d.positiveValuesOnly : !1;
              var k,
                  m = 0,
                  f = 0,
                  p = 0;
              a = a || this.stackedYData || this.processedYData || [];
              var t = a.length;

              if (e) {
                var n = e.getExtremes();
                m = n.min;
                f = n.max;
              }

              for (k = 0; k < t; k++) {
                var w = c[k];
                n = a[k];
                var x = (L(n) || I(n)) && (n.length || 0 < n || !d);
                w = b || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !e || (c[k + h] || w) >= m && (c[k - h] || w) <= f;
                if (x && w) if (x = n.length) for (; x--;) {
                  L(n[x]) && (g[p++] = n[x]);
                } else g[p++] = n;
              }

              a = {
                activeYData: g,
                dataMin: l(g),
                dataMax: q(g)
              };
              J(this, "afterGetExtremes", {
                dataExtremes: a
              });
              return a;
            };

            c.prototype.applyExtremes = function () {
              var a = this.getExtremes();
              this.dataMin = a.dataMin;
              this.dataMax = a.dataMax;
              return a;
            };

            c.prototype.getFirstValidPoint = function (a) {
              for (var b = a.length, e = 0, d = null; null === d && e < b;) {
                d = a[e], e++;
              }

              return d;
            };

            c.prototype.translate = function () {
              this.processedXData || this.processData();
              this.generatePoints();
              var b = this.options,
                  e = b.stacking,
                  d = this.xAxis,
                  c = d.categories,
                  h = this.enabledDataSorting,
                  l = this.yAxis,
                  k = this.points,
                  m = k.length,
                  f = this.pointPlacementToXValue(),
                  q = !!f,
                  p = b.threshold,
                  t = b.startFromThreshold ? p : 0,
                  n = this.zoneAxis || "y",
                  w,
                  x,
                  z = Number.MAX_VALUE;

              for (w = 0; w < m; w++) {
                var y = k[w],
                    E = y.x,
                    u = void 0,
                    r = void 0,
                    G = y.y,
                    A = y.low,
                    M = e && l.stacking && l.stacking.stacks[(this.negStacks && G < (t ? 0 : p) ? "-" : "") + this.stackKey];
                if (l.positiveValuesOnly && !l.validatePositiveValue(G) || d.positiveValuesOnly && !d.validatePositiveValue(E)) y.isNull = !0;
                y.plotX = x = a(g(d.translate(E, 0, 0, 0, 1, f, "flags" === this.type), -1E5, 1E5));

                if (e && this.visible && M && M[E]) {
                  var v = this.getStackIndicator(v, E, this.index);
                  y.isNull || (u = M[E], r = u.points[v.key]);
                }

                I(r) && (A = r[0], G = r[1], A === t && v.key === M[E].base && (A = K(L(p) && p, l.min)), l.positiveValuesOnly && 0 >= A && (A = null), y.total = y.stackTotal = u.total, y.percentage = u.total && y.y / u.total * 100, y.stackY = G, this.irregularWidths || u.setOffset(this.pointXOffset || 0, this.barW || 0));
                y.yBottom = B(A) ? g(l.translate(A, 0, 1, 0, 1), -1E5, 1E5) : null;
                this.dataModify && (G = this.dataModify.modifyValue(G, w));
                y.plotY = void 0;
                L(G) && (u = l.translate(G, !1, !0, !1, !0), "undefined" !== typeof u && (y.plotY = g(u, -1E5, 1E5)));
                y.isInside = this.isPointInside(y);
                y.clientX = q ? a(d.translate(E, 0, 0, 0, 1, f)) : x;
                y.negative = y[n] < (b[n + "Threshold"] || p || 0);
                y.category = K(c && c[y.x], y.x);

                if (!y.isNull && !1 !== y.visible) {
                  "undefined" !== typeof F && (z = Math.min(z, Math.abs(x - F)));
                  var F = x;
                }

                y.zone = this.zones.length ? y.getZone() : void 0;
                !y.graphic && this.group && h && (y.isNew = !0);
              }

              this.closestPointRangePx = z;
              J(this, "afterTranslate");
            };

            c.prototype.getValidPoints = function (a, b, e) {
              var d = this.chart;
              return (a || this.points || []).filter(function (a) {
                return b && !d.isInsidePlot(a.plotX, a.plotY, {
                  inverted: d.inverted
                }) ? !1 : !1 !== a.visible && (e || !a.isNull);
              });
            };

            c.prototype.getClipBox = function () {
              var a = this.chart,
                  b = this.xAxis,
                  e = this.yAxis,
                  d = X(a.clipBox);
              b && b.len !== a.plotSizeX && (d.width = b.len);
              e && e.len !== a.plotSizeY && (d.height = e.len);
              return d;
            };

            c.prototype.getSharedClipKey = function () {
              return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
            };

            c.prototype.setClip = function () {
              var a = this.chart,
                  b = this.group,
                  e = this.markerGroup,
                  d = a.sharedClips;
              a = a.renderer;
              var c = this.getClipBox(),
                  g = this.getSharedClipKey(),
                  h = d[g];
              h ? h.animate(c) : d[g] = h = a.clipRect(c);
              b && b.clip(!1 === this.options.clip ? void 0 : h);
              e && e.clip();
            };

            c.prototype.animate = function (a) {
              var b = this.chart,
                  e = this.group,
                  d = this.markerGroup,
                  c = b.inverted,
                  g = k(this.options.animation),
                  h = [this.getSharedClipKey(), g.duration, g.easing, g.defer].join(),
                  l = b.sharedClips[h],
                  m = b.sharedClips[h + "m"];
              if (a && e) g = this.getClipBox(), l ? l.attr("height", g.height) : (g.width = 0, c && (g.x = b.plotHeight), l = b.renderer.clipRect(g), b.sharedClips[h] = l, m = b.renderer.clipRect({
                x: c ? (b.plotSizeX || 0) + 99 : -99,
                y: c ? -b.plotLeft : -b.plotTop,
                width: 99,
                height: c ? b.chartWidth : b.chartHeight
              }), b.sharedClips[h + "m"] = m), e.clip(l), d && d.clip(m);else if (l && !l.hasClass("highcharts-animating")) {
                b = this.getClipBox();
                var f = g.step;
                d && d.element.childNodes.length && (g.step = function (a, b) {
                  f && f.apply(b, arguments);
                  m && m.element && m.attr(b.prop, "width" === b.prop ? a + 99 : a);
                });
                l.addClass("highcharts-animating").animate(b, g);
              }
            };

            c.prototype.afterAnimate = function () {
              var a = this;
              this.setClip();
              H(this.chart.sharedClips, function (b, e, d) {
                b && !a.chart.container.querySelector('[clip-path="url(#'.concat(b.id, ')"]')) && (b.destroy(), delete d[e]);
              });
              this.finishedAnimating = !0;
              J(this, "afterAnimate");
            };

            c.prototype.drawPoints = function () {
              var a = this.points,
                  b = this.chart,
                  e = this.options.marker,
                  d = this[this.specialGroup] || this.markerGroup,
                  c = this.xAxis,
                  g = K(e.enabled, !c || c.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius),
                  h,
                  l;
              if (!1 !== e.enabled || this._hasPointMarkers) for (h = 0; h < a.length; h++) {
                var k = a[h];
                var m = (l = k.graphic) ? "animate" : "attr";
                var f = k.marker || {};
                var q = !!k.marker;

                if ((g && "undefined" === typeof f.enabled || f.enabled) && !k.isNull && !1 !== k.visible) {
                  var p = K(f.symbol, this.symbol, "rect");
                  var t = this.markerAttribs(k, k.selected && "select");
                  this.enabledDataSorting && (k.startXPos = c.reversed ? -(t.width || 0) : c.width);
                  var n = !1 !== k.isInside;
                  l ? l[n ? "show" : "hide"](n).animate(t) : n && (0 < (t.width || 0) || k.hasImage) && (k.graphic = l = b.renderer.symbol(p, t.x, t.y, t.width, t.height, q ? f : e).add(d), this.enabledDataSorting && b.hasRendered && (l.attr({
                    x: k.startXPos
                  }), m = "animate"));
                  l && "animate" === m && l[n ? "show" : "hide"](n).animate(t);
                  if (l && !b.styledMode) l[m](this.pointAttribs(k, k.selected && "select"));
                  l && l.addClass(k.getClassName(), !0);
                } else l && (k.graphic = l.destroy());
              }
            };

            c.prototype.markerAttribs = function (a, b) {
              var e = this.options,
                  d = e.marker,
                  c = a.marker || {},
                  g = c.symbol || d.symbol,
                  h = K(c.radius, d && d.radius);
              b && (d = d.states[b], b = c.states && c.states[b], h = K(b && b.radius, d && d.radius, h && h + (d && d.radiusPlus || 0)));
              a.hasImage = g && 0 === g.indexOf("url");
              a.hasImage && (h = 0);
              a = L(h) ? {
                x: e.crisp ? Math.floor(a.plotX - h) : a.plotX - h,
                y: a.plotY - h
              } : {};
              h && (a.width = a.height = 2 * h);
              return a;
            };

            c.prototype.pointAttribs = function (a, b) {
              var e = this.options.marker,
                  d = a && a.options,
                  c = d && d.marker || {},
                  g = d && d.color,
                  h = a && a.color,
                  l = a && a.zone && a.zone.color,
                  k = this.color;
              a = K(c.lineWidth, e.lineWidth);
              d = 1;
              k = g || l || h || k;
              g = c.fillColor || e.fillColor || k;
              h = c.lineColor || e.lineColor || k;
              b = b || "normal";
              e = e.states[b] || {};
              b = c.states && c.states[b] || {};
              a = K(b.lineWidth, e.lineWidth, a + K(b.lineWidthPlus, e.lineWidthPlus, 0));
              g = b.fillColor || e.fillColor || g;
              h = b.lineColor || e.lineColor || h;
              d = K(b.opacity, e.opacity, d);
              return {
                stroke: h,
                "stroke-width": a,
                fill: g,
                opacity: d
              };
            };

            c.prototype.destroy = function (a) {
              var b = this,
                  d = b.chart,
                  c = /AppleWebKit\/533/.test(E.navigator.userAgent),
                  g = b.data || [],
                  h,
                  l,
                  k,
                  m;
              J(b, "destroy", {
                keepEventsForUpdate: a
              });
              this.removeEvents(a);
              (b.axisTypes || []).forEach(function (a) {
                (m = b[a]) && m.series && (e(m.series, b), m.isDirty = m.forceRedraw = !0);
              });
              b.legendItem && b.chart.legend.destroyItem(b);

              for (l = g.length; l--;) {
                (k = g[l]) && k.destroy && k.destroy();
              }

              b.clips && b.clips.forEach(function (a) {
                return a.destroy();
              });
              n.clearTimeout(b.animationTimeout);
              H(b, function (a, b) {
                a instanceof u && !a.survive && (h = c && "group" === b ? "hide" : "destroy", a[h]());
              });
              d.hoverSeries === b && (d.hoverSeries = void 0);
              e(d.series, b);
              d.orderSeries();
              H(b, function (e, d) {
                a && "hcEvents" === d || delete b[d];
              });
            };

            c.prototype.applyZones = function () {
              var a = this,
                  b = this.chart,
                  e = b.renderer,
                  d = this.zones,
                  c = this.clips || [],
                  h = this.graph,
                  l = this.area,
                  k = Math.max(b.chartWidth, b.chartHeight),
                  m = this[(this.zoneAxis || "y") + "Axis"],
                  f = b.inverted,
                  q,
                  p,
                  t,
                  n,
                  w,
                  x,
                  z,
                  B,
                  y = !1;

              if (d.length && (h || l) && m && "undefined" !== typeof m.min) {
                var E = m.reversed;
                var u = m.horiz;
                h && !this.showLine && h.hide();
                l && l.hide();
                var r = m.getExtremes();
                d.forEach(function (d, J) {
                  q = E ? u ? b.plotWidth : 0 : u ? 0 : m.toPixels(r.min) || 0;
                  q = g(K(p, q), 0, k);
                  p = g(Math.round(m.toPixels(K(d.value, r.max), !0) || 0), 0, k);
                  y && (q = p = m.toPixels(r.max));
                  n = Math.abs(q - p);
                  w = Math.min(q, p);
                  x = Math.max(q, p);
                  m.isXAxis ? (t = {
                    x: f ? x : w,
                    y: 0,
                    width: n,
                    height: k
                  }, u || (t.x = b.plotHeight - t.x)) : (t = {
                    x: 0,
                    y: f ? x : w,
                    width: k,
                    height: n
                  }, u && (t.y = b.plotWidth - t.y));
                  f && e.isVML && (t = m.isXAxis ? {
                    x: 0,
                    y: E ? w : x,
                    height: t.width,
                    width: b.chartWidth
                  } : {
                    x: t.y - b.plotLeft - b.spacingBox.x,
                    y: 0,
                    width: t.height,
                    height: b.chartHeight
                  });
                  c[J] ? c[J].animate(t) : c[J] = e.clipRect(t);
                  z = a["zone-area-" + J];
                  B = a["zone-graph-" + J];
                  h && B && B.clip(c[J]);
                  l && z && z.clip(c[J]);
                  y = d.value > r.max;
                  a.resetZones && 0 === p && (p = void 0);
                });
                this.clips = c;
              } else a.visible && (h && h.show(), l && l.show());
            };

            c.prototype.invertGroups = function (a) {
              function b() {
                ["group", "markerGroup"].forEach(function (b) {
                  e[b] && (d.renderer.isVML && e[b].attr({
                    width: e.yAxis.len,
                    height: e.xAxis.len
                  }), e[b].width = e.yAxis.len, e[b].height = e.xAxis.len, e[b].invert(e.isRadialSeries ? !1 : a));
                });
              }

              var e = this,
                  d = e.chart;
              e.xAxis && (e.eventsToUnbind.push(t(d, "resize", b)), b(), e.invertGroups = b);
            };

            c.prototype.plotGroup = function (a, b, e, d, c) {
              var g = this[a],
                  h = !g;
              e = {
                visibility: e,
                zIndex: d || .1
              };
              "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (e.opacity = this.opacity);
              h && (this[a] = g = this.chart.renderer.g().add(c));
              g.addClass("highcharts-" + b + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (B(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (g.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
              g.attr(e)[h ? "attr" : "animate"](this.getPlotBox());
              return g;
            };

            c.prototype.getPlotBox = function () {
              var a = this.chart,
                  b = this.xAxis,
                  e = this.yAxis;
              a.inverted && (b = e, e = this.xAxis);
              return {
                translateX: b ? b.left : a.plotLeft,
                translateY: e ? e.top : a.plotTop,
                scaleX: 1,
                scaleY: 1
              };
            };

            c.prototype.removeEvents = function (a) {
              a || ba(this);
              this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
                a();
              }), this.eventsToUnbind.length = 0);
            };

            c.prototype.render = function () {
              var a = this,
                  b = a.chart,
                  e = a.options,
                  d = k(e.animation),
                  c = a.visible ? "inherit" : "hidden",
                  g = e.zIndex,
                  h = a.hasRendered,
                  l = b.seriesGroup,
                  m = b.inverted;
              b = !a.finishedAnimating && b.renderer.isSVG ? d.duration : 0;
              J(this, "render");
              var f = a.plotGroup("group", "series", c, g, l);
              a.markerGroup = a.plotGroup("markerGroup", "markers", c, g, l);
              !1 !== e.clip && a.setClip();
              a.animate && b && a.animate(!0);
              f.inverted = K(a.invertible, a.isCartesian) ? m : !1;
              a.drawGraph && (a.drawGraph(), a.applyZones());
              a.visible && a.drawPoints();
              a.drawDataLabels && a.drawDataLabels();
              a.redrawPoints && a.redrawPoints();
              a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
              a.invertGroups(m);
              a.animate && b && a.animate();
              h || (b && d.defer && (b += d.defer), a.animationTimeout = N(function () {
                a.afterAnimate();
              }, b || 0));
              a.isDirty = !1;
              a.hasRendered = !0;
              J(a, "afterRender");
            };

            c.prototype.redraw = function () {
              var a = this.chart,
                  b = this.isDirty || this.isDirtyData,
                  e = this.group,
                  d = this.xAxis,
                  c = this.yAxis;
              e && (a.inverted && e.attr({
                width: a.plotWidth,
                height: a.plotHeight
              }), e.animate({
                translateX: K(d && d.left, a.plotLeft),
                translateY: K(c && c.top, a.plotTop)
              }));
              this.translate();
              this.render();
              b && delete this.kdTree;
            };

            c.prototype.searchPoint = function (a, b) {
              var e = this.xAxis,
                  d = this.yAxis,
                  c = this.chart.inverted;
              return this.searchKDTree({
                clientX: c ? e.len - a.chartY + e.pos : a.chartX - e.pos,
                plotY: c ? d.len - a.chartX + d.pos : a.chartY - d.pos
              }, b, a);
            };

            c.prototype.buildKDTree = function (a) {
              function b(a, d, c) {
                var g = a && a.length;

                if (g) {
                  var h = e.kdAxisArray[d % c];
                  a.sort(function (a, b) {
                    return a[h] - b[h];
                  });
                  g = Math.floor(g / 2);
                  return {
                    point: a[g],
                    left: b(a.slice(0, g), d + 1, c),
                    right: b(a.slice(g + 1), d + 1, c)
                  };
                }
              }

              this.buildingKdTree = !0;
              var e = this,
                  d = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete e.kdTree;
              N(function () {
                e.kdTree = b(e.getValidPoints(null, !e.directTouch), d, d);
                e.buildingKdTree = !1;
              }, e.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
            };

            c.prototype.searchKDTree = function (a, b, e) {
              function d(a, b, e, k) {
                var m = b.point,
                    f = c.kdAxisArray[e % k],
                    q = m,
                    p = B(a[g]) && B(m[g]) ? Math.pow(a[g] - m[g], 2) : null;
                var t = B(a[h]) && B(m[h]) ? Math.pow(a[h] - m[h], 2) : null;
                t = (p || 0) + (t || 0);
                m.dist = B(t) ? Math.sqrt(t) : Number.MAX_VALUE;
                m.distX = B(p) ? Math.sqrt(p) : Number.MAX_VALUE;
                f = a[f] - m[f];
                t = 0 > f ? "left" : "right";
                p = 0 > f ? "right" : "left";
                b[t] && (t = d(a, b[t], e + 1, k), q = t[l] < q[l] ? t : m);
                b[p] && Math.sqrt(f * f) < q[l] && (a = d(a, b[p], e + 1, k), q = a[l] < q[l] ? a : q);
                return q;
              }

              var c = this,
                  g = this.kdAxisArray[0],
                  h = this.kdAxisArray[1],
                  l = b ? "distX" : "dist";
              b = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              this.kdTree || this.buildingKdTree || this.buildKDTree(e);
              if (this.kdTree) return d(a, this.kdTree, b, b);
            };

            c.prototype.pointPlacementToXValue = function () {
              var a = this.options,
                  b = a.pointRange,
                  e = this.xAxis;
              a = a.pointPlacement;
              "between" === a && (a = e.reversed ? -.5 : .5);
              return L(a) ? a * (b || e.pointRange) : 0;
            };

            c.prototype.isPointInside = function (a) {
              var b = this.chart,
                  e = this.xAxis,
                  d = this.yAxis;
              return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= (d ? d.len : b.plotHeight) && 0 <= a.plotX && a.plotX <= (e ? e.len : b.plotWidth);
            };

            c.prototype.drawTracker = function () {
              var a = this,
                  b = a.options,
                  e = b.trackByArea,
                  d = [].concat(e ? a.areaPath : a.graphPath),
                  c = a.chart,
                  g = c.pointer,
                  h = c.renderer,
                  l = c.options.tooltip.snap,
                  k = a.tracker,
                  m = function m(b) {
                if (c.hoverSeries !== a) a.onMouseOver();
              },
                  f = "rgba(192,192,192," + (z ? .0001 : .002) + ")";

              k ? k.attr({
                d: d
              }) : a.graph && (a.tracker = h.path(d).attr({
                visibility: a.visible ? "inherit" : "hidden",
                zIndex: 2
              }).addClass(e ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), c.styledMode || a.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: f,
                fill: e ? f : "none",
                "stroke-width": a.graph.strokeWidth() + (e ? 0 : 2 * l)
              }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function (a) {
                if (a && (a.addClass("highcharts-tracker").on("mouseover", m).on("mouseout", function (a) {
                  g.onTrackerMouseOut(a);
                }), b.cursor && !c.styledMode && a.css({
                  cursor: b.cursor
                }), p)) a.on("touchstart", m);
              }));
              J(this, "afterDrawTracker");
            };

            c.prototype.addPoint = function (a, b, e, d, c) {
              var g = this.options,
                  h = this.data,
                  l = this.chart,
                  k = this.xAxis;
              k = k && k.hasNames && k.names;
              var m = g.data,
                  f = this.xData,
                  q;
              b = K(b, !0);
              var p = {
                series: this
              };
              this.pointClass.prototype.applyOptions.apply(p, [a]);
              var t = p.x;
              var n = f.length;
              if (this.requireSorting && t < f[n - 1]) for (q = !0; n && f[n - 1] > t;) {
                n--;
              }
              this.updateParallelArrays(p, "splice", n, 0, 0);
              this.updateParallelArrays(p, n);
              k && p.name && (k[t] = p.name);
              m.splice(n, 0, a);
              if (q || this.processedData) this.data.splice(n, 0, null), this.processData();
              "point" === g.legendType && this.generatePoints();
              e && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(p, "shift"), m.shift()));
              !1 !== c && J(this, "addPoint", {
                point: p
              });
              this.isDirtyData = this.isDirty = !0;
              b && l.redraw(d);
            };

            c.prototype.removePoint = function (a, b, e) {
              var c = this,
                  g = c.data,
                  h = g[a],
                  l = c.points,
                  k = c.chart,
                  m = function m() {
                l && l.length === g.length && l.splice(a, 1);
                g.splice(a, 1);
                c.options.data.splice(a, 1);
                c.updateParallelArrays(h || {
                  series: c
                }, "splice", a, 1);
                h && h.destroy();
                c.isDirty = !0;
                c.isDirtyData = !0;
                b && k.redraw();
              };

              d(e, k);
              b = K(b, !0);
              h ? h.firePointEvent("remove", null, m) : m();
            };

            c.prototype.remove = function (a, b, e, d) {
              function c() {
                g.destroy(d);
                h.isDirtyLegend = h.isDirtyBox = !0;
                h.linkSeries();
                K(a, !0) && h.redraw(b);
              }

              var g = this,
                  h = g.chart;
              !1 !== e ? J(g, "remove", null, c) : c();
            };

            c.prototype.update = function (a, b) {
              a = w(a, this.userOptions);
              J(this, "update", {
                options: a
              });
              var e = this,
                  d = e.chart,
                  c = e.userOptions,
                  g = e.initialType || e.type,
                  h = d.options.plotOptions,
                  l = y[g].prototype,
                  k = e.finishedAnimating && {
                animation: !1
              },
                  f = {},
                  q,
                  p = ["eventOptions", "navigatorSeries", "baseSeries"],
                  t = a.type || c.type || d.options.chart.type,
                  n = !(this.hasDerivedData || t && t !== this.type || "undefined" !== typeof a.pointStart || "undefined" !== typeof a.pointInterval || "undefined" !== typeof a.relativeXValue || a.joinBy || a.mapData || e.hasOptionChanged("dataGrouping") || e.hasOptionChanged("pointStart") || e.hasOptionChanged("pointInterval") || e.hasOptionChanged("pointIntervalUnit") || e.hasOptionChanged("keys"));
              t = t || g;
              n && (p.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && p.push("area", "graph"), e.parallelArrays.forEach(function (a) {
                p.push(a + "Data");
              }), a.data && (a.dataSorting && m(e.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
              a = X(c, k, {
                index: "undefined" === typeof c.index ? e.index : c.index,
                pointStart: K(h && h.series && h.series.pointStart, c.pointStart, e.xData[0])
              }, !n && {
                data: e.options.data
              }, a);
              n && a.data && (a.data = e.options.data);
              p = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p);
              p.forEach(function (a) {
                p[a] = e[a];
                delete e[a];
              });
              h = !1;

              if (y[t]) {
                if (h = t !== e.type, e.remove(!1, !1, !1, !0), h) if (Object.setPrototypeOf) Object.setPrototypeOf(e, y[t].prototype);else {
                  k = Object.hasOwnProperty.call(e, "hcEvents") && e.hcEvents;

                  for (q in l) {
                    e[q] = void 0;
                  }

                  m(e, y[t].prototype);
                  k ? e.hcEvents = k : delete e.hcEvents;
                }
              } else G(17, !0, d, {
                missingModuleFor: t
              });

              p.forEach(function (a) {
                e[a] = p[a];
              });
              e.init(d, a);

              if (n && this.points) {
                var x = e.options;
                !1 === x.visible ? (f.graphic = 1, f.dataLabel = 1) : e._hasPointLabels || (a = x.marker, l = x.dataLabels, !a || !1 !== a.enabled && (c.marker && c.marker.symbol) === a.symbol || (f.graphic = 1), l && !1 === l.enabled && (f.dataLabel = 1));
                this.points.forEach(function (a) {
                  a && a.series && (a.resolveColor(), Object.keys(f).length && a.destroyElements(f), !1 === x.showInLegend && a.legendItem && d.legend.destroyItem(a));
                }, this);
              }

              e.initialType = g;
              d.linkSeries();
              h && e.linkedSeries.length && (e.isDirtyData = !0);
              J(this, "afterUpdate");
              K(b, !0) && d.redraw(n ? void 0 : !1);
            };

            c.prototype.setName = function (a) {
              this.name = this.options.name = this.userOptions.name = a;
              this.chart.isDirtyLegend = !0;
            };

            c.prototype.hasOptionChanged = function (a) {
              var b = this.options[a],
                  e = this.chart.options.plotOptions,
                  d = this.userOptions[a];
              return d ? b !== d : b !== K(e && e[this.type] && e[this.type][a], e && e.series && e.series[a], b);
            };

            c.prototype.onMouseOver = function () {
              var a = this.chart,
                  b = a.hoverSeries;
              a.pointer.setHoverChartIndex();
              if (b && b !== this) b.onMouseOut();
              this.options.events.mouseOver && J(this, "mouseOver");
              this.setState("hover");
              a.hoverSeries = this;
            };

            c.prototype.onMouseOut = function () {
              var a = this.options,
                  b = this.chart,
                  e = b.tooltip,
                  d = b.hoverPoint;
              b.hoverSeries = null;
              if (d) d.onMouseOut();
              this && a.events.mouseOut && J(this, "mouseOut");
              !e || this.stickyTracking || e.shared && !this.noSharedTooltip || e.hide();
              b.series.forEach(function (a) {
                a.setState("", !0);
              });
            };

            c.prototype.setState = function (a, b) {
              var e = this,
                  d = e.options,
                  c = e.graph,
                  g = d.inactiveOtherPoints,
                  h = d.states,
                  l = K(h[a || "normal"] && h[a || "normal"].animation, e.chart.options.chart.animation),
                  k = d.lineWidth,
                  m = 0,
                  f = d.opacity;
              a = a || "";

              if (e.state !== a && ([e.group, e.markerGroup, e.dataLabelsGroup].forEach(function (b) {
                b && (e.state && b.removeClass("highcharts-series-" + e.state), a && b.addClass("highcharts-series-" + a));
              }), e.state = a, !e.chart.styledMode)) {
                if (h[a] && !1 === h[a].enabled) return;
                a && (k = h[a].lineWidth || k + (h[a].lineWidthPlus || 0), f = K(h[a].opacity, f));
                if (c && !c.dashstyle) for (d = {
                  "stroke-width": k
                }, c.animate(d, l); e["zone-graph-" + m];) {
                  e["zone-graph-" + m].animate(d, l), m += 1;
                }
                g || [e.group, e.markerGroup, e.dataLabelsGroup, e.labelBySeries].forEach(function (a) {
                  a && a.animate({
                    opacity: f
                  }, l);
                });
              }

              b && g && e.points && e.setAllPointsToState(a || void 0);
            };

            c.prototype.setAllPointsToState = function (a) {
              this.points.forEach(function (b) {
                b.setState && b.setState(a);
              });
            };

            c.prototype.setVisible = function (a, b) {
              var e = this,
                  d = e.chart,
                  c = e.legendItem,
                  g = d.options.chart.ignoreHiddenSeries,
                  h = e.visible,
                  l = (e.visible = a = e.options.visible = e.userOptions.visible = "undefined" === typeof a ? !h : a) ? "show" : "hide";
              ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
                if (e[a]) e[a][l]();
              });
              if (d.hoverSeries === e || (d.hoverPoint && d.hoverPoint.series) === e) e.onMouseOut();
              c && d.legend.colorizeItem(e, a);
              e.isDirty = !0;
              e.options.stacking && d.series.forEach(function (a) {
                a.options.stacking && a.visible && (a.isDirty = !0);
              });
              e.linkedSeries.forEach(function (b) {
                b.setVisible(a, !1);
              });
              g && (d.isDirtyBox = !0);
              J(e, l);
              !1 !== b && d.redraw();
            };

            c.prototype.show = function () {
              this.setVisible(!0);
            };

            c.prototype.hide = function () {
              this.setVisible(!1);
            };

            c.prototype.select = function (a) {
              this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
              this.checkbox && (this.checkbox.checked = a);
              J(this, a ? "select" : "unselect");
            };

            c.prototype.shouldShowTooltip = function (a, b, e) {
              void 0 === e && (e = {});
              e.series = this;
              e.visiblePlotOnly = !0;
              return this.chart.isInsidePlot(a, b, e);
            };

            c.defaultOptions = F;
            return c;
          }();

          m(c.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: r.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: C,
            requireSorting: !0,
            sorted: !0
          });
          A.series = c;
          "";
          "";
          return c;
        });
        H(f, "Extensions/ScrollablePlotArea.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/Chart/Chart.js"], f["Core/Series/Series.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C) {
          var F = c.stop,
              A = C.addEvent,
              u = C.createElement,
              n = C.defined,
              k = C.merge,
              d = C.pick;
          A(v, "afterSetChartSize", function (b) {
            var d = this.options.chart.scrollablePlotArea,
                c = d && d.minWidth;
            d = d && d.minHeight;

            if (!this.renderer.forExport) {
              if (c) {
                if (this.scrollablePixelsX = c = Math.max(0, c - this.chartWidth)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = k(this.plotBox);
                  this.plotBox.width = this.plotWidth += c;
                  this.inverted ? this.clipBox.height += c : this.clipBox.width += c;
                  var z = {
                    1: {
                      name: "right",
                      value: c
                    }
                  };
                }
              } else d && (this.scrollablePixelsY = c = Math.max(0, d - this.chartHeight), n(c) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = k(this.plotBox), this.plotBox.height = this.plotHeight += c, this.inverted ? this.clipBox.width += c : this.clipBox.height += c, z = {
                2: {
                  name: "bottom",
                  value: c
                }
              }));

              z && !b.skipAxes && this.axes.forEach(function (b) {
                z[b.side] ? b.getPlotLinePath = function () {
                  var d = z[b.side].name,
                      c = this[d];
                  this[d] = c - z[b.side].value;
                  var h = f.prototype.getPlotLinePath.apply(this, arguments);
                  this[d] = c;
                  return h;
                } : (b.setAxisSize(), b.setAxisTranslation());
              });
            }
          });
          A(v, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });

          v.prototype.setUpScrolling = function () {
            var b = this,
                d = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            this.scrollablePixelsX && (d.overflowX = "auto");
            this.scrollablePixelsY && (d.overflowY = "auto");
            this.scrollingParent = u("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = u("div", {
              className: "highcharts-scrolling"
            }, d, this.scrollingParent);
            A(this.scrollingContainer, "scroll", function () {
              b.pointer && delete b.pointer.chartPosition;
            });
            this.innerContainer = u("div", {
              className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };

          v.prototype.moveFixedElements = function () {
            var b = this.container,
                d = this.fixedRenderer,
                c = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
                k;
            this.scrollablePixelsX && !this.inverted ? k = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? k = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? k = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (k = ".highcharts-yaxis");
            k && c.push("" + k + ":not(.highcharts-radial-axis)", "" + k + "-labels:not(.highcharts-radial-axis-labels)");
            c.forEach(function (c) {
              [].forEach.call(b.querySelectorAll(c), function (b) {
                (b.namespaceURI === d.SVG_NS ? d.box : d.box.parentNode).appendChild(b);
                b.style.pointerEvents = "auto";
              });
            });
          };

          v.prototype.applyFixed = function () {
            var b = !this.fixedDiv,
                c = this.options.chart,
                k = c.scrollablePlotArea,
                f = r.getRendererType();
            b ? (this.fixedDiv = u("div", {
              className: "highcharts-fixed"
            }, {
              position: "absolute",
              overflow: "hidden",
              pointerEvents: "none",
              zIndex: (c.style && c.style.zIndex || 0) + 2,
              top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = c = new f(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({
              fill: this.options.chart.backgroundColor || "#fff",
              "fill-opacity": d(k.opacity, .85),
              zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), A(this, "afterShowResetZoom", this.moveFixedElements), A(this, "afterApplyDrilldown", this.moveFixedElements), A(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || b) this.scrollableDirty = !1, this.moveFixedElements();
            c = this.chartWidth + (this.scrollablePixelsX || 0);
            f = this.chartHeight + (this.scrollablePixelsY || 0);
            F(this.container);
            this.container.style.width = c + "px";
            this.container.style.height = f + "px";
            this.renderer.boxWrapper.attr({
              width: c,
              height: f,
              viewBox: [0, 0, c, f].join(" ")
            });
            this.chartBackground.attr({
              width: c,
              height: f
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            b && (k.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * k.scrollPositionX), k.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * k.scrollPositionY));
            f = this.axisOffset;
            b = this.plotTop - f[0] - 1;
            k = this.plotLeft - f[3] - 1;
            c = this.plotTop + this.plotHeight + f[2] + 1;
            f = this.plotLeft + this.plotWidth + f[1] + 1;
            var n = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                y = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            b = this.scrollablePixelsX ? [["M", 0, b], ["L", this.plotLeft - 1, b], ["L", this.plotLeft - 1, c], ["L", 0, c], ["Z"], ["M", n, b], ["L", this.chartWidth, b], ["L", this.chartWidth, c], ["L", n, c], ["Z"]] : this.scrollablePixelsY ? [["M", k, 0], ["L", k, this.plotTop - 1], ["L", f, this.plotTop - 1], ["L", f, 0], ["Z"], ["M", k, y], ["L", k, this.chartHeight], ["L", f, this.chartHeight], ["L", f, y], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
              d: b
            });
          };

          A(f, "afterInit", function () {
            this.chart.scrollableDirty = !0;
          });
          A(D, "show", function () {
            this.chart.scrollableDirty = !0;
          });
          "";
        });
        H(f, "Core/Axis/StackingAxis.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = c.getDeferredAnimation,
              r = v.addEvent,
              C = v.destroyObjectProperties,
              F = v.fireEvent,
              A = v.isNumber,
              u = v.objectEach,
              n;

          (function (c) {
            function d() {
              var b = this.stacking;

              if (b) {
                var d = b.stacks;
                u(d, function (b, c) {
                  C(b);
                  d[c] = null;
                });
                b && b.stackTotalGroup && b.stackTotalGroup.destroy();
              }
            }

            function b() {
              this.stacking || (this.stacking = new k(this));
            }

            var h = [];

            c.compose = function (c) {
              -1 === h.indexOf(c) && (h.push(c), r(c, "init", b), r(c, "destroy", d));
              return c;
            };

            var k = function () {
              function b(b) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = b;
              }

              b.prototype.buildStacks = function () {
                var b = this.axis,
                    d = b.series,
                    c = b.options.reversedStacks,
                    h = d.length,
                    l;

                if (!b.isXAxis) {
                  this.usePercentage = !1;

                  for (l = h; l--;) {
                    var g = d[c ? l : h - l - 1];
                    g.setStackedPoints();
                    g.setGroupedPoints();
                  }

                  for (l = 0; l < h; l++) {
                    d[l].modifyStacks();
                  }

                  F(b, "afterBuildStacks");
                }
              };

              b.prototype.cleanStacks = function () {
                if (!this.axis.isXAxis) {
                  if (this.oldStacks) var b = this.stacks = this.oldStacks;
                  u(b, function (b) {
                    u(b, function (b) {
                      b.cumulative = b.total;
                    });
                  });
                }
              };

              b.prototype.resetStacks = function () {
                var b = this,
                    d = b.stacks;
                b.axis.isXAxis || u(d, function (d) {
                  u(d, function (c, h) {
                    A(c.touched) && c.touched < b.stacksTouched ? (c.destroy(), delete d[h]) : (c.total = null, c.cumulative = null);
                  });
                });
              };

              b.prototype.renderStackTotals = function () {
                var b = this.axis,
                    d = b.chart,
                    c = d.renderer,
                    h = this.stacks;
                b = D(d, b.options.stackLabels && b.options.stackLabels.animation || !1);
                var l = this.stackTotalGroup = this.stackTotalGroup || c.g("stack-labels").attr({
                  zIndex: 6,
                  opacity: 0
                }).add();
                l.translate(d.plotLeft, d.plotTop);
                u(h, function (b) {
                  u(b, function (b) {
                    b.render(l);
                  });
                });
                l.animate({
                  opacity: 1
                }, b);
              };

              return b;
            }();

            c.Additions = k;
          })(n || (n = {}));

          return n;
        });
        H(f, "Extensions/Stacking.js", [f["Core/Axis/Axis.js"], f["Core/Chart/Chart.js"], f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Series/Series.js"], f["Core/Axis/StackingAxis.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F) {
          var A = v.format,
              u = F.correctFloat,
              n = F.defined,
              k = F.destroyObjectProperties,
              d = F.isArray,
              b = F.isNumber,
              h = F.objectEach,
              p = F.pick,
              z = function () {
            function d(b, d, c, h, g) {
              var l = b.chart.inverted;
              this.axis = b;
              this.isNegative = c;
              this.options = d = d || {};
              this.x = h;
              this.total = null;
              this.points = {};
              this.hasValidPoints = !1;
              this.stack = g;
              this.rightCliff = this.leftCliff = 0;
              this.alignOptions = {
                align: d.align || (l ? c ? "left" : "right" : "center"),
                verticalAlign: d.verticalAlign || (l ? "middle" : c ? "bottom" : "top"),
                y: d.y,
                x: d.x
              };
              this.textAlign = d.textAlign || (l ? c ? "right" : "left" : "center");
            }

            d.prototype.destroy = function () {
              k(this, this.axis);
            };

            d.prototype.render = function (b) {
              var d = this.axis.chart,
                  c = this.options,
                  h = c.format;
              h = h ? A(h, this, d) : c.formatter.call(this);
              this.label ? this.label.attr({
                text: h,
                visibility: "hidden"
              }) : (this.label = d.renderer.label(h, null, null, c.shape, null, null, c.useHTML, !1, "stack-labels"), h = {
                r: c.borderRadius || 0,
                text: h,
                rotation: c.rotation,
                padding: p(c.padding, 5),
                visibility: "hidden"
              }, d.styledMode || (h.fill = c.backgroundColor, h.stroke = c.borderColor, h["stroke-width"] = c.borderWidth, this.label.css(c.style)), this.label.attr(h), this.label.added || this.label.add(b));
              this.label.labelrank = d.plotSizeY;
            };

            d.prototype.setOffset = function (d, c, h, l, g) {
              var k = this.axis,
                  a = k.chart;
              l = k.translate(k.stacking.usePercentage ? 100 : l ? l : this.total, 0, 0, 0, 1);
              h = k.translate(h ? h : 0);
              h = n(l) && Math.abs(l - h);
              d = p(g, a.xAxis[0].translate(this.x)) + d;
              k = n(l) && this.getStackBox(a, this, d, l, c, h, k);
              c = this.label;
              h = this.isNegative;
              d = "justify" === p(this.options.overflow, "justify");
              var f = this.textAlign;
              c && k && (g = c.getBBox(), l = c.padding, f = "left" === f ? a.inverted ? -l : l : "right" === f ? g.width : a.inverted && "center" === f ? g.width / 2 : a.inverted ? h ? g.width + l : -l : g.width / 2, h = a.inverted ? g.height / 2 : h ? -l : g.height, this.alignOptions.x = p(this.options.x, 0), this.alignOptions.y = p(this.options.y, 0), k.x -= f, k.y -= h, c.align(this.alignOptions, null, k), a.isInsidePlot(c.alignAttr.x + f - this.alignOptions.x, c.alignAttr.y + h - this.alignOptions.y) ? c.show() : (c.hide(), d = !1), d && r.prototype.justifyDataLabel.call(this.axis, c, this.alignOptions, c.alignAttr, g, k), c.attr({
                x: c.alignAttr.x,
                y: c.alignAttr.y
              }), p(!d && this.options.crop, !0) && ((a = b(c.x) && b(c.y) && a.isInsidePlot(c.x - l + c.width, c.y) && a.isInsidePlot(c.x + l, c.y)) || c.hide()));
            };

            d.prototype.getStackBox = function (b, d, c, h, g, k, a) {
              var l = d.axis.reversed,
                  e = b.inverted,
                  f = a.height + a.pos - (e ? b.plotLeft : b.plotTop);
              d = d.isNegative && !l || !d.isNegative && l;
              return {
                x: e ? d ? h - a.right : h - k + a.pos - b.plotLeft : c + b.xAxis[0].transB - b.plotLeft,
                y: e ? a.height - c - g : d ? f - h - k : f - h,
                width: e ? k : g,
                height: e ? g : k
              };
            };

            return d;
          }();

          f.prototype.getStacks = function () {
            var b = this,
                d = b.inverted;
            b.yAxis.forEach(function (b) {
              b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);
            });
            b.series.forEach(function (c) {
              var h = c.xAxis && c.xAxis.options || {};
              !c.options.stacking || !0 !== c.visible && !1 !== b.options.chart.ignoreHiddenSeries || (c.stackKey = [c.type, p(c.options.stack, ""), d ? h.top : h.left, d ? h.height : h.width].join());
            });
          };

          C.compose(c);

          r.prototype.setGroupedPoints = function () {
            var b = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? r.prototype.setStackedPoints.call(this, "group") : b && h(b.stacks, function (d, c) {
              "group" === c.slice(-5) && (h(d, function (b) {
                return b.destroy();
              }), delete b.stacks[c]);
            });
          };

          r.prototype.setStackedPoints = function (b) {
            var c = b || this.options.stacking;

            if (c && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
              var h = this.processedXData,
                  k = this.processedYData,
                  l = [],
                  g = k.length,
                  f = this.options,
                  a = f.threshold,
                  B = p(f.startFromThreshold && a, 0);
              f = f.stack;
              b = b ? "" + this.type + ",".concat(c) : this.stackKey;
              var e = "-" + b,
                  E = this.negStacks,
                  m = this.yAxis,
                  x = m.stacking.stacks,
                  r = m.stacking.oldStacks,
                  A,
                  v;
              m.stacking.stacksTouched += 1;

              for (v = 0; v < g; v++) {
                var F = h[v];
                var C = k[v];
                var D = this.getStackIndicator(D, F, this.index);
                var I = D.key;
                var K = (A = E && C < (B ? 0 : a)) ? e : b;
                x[K] || (x[K] = {});
                x[K][F] || (r[K] && r[K][F] ? (x[K][F] = r[K][F], x[K][F].total = null) : x[K][F] = new z(m, m.options.stackLabels, A, F, f));
                K = x[K][F];
                null !== C ? (K.points[I] = K.points[this.index] = [p(K.cumulative, B)], n(K.cumulative) || (K.base = I), K.touched = m.stacking.stacksTouched, 0 < D.index && !1 === this.singleStacks && (K.points[I][0] = K.points[this.index + "," + F + ",0"][0])) : K.points[I] = K.points[this.index] = null;
                "percent" === c ? (A = A ? b : e, E && x[A] && x[A][F] ? (A = x[A][F], K.total = A.total = Math.max(A.total, K.total) + Math.abs(C) || 0) : K.total = u(K.total + (Math.abs(C) || 0))) : "group" === c ? (d(C) && (C = C[0]), null !== C && (K.total = (K.total || 0) + 1)) : K.total = u(K.total + (C || 0));
                K.cumulative = "group" === c ? (K.total || 1) - 1 : p(K.cumulative, B) + (C || 0);
                null !== C && (K.points[I].push(K.cumulative), l[v] = K.cumulative, K.hasValidPoints = !0);
              }

              "percent" === c && (m.stacking.usePercentage = !0);
              "group" !== c && (this.stackedYData = l);
              m.stacking.oldStacks = {};
            }
          };

          r.prototype.modifyStacks = function () {
            var b = this,
                d = b.stackKey,
                c = b.yAxis.stacking.stacks,
                h = b.processedXData,
                l,
                g = b.options.stacking;
            b[g + "Stacker"] && [d, "-" + d].forEach(function (d) {
              for (var a = h.length, k, e; a--;) {
                if (k = h[a], l = b.getStackIndicator(l, k, b.index, d), e = (k = c[d] && c[d][k]) && k.points[l.key]) b[g + "Stacker"](e, k, a);
              }
            });
          };

          r.prototype.percentStacker = function (b, d, c) {
            d = d.total ? 100 / d.total : 0;
            b[0] = u(b[0] * d);
            b[1] = u(b[1] * d);
            this.stackedYData[c] = b[1];
          };

          r.prototype.getStackIndicator = function (b, d, c, h) {
            !n(b) || b.x !== d || h && b.stackKey !== h ? b = {
              x: d,
              index: 0,
              key: h,
              stackKey: h
            } : b.index++;
            b.key = [c, d, b.index].join();
            return b;
          };

          D.StackItem = z;
          "";
          return D.StackItem;
        });
        H(f, "Series/Line/LineSeries.js", [f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = this && this.__extends || function () {
            var _c10 = function c(f, u) {
              _c10 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, k) {
                c.__proto__ = k;
              } || function (c, k) {
                for (var d in k) {
                  k.hasOwnProperty(d) && (c[d] = k[d]);
                }
              };

              return _c10(f, u);
            };

            return function (f, u) {
              function n() {
                this.constructor = f;
              }

              _c10(f, u);

              f.prototype = null === u ? Object.create(u) : (n.prototype = u.prototype, new n());
            };
          }(),
              r = v.defined,
              C = v.merge;

          v = function (f) {
            function A() {
              var c = null !== f && f.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            D(A, f);

            A.prototype.drawGraph = function () {
              var c = this,
                  f = this.options,
                  k = (this.gappedPath || this.getGraphPath).call(this),
                  d = this.chart.styledMode,
                  b = [["graph", "highcharts-graph"]];
              d || b[0].push(f.lineColor || this.color || "#cccccc", f.dashStyle);
              b = c.getZonesGraphs(b);
              b.forEach(function (b, p) {
                var h = b[0],
                    n = c[h],
                    y = n ? "animate" : "attr";
                n ? (n.endX = c.preventGraphAnimation ? null : k.xMap, n.animate({
                  d: k
                })) : k.length && (c[h] = n = c.chart.renderer.path(k).addClass(b[1]).attr({
                  zIndex: 1
                }).add(c.group));
                n && !d && (h = {
                  stroke: b[2],
                  "stroke-width": f.lineWidth,
                  fill: c.fillGraph && c.color || "none"
                }, b[3] ? h.dashstyle = b[3] : "square" !== f.linecap && (h["stroke-linecap"] = h["stroke-linejoin"] = "round"), n[y](h).shadow(2 > p && f.shadow));
                n && (n.startX = k.xMap, n.isArea = k.isArea);
              });
            };

            A.prototype.getGraphPath = function (c, f, k) {
              var d = this,
                  b = d.options,
                  h = [],
                  p = [],
                  n,
                  u = b.step;
              c = c || d.points;
              var y = c.reversed;
              y && c.reverse();
              (u = {
                right: 1,
                center: 2
              }[u] || u && 3) && y && (u = 4 - u);
              c = this.getValidPoints(c, !1, !(b.connectNulls && !f && !k));
              c.forEach(function (t, q) {
                var l = t.plotX,
                    g = t.plotY,
                    w = c[q - 1];
                (t.leftCliff || w && w.rightCliff) && !k && (n = !0);
                t.isNull && !r(f) && 0 < q ? n = !b.connectNulls : t.isNull && !f ? n = !0 : (0 === q || n ? q = [["M", t.plotX, t.plotY]] : d.getPointSpline ? q = [d.getPointSpline(c, t, q)] : u ? (q = 1 === u ? [["L", w.plotX, g]] : 2 === u ? [["L", (w.plotX + l) / 2, w.plotY], ["L", (w.plotX + l) / 2, g]] : [["L", l, w.plotY]], q.push(["L", l, g])) : q = [["L", l, g]], p.push(t.x), u && (p.push(t.x), 2 === u && p.push(t.x)), h.push.apply(h, q), n = !1);
              });
              h.xMap = p;
              return d.graphPath = h;
            };

            A.prototype.getZonesGraphs = function (c) {
              this.zones.forEach(function (f, k) {
                k = ["zone-graph-" + k, "highcharts-graph highcharts-zone-graph-" + k + " " + (f.className || "")];
                this.chart.styledMode || k.push(f.color || this.color, f.dashStyle || this.options.dashStyle);
                c.push(k);
              }, this);
              return c;
            };

            A.defaultOptions = C(c.defaultOptions, {});
            return A;
          }(c);

          f.registerSeriesType("line", v);
          "";
          return v;
        });
        H(f, "Series/Area/AreaSeries.js", [f["Core/Color/Color.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = this && this.__extends || function () {
            var _c11 = function c(d, b) {
              _c11 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _c11(d, b);
            };

            return function (d, b) {
              function h() {
                this.constructor = d;
              }

              _c11(d, b);

              d.prototype = null === b ? Object.create(b) : (h.prototype = b.prototype, new h());
            };
          }(),
              C = c.parse,
              F = v.seriesTypes.line;

          c = D.extend;
          var A = D.merge,
              u = D.objectEach,
              n = D.pick;

          D = function (c) {
            function d() {
              var b = null !== c && c.apply(this, arguments) || this;
              b.data = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            r(d, c);

            d.prototype.drawGraph = function () {
              this.areaPath = [];
              c.prototype.drawGraph.apply(this);
              var b = this,
                  d = this.areaPath,
                  k = this.options,
                  f = [["area", "highcharts-area", this.color, k.fillColor]];
              this.zones.forEach(function (c, d) {
                f.push(["zone-area-" + d, "highcharts-area highcharts-zone-area-" + d + " " + c.className, c.color || b.color, c.fillColor || k.fillColor]);
              });
              f.forEach(function (c) {
                var h = c[0],
                    f = {},
                    q = b[h],
                    l = q ? "animate" : "attr";
                q ? (q.endX = b.preventGraphAnimation ? null : d.xMap, q.animate({
                  d: d
                })) : (f.zIndex = 0, q = b[h] = b.chart.renderer.path(d).addClass(c[1]).add(b.group), q.isArea = !0);
                b.chart.styledMode || (f.fill = n(c[3], C(c[2]).setOpacity(n(k.fillOpacity, .75)).get()));
                q[l](f);
                q.startX = d.xMap;
                q.shiftUnit = k.step ? 2 : 1;
              });
            };

            d.prototype.getGraphPath = function (b) {
              var c = F.prototype.getGraphPath,
                  d = this.options,
                  k = d.stacking,
                  f = this.yAxis,
                  y = [],
                  t = [],
                  q = this.index,
                  l = f.stacking.stacks[this.stackKey],
                  g = d.threshold,
                  w = Math.round(f.getThreshold(d.threshold));
              d = n(d.connectNulls, "percent" === k);

              var a = function a(_a10, e, c) {
                var d = b[_a10];
                _a10 = k && l[d.x].points[q];
                var h = d[c + "Null"] || 0;
                c = d[c + "Cliff"] || 0;
                d = !0;

                if (c || h) {
                  var p = (h ? _a10[0] : _a10[1]) + c;
                  var n = _a10[0] + c;
                  d = !!h;
                } else !k && b[e] && b[e].isNull && (p = n = g);

                "undefined" !== typeof p && (t.push({
                  plotX: m,
                  plotY: null === p ? w : f.getThreshold(p),
                  isNull: d,
                  isCliff: !0
                }), y.push({
                  plotX: m,
                  plotY: null === n ? w : f.getThreshold(n),
                  doCurve: !1
                }));
              };

              b = b || this.points;
              k && (b = this.getStackPoints(b));

              for (var B = 0, e = b.length; B < e; ++B) {
                k || (b[B].leftCliff = b[B].rightCliff = b[B].leftNull = b[B].rightNull = void 0);
                var u = b[B].isNull;
                var m = n(b[B].rectPlotX, b[B].plotX);
                var x = k ? n(b[B].yBottom, w) : w;
                if (!u || d) d || a(B, B - 1, "left"), u && !k && d || (t.push(b[B]), y.push({
                  x: B,
                  plotX: m,
                  plotY: x
                })), d || a(B, B + 1, "right");
              }

              a = c.call(this, t, !0, !0);
              y.reversed = !0;
              u = c.call(this, y, !0, !0);
              (x = u[0]) && "M" === x[0] && (u[0] = ["L", x[1], x[2]]);
              u = a.concat(u);
              u.length && u.push(["Z"]);
              c = c.call(this, t, !1, d);
              u.xMap = a.xMap;
              this.areaPath = u;
              return c;
            };

            d.prototype.getStackPoints = function (b) {
              var c = this,
                  d = [],
                  k = [],
                  f = this.xAxis,
                  y = this.yAxis,
                  t = y.stacking.stacks[this.stackKey],
                  q = {},
                  l = y.series,
                  g = l.length,
                  w = y.options.reversedStacks ? 1 : -1,
                  a = l.indexOf(c);
              b = b || this.points;

              if (this.options.stacking) {
                for (var B = 0; B < b.length; B++) {
                  b[B].leftNull = b[B].rightNull = void 0, q[b[B].x] = b[B];
                }

                u(t, function (a, b) {
                  null !== a.total && k.push(b);
                });
                k.sort(function (a, b) {
                  return a - b;
                });
                var e = l.map(function (a) {
                  return a.visible;
                });
                k.forEach(function (b, h) {
                  var m = 0,
                      p,
                      B;
                  if (q[b] && !q[b].isNull) d.push(q[b]), [-1, 1].forEach(function (d) {
                    var f = 1 === d ? "rightNull" : "leftNull",
                        m = t[k[h + d]],
                        n = 0;
                    if (m) for (var x = a; 0 <= x && x < g;) {
                      var z = l[x].index;
                      p = m.points[z];
                      p || (z === c.index ? q[b][f] = !0 : e[x] && (B = t[b].points[z]) && (n -= B[1] - B[0]));
                      x += w;
                    }
                    q[b][1 === d ? "rightCliff" : "leftCliff"] = n;
                  });else {
                    for (var z = a; 0 <= z && z < g;) {
                      if (p = t[b].points[l[z].index]) {
                        m = p[1];
                        break;
                      }

                      z += w;
                    }

                    m = n(m, 0);
                    m = y.translate(m, 0, 1, 0, 1);
                    d.push({
                      isNull: !0,
                      plotX: f.translate(b, 0, 0, 0, 1),
                      x: b,
                      plotY: m,
                      yBottom: m
                    });
                  }
                });
              }

              return d;
            };

            d.defaultOptions = A(F.defaultOptions, {
              threshold: 0
            });
            return d;
          }(F);

          c(D.prototype, {
            singleStacks: !1,
            drawLegendSymbol: f.drawRectangle
          });
          v.registerSeriesType("area", D);
          "";
          return D;
        });
        H(f, "Series/Spline/SplineSeries.js", [f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = this && this.__extends || function () {
            var _c12 = function c(f, u) {
              _c12 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, k) {
                c.__proto__ = k;
              } || function (c, k) {
                for (var d in k) {
                  k.hasOwnProperty(d) && (c[d] = k[d]);
                }
              };

              return _c12(f, u);
            };

            return function (f, u) {
              function n() {
                this.constructor = f;
              }

              _c12(f, u);

              f.prototype = null === u ? Object.create(u) : (n.prototype = u.prototype, new n());
            };
          }(),
              D = c.seriesTypes.line,
              r = f.merge,
              C = f.pick;

          f = function (c) {
            function f() {
              var f = null !== c && c.apply(this, arguments) || this;
              f.data = void 0;
              f.options = void 0;
              f.points = void 0;
              return f;
            }

            v(f, c);

            f.prototype.getPointSpline = function (c, f, k) {
              var d = f.plotX || 0,
                  b = f.plotY || 0,
                  h = c[k - 1];
              k = c[k + 1];

              if (h && !h.isNull && !1 !== h.doCurve && !f.isCliff && k && !k.isNull && !1 !== k.doCurve && !f.isCliff) {
                c = h.plotY || 0;
                var p = k.plotX || 0;
                k = k.plotY || 0;
                var n = 0;
                var u = (1.5 * d + (h.plotX || 0)) / 2.5;
                var y = (1.5 * b + c) / 2.5;
                p = (1.5 * d + p) / 2.5;
                var t = (1.5 * b + k) / 2.5;
                p !== u && (n = (t - y) * (p - d) / (p - u) + b - t);
                y += n;
                t += n;
                y > c && y > b ? (y = Math.max(c, b), t = 2 * b - y) : y < c && y < b && (y = Math.min(c, b), t = 2 * b - y);
                t > k && t > b ? (t = Math.max(k, b), y = 2 * b - t) : t < k && t < b && (t = Math.min(k, b), y = 2 * b - t);
                f.rightContX = p;
                f.rightContY = t;
              }

              f = ["C", C(h.rightContX, h.plotX, 0), C(h.rightContY, h.plotY, 0), C(u, d, 0), C(y, b, 0), d, b];
              h.rightContX = h.rightContY = void 0;
              return f;
            };

            f.defaultOptions = r(D.defaultOptions);
            return f;
          }(D);

          c.registerSeriesType("spline", f);
          "";
          return f;
        });
        H(f, "Series/AreaSpline/AreaSplineSeries.js", [f["Series/Spline/SplineSeries.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = this && this.__extends || function () {
            var _c13 = function c(k, d) {
              _c13 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _c13(k, d);
            };

            return function (k, d) {
              function b() {
                this.constructor = k;
              }

              _c13(k, d);

              k.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              C = v.seriesTypes,
              F = C.area;

          C = C.area.prototype;
          var A = D.extend,
              u = D.merge;

          D = function (f) {
            function k() {
              var c = null !== f && f.apply(this, arguments) || this;
              c.data = void 0;
              c.points = void 0;
              c.options = void 0;
              return c;
            }

            r(k, f);
            k.defaultOptions = u(c.defaultOptions, F.defaultOptions);
            return k;
          }(c);

          A(D.prototype, {
            getGraphPath: C.getGraphPath,
            getStackPoints: C.getStackPoints,
            drawGraph: C.drawGraph,
            drawLegendSymbol: f.drawRectangle
          });
          v.registerSeriesType("areaspline", D);
          "";
          return D;
        });
        H(f, "Series/Column/ColumnSeries.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F) {
          var A = this && this.__extends || function () {
            var _b9 = function b(c, a) {
              _b9 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var c in b) {
                  b.hasOwnProperty(c) && (a[c] = b[c]);
                }
              };

              return _b9(c, a);
            };

            return function (c, a) {
              function d() {
                this.constructor = c;
              }

              _b9(c, a);

              c.prototype = null === a ? Object.create(a) : (d.prototype = a.prototype, new d());
            };
          }(),
              u = c.animObject,
              n = f.parse,
              k = v.hasTouch;

          c = v.noop;
          var d = F.clamp,
              b = F.css,
              h = F.defined,
              p = F.extend,
              z = F.fireEvent,
              E = F.isArray,
              y = F.isNumber,
              t = F.merge,
              q = F.pick,
              l = F.objectEach;

          F = function (c) {
            function g() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.borderWidth = void 0;
              a.data = void 0;
              a.group = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            A(g, c);

            g.prototype.animate = function (a) {
              var b = this,
                  c = this.yAxis,
                  g = b.options,
                  h = this.chart.inverted,
                  l = {},
                  k = h ? "translateX" : "translateY";
              if (a) l.scaleY = .001, a = d(c.toPixels(g.threshold), c.pos, c.pos + c.len), h ? l.translateX = a - c.len : l.translateY = a, b.clipBox && b.setClip(), b.group.attr(l);else {
                var f = Number(b.group.attr(k));
                b.group.animate({
                  scaleY: 1
                }, p(u(b.options.animation), {
                  step: function step(a, e) {
                    b.group && (l[k] = f + e.pos * (c.pos - f), b.group.attr(l));
                  }
                }));
              }
            };

            g.prototype.init = function (a, b) {
              c.prototype.init.apply(this, arguments);
              var e = this;
              a = e.chart;
              a.hasRendered && a.series.forEach(function (a) {
                a.type === e.type && (a.isDirty = !0);
              });
            };

            g.prototype.getColumnMetrics = function () {
              var a = this,
                  b = a.options,
                  c = a.xAxis,
                  d = a.yAxis,
                  g = c.options.reversedStacks;
              g = c.reversed && !g || !c.reversed && g;
              var h = {},
                  l,
                  k = 0;
              !1 === b.grouping ? k = 1 : a.chart.series.forEach(function (b) {
                var c = b.yAxis,
                    e = b.options;

                if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && d.len === c.len && d.pos === c.pos) {
                  if (e.stacking && "group" !== e.stacking) {
                    l = b.stackKey;
                    "undefined" === typeof h[l] && (h[l] = k++);
                    var g = h[l];
                  } else !1 !== e.grouping && (g = k++);

                  b.columnIndex = g;
                }
              });
              var f = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
                  p = f * b.groupPadding,
                  n = (f - 2 * p) / (k || 1);
              b = Math.min(b.maxPointWidth || c.len, q(b.pointWidth, n * (1 - 2 * b.pointPadding)));
              a.columnMetrics = {
                width: b,
                offset: (n - b) / 2 + (p + ((a.columnIndex || 0) + (g ? 1 : 0)) * n - f / 2) * (g ? -1 : 1),
                paddedWidth: n,
                columnCount: k
              };
              return a.columnMetrics;
            };

            g.prototype.crispCol = function (a, b, c, d) {
              var e = this.chart,
                  g = this.borderWidth,
                  h = -(g % 2 ? .5 : 0);
              g = g % 2 ? .5 : 1;
              e.inverted && e.renderer.isVML && (g += 1);
              this.options.crisp && (c = Math.round(a + c) + h, a = Math.round(a) + h, c -= a);
              d = Math.round(b + d) + g;
              h = .5 >= Math.abs(b) && .5 < d;
              b = Math.round(b) + g;
              d -= b;
              h && d && (--b, d += 1);
              return {
                x: a,
                y: b,
                width: c,
                height: d
              };
            };

            g.prototype.adjustForMissingColumns = function (a, b, c, d) {
              var e = this,
                  g = this.options.stacking;

              if (!c.isNull && 1 < d.columnCount) {
                var h = this.yAxis.options.reversedStacks,
                    k = 0,
                    f = h ? 0 : -d.columnCount;
                l(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {
                  if ("number" === typeof c.x && (a = a[c.x.toString()])) {
                    var b = a.points[e.index],
                        d = a.total;
                    g ? (b && (k = f), a.hasValidPoints && (h ? f++ : f--)) : E(b) && (k = b[1], f = d || 0);
                  }
                });
                a = (c.plotX || 0) + ((f - 1) * d.paddedWidth + b) / 2 - b - k * d.paddedWidth;
              }

              return a;
            };

            g.prototype.translate = function () {
              var a = this,
                  b = a.chart,
                  c = a.options,
                  g = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
              g = a.borderWidth = q(c.borderWidth, g ? 0 : 1);
              var l = a.xAxis,
                  k = a.yAxis,
                  f = c.threshold,
                  p = a.translatedThreshold = k.getThreshold(f),
                  n = q(c.minPointLength, 5),
                  t = a.getColumnMetrics(),
                  w = t.width,
                  z = a.pointXOffset = t.offset,
                  u = a.dataMin,
                  E = a.dataMax,
                  A = a.barW = Math.max(w, 1 + 2 * g);
              b.inverted && (p -= .5);
              c.pointPadding && (A = Math.ceil(A));
              r.prototype.translate.apply(a);
              a.points.forEach(function (e) {
                var g = q(e.yBottom, p),
                    m = 999 + Math.abs(g),
                    x = e.plotX || 0;
                m = d(e.plotY, -m, k.len + m);
                var B = Math.min(m, g),
                    r = Math.max(m, g) - B,
                    J = w,
                    v = x + z,
                    C = A;
                n && Math.abs(r) < n && (r = n, x = !k.reversed && !e.negative || k.reversed && e.negative, y(f) && y(E) && e.y === f && E <= f && (k.min || 0) < f && (u !== E || (k.max || 0) <= f) && (x = !x), B = Math.abs(B - p) > n ? g - n : p - (x ? n : 0));
                h(e.options.pointWidth) && (J = C = Math.ceil(e.options.pointWidth), v -= Math.round((J - w) / 2));
                c.centerInCategory && (v = a.adjustForMissingColumns(v, J, e, t));
                e.barX = v;
                e.pointWidth = J;
                e.tooltipPos = b.inverted ? [d(k.len + k.pos - b.plotLeft - m, k.pos - b.plotLeft, k.len + k.pos - b.plotLeft), l.len + l.pos - b.plotTop - v - C / 2, r] : [l.left - b.plotLeft + v + C / 2, d(m + k.pos - b.plotTop, k.pos - b.plotTop, k.len + k.pos - b.plotTop), r];
                e.shapeType = a.pointClass.prototype.shapeType || "rect";
                e.shapeArgs = a.crispCol.apply(a, e.isNull ? [v, p, C, 0] : [v, B, C, r]);
              });
            };

            g.prototype.drawGraph = function () {
              this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };

            g.prototype.pointAttribs = function (a, b) {
              var c = this.options,
                  d = this.pointAttrToOptions || {},
                  g = d.stroke || "borderColor",
                  h = d["stroke-width"] || "borderWidth",
                  l = a && a.color || this.color,
                  k = a && a[g] || c[g] || l;
              d = a && a.options.dashStyle || c.dashStyle;
              var f = a && a[h] || c[h] || this[h] || 0,
                  p = q(a && a.opacity, c.opacity, 1);

              if (a && this.zones.length) {
                var w = a.getZone();
                l = a.options.color || w && (w.color || a.nonZonedColor) || this.color;
                w && (k = w.borderColor || k, d = w.dashStyle || d, f = w.borderWidth || f);
              }

              b && a && (a = t(c.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, l = a.color || "undefined" !== typeof b && n(l).brighten(a.brightness).get() || l, k = a[g] || k, f = a[h] || f, d = a.dashStyle || d, p = q(a.opacity, p));
              g = {
                fill: l,
                stroke: k,
                "stroke-width": f,
                opacity: p
              };
              d && (g.dashstyle = d);
              return g;
            };

            g.prototype.drawPoints = function () {
              var a = this,
                  b = this.chart,
                  c = a.options,
                  d = b.renderer,
                  g = c.animationLimit || 250,
                  h;
              a.points.forEach(function (e) {
                var l = e.graphic,
                    k = !!l,
                    f = l && b.pointCount < g ? "animate" : "attr";

                if (y(e.plotY) && null !== e.y) {
                  h = e.shapeArgs;
                  l && e.hasNewShapeType() && (l = l.destroy());
                  a.enabledDataSorting && (e.startXPos = a.xAxis.reversed ? -(h ? h.width || 0 : 0) : a.xAxis.width);
                  l || (e.graphic = l = d[e.shapeType](h).add(e.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < g && (l.attr({
                    x: e.startXPos
                  }), k = !0, f = "animate");
                  if (l && k) l[f](t(h));
                  if (c.borderRadius) l[f]({
                    r: c.borderRadius
                  });
                  b.styledMode || l[f](a.pointAttribs(e, e.selected && "select")).shadow(!1 !== e.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);
                  l && (l.addClass(e.getClassName(), !0), l.attr({
                    visibility: e.visible ? "inherit" : "hidden"
                  }));
                } else l && (e.graphic = l.destroy());
              });
            };

            g.prototype.drawTracker = function () {
              var a = this,
                  c = a.chart,
                  d = c.pointer,
                  g = function g(a) {
                var b = d.getPointFromEvent(a);
                "undefined" !== typeof b && (d.isDirectTouch = !0, b.onMouseOver(a));
              },
                  h;

              a.points.forEach(function (a) {
                h = E(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
                a.graphic && (a.graphic.element.point = a);
                h.forEach(function (b) {
                  b.div ? b.div.point = a : b.element.point = a;
                });
              });
              a._hasTracking || (a.trackerGroups.forEach(function (e) {
                if (a[e]) {
                  a[e].addClass("highcharts-tracker").on("mouseover", g).on("mouseout", function (a) {
                    d.onTrackerMouseOut(a);
                  });
                  if (k) a[e].on("touchstart", g);
                  !c.styledMode && a.options.cursor && a[e].css(b).css({
                    cursor: a.options.cursor
                  });
                }
              }), a._hasTracking = !0);
              z(this, "afterDrawTracker");
            };

            g.prototype.remove = function () {
              var a = this,
                  b = a.chart;
              b.hasRendered && b.series.forEach(function (b) {
                b.type === a.type && (b.isDirty = !0);
              });
              r.prototype.remove.apply(a, arguments);
            };

            g.defaultOptions = t(r.defaultOptions, {
              borderRadius: 0,
              centerInCategory: !1,
              groupPadding: .2,
              marker: null,
              pointPadding: .1,
              minPointLength: 0,
              cropThreshold: 50,
              pointRange: null,
              states: {
                hover: {
                  halo: !1,
                  brightness: .1
                },
                select: {
                  color: "#cccccc",
                  borderColor: "#000000"
                }
              },
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
              },
              startFromThreshold: !0,
              stickyTracking: !1,
              tooltip: {
                distance: 6
              },
              threshold: 0,
              borderColor: "#ffffff"
            });
            return g;
          }(r);

          p(F.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: D.drawRectangle,
            getSymbol: c,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          C.registerSeriesType("column", F);
          "";
          "";
          return F;
        });
        H(f, "Core/Series/DataLabel.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/FormatUtilities.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = c.getDeferredAnimation,
              r = f.format,
              C = v.defined,
              F = v.extend,
              A = v.fireEvent,
              u = v.isArray,
              n = v.merge,
              k = v.objectEach,
              d = v.pick,
              b = v.splat,
              h;

          (function (c) {
            function h(b, a, c, e, g) {
              var h = this,
                  l = this.chart,
                  k = this.isCartesian && l.inverted,
                  f = this.enabledDataSorting,
                  q = d(b.dlBox && b.dlBox.centerX, b.plotX),
                  p = b.plotY,
                  n = c.rotation,
                  t = c.align,
                  w = C(q) && C(p) && l.isInsidePlot(q, Math.round(p), {
                inverted: k,
                paneCoordinates: !0,
                series: h
              }),
                  z = function z(c) {
                f && h.xAxis && !B && h.setDataLabelStartPos(b, a, g, w, c);
              },
                  B = "justify" === d(c.overflow, f ? "none" : "justify"),
                  y = this.visible && !1 !== b.visible && (b.series.forceDL || f && !B || w || d(c.inside, !!this.options.stacking) && e && l.isInsidePlot(q, k ? e.x + 1 : e.y + e.height - 1, {
                inverted: k,
                paneCoordinates: !0,
                series: h
              }));

              if (y && C(q) && C(p)) {
                n && a.attr({
                  align: t
                });
                t = a.getBBox(!0);
                var u = [0, 0];
                var r = l.renderer.fontMetrics(l.styledMode ? void 0 : c.style.fontSize, a).b;
                e = F({
                  x: k ? this.yAxis.len - p : q,
                  y: Math.round(k ? this.xAxis.len - q : p),
                  width: 0,
                  height: 0
                }, e);
                F(c, {
                  width: t.width,
                  height: t.height
                });
                n ? (B = !1, u = l.renderer.rotCorr(r, n), q = {
                  x: e.x + (c.x || 0) + e.width / 2 + u.x,
                  y: e.y + (c.y || 0) + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                  }[c.verticalAlign] * e.height
                }, u = [t.x - Number(a.attr("x")), t.y - Number(a.attr("y"))], z(q), a[g ? "attr" : "animate"](q)) : (z(e), a.align(c, void 0, e), q = a.alignAttr);
                B && 0 <= e.height ? this.justifyDataLabel(a, c, q, t, e, g) : d(c.crop, !0) && (e = q.x, z = q.y, e += u[0], z += u[1], y = l.isInsidePlot(e, z, {
                  paneCoordinates: !0,
                  series: h
                }) && l.isInsidePlot(e + t.width, z + t.height, {
                  paneCoordinates: !0,
                  series: h
                }));
                if (c.shape && !n) a[g ? "attr" : "animate"]({
                  anchorX: k ? l.plotWidth - b.plotY : b.plotX,
                  anchorY: k ? l.plotHeight - b.plotX : b.plotY
                });
              }

              g && f && (a.placed = !1);
              y || f && !B ? a.show() : (a.hide(), a.placed = !1);
            }

            function f(b, a) {
              var c = a.filter;
              return c ? (a = c.operator, b = b[c.property], c = c.value, ">" === a && b > c || "<" === a && b < c || ">=" === a && b >= c || "<=" === a && b <= c || "==" === a && b == c || "===" === a && b === c ? !0 : !1) : !0;
            }

            function p() {
              var c = this,
                  a = c.chart,
                  g = c.options,
                  e = c.points,
                  h = c.hasRendered || 0,
                  l = a.renderer,
                  p = g.dataLabels,
                  n,
                  t = p.animation;
              t = p.defer ? D(a, t, c) : {
                defer: 0,
                duration: 0
              };
              p = q(q(a.options.plotOptions && a.options.plotOptions.series && a.options.plotOptions.series.dataLabels, a.options.plotOptions && a.options.plotOptions[c.type] && a.options.plotOptions[c.type].dataLabels), p);
              A(this, "drawDataLabels");

              if (u(p) || p.enabled || c._hasPointLabels) {
                var z = c.plotGroup("dataLabelsGroup", "data-labels", h ? "inherit" : "hidden", p.zIndex || 6);
                z.attr({
                  opacity: +h
                });
                !h && (h = c.dataLabelsGroup) && (c.visible && z.show(), h[g.animation ? "animate" : "attr"]({
                  opacity: 1
                }, t));
                e.forEach(function (e) {
                  n = b(q(p, e.dlOptions || e.options && e.options.dataLabels));
                  n.forEach(function (b, h) {
                    var m = b.enabled && (!e.isNull || e.dataLabelOnNull) && f(e, b),
                        q = e.connectors ? e.connectors[h] : e.connector,
                        p = e.dataLabels ? e.dataLabels[h] : e.dataLabel,
                        n = !p,
                        t = d(b.distance, e.labelDistance);

                    if (m) {
                      var w = e.getLabelConfig();
                      var x = d(b[e.formatPrefix + "Format"], b.format);
                      w = C(x) ? r(x, w, a) : (b[e.formatPrefix + "Formatter"] || b.formatter).call(w, b);
                      x = b.style;
                      var y = b.rotation;
                      a.styledMode || (x.color = d(b.color, x.color, c.color, "#000000"), "contrast" === x.color ? (e.contrastColor = l.getContrast(e.color || c.color), x.color = !C(t) && b.inside || 0 > t || g.stacking ? e.contrastColor : "#000000") : delete e.contrastColor, g.cursor && (x.cursor = g.cursor));
                      var B = {
                        r: b.borderRadius || 0,
                        rotation: y,
                        padding: b.padding,
                        zIndex: 1
                      };
                      a.styledMode || (B.fill = b.backgroundColor, B.stroke = b.borderColor, B["stroke-width"] = b.borderWidth);
                      k(B, function (a, b) {
                        "undefined" === typeof a && delete B[b];
                      });
                    }

                    !p || m && C(w) && !!p.div === !!b.useHTML && (p.rotation && b.rotation || p.rotation === b.rotation) || (n = !0, e.dataLabel = p = e.dataLabel && e.dataLabel.destroy(), e.dataLabels && (1 === e.dataLabels.length ? delete e.dataLabels : delete e.dataLabels[h]), h || delete e.dataLabel, q && (e.connector = e.connector.destroy(), e.connectors && (1 === e.connectors.length ? delete e.connectors : delete e.connectors[h])));
                    m && C(w) ? (p ? B.text = w : (e.dataLabels = e.dataLabels || [], p = e.dataLabels[h] = y ? l.text(w, 0, 0, b.useHTML).addClass("highcharts-data-label") : l.label(w, 0, 0, b.shape, null, null, b.useHTML, null, "data-label"), h || (e.dataLabel = p), p.addClass(" highcharts-data-label-color-" + e.colorIndex + " " + (b.className || "") + (b.useHTML ? " highcharts-tracker" : ""))), p.options = b, p.attr(B), a.styledMode || p.css(x).shadow(b.shadow), p.added || p.add(z), b.textPath && !b.useHTML && (p.setTextPath(e.getDataLabelPath && e.getDataLabelPath(p) || e.graphic, b.textPath), e.dataLabelPath && !b.textPath.enabled && (e.dataLabelPath = e.dataLabelPath.destroy())), c.alignDataLabel(e, p, b, null, n)) : p && p.hide();
                  });
                });
              }

              A(this, "afterDrawDataLabels");
            }

            function t(b, a, c, e, d, g) {
              var h = this.chart,
                  l = a.align,
                  k = a.verticalAlign,
                  f = b.box ? 0 : b.padding || 0,
                  m = a.x;
              m = void 0 === m ? 0 : m;
              var p = a.y;
              p = void 0 === p ? 0 : p;
              var q = (c.x || 0) + f;

              if (0 > q) {
                "right" === l && 0 <= m ? (a.align = "left", a.inside = !0) : m -= q;
                var n = !0;
              }

              q = (c.x || 0) + e.width - f;
              q > h.plotWidth && ("left" === l && 0 >= m ? (a.align = "right", a.inside = !0) : m += h.plotWidth - q, n = !0);
              q = c.y + f;
              0 > q && ("bottom" === k && 0 <= p ? (a.verticalAlign = "top", a.inside = !0) : p -= q, n = !0);
              q = (c.y || 0) + e.height - f;
              q > h.plotHeight && ("top" === k && 0 >= p ? (a.verticalAlign = "bottom", a.inside = !0) : p += h.plotHeight - q, n = !0);
              n && (a.x = m, a.y = p, b.placed = !g, b.align(a, void 0, d));
              return n;
            }

            function q(b, a) {
              var c = [],
                  e;
              if (u(b) && !u(a)) c = b.map(function (b) {
                return n(b, a);
              });else if (u(a) && !u(b)) c = a.map(function (a) {
                return n(b, a);
              });else if (u(b) || u(a)) for (e = Math.max(b.length, a.length); e--;) {
                c[e] = n(b[e], a[e]);
              } else c = n(b, a);
              return c;
            }

            function l(b, a, c, e, d) {
              var g = this.chart,
                  h = g.inverted,
                  l = this.xAxis,
                  k = l.reversed,
                  f = h ? a.height / 2 : a.width / 2;
              b = (b = b.pointWidth) ? b / 2 : 0;
              a.startXPos = h ? d.x : k ? -f - b : l.width - f + b;
              a.startYPos = h ? k ? this.yAxis.height - f + b : -f - b : d.y;
              e ? "hidden" === a.visibility && (a.show(), a.attr({
                opacity: 0
              }).animate({
                opacity: 1
              })) : a.attr({
                opacity: 1
              }).animate({
                opacity: 0
              }, void 0, a.hide);
              g.hasRendered && (c && a.attr({
                x: a.startXPos,
                y: a.startYPos
              }), a.placed = !0);
            }

            var g = [];

            c.compose = function (b) {
              if (-1 === g.indexOf(b)) {
                var a = b.prototype;
                g.push(b);
                a.alignDataLabel = h;
                a.drawDataLabels = p;
                a.justifyDataLabel = t;
                a.setDataLabelStartPos = l;
              }
            };
          })(h || (h = {}));

          "";
          return h;
        });
        H(f, "Series/Column/ColumnDataLabel.js", [f["Core/Series/DataLabel.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = f.series,
              r = v.merge,
              C = v.pick,
              F;

          (function (f) {
            function u(c, d, b, h, f) {
              var k = this.chart.inverted,
                  p = c.series,
                  n = (p.xAxis ? p.xAxis.len : this.chart.plotSizeX) || 0;
              p = (p.yAxis ? p.yAxis.len : this.chart.plotSizeY) || 0;
              var t = c.dlBox || c.shapeArgs,
                  q = C(c.below, c.plotY > C(this.translatedThreshold, p)),
                  l = C(b.inside, !!this.options.stacking);
              t && (h = r(t), 0 > h.y && (h.height += h.y, h.y = 0), t = h.y + h.height - p, 0 < t && t < h.height && (h.height -= t), k && (h = {
                x: p - h.y - h.height,
                y: n - h.x - h.width,
                width: h.height,
                height: h.width
              }), l || (k ? (h.x += q ? 0 : h.width, h.width = 0) : (h.y += q ? h.height : 0, h.height = 0)));
              b.align = C(b.align, !k || l ? "center" : q ? "right" : "left");
              b.verticalAlign = C(b.verticalAlign, k || l ? "middle" : q ? "top" : "bottom");
              D.prototype.alignDataLabel.call(this, c, d, b, h, f);
              b.inside && c.contrastColor && d.css({
                color: c.contrastColor
              });
            }

            var n = [];

            f.compose = function (k) {
              c.compose(D);
              -1 === n.indexOf(k) && (n.push(k), k.prototype.alignDataLabel = u);
            };
          })(F || (F = {}));

          return F;
        });
        H(f, "Series/Bar/BarSeries.js", [f["Series/Column/ColumnSeries.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = this && this.__extends || function () {
            var _c14 = function c(f, u) {
              _c14 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, k) {
                c.__proto__ = k;
              } || function (c, k) {
                for (var d in k) {
                  k.hasOwnProperty(d) && (c[d] = k[d]);
                }
              };

              return _c14(f, u);
            };

            return function (f, u) {
              function n() {
                this.constructor = f;
              }

              _c14(f, u);

              f.prototype = null === u ? Object.create(u) : (n.prototype = u.prototype, new n());
            };
          }(),
              r = v.extend,
              C = v.merge;

          v = function (f) {
            function r() {
              var c = null !== f && f.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            D(r, f);
            r.defaultOptions = C(c.defaultOptions, {});
            return r;
          }(c);

          r(v.prototype, {
            inverted: !0
          });
          f.registerSeriesType("bar", v);
          "";
          return v;
        });
        H(f, "Series/Scatter/ScatterSeries.js", [f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = this && this.__extends || function () {
            var _c15 = function c(f, k) {
              _c15 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, b) {
                c.__proto__ = b;
              } || function (c, b) {
                for (var d in b) {
                  b.hasOwnProperty(d) && (c[d] = b[d]);
                }
              };

              return _c15(f, k);
            };

            return function (f, k) {
              function d() {
                this.constructor = f;
              }

              _c15(f, k);

              f.prototype = null === k ? Object.create(k) : (d.prototype = k.prototype, new d());
            };
          }(),
              D = c.seriesTypes,
              r = D.column,
              C = D.line;

          D = f.addEvent;
          var F = f.extend,
              A = f.merge;

          f = function (c) {
            function f() {
              var f = null !== c && c.apply(this, arguments) || this;
              f.data = void 0;
              f.options = void 0;
              f.points = void 0;
              return f;
            }

            v(f, c);

            f.prototype.applyJitter = function () {
              var c = this,
                  d = this.options.jitter,
                  b = this.points.length;
              d && this.points.forEach(function (h, f) {
                ["x", "y"].forEach(function (k, p) {
                  var n = "plot" + k.toUpperCase();

                  if (d[k] && !h.isNull) {
                    var t = c[k + "Axis"];
                    var q = d[k] * t.transA;

                    if (t && !t.isLog) {
                      var l = Math.max(0, h[n] - q);
                      t = Math.min(t.len, h[n] + q);
                      p = 1E4 * Math.sin(f + p * b);
                      h[n] = l + (t - l) * (p - Math.floor(p));
                      "x" === k && (h.clientX = h.plotX);
                    }
                  }
                });
              });
            };

            f.prototype.drawGraph = function () {
              this.options.lineWidth ? c.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };

            f.defaultOptions = A(C.defaultOptions, {
              lineWidth: 0,
              findNearestPointBy: "xy",
              jitter: {
                x: 0,
                y: 0
              },
              marker: {
                enabled: !0
              },
              tooltip: {
                headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
              }
            });
            return f;
          }(C);

          F(f.prototype, {
            drawTracker: r.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
          });
          D(f, "afterTranslate", function () {
            this.applyJitter();
          });
          c.registerSeriesType("scatter", f);
          "";
          return f;
        });
        H(f, "Series/CenteredUtilities.js", [f["Core/Globals.js"], f["Core/Series/Series.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = c.deg2rad,
              r = v.fireEvent,
              C = v.isNumber,
              F = v.pick,
              A = v.relativeLength,
              u;

          (function (c) {
            c.getCenter = function () {
              var c = this.options,
                  d = this.chart,
                  b = 2 * (c.slicedOffset || 0),
                  h = d.plotWidth - 2 * b,
                  p = d.plotHeight - 2 * b,
                  n = c.center,
                  u = Math.min(h, p),
                  y = c.thickness,
                  t = c.size,
                  q = c.innerSize || 0;
              "string" === typeof t && (t = parseFloat(t));
              "string" === typeof q && (q = parseFloat(q));
              c = [F(n[0], "50%"), F(n[1], "50%"), F(t && 0 > t ? void 0 : c.size, "100%"), F(q && 0 > q ? void 0 : c.innerSize || 0, "0%")];
              !d.angular || this instanceof f || (c[3] = 0);

              for (n = 0; 4 > n; ++n) {
                t = c[n], d = 2 > n || 2 === n && /%$/.test(t), c[n] = A(t, [h, p, u, c[2]][n]) + (d ? b : 0);
              }

              c[3] > c[2] && (c[3] = c[2]);
              C(y) && 2 * y < c[2] && 0 < y && (c[3] = c[2] - 2 * y);
              r(this, "afterGetCenter", {
                positions: c
              });
              return c;
            };

            c.getStartAndEndRadians = function (c, d) {
              c = C(c) ? c : 0;
              d = C(d) && d > c && 360 > d - c ? d : c + 360;
              return {
                start: D * (c + -90),
                end: D * (d + -90)
              };
            };
          })(u || (u = {}));

          "";
          return u;
        });
        H(f, "Series/Pie/PiePoint.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Series/Point.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = this && this.__extends || function () {
            var _c16 = function c(d, b) {
              _c16 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _c16(d, b);
            };

            return function (d, b) {
              function h() {
                this.constructor = d;
              }

              _c16(d, b);

              d.prototype = null === b ? Object.create(b) : (h.prototype = b.prototype, new h());
            };
          }(),
              r = c.setAnimation,
              C = v.addEvent,
              F = v.defined;

          c = v.extend;
          var A = v.isNumber,
              u = v.pick,
              n = v.relativeLength;

          f = function (c) {
            function d() {
              var b = null !== c && c.apply(this, arguments) || this;
              b.labelDistance = void 0;
              b.options = void 0;
              b.series = void 0;
              return b;
            }

            D(d, c);

            d.prototype.getConnectorPath = function () {
              var b = this.labelPosition,
                  c = this.series.options.dataLabels,
                  d = this.connectorShapes,
                  f = c.connectorShape;
              d[f] && (f = d[f]);
              return f.call(this, {
                x: b["final"].x,
                y: b["final"].y,
                alignment: b.alignment
              }, b.connectorPosition, c);
            };

            d.prototype.getTranslate = function () {
              return this.sliced ? this.slicedTranslation : {
                translateX: 0,
                translateY: 0
              };
            };

            d.prototype.haloPath = function (b) {
              var c = this.shapeArgs;
              return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + b, c.r + b, {
                innerR: c.r - 1,
                start: c.start,
                end: c.end
              });
            };

            d.prototype.init = function () {
              var b = this;
              c.prototype.init.apply(this, arguments);
              this.name = u(this.name, "Slice");

              var d = function d(c) {
                b.slice("select" === c.type);
              };

              C(this, "select", d);
              C(this, "unselect", d);
              return this;
            };

            d.prototype.isValid = function () {
              return A(this.y) && 0 <= this.y;
            };

            d.prototype.setVisible = function (b, c) {
              var d = this,
                  h = this.series,
                  f = h.chart,
                  k = h.options.ignoreHiddenPoint;
              c = u(c, k);
              b !== this.visible && (this.visible = this.options.visible = b = "undefined" === typeof b ? !this.visible : b, h.options.data[h.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (c) {
                if (d[c]) d[c][b ? "show" : "hide"](b);
              }), this.legendItem && f.legend.colorizeItem(this, b), b || "hover" !== this.state || this.setState(""), k && (h.isDirty = !0), c && f.redraw());
            };

            d.prototype.slice = function (b, c, d) {
              var h = this.series;
              r(d, h.chart);
              u(c, !0);
              this.sliced = this.options.sliced = F(b) ? b : !this.sliced;
              h.options.data[h.data.indexOf(this)] = this.options;
              this.graphic && this.graphic.animate(this.getTranslate());
              this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };

            return d;
          }(f);

          c(f.prototype, {
            connectorShapes: {
              fixedOffset: function fixedOffset(c, d, b) {
                var h = d.breakAt;
                d = d.touchingSliceAt;
                return [["M", c.x, c.y], b.softConnector ? ["C", c.x + ("left" === c.alignment ? -5 : 5), c.y, 2 * h.x - d.x, 2 * h.y - d.y, h.x, h.y] : ["L", h.x, h.y], ["L", d.x, d.y]];
              },
              straight: function straight(c, d) {
                d = d.touchingSliceAt;
                return [["M", c.x, c.y], ["L", d.x, d.y]];
              },
              crookedLine: function crookedLine(c, d, b) {
                d = d.touchingSliceAt;
                var h = this.series,
                    f = h.center[0],
                    k = h.chart.plotWidth,
                    u = h.chart.plotLeft;
                h = c.alignment;
                var y = this.shapeArgs.r;
                b = n(b.crookDistance, 1);
                k = "left" === h ? f + y + (k + u - f - y) * (1 - b) : u + (f - y) * b;
                b = ["L", k, c.y];
                f = !0;
                if ("left" === h ? k > c.x || k < d.x : k < c.x || k > d.x) f = !1;
                c = [["M", c.x, c.y]];
                f && c.push(b);
                c.push(["L", d.x, d.y]);
                return c;
              }
            }
          });
          return f;
        });
        H(f, "Series/Pie/PieSeries.js", [f["Series/CenteredUtilities.js"], f["Series/Column/ColumnSeries.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Series/Pie/PiePoint.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/Symbols.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F, A, u) {
          var n = this && this.__extends || function () {
            var _b10 = function b(c, d) {
              _b10 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _b10(c, d);
            };

            return function (c, d) {
              function h() {
                this.constructor = c;
              }

              _b10(c, d);

              c.prototype = null === d ? Object.create(d) : (h.prototype = d.prototype, new h());
            };
          }(),
              k = c.getStartAndEndRadians;

          v = v.noop;
          var d = u.clamp,
              b = u.extend,
              h = u.fireEvent,
              p = u.merge,
              z = u.pick,
              E = u.relativeLength;

          u = function (b) {
            function c() {
              var c = null !== b && b.apply(this, arguments) || this;
              c.center = void 0;
              c.data = void 0;
              c.maxLabelDistance = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            n(c, b);

            c.prototype.animate = function (b) {
              var c = this,
                  d = c.points,
                  h = c.startAngleRad;
              b || d.forEach(function (a) {
                var b = a.graphic,
                    d = a.shapeArgs;
                b && d && (b.attr({
                  r: z(a.startR, c.center && c.center[3] / 2),
                  start: h,
                  end: h
                }), b.animate({
                  r: d.r,
                  start: d.start,
                  end: d.end
                }, c.options.animation));
              });
            };

            c.prototype.drawEmpty = function () {
              var b = this.startAngleRad,
                  c = this.endAngleRad,
                  d = this.options;

              if (0 === this.total && this.center) {
                var h = this.center[0];
                var a = this.center[1];
                this.graph || (this.graph = this.chart.renderer.arc(h, a, this.center[1] / 2, 0, b, c).addClass("highcharts-empty-series").add(this.group));
                this.graph.attr({
                  d: A.arc(h, a, this.center[2] / 2, 0, {
                    start: b,
                    end: c,
                    innerR: this.center[3] / 2
                  })
                });
                this.chart.styledMode || this.graph.attr({
                  "stroke-width": d.borderWidth,
                  fill: d.fillColor || "none",
                  stroke: d.color || "#cccccc"
                });
              } else this.graph && (this.graph = this.graph.destroy());
            };

            c.prototype.drawPoints = function () {
              var b = this.chart.renderer;
              this.points.forEach(function (c) {
                c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
                c.graphic || (c.graphic = b[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
              });
            };

            c.prototype.generatePoints = function () {
              b.prototype.generatePoints.call(this);
              this.updateTotals();
            };

            c.prototype.getX = function (b, c, g) {
              var h = this.center,
                  a = this.radii ? this.radii[g.index] || 0 : h[2] / 2;
              b = Math.asin(d((b - h[1]) / (a + g.labelDistance), -1, 1));
              return h[0] + (c ? -1 : 1) * Math.cos(b) * (a + g.labelDistance) + (0 < g.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
            };

            c.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            c.prototype.redrawPoints = function () {
              var b = this,
                  c = b.chart,
                  d = c.renderer,
                  h = b.options.shadow,
                  a,
                  f,
                  e,
                  k;
              this.drawEmpty();
              !h || b.shadowGroup || c.styledMode || (b.shadowGroup = d.g("shadow").attr({
                zIndex: -1
              }).add(b.group));
              b.points.forEach(function (g) {
                var l = {};
                f = g.graphic;

                if (!g.isNull && f) {
                  var m = void 0;
                  k = g.shapeArgs;
                  a = g.getTranslate();
                  c.styledMode || (m = g.shadowGroup, h && !m && (m = g.shadowGroup = d.g("shadow").add(b.shadowGroup)), m && m.attr(a), e = b.pointAttribs(g, g.selected && "select"));
                  g.delayedRendering ? (f.setRadialReference(b.center).attr(k).attr(a), c.styledMode || f.attr(e).attr({
                    "stroke-linejoin": "round"
                  }).shadow(h, m), g.delayedRendering = !1) : (f.setRadialReference(b.center), c.styledMode || p(!0, l, e), p(!0, l, k, a), f.animate(l));
                  f.attr({
                    visibility: g.visible ? "inherit" : "hidden"
                  });
                  f.addClass(g.getClassName(), !0);
                } else f && (g.graphic = f.destroy());
              });
            };

            c.prototype.sortByAngle = function (b, c) {
              b.sort(function (b, d) {
                return "undefined" !== typeof b.angle && (d.angle - b.angle) * c;
              });
            };

            c.prototype.translate = function (b) {
              h(this, "translate");
              this.generatePoints();
              var c = this.options,
                  d = c.slicedOffset,
                  f = d + (c.borderWidth || 0),
                  a = k(c.startAngle, c.endAngle),
                  p = this.startAngleRad = a.start;
              a = (this.endAngleRad = a.end) - p;
              var e = this.points,
                  q = c.dataLabels.distance;
              c = c.ignoreHiddenPoint;
              var m = e.length,
                  n,
                  t = 0;
              b || (this.center = b = this.getCenter());

              for (n = 0; n < m; n++) {
                var y = e[n];
                var u = p + t * a;
                !y.isValid() || c && !y.visible || (t += y.percentage / 100);
                var r = p + t * a;
                var A = {
                  x: b[0],
                  y: b[1],
                  r: b[2] / 2,
                  innerR: b[3] / 2,
                  start: Math.round(1E3 * u) / 1E3,
                  end: Math.round(1E3 * r) / 1E3
                };
                y.shapeType = "arc";
                y.shapeArgs = A;
                y.labelDistance = z(y.options.dataLabels && y.options.dataLabels.distance, q);
                y.labelDistance = E(y.labelDistance, A.r);
                this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, y.labelDistance);
                r = (r + u) / 2;
                r > 1.5 * Math.PI ? r -= 2 * Math.PI : r < -Math.PI / 2 && (r += 2 * Math.PI);
                y.slicedTranslation = {
                  translateX: Math.round(Math.cos(r) * d),
                  translateY: Math.round(Math.sin(r) * d)
                };
                A = Math.cos(r) * b[2] / 2;
                var v = Math.sin(r) * b[2] / 2;
                y.tooltipPos = [b[0] + .7 * A, b[1] + .7 * v];
                y.half = r < -Math.PI / 2 || r > Math.PI / 2 ? 1 : 0;
                y.angle = r;
                u = Math.min(f, y.labelDistance / 5);
                y.labelPosition = {
                  natural: {
                    x: b[0] + A + Math.cos(r) * y.labelDistance,
                    y: b[1] + v + Math.sin(r) * y.labelDistance
                  },
                  "final": {},
                  alignment: 0 > y.labelDistance ? "center" : y.half ? "right" : "left",
                  connectorPosition: {
                    breakAt: {
                      x: b[0] + A + Math.cos(r) * u,
                      y: b[1] + v + Math.sin(r) * u
                    },
                    touchingSliceAt: {
                      x: b[0] + A,
                      y: b[1] + v
                    }
                  }
                };
              }

              h(this, "afterTranslate");
            };

            c.prototype.updateTotals = function () {
              var b = this.points,
                  c = b.length,
                  d = this.options.ignoreHiddenPoint,
                  h,
                  a = 0;

              for (h = 0; h < c; h++) {
                var f = b[h];
                !f.isValid() || d && !f.visible || (a += f.y);
              }

              this.total = a;

              for (h = 0; h < c; h++) {
                f = b[h], f.percentage = 0 < a && (f.visible || !d) ? f.y / a * 100 : 0, f.total = a;
              }
            };

            c.defaultOptions = p(C.defaultOptions, {
              center: [null, null],
              clip: !1,
              colorByPoint: !0,
              dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0
              },
              fillColor: void 0,
              ignoreHiddenPoint: !0,
              inactiveOtherPoints: !0,
              legendType: "point",
              marker: null,
              size: null,
              showInLegend: !1,
              slicedOffset: 10,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0
              },
              borderColor: "#ffffff",
              borderWidth: 1,
              lineWidth: void 0,
              states: {
                hover: {
                  brightness: .1
                }
              }
            });
            return c;
          }(C);

          b(u.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: D.drawRectangle,
            drawTracker: f.prototype.drawTracker,
            getCenter: c.getCenter,
            getSymbol: v,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: f.prototype.pointAttribs,
            pointClass: r,
            requireSorting: !1,
            searchPoint: v,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          F.registerSeriesType("pie", u);
          "";
          return u;
        });
        H(f, "Series/Pie/PieDataLabel.js", [f["Core/Series/DataLabel.js"], f["Core/Globals.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D, r) {
          var C = f.noop,
              F = v.distribute,
              A = D.series,
              u = r.arrayMax,
              n = r.clamp,
              k = r.defined,
              d = r.merge,
              b = r.pick,
              h = r.relativeLength,
              p;

          (function (f) {
            function p() {
              var c = this,
                  h = c.data,
                  a = c.chart,
                  f = c.options.dataLabels || {},
                  e = f.connectorPadding,
                  l = a.plotWidth,
                  m = a.plotHeight,
                  p = a.plotLeft,
                  q = Math.round(a.chartWidth / 3),
                  n = c.center,
                  t = n[2] / 2,
                  y = n[1],
                  z = [[], []],
                  r = [0, 0, 0, 0],
                  E = c.dataLabelPositioners,
                  v,
                  C,
                  D,
                  I,
                  H,
                  R,
                  Z,
                  Q,
                  T,
                  S,
                  W,
                  O;
              c.visible && (f.enabled || c._hasPointLabels) && (h.forEach(function (a) {
                a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
                  width: "auto"
                }).css({
                  width: "auto",
                  textOverflow: "clip"
                }), a.dataLabel.shortened = !1);
              }), A.prototype.drawDataLabels.apply(c), h.forEach(function (a) {
                a.dataLabel && (a.visible ? (z[a.half].push(a), a.dataLabel._pos = null, !k(f.style.width) && !k(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > q && (a.dataLabel.css({
                  width: Math.round(.7 * q) + "px"
                }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
              }), z.forEach(function (d, g) {
                var h = d.length,
                    q = [],
                    w;

                if (h) {
                  c.sortByAngle(d, g - .5);

                  if (0 < c.maxLabelDistance) {
                    var x = Math.max(0, y - t - c.maxLabelDistance);
                    var z = Math.min(y + t + c.maxLabelDistance, a.plotHeight);
                    d.forEach(function (b) {
                      0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, y - t - b.labelDistance), b.bottom = Math.min(y + t + b.labelDistance, a.plotHeight), w = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                        target: b.labelPosition.natural.y - b.top + w / 2,
                        size: w,
                        rank: b.y
                      }, q.push(b.distributeBox));
                    });
                    x = z + w - x;
                    F(q, x, x / 5);
                  }

                  for (W = 0; W < h; W++) {
                    v = d[W];
                    R = v.labelPosition;
                    I = v.dataLabel;
                    S = !1 === v.visible ? "hidden" : "inherit";
                    T = x = R.natural.y;
                    q && k(v.distributeBox) && ("undefined" === typeof v.distributeBox.pos ? S = "hidden" : (Z = v.distributeBox.size, T = E.radialDistributionY(v)));
                    delete v.positionIndex;
                    if (f.justify) Q = E.justify(v, t, n);else switch (f.alignTo) {
                      case "connectors":
                        Q = E.alignToConnectors(d, g, l, p);
                        break;

                      case "plotEdges":
                        Q = E.alignToPlotEdges(I, g, l, p);
                        break;

                      default:
                        Q = E.radialDistributionX(c, v, T, x);
                    }
                    I._attr = {
                      visibility: S,
                      align: R.alignment
                    };
                    O = v.options.dataLabels || {};
                    I._pos = {
                      x: Q + b(O.x, f.x) + ({
                        left: e,
                        right: -e
                      }[R.alignment] || 0),
                      y: T + b(O.y, f.y) - 10
                    };
                    R["final"].x = Q;
                    R["final"].y = T;
                    b(f.crop, !0) && (H = I.getBBox().width, x = null, Q - H < e && 1 === g ? (x = Math.round(H - Q + e), r[3] = Math.max(x, r[3])) : Q + H > l - e && 0 === g && (x = Math.round(Q + H - l + e), r[1] = Math.max(x, r[1])), 0 > T - Z / 2 ? r[0] = Math.max(Math.round(-T + Z / 2), r[0]) : T + Z / 2 > m && (r[2] = Math.max(Math.round(T + Z / 2 - m), r[2])), I.sideOverflow = x);
                  }
                }
              }), 0 === u(r) || this.verifyDataLabelOverflow(r)) && (this.placeDataLabels(), this.points.forEach(function (e) {
                O = d(f, e.options.dataLabels);

                if (C = b(O.connectorWidth, 1)) {
                  var g;
                  D = e.connector;

                  if ((I = e.dataLabel) && I._pos && e.visible && 0 < e.labelDistance) {
                    S = I._attr.visibility;
                    if (g = !D) e.connector = D = a.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e.colorIndex + (e.className ? " " + e.className : "")).add(c.dataLabelsGroup), a.styledMode || D.attr({
                      "stroke-width": C,
                      stroke: O.connectorColor || e.color || "#666666"
                    });
                    D[g ? "attr" : "animate"]({
                      d: e.getConnectorPath()
                    });
                    D.attr("visibility", S);
                  } else D && (e.connector = D.destroy());
                }
              }));
            }

            function y() {
              this.points.forEach(function (b) {
                var c = b.dataLabel,
                    a;
                c && b.visible && ((a = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
                  width: c._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](a), c.moved = !0) : c && c.attr({
                  y: -9999
                }));
                delete b.distributeBox;
              }, this);
            }

            function t(b) {
              var c = this.center,
                  a = this.options,
                  d = a.center,
                  e = a.minSize || 80,
                  g = null !== a.size;

              if (!g) {
                if (null !== d[0]) var f = Math.max(c[2] - Math.max(b[1], b[3]), e);else f = Math.max(c[2] - b[1] - b[3], e), c[0] += (b[3] - b[1]) / 2;
                null !== d[1] ? f = n(f, e, c[2] - Math.max(b[0], b[2])) : (f = n(f, e, c[2] - b[0] - b[2]), c[1] += (b[0] - b[2]) / 2);
                f < c[2] ? (c[2] = f, c[3] = Math.min(a.thickness ? Math.max(0, f - 2 * a.thickness) : Math.max(0, h(a.innerSize || 0, f)), f), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : g = !0;
              }

              return g;
            }

            var q = [],
                l = {
              radialDistributionY: function radialDistributionY(b) {
                return b.top + b.distributeBox.pos;
              },
              radialDistributionX: function radialDistributionX(b, c, a, d) {
                return b.getX(a < c.top + 2 || a > c.bottom - 2 ? d : a, c.half, c);
              },
              justify: function justify(b, c, a) {
                return a[0] + (b.half ? -1 : 1) * (c + b.labelDistance);
              },
              alignToPlotEdges: function alignToPlotEdges(b, c, a, d) {
                b = b.getBBox().width;
                return c ? b + d : a - b - d;
              },
              alignToConnectors: function alignToConnectors(b, c, a, d) {
                var e = 0,
                    g;
                b.forEach(function (a) {
                  g = a.dataLabel.getBBox().width;
                  g > e && (e = g);
                });
                return c ? e + d : a - e - d;
              }
            };

            f.compose = function (b) {
              c.compose(A);
              -1 === q.indexOf(b) && (q.push(b), b = b.prototype, b.dataLabelPositioners = l, b.alignDataLabel = C, b.drawDataLabels = p, b.placeDataLabels = y, b.verifyDataLabelOverflow = t);
            };
          })(p || (p = {}));

          return p;
        });
        H(f, "Extensions/OverlappingDataLabels.js", [f["Core/Chart/Chart.js"], f["Core/Utilities.js"]], function (c, f) {
          function v(c, f) {
            var d = !1;

            if (c) {
              var b = c.newOpacity;
              c.oldOpacity !== b && (c.alignAttr && c.placed ? (c[b ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), d = !0, c.alignAttr.opacity = b, c[c.isOld ? "animate" : "attr"](c.alignAttr, null, function () {
                f.styledMode || c.css({
                  pointerEvents: b ? "auto" : "none"
                });
              }), r(f, "afterHideOverlappingLabel")) : c.attr({
                opacity: b
              }));
              c.isOld = !0;
            }

            return d;
          }

          var D = f.addEvent,
              r = f.fireEvent,
              C = f.isArray,
              F = f.isNumber,
              A = f.objectEach,
              u = f.pick;
          D(c, "render", function () {
            var c = this,
                f = [];
            (this.labelCollectors || []).forEach(function (c) {
              f = f.concat(c());
            });
            (this.yAxis || []).forEach(function (c) {
              c.stacking && c.options.stackLabels && !c.options.stackLabels.allowOverlap && A(c.stacking.stacks, function (b) {
                A(b, function (b) {
                  b.label && f.push(b.label);
                });
              });
            });
            (this.series || []).forEach(function (d) {
              var b = d.options.dataLabels;
              d.visible && (!1 !== b.enabled || d._hasPointLabels) && (b = function b(_b11) {
                return _b11.forEach(function (b) {
                  b.visible && (C(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : []).forEach(function (d) {
                    var h = d.options;
                    d.labelrank = u(h.labelrank, b.labelrank, b.shapeArgs && b.shapeArgs.height);
                    h.allowOverlap ? (d.oldOpacity = d.opacity, d.newOpacity = 1, v(d, c)) : f.push(d);
                  });
                });
              }, b(d.nodes || []), b(d.points));
            });
            this.hideOverlappingLabels(f);
          });

          c.prototype.hideOverlappingLabels = function (c) {
            var f = this,
                d = c.length,
                b = f.renderer,
                h,
                p,
                n,
                u = !1;

            var y = function y(c) {
              var d,
                  h = c.box ? 0 : c.padding || 0,
                  a = d = 0,
                  f;

              if (c && (!c.alignAttr || c.placed)) {
                var e = c.alignAttr || {
                  x: c.attr("x"),
                  y: c.attr("y")
                };
                var l = c.parentGroup;
                c.width || (d = c.getBBox(), c.width = d.width, c.height = d.height, d = b.fontMetrics(null, c.element).h);
                var k = c.width - 2 * h;
                (f = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[c.alignValue]) ? a = +f * k : F(c.x) && Math.round(c.x) !== c.translateX && (a = c.x - c.translateX);
                return {
                  x: e.x + (l.translateX || 0) + h - (a || 0),
                  y: e.y + (l.translateY || 0) + h - d,
                  width: c.width - 2 * h,
                  height: c.height - 2 * h
                };
              }
            };

            for (p = 0; p < d; p++) {
              if (h = c[p]) h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = y(h);
            }

            c.sort(function (b, c) {
              return (c.labelrank || 0) - (b.labelrank || 0);
            });

            for (p = 0; p < d; p++) {
              var t = (y = c[p]) && y.absoluteBox;

              for (h = p + 1; h < d; ++h) {
                var q = (n = c[h]) && n.absoluteBox;
                !t || !q || y === n || 0 === y.newOpacity || 0 === n.newOpacity || "hidden" === y.visibility || "hidden" === n.visibility || q.x >= t.x + t.width || q.x + q.width <= t.x || q.y >= t.y + t.height || q.y + q.height <= t.y || ((y.labelrank < n.labelrank ? y : n).newOpacity = 0);
              }
            }

            c.forEach(function (b) {
              v(b, f) && (u = !0);
            });
            u && r(f, "afterHideAllOverlappingLabels");
          };
        });
        H(f, "Core/Responsive.js", [f["Core/Utilities.js"]], function (c) {
          var f = c.extend,
              v = c.find,
              D = c.isArray,
              r = c.isObject,
              C = c.merge,
              F = c.objectEach,
              A = c.pick,
              u = c.splat,
              n = c.uniqueKey,
              k;

          (function (c) {
            var b = [];

            c.compose = function (c) {
              -1 === b.indexOf(c) && (b.push(c), f(c.prototype, d.prototype));
              return c;
            };

            var d = function () {
              function b() {}

              b.prototype.currentOptions = function (b) {
                function c(b, h, g, f) {
                  var a;
                  F(b, function (b, e) {
                    if (!f && -1 < d.collectionsWithUpdate.indexOf(e) && h[e]) for (b = u(b), g[e] = [], a = 0; a < Math.max(b.length, h[e].length); a++) {
                      h[e][a] && (void 0 === b[a] ? g[e][a] = h[e][a] : (g[e][a] = {}, c(b[a], h[e][a], g[e][a], f + 1)));
                    } else r(b) ? (g[e] = D(b) ? [] : {}, c(b, h[e] || {}, g[e], f + 1)) : g[e] = "undefined" === typeof h[e] ? null : h[e];
                  });
                }

                var d = this,
                    h = {};
                c(b, this.options, h, 0);
                return h;
              };

              b.prototype.matchResponsiveRule = function (b, c) {
                var d = b.condition;
                (d.callback || function () {
                  return this.chartWidth <= A(d.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(d.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(d.minWidth, 0) && this.chartHeight >= A(d.minHeight, 0);
                }).call(this) && c.push(b._id);
              };

              b.prototype.setResponsive = function (b, c) {
                var d = this,
                    h = this.options.responsive,
                    f = this.currentResponsive,
                    l = [];
                !c && h && h.rules && h.rules.forEach(function (b) {
                  "undefined" === typeof b._id && (b._id = n());
                  d.matchResponsiveRule(b, l);
                }, this);
                c = C.apply(void 0, l.map(function (b) {
                  return v((h || {}).rules || [], function (c) {
                    return c._id === b;
                  });
                }).map(function (b) {
                  return b && b.chartOptions;
                }));
                c.isResponsiveOptions = !0;
                l = l.toString() || void 0;
                l !== (f && f.ruleIds) && (f && this.update(f.undoOptions, b, !0), l ? (f = this.currentOptions(c), f.isResponsiveOptions = !0, this.currentResponsive = {
                  ruleIds: l,
                  mergedOptions: c,
                  undoOptions: f
                }, this.update(c, b, !0)) : this.currentResponsive = void 0);
              };

              return b;
            }();
          })(k || (k = {}));

          "";
          "";
          return k;
        });
        H(f, "masters/highcharts.src.js", [f["Core/Globals.js"], f["Core/Utilities.js"], f["Core/DefaultOptions.js"], f["Core/Animation/Fx.js"], f["Core/Animation/AnimationUtilities.js"], f["Core/Renderer/HTML/AST.js"], f["Core/FormatUtilities.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Renderer/HTML/HTMLElement.js"], f["Core/Renderer/HTML/HTMLRenderer.js"], f["Core/Axis/Axis.js"], f["Core/Axis/DateTimeAxis.js"], f["Core/Axis/LogarithmicAxis.js"], f["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], f["Core/Axis/Tick.js"], f["Core/Tooltip.js"], f["Core/Series/Point.js"], f["Core/Pointer.js"], f["Core/MSPointer.js"], f["Core/Legend/Legend.js"], f["Core/Chart/Chart.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Series/Column/ColumnSeries.js"], f["Series/Column/ColumnDataLabel.js"], f["Series/Pie/PieSeries.js"], f["Series/Pie/PieDataLabel.js"], f["Core/Series/DataLabel.js"], f["Core/Responsive.js"], f["Core/Color/Color.js"], f["Core/Time.js"]], function (c, f, v, D, r, C, F, A, u, n, k, d, b, h, p, z, E, y, t, q, l, g, w, a, B, e, G, m, x, J, M, P, L) {
          c.animate = r.animate;
          c.animObject = r.animObject;
          c.getDeferredAnimation = r.getDeferredAnimation;
          c.setAnimation = r.setAnimation;
          c.stop = r.stop;
          c.timers = D.timers;
          c.AST = C;
          c.Axis = b;
          c.Chart = w;
          c.chart = w.chart;
          c.Fx = D;
          c.Legend = g;
          c.PlotLineOrBand = z;
          c.Point = t;
          c.Pointer = l.isRequired() ? l : q;
          c.Series = a;
          c.SVGElement = u;
          c.SVGRenderer = n;
          c.Tick = E;
          c.Time = L;
          c.Tooltip = y;
          c.Color = P;
          c.color = P.parse;
          d.compose(n);
          k.compose(u);
          c.defaultOptions = v.defaultOptions;
          c.getOptions = v.getOptions;
          c.time = v.defaultTime;
          c.setOptions = v.setOptions;
          c.dateFormat = F.dateFormat;
          c.format = F.format;
          c.numberFormat = F.numberFormat;
          c.addEvent = f.addEvent;
          c.arrayMax = f.arrayMax;
          c.arrayMin = f.arrayMin;
          c.attr = f.attr;
          c.clearTimeout = f.clearTimeout;
          c.correctFloat = f.correctFloat;
          c.createElement = f.createElement;
          c.css = f.css;
          c.defined = f.defined;
          c.destroyObjectProperties = f.destroyObjectProperties;
          c.discardElement = f.discardElement;
          c.distribute = A.distribute;
          c.erase = f.erase;
          c.error = f.error;
          c.extend = f.extend;
          c.extendClass = f.extendClass;
          c.find = f.find;
          c.fireEvent = f.fireEvent;
          c.getMagnitude = f.getMagnitude;
          c.getStyle = f.getStyle;
          c.inArray = f.inArray;
          c.isArray = f.isArray;
          c.isClass = f.isClass;
          c.isDOMElement = f.isDOMElement;
          c.isFunction = f.isFunction;
          c.isNumber = f.isNumber;
          c.isObject = f.isObject;
          c.isString = f.isString;
          c.keys = f.keys;
          c.merge = f.merge;
          c.normalizeTickInterval = f.normalizeTickInterval;
          c.objectEach = f.objectEach;
          c.offset = f.offset;
          c.pad = f.pad;
          c.pick = f.pick;
          c.pInt = f.pInt;
          c.relativeLength = f.relativeLength;
          c.removeEvent = f.removeEvent;
          c.seriesType = B.seriesType;
          c.splat = f.splat;
          c.stableSort = f.stableSort;
          c.syncTimeout = f.syncTimeout;
          c.timeUnits = f.timeUnits;
          c.uniqueKey = f.uniqueKey;
          c.useSerialIds = f.useSerialIds;
          c.wrap = f.wrap;
          G.compose(e);
          J.compose(a);
          h.compose(b);
          p.compose(b);
          x.compose(m);
          z.compose(b);
          M.compose(w);
          return c;
        });
        H(f, "Core/Axis/Color/ColorAxisComposition.js", [f["Core/Color/Color.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = c.parse,
              D = f.addEvent,
              r = f.extend,
              C = f.merge,
              F = f.pick,
              A = f.splat,
              u;

          (function (c) {
            function f() {
              var a = this,
                  b = this.options;
              this.colorAxis = [];
              b.colorAxis && (b.colorAxis = A(b.colorAxis), b.colorAxis.forEach(function (b, c) {
                b.index = c;
                new w(a, b);
              }));
            }

            function d(a) {
              var b = this,
                  c = function c(_c17) {
                _c17 = a.allItems.indexOf(_c17);
                -1 !== _c17 && (b.destroyItem(a.allItems[_c17]), a.allItems.splice(_c17, 1));
              },
                  d = [],
                  g,
                  h;

              (this.chart.colorAxis || []).forEach(function (a) {
                (g = a.options) && g.showInLegend && (g.dataClasses && g.visible ? d = d.concat(a.getDataClassLegendSymbols()) : g.visible && d.push(a), a.series.forEach(function (a) {
                  if (!a.options.showInLegend || g.dataClasses) "point" === a.options.legendType ? a.points.forEach(function (a) {
                    c(a);
                  }) : c(a);
                }));
              });

              for (h = d.length; h--;) {
                a.allItems.unshift(d[h]);
              }
            }

            function b(a) {
              a.visible && a.item.legendColor && a.item.legendSymbol.attr({
                fill: a.item.legendColor
              });
            }

            function h() {
              var a = this.chart.colorAxis;
              a && a.forEach(function (a, b, c) {
                a.update({}, c);
              });
            }

            function p() {
              (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
            }

            function n() {
              var a = this.axisTypes;
              a ? -1 === a.indexOf("colorAxis") && a.push("colorAxis") : this.axisTypes = ["colorAxis"];
            }

            function u(a) {
              var b = this,
                  c = a ? "show" : "hide";
              b.visible = b.options.visible = !!a;
              ["graphic", "dataLabel"].forEach(function (a) {
                if (b[a]) b[a][c]();
              });
              this.series.buildKDTree();
            }

            function y() {
              var a = this,
                  b = this.options.nullColor,
                  c = this.colorAxis,
                  d = this.colorKey;
              (this.data.length ? this.data : this.points).forEach(function (e) {
                var g = e.getNestedProperty(d);
                (g = e.options.color || (e.isNull || null === e.value ? b : c && "undefined" !== typeof g ? c.toColor(g, e) : e.color || a.color)) && e.color !== g && (e.color = g, "point" === a.options.legendType && e.legendItem && a.chart.legend.colorizeItem(e, e.visible));
              });
            }

            function t(a) {
              var b = a.prototype.createAxis;

              a.prototype.createAxis = function (a, c) {
                if ("colorAxis" !== a) return b.apply(this, arguments);
                var d = new w(this, C(c.axis, {
                  index: this[a].length,
                  isX: !1
                }));
                this.isDirtyLegend = !0;
                this.axes.forEach(function (a) {
                  a.series = [];
                });
                this.series.forEach(function (a) {
                  a.bindAxes();
                  a.isDirtyData = !0;
                });
                F(c.redraw, !0) && this.redraw(c.animation);
                return d;
              };
            }

            function q() {
              this.elem.attr("fill", v(this.start).tweenTo(v(this.end), this.pos), void 0, !0);
            }

            function l() {
              this.elem.attr("stroke", v(this.start).tweenTo(v(this.end), this.pos), void 0, !0);
            }

            var g = [],
                w;

            c.compose = function (a, c, e, k, m) {
              w || (w = a);
              -1 === g.indexOf(c) && (g.push(c), a = c.prototype, a.collectionsWithUpdate.push("colorAxis"), a.collectionsWithInit.colorAxis = [a.addColorAxis], D(c, "afterGetAxes", f), t(c));
              -1 === g.indexOf(e) && (g.push(e), c = e.prototype, c.fillSetter = q, c.strokeSetter = l);
              -1 === g.indexOf(k) && (g.push(k), D(k, "afterGetAllItems", d), D(k, "afterColorizeItem", b), D(k, "afterUpdate", h));
              -1 === g.indexOf(m) && (g.push(m), r(m.prototype, {
                optionalAxis: "colorAxis",
                translateColors: y
              }), r(m.prototype.pointClass.prototype, {
                setVisible: u
              }), D(m, "afterTranslate", p), D(m, "bindAxes", n));
            };

            c.pointSetVisible = u;
          })(u || (u = {}));

          return u;
        });
        H(f, "Core/Axis/Color/ColorAxisDefaults.js", [], function () {
          return {
            lineWidth: 0,
            minPadding: 0,
            maxPadding: 0,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            startOnTick: !0,
            endOnTick: !0,
            offset: 0,
            marker: {
              animation: {
                duration: 50
              },
              width: .01,
              color: "#999999"
            },
            labels: {
              overflow: "justify",
              rotation: 0
            },
            minColor: "#e6ebf5",
            maxColor: "#003399",
            tickLength: 5,
            showInLegend: !0
          };
        });
        H(f, "Core/Axis/Color/ColorAxis.js", [f["Core/Axis/Axis.js"], f["Core/Color/Color.js"], f["Core/Axis/Color/ColorAxisComposition.js"], f["Core/Axis/Color/ColorAxisDefaults.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F, A) {
          var u = this && this.__extends || function () {
            var _b12 = function b(c, d) {
              _b12 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _b12(c, d);
            };

            return function (c, d) {
              function h() {
                this.constructor = c;
              }

              _b12(c, d);

              c.prototype = null === d ? Object.create(d) : (h.prototype = d.prototype, new h());
            };
          }(),
              n = f.parse,
              k = r.noop,
              d = F.series,
              b = A.extend,
              h = A.isNumber,
              p = A.merge,
              z = A.pick;

          f = function (c) {
            function f(b, d) {
              var h = c.call(this, b, d) || this;
              h.beforePadding = !1;
              h.chart = void 0;
              h.coll = "colorAxis";
              h.dataClasses = void 0;
              h.legendItem = void 0;
              h.legendItems = void 0;
              h.name = "";
              h.options = void 0;
              h.stops = void 0;
              h.visible = !0;
              h.init(b, d);
              return h;
            }

            u(f, c);

            f.compose = function (b, c, d, g) {
              v.compose(f, b, c, d, g);
            };

            f.prototype.init = function (b, d) {
              var h = b.options.legend || {},
                  g = d.layout ? "vertical" !== d.layout : "vertical" !== h.layout,
                  k = d.visible;
              h = p(f.defaultColorAxisOptions, d, {
                showEmpty: !1,
                title: null,
                visible: h.enabled && !1 !== k
              });
              this.coll = "colorAxis";
              this.side = d.side || g ? 2 : 1;
              this.reversed = d.reversed || !g;
              this.opposite = !g;
              c.prototype.init.call(this, b, h);
              this.userOptions.visible = k;
              d.dataClasses && this.initDataClasses(d);
              this.initStops();
              this.horiz = g;
              this.zoomEnabled = !1;
            };

            f.prototype.initDataClasses = function (b) {
              var c = this.chart,
                  d = this.options,
                  g = b.dataClasses.length,
                  h,
                  a = 0,
                  f = c.options.chart.colorCount;
              this.dataClasses = h = [];
              this.legendItems = [];
              (b.dataClasses || []).forEach(function (b, k) {
                b = p(b);
                h.push(b);
                if (c.styledMode || !b.color) "category" === d.dataClassColor ? (c.styledMode || (k = c.options.colors, f = k.length, b.color = k[a]), b.colorIndex = a, a++, a === f && (a = 0)) : b.color = n(d.minColor).tweenTo(n(d.maxColor), 2 > g ? .5 : k / (g - 1));
              });
            };

            f.prototype.hasData = function () {
              return !!(this.tickPositions || []).length;
            };

            f.prototype.setTickPositions = function () {
              if (!this.dataClasses) return c.prototype.setTickPositions.call(this);
            };

            f.prototype.initStops = function () {
              this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
              this.stops.forEach(function (b) {
                b.color = n(b[1]);
              });
            };

            f.prototype.setOptions = function (b) {
              c.prototype.setOptions.call(this, b);
              this.options.crosshair = this.options.marker;
            };

            f.prototype.setAxisSize = function () {
              var b = this.legendSymbol,
                  c = this.chart,
                  d = c.options.legend || {},
                  g,
                  h;
              b ? (this.left = d = b.attr("x"), this.top = g = b.attr("y"), this.width = h = b.attr("width"), this.height = b = b.attr("height"), this.right = c.chartWidth - d - h, this.bottom = c.chartHeight - g - b, this.len = this.horiz ? h : b, this.pos = this.horiz ? d : g) : this.len = (this.horiz ? d.symbolWidth : d.symbolHeight) || f.defaultLegendLength;
            };

            f.prototype.normalizedValue = function (b) {
              this.logarithmic && (b = this.logarithmic.log2lin(b));
              return 1 - (this.max - b) / (this.max - this.min || 1);
            };

            f.prototype.toColor = function (b, c) {
              var d = this.dataClasses,
                  g = this.stops,
                  h;
              if (d) for (h = d.length; h--;) {
                var a = d[h];
                var f = a.from;
                g = a.to;

                if (("undefined" === typeof f || b >= f) && ("undefined" === typeof g || b <= g)) {
                  var e = a.color;
                  c && (c.dataClass = h, c.colorIndex = a.colorIndex);
                  break;
                }
              } else {
                b = this.normalizedValue(b);

                for (h = g.length; h-- && !(b > g[h][0]);) {
                  ;
                }

                f = g[h] || g[h + 1];
                g = g[h + 1] || f;
                b = 1 - (g[0] - b) / (g[0] - f[0] || 1);
                e = f.color.tweenTo(g.color, b);
              }
              return e;
            };

            f.prototype.getOffset = function () {
              var b = this.legendGroup,
                  d = this.chart.axisOffset[this.side];

              if (b) {
                this.axisParent = b;
                c.prototype.getOffset.call(this);
                var h = this.chart.legend;
                h.allItems.forEach(function (b) {
                  b instanceof f && b.drawLegendSymbol(h, b);
                });
                h.render();
                this.chart.getMargins(!0);
                this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width);
                this.chart.axisOffset[this.side] = d;
              }
            };

            f.prototype.setLegendColor = function () {
              var b = this.reversed,
                  c = b ? 1 : 0;
              b = b ? 0 : 1;
              c = this.horiz ? [c, 0, b, 0] : [0, b, 0, c];
              this.legendColor = {
                linearGradient: {
                  x1: c[0],
                  y1: c[1],
                  x2: c[2],
                  y2: c[3]
                },
                stops: this.stops
              };
            };

            f.prototype.drawLegendSymbol = function (b, c) {
              var d = b.padding,
                  g = b.options,
                  h = this.horiz,
                  a = z(g.symbolWidth, h ? f.defaultLegendLength : 12),
                  k = z(g.symbolHeight, h ? 12 : f.defaultLegendLength),
                  e = z(g.labelPadding, h ? 16 : 30);
              g = z(g.itemDistance, 10);
              this.setLegendColor();
              c.legendSymbol || (c.legendSymbol = this.chart.renderer.rect(0, b.baseline - 11, a, k).attr({
                zIndex: 1
              }).add(c.legendGroup));
              this.legendItemWidth = a + d + (h ? g : this.options.labels.x + this.maxLabelLength);
              this.legendItemHeight = k + d + (h ? e : 0);
            };

            f.prototype.setState = function (b) {
              this.series.forEach(function (c) {
                c.setState(b);
              });
            };

            f.prototype.setVisible = function () {};

            f.prototype.getSeriesExtremes = function () {
              var b = this.series,
                  c = b.length,
                  h;
              this.dataMin = Infinity;

              for (this.dataMax = -Infinity; c--;) {
                var g = b[c];
                var f = g.colorKey = z(g.options.colorKey, g.colorKey, g.pointValKey, g.zoneAxis, "y");
                var a = g.pointArrayMap;
                var k = g[f + "Min"] && g[f + "Max"];
                if (g[f + "Data"]) var e = g[f + "Data"];else if (a) {
                  e = [];
                  a = a.indexOf(f);
                  var p = g.yData;
                  if (0 <= a && p) for (h = 0; h < p.length; h++) {
                    e.push(z(p[h][a], p[h]));
                  }
                } else e = g.yData;
                k ? (g.minColorValue = g[f + "Min"], g.maxColorValue = g[f + "Max"]) : (e = d.prototype.getExtremes.call(g, e), g.minColorValue = e.dataMin, g.maxColorValue = e.dataMax);
                "undefined" !== typeof g.minColorValue && (this.dataMin = Math.min(this.dataMin, g.minColorValue), this.dataMax = Math.max(this.dataMax, g.maxColorValue));
                k || d.prototype.applyExtremes.call(g);
              }
            };

            f.prototype.drawCrosshair = function (b, d) {
              var h = d && d.plotX,
                  g = d && d.plotY,
                  f = this.pos,
                  a = this.len;

              if (d) {
                var k = this.toPixels(d.getNestedProperty(d.series.colorKey));
                k < f ? k = f - 2 : k > f + a && (k = f + a + 2);
                d.plotX = k;
                d.plotY = this.len - k;
                c.prototype.drawCrosshair.call(this, b, d);
                d.plotX = h;
                d.plotY = g;
                this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || "object" !== typeof this.crosshair || this.cross.attr({
                  fill: this.crosshair.color
                }));
              }
            };

            f.prototype.getPlotLinePath = function (b) {
              var d = this.left,
                  f = b.translatedValue,
                  g = this.top;
              return h(f) ? this.horiz ? [["M", f - 4, g - 6], ["L", f + 4, g - 6], ["L", f, g], ["Z"]] : [["M", d, f], ["L", d - 6, f + 6], ["L", d - 6, f - 6], ["Z"]] : c.prototype.getPlotLinePath.call(this, b);
            };

            f.prototype.update = function (b, d) {
              var h = this.chart.legend;
              this.series.forEach(function (b) {
                b.isDirtyData = !0;
              });
              (b.dataClasses && h.allItems || this.dataClasses) && this.destroyItems();
              c.prototype.update.call(this, b, d);
              this.legendItem && (this.setLegendColor(), h.colorizeItem(this, !0));
            };

            f.prototype.destroyItems = function () {
              var b = this.chart;
              this.legendItem ? b.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (c) {
                b.legend.destroyItem(c);
              });
              b.isDirtyLegend = !0;
            };

            f.prototype.destroy = function () {
              this.chart.isDirtyLegend = !0;
              this.destroyItems();
              c.prototype.destroy.apply(this, [].slice.call(arguments));
            };

            f.prototype.remove = function (b) {
              this.destroyItems();
              c.prototype.remove.call(this, b);
            };

            f.prototype.getDataClassLegendSymbols = function () {
              var c = this,
                  d = c.chart,
                  h = c.legendItems,
                  g = d.options.legend,
                  f = g.valueDecimals,
                  a = g.valueSuffix || "",
                  p;
              h.length || c.dataClasses.forEach(function (e, g) {
                var l = e.from,
                    n = e.to,
                    q = d.numberFormatter,
                    t = !0;
                p = "";
                "undefined" === typeof l ? p = "< " : "undefined" === typeof n && (p = "> ");
                "undefined" !== typeof l && (p += q(l, f) + a);
                "undefined" !== typeof l && "undefined" !== typeof n && (p += " - ");
                "undefined" !== typeof n && (p += q(n, f) + a);
                h.push(b({
                  chart: d,
                  name: p,
                  options: {},
                  drawLegendSymbol: C.drawRectangle,
                  visible: !0,
                  setState: k,
                  isDataClass: !0,
                  setVisible: function setVisible() {
                    this.visible = t = c.visible = !t;
                    c.series.forEach(function (a) {
                      a.points.forEach(function (a) {
                        a.dataClass === g && a.setVisible(t);
                      });
                    });
                    d.legend.colorizeItem(this, t);
                  }
                }, e));
              });
              return h;
            };

            f.defaultColorAxisOptions = D;
            f.defaultLegendLength = 200;
            f.keepProps = ["legendGroup", "legendItemHeight", "legendItemWidth", "legendItem", "legendSymbol"];
            return f;
          }(c);

          Array.prototype.push.apply(c.keepProps, f.keepProps);
          "";
          return f;
        });
        H(f, "Maps/MapNavigationOptionsDefault.js", [f["Core/DefaultOptions.js"], f["Core/Utilities.js"]], function (c, f) {
          f = f.extend;
          var v = {
            buttonOptions: {
              alignTo: "plotBox",
              align: "left",
              verticalAlign: "top",
              x: 0,
              width: 18,
              height: 18,
              padding: 5,
              style: {
                fontSize: "15px",
                fontWeight: "bold"
              },
              theme: {
                "stroke-width": 1,
                "text-align": "center"
              }
            },
            buttons: {
              zoomIn: {
                onclick: function onclick() {
                  this.mapZoom(.5);
                },
                text: "+",
                y: 0
              },
              zoomOut: {
                onclick: function onclick() {
                  this.mapZoom(2);
                },
                text: "-",
                y: 28
              }
            },
            mouseWheelSensitivity: 1.1
          };
          f(c.defaultOptions.lang, {
            zoomIn: "Zoom in",
            zoomOut: "Zoom out"
          });
          return c.defaultOptions.mapNavigation = v;
        });
        H(f, "Maps/MapNavigation.js", [f["Core/Chart/Chart.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f, v) {
          function D(b) {
            b && (b.preventDefault && b.preventDefault(), b.stopPropagation && b.stopPropagation(), b.cancelBubble = !0);
          }

          function r(b) {
            this.navButtons = [];
            this.init(b);
          }

          var C = f.doc,
              F = v.addEvent,
              A = v.extend,
              u = v.isNumber,
              n = v.merge,
              k = v.objectEach,
              d = v.pick;

          r.prototype.init = function (b) {
            this.chart = b;
          };

          r.prototype.update = function (b) {
            var c = this,
                f = this.chart,
                u = f.options.mapNavigation,
                r,
                y = function y(b) {
              this.handler.call(f, b);
              D(b);
            },
                t = c.navButtons;

            b && (u = f.options.mapNavigation = n(f.options.mapNavigation, b));

            for (; t.length;) {
              t.pop().destroy();
            }

            d(u.enableButtons, u.enabled) && !f.renderer.forExport && (c.navButtonsGroup || (c.navButtonsGroup = f.renderer.g().attr({
              zIndex: 4
            }).add()), k(u.buttons, function (b, d) {
              b = n(u.buttonOptions, b);
              !f.styledMode && b.theme && (r = b.theme, r.style = n(b.theme.style, b.style));
              var g = f.renderer.button(b.text || "", 0, 0, y, r, void 0, void 0, void 0, "zoomIn" === d ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + {
                zoomIn: "zoom-in",
                zoomOut: "zoom-out"
              }[d]).attr({
                width: b.width,
                height: b.height,
                title: f.options.lang[d],
                padding: b.padding,
                zIndex: 5
              }).add(c.navButtonsGroup);
              g.handler = b.onclick;
              F(g.element, "dblclick", D);
              t.push(g);
              A(b, {
                width: g.width,
                height: 2 * g.height
              });
              if (f.hasLoaded) g.align(b, !1, b.alignTo);else var h = F(f, "load", function () {
                g.element && g.align(b, !1, b.alignTo);
                h();
              });
            }), b = function b() {
              var b = f.exportingGroup && f.exportingGroup.getBBox();

              if (b) {
                var d = c.navButtonsGroup.getBBox();

                if (!(d.x >= b.x + b.width || d.x + d.width <= b.x || d.y >= b.y + b.height || d.y + d.height <= b.y)) {
                  var g = -d.y - d.height + b.y - 5;
                  b = b.y + b.height - d.y + 5;
                  c.navButtonsGroup.attr({
                    translateY: "bottom" === (u.buttonOptions && u.buttonOptions.verticalAlign) ? g : b
                  });
                }
              }
            }, f.hasLoaded || F(f, "render", b));
            this.updateEvents(u);
          };

          r.prototype.updateEvents = function (b) {
            var c = this.chart;
            d(b.enableDoubleClickZoom, b.enabled) || b.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || F(c.container, "dblclick", function (b) {
              c.pointer.onContainerDblClick(b);
            }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());
            d(b.enableMouseWheelZoom, b.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || F(c.container, void 0 !== C.onwheel ? "wheel" : void 0 !== C.onmousewheel ? "mousewheel" : "DOMMouseScroll", function (b) {
              c.pointer.inClass(b.target, "highcharts-no-mousewheel") || (c.pointer.onContainerMouseWheel(b), D(b));
              return !1;
            }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
          };

          A(c.prototype, {
            fitToBox: function fitToBox(b, c) {
              [["x", "width"], ["y", "height"]].forEach(function (d) {
                var h = d[0];
                d = d[1];
                b[h] + b[d] > c[h] + c[d] && (b[d] > c[d] ? (b[d] = c[d], b[h] = c[h]) : b[h] = c[h] + c[d] - b[d]);
                b[d] > c[d] && (b[d] = c[d]);
                b[h] < c[h] && (b[h] = c[h]);
              });
              return b;
            },
            mapZoom: function mapZoom(b, c, d, f, k) {
              this.mapView && (u(b) && (b = Math.log(b) / Math.log(.5)), this.mapView.zoomBy(b, u(c) && u(d) ? this.mapView.projection.inverse([c, d]) : void 0, u(f) && u(k) ? [f, k] : void 0));
            }
          });
          F(c, "beforeRender", function () {
            this.mapNavigation = new r(this);
            this.mapNavigation.update();
          });
          f.MapNavigation = r;
        });
        H(f, "Maps/MapPointer.js", [f["Core/Pointer.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = f.defined,
              D = f.extend,
              r = f.pick;
          f = f.wrap;
          var C = c.prototype.normalize,
              F = 0,
              A;
          D(c.prototype, {
            normalize: function normalize(c, f) {
              var k = this.chart;
              c = C.call(this, c, f);
              k && k.mapView && (f = k.mapView.pixelsToLonLat({
                x: c.chartX - k.plotLeft,
                y: c.chartY - k.plotTop
              })) && D(c, f);
              return c;
            },
            onContainerDblClick: function onContainerDblClick(c) {
              var f = this.chart;
              c = this.normalize(c);
              f.options.mapNavigation.enableDoubleClickZoomTo ? f.pointer.inClass(c.target, "highcharts-tracker") && f.hoverPoint && f.hoverPoint.zoomTo() : f.isInsidePlot(c.chartX - f.plotLeft, c.chartY - f.plotTop) && f.mapZoom(.5, void 0, void 0, c.chartX, c.chartY);
            },
            onContainerMouseWheel: function onContainerMouseWheel(c) {
              var f = this.chart;
              c = this.normalize(c);
              var k = v(c.wheelDelta) && -c.wheelDelta / 120 || c.deltaY || c.detail;
              1 <= Math.abs(k) && (F += Math.abs(k), A && clearTimeout(A), A = setTimeout(function () {
                F = 0;
              }, 50));
              10 > F && f.isInsidePlot(c.chartX - f.plotLeft, c.chartY - f.plotTop) && f.mapView && f.mapView.zoomBy((f.options.mapNavigation.mouseWheelSensitivity - 1) * -k, void 0, [c.chartX, c.chartY], 1 > Math.abs(k) ? !1 : void 0);
            }
          });
          f(c.prototype, "zoomOption", function (c) {
            var f = this.chart.options.mapNavigation;
            r(f.enableTouchZoom, f.enabled) && (this.chart.options.chart.pinchType = "xy");
            c.apply(this, [].slice.call(arguments, 1));
          });
          f(c.prototype, "pinchTranslate", function (c, f, k, d, b, h, p) {
            c.call(this, f, k, d, b, h, p);
            "map" === this.chart.options.chart.type && this.hasZoom && (c = d.scaleX > d.scaleY, this.pinchTranslateDirection(!c, f, k, d, b, h, p, c ? d.scaleX : d.scaleY));
          });
        });
        H(f, "Series/ColorMapComposition.js", [f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = c.seriesTypes.column.prototype,
              D = f.addEvent,
              r = f.defined,
              C;

          (function (c) {
            function f(c) {
              this.moveToTopOnHover && this.graphic && this.graphic.attr({
                zIndex: c && "hover" === c.state ? 1 : 0
              });
            }

            var u = [];
            c.pointMembers = {
              dataLabelOnNull: !0,
              moveToTopOnHover: !0,
              isValid: function isValid() {
                return null !== this.value && Infinity !== this.value && -Infinity !== this.value && (void 0 === this.value || !isNaN(this.value));
              }
            };
            c.seriesMembers = {
              colorKey: "value",
              axisTypes: ["xAxis", "yAxis", "colorAxis"],
              parallelArrays: ["x", "y", "value"],
              pointArrayMap: ["value"],
              trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
              colorAttribs: function colorAttribs(c) {
                var f = {};
                !r(c.color) || c.state && "normal" !== c.state || (f[this.colorProp || "fill"] = c.color);
                return f;
              },
              pointAttribs: v.pointAttribs
            };

            c.compose = function (c) {
              var k = c.prototype.pointClass;
              -1 === u.indexOf(k) && (u.push(k), D(k, "afterSetState", f));
              return c;
            };
          })(C || (C = {}));

          return C;
        });
        H(f, "Maps/MapSymbols.js", [f["Core/Renderer/SVG/SVGRenderer.js"]], function (c) {
          function f(c, f, r, C, F, A, u, n) {
            return [["M", c + F, f], ["L", c + r - A, f], ["C", c + r - A / 2, f, c + r, f + A / 2, c + r, f + A], ["L", c + r, f + C - u], ["C", c + r, f + C - u / 2, c + r - u / 2, f + C, c + r - u, f + C], ["L", c + n, f + C], ["C", c + n / 2, f + C, c, f + C - n / 2, c, f + C - n], ["L", c, f + F], ["C", c, f + F / 2, c + F / 2, f, c + F, f], ["Z"]];
          }

          c = c.prototype.symbols;

          c.bottombutton = function (c, D, r, C, F) {
            F = F && F.r || 0;
            return f(c - 1, D - 1, r, C, 0, 0, F, F);
          };

          c.topbutton = function (c, D, r, C, F) {
            F = F && F.r || 0;
            return f(c - 1, D - 1, r, C, F, F, 0, 0);
          };

          return c;
        });
        H(f, "Core/Chart/MapChart.js", [f["Core/Chart/Chart.js"], f["Core/DefaultOptions.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = this && this.__extends || function () {
            var _c18 = function c(f, k) {
              _c18 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, b) {
                c.__proto__ = b;
              } || function (c, b) {
                for (var d in b) {
                  b.hasOwnProperty(d) && (c[d] = b[d]);
                }
              };

              return _c18(f, k);
            };

            return function (f, k) {
              function d() {
                this.constructor = f;
              }

              _c18(f, k);

              f.prototype = null === k ? Object.create(k) : (d.prototype = k.prototype, new d());
            };
          }(),
              C = f.getOptions,
              F = D.merge,
              A = D.pick;

          c = function (c) {
            function f() {
              return null !== c && c.apply(this, arguments) || this;
            }

            r(f, c);

            f.prototype.init = function (f, d) {
              var b = C().credits;
              f = F({
                chart: {
                  panning: {
                    enabled: !0,
                    type: "xy"
                  },
                  type: "map"
                },
                credits: {
                  mapText: A(b.mapText, " \xA9 <a href=\"{geojson.copyrightUrl}\">{geojson.copyrightShort}</a>"),
                  mapTextFull: A(b.mapTextFull, "{geojson.copyright}")
                },
                mapView: {},
                tooltip: {
                  followTouchMove: !1
                }
              }, f);
              c.prototype.init.call(this, f, d);
            };

            return f;
          }(c);

          (function (c) {
            c.maps = {};

            c.mapChart = function (f, k, d) {
              return new c(f, k, d);
            };

            c.splitPath = function (c) {
              "string" === typeof c && (c = c.replace(/([A-Za-z])/g, " $1 ").replace(/^\s*/, "").replace(/\s*$/, ""), c = c.split(/[ ,;]+/).map(function (c) {
                return /[A-za-z]/.test(c) ? c : parseFloat(c);
              }));
              return v.prototype.pathToSegments(c);
            };
          })(c || (c = {}));

          return c;
        });
        H(f, "Maps/MapUtilities.js", [], function () {
          return {
            boundsFromPath: function boundsFromPath(c) {
              var f = -Number.MAX_VALUE,
                  v = Number.MAX_VALUE,
                  D = -Number.MAX_VALUE,
                  r = Number.MAX_VALUE,
                  C;
              c.forEach(function (c) {
                var A = c[c.length - 2];
                c = c[c.length - 1];
                "number" === typeof A && "number" === typeof c && (v = Math.min(v, A), f = Math.max(f, A), r = Math.min(r, c), D = Math.max(D, c), C = !0);
              });
              if (C) return {
                x1: v,
                y1: r,
                x2: f,
                y2: D
              };
            },
            pointInPolygon: function pointInPolygon(c, f) {
              var v,
                  D = !1,
                  r = c.x,
                  C = c.y;
              c = 0;

              for (v = f.length - 1; c < f.length; v = c++) {
                var F = f[c][1] > C;
                var A = f[v][1] > C;
                F !== A && r < (f[v][0] - f[c][0]) * (C - f[c][1]) / (f[v][1] - f[c][1]) + f[c][0] && (D = !D);
              }

              return D;
            }
          };
        });
        H(f, "Series/Map/MapPoint.js", [f["Series/ColorMapComposition.js"], f["Maps/MapUtilities.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = this && this.__extends || function () {
            var _c19 = function c(f, d) {
              _c19 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _c19(f, d);
            };

            return function (f, d) {
              function b() {
                this.constructor = f;
              }

              _c19(f, d);

              f.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              C = f.boundsFromPath,
              F = D.extend,
              A = D.isNumber,
              u = D.pick;

          f = function (c) {
            function f() {
              var d = null !== c && c.apply(this, arguments) || this;
              d.options = void 0;
              d.path = void 0;
              d.series = void 0;
              return d;
            }

            r(f, c);

            f.getProjectedPath = function (c, b) {
              c.projectedPath || (b && c.geometry ? (b.hasCoordinates = !0, c.projectedPath = b.path(c.geometry)) : c.projectedPath = c.path);
              return c.projectedPath || [];
            };

            f.prototype.applyOptions = function (d, b) {
              var f = this.series;
              d = c.prototype.applyOptions.call(this, d, b);
              b = f.joinBy;
              f.mapData && f.mapMap && (b = c.prototype.getNestedProperty.call(d, b[1]), (f = "undefined" !== typeof b && f.mapMap[b]) ? F(d, f) : d.value = d.value || null);
              return d;
            };

            f.prototype.getProjectedBounds = function (c) {
              c = f.getProjectedPath(this, c);
              c = C(c);
              var b = this.properties;

              if (c) {
                var d = b && b["hc-middle-x"];
                b = b && b["hc-middle-y"];
                c.midX = c.x1 + (c.x2 - c.x1) * u(this.middleX, A(d) ? d : .5);
                d = u(this.middleY, A(b) ? b : .5);
                this.geometry || (d = 1 - d);
                c.midY = c.y2 - (c.y2 - c.y1) * d;
                return c;
              }
            };

            f.prototype.onMouseOver = function (d) {
              D.clearTimeout(this.colorInterval);
              if (!this.isNull || this.series.options.nullInteraction) c.prototype.onMouseOver.call(this, d);else this.series.onMouseOut(d);
            };

            f.prototype.zoomTo = function () {
              var c = this.series.chart;
              c.mapView && this.bounds && (c.mapView.fitToBounds(this.bounds, void 0, !1), this.series.isDirty = !0, c.redraw());
            };

            return f;
          }(v.seriesTypes.scatter.prototype.pointClass);

          F(f.prototype, {
            dataLabelOnNull: c.pointMembers.dataLabelOnNull,
            moveToTopOnHover: c.pointMembers.moveToTopOnHover,
            isValid: c.pointMembers.isValid
          });
          return f;
        });
        H(f, "Maps/MapViewOptionsDefault.js", [], function () {
          return {
            center: [0, 0],
            maxZoom: void 0,
            padding: 0,
            projection: {
              name: void 0,
              parallels: void 0,
              rotation: void 0
            },
            zoom: void 0
          };
        });
        H(f, "Maps/MapViewInsetsOptionsDefault.js", [], function () {
          return {
            borderColor: "#cccccc",
            borderWidth: 1,
            center: [0, 0],
            padding: "10%",
            relativeTo: "mapBoundingBox",
            units: "percent"
          };
        });
        H(f, "Extensions/GeoJSON.js", [f["Core/Chart/Chart.js"], f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          function r(c, b) {
            b || (b = Object.keys(c.objects)[0]);
            b = c.objects[b];
            if (b["hc-decoded-geojson"]) return b["hc-decoded-geojson"];
            var d = c.arcs;

            if (c.transform) {
              var f = c.transform,
                  k = f.scale,
                  n = f.translate;
              d = c.arcs.map(function (b) {
                var c = 0,
                    d = 0;
                return b.map(function (b) {
                  b = b.slice();
                  b[0] = (c += b[0]) * k[0] + n[0];
                  b[1] = (d += b[1]) * k[1] + n[1];
                  return b;
                });
              });
            }

            var r = function r(b) {
              return "number" === typeof b[0] ? b.reduce(function (b, c, f) {
                var g = 0 > c ? d[~c] : d[c];
                0 > c ? (g = g.slice(0, 0 === f ? g.length : g.length - 1), g.reverse()) : f && (g = g.slice(1));
                return b.concat(g);
              }, []) : b.map(r);
            };

            f = b.geometries.map(function (b) {
              return {
                type: "Feature",
                properties: b.properties,
                geometry: {
                  type: b.type,
                  coordinates: b.coordinates || r(b.arcs)
                }
              };
            });
            c = {
              type: "FeatureCollection",
              copyright: c.copyright,
              copyrightShort: c.copyrightShort,
              copyrightUrl: c.copyrightUrl,
              features: f,
              "hc-recommended-mapview": b["hc-recommended-mapview"],
              bbox: c.bbox,
              title: c.title
            };
            return b["hc-decoded-geojson"] = c;
          }

          function C(c, b, f) {
            void 0 === b && (b = "map");
            var d = [];
            c = "Topology" === c.type ? r(c) : c;
            c.features.forEach(function (c) {
              var f = c.geometry || {},
                  h = f.type;
              f = f.coordinates;
              c = c.properties;
              var k;
              "map" !== b && "mapbubble" !== b || "Polygon" !== h && "MultiPolygon" !== h ? "mapline" !== b || "LineString" !== h && "MultiLineString" !== h ? "mappoint" === b && "Point" === h && f.length && (k = {
                geometry: {
                  coordinates: f,
                  type: h
                }
              }) : f.length && (k = {
                geometry: {
                  coordinates: f,
                  type: h
                }
              }) : f.length && (k = {
                geometry: {
                  coordinates: f,
                  type: h
                }
              });
              k && (h = c && (c.name || c.NAME), d.push(n(k, {
                name: "string" === typeof h ? h : void 0,
                properties: c
              })));
            });
            f && c.copyrightShort && (f.chart.mapCredits = F(f.chart.options.credits.mapText, {
              geojson: c
            }), f.chart.mapCreditsFull = F(f.chart.options.credits.mapTextFull, {
              geojson: c
            }));
            return d;
          }

          var F = f.format,
              A = v.win,
              u = D.error,
              n = D.extend,
              k = D.merge;
          f = D.wrap;
          "";

          c.prototype.transformFromLatLon = function (c, b) {
            var d = this.options.chart.proj4 || A.proj4;

            if (d) {
              var f = b.jsonmarginX;
              f = void 0 === f ? 0 : f;
              var k = b.jsonmarginY;
              k = void 0 === k ? 0 : k;
              var n = b.jsonres;
              n = void 0 === n ? 1 : n;
              var r = b.scale;
              r = void 0 === r ? 1 : r;
              var t = b.xoffset;
              t = void 0 === t ? 0 : t;
              var q = b.xpan;
              q = void 0 === q ? 0 : q;
              var l = b.yoffset;
              l = void 0 === l ? 0 : l;
              var g = b.ypan;
              g = void 0 === g ? 0 : g;
              c = d(b.crs, [c.lon, c.lat]);
              d = b.cosAngle || b.rotation && Math.cos(b.rotation);
              var w = b.sinAngle || b.rotation && Math.sin(b.rotation);
              b = b.rotation ? [c[0] * d + c[1] * w, -c[0] * w + c[1] * d] : c;
              return {
                x: ((b[0] - t) * r + q) * n + f,
                y: -(((l - b[1]) * r + g) * n - k)
              };
            }

            u(21, !1, this);
          };

          c.prototype.transformToLatLon = function (c, b) {
            var d = this.options.chart.proj4 || A.proj4;
            if (!d) u(21, !1, this);else if (null !== c.y) {
              var f = b.jsonmarginX,
                  k = b.jsonmarginY,
                  n = b.jsonres;
              n = void 0 === n ? 1 : n;
              var r = b.scale;
              r = void 0 === r ? 1 : r;
              var t = b.xoffset,
                  q = b.xpan,
                  l = b.yoffset,
                  g = b.ypan;
              c = {
                x: ((c.x - (void 0 === f ? 0 : f)) / n - (void 0 === q ? 0 : q)) / r + (void 0 === t ? 0 : t),
                y: ((c.y - (void 0 === k ? 0 : k)) / n + (void 0 === g ? 0 : g)) / r + (void 0 === l ? 0 : l)
              };
              f = b.cosAngle || b.rotation && Math.cos(b.rotation);
              k = b.sinAngle || b.rotation && Math.sin(b.rotation);
              b = d(b.crs, "WGS84", b.rotation ? {
                x: c.x * f + c.y * -k,
                y: c.x * k + c.y * f
              } : c);
              return {
                lat: b.y,
                lon: b.x
              };
            }
          };

          c.prototype.fromPointToLatLon = function (c) {
            return this.mapView && this.mapView.projectedUnitsToLonLat(c);
          };

          c.prototype.fromLatLonToPoint = function (c) {
            return this.mapView && this.mapView.lonLatToProjectedUnits(c);
          };

          f(c.prototype, "addCredits", function (c, b) {
            b = k(!0, this.options.credits, b);
            this.mapCredits && (b.href = null);
            c.call(this, b);
            this.credits && this.mapCreditsFull && this.credits.attr({
              title: this.mapCreditsFull
            });
          });
          v.geojson = C;
          return {
            geojson: C,
            topo2geo: r
          };
        });
        H(f, "Core/Geometry/PolygonClip.js", [], function () {
          var c = function c(_c20, f, C) {
            return (f[0] - _c20[0]) * (C[1] - _c20[1]) > (f[1] - _c20[1]) * (C[0] - _c20[0]);
          },
              f = function f(c, _f2, C, v) {
            var r = [c[0] - _f2[0], c[1] - _f2[1]],
                u = [C[0] - v[0], C[1] - v[1]];
            c = c[0] * _f2[1] - c[1] * _f2[0];
            C = C[0] * v[1] - C[1] * v[0];
            v = 1 / (r[0] * u[1] - r[1] * u[0]);
            r = [(c * u[0] - C * r[0]) * v, (c * u[1] - C * r[1]) * v];
            r.isIntersection = !0;
            return r;
          },
              v;

          (function (v) {
            v.clipLineString = function (c, f) {
              var r = [];
              c = v.clipPolygon(c, f, !1);

              for (f = 1; f < c.length; f++) {
                c[f].isIntersection && c[f - 1].isIntersection && (r.push(c.splice(0, f)), f = 0), f === c.length - 1 && r.push(c);
              }

              return r;
            };

            v.clipPolygon = function (r, v, D) {
              void 0 === D && (D = !0);

              for (var A = v[v.length - 1], u, n, k = r, d = 0; d < v.length; d++) {
                var b = k;
                r = v[d];
                k = [];
                u = D ? b[b.length - 1] : b[0];

                for (var h = 0; h < b.length; h++) {
                  n = b[h], c(A, r, n) ? (c(A, r, u) || k.push(f(A, r, u, n)), k.push(n)) : c(A, r, u) && k.push(f(A, r, u, n)), u = n;
                }

                A = r;
              }

              return k;
            };
          })(v || (v = {}));

          return v;
        });
        H(f, "Maps/Projections/LambertConformalConic.js", [], function () {
          var c = Math.sign || function (c) {
            return 0 === c ? 0 : 0 < c ? 1 : -1;
          },
              f = Math.PI / 180,
              v = Math.PI / 2;

          return function () {
            function D(r) {
              var C,
                  D = (r.parallels || []).map(function (c) {
                return c * f;
              }),
                  A = D[0] || 0;
              D = null !== (C = D[1]) && void 0 !== C ? C : A;
              C = Math.cos(A);
              "object" === typeof r.projectedBounds && (this.projectedBounds = r.projectedBounds);
              r = A === D ? Math.sin(A) : Math.log(C / Math.cos(D)) / Math.log(Math.tan((v + D) / 2) / Math.tan((v + A) / 2));
              1e-10 > Math.abs(r) && (r = 1e-10 * (c(r) || 1));
              this.n = r;
              this.c = C * Math.pow(Math.tan((v + A) / 2), r) / r;
            }

            D.prototype.forward = function (c) {
              var r = c[0] * f,
                  D = this.c,
                  A = this.n,
                  u = this.projectedBounds;
              c = c[1] * f;
              0 < D ? c < -v + .000001 && (c = -v + .000001) : c > v - .000001 && (c = v - .000001);
              var n = D / Math.pow(Math.tan((v + c) / 2), A);
              c = n * Math.sin(A * r) * 63.78137;
              r = 63.78137 * (D - n * Math.cos(A * r));
              D = [c, r];
              u && (c < u.x1 || c > u.x2 || r < u.y1 || r > u.y2) && (D.outside = !0);
              return D;
            };

            D.prototype.inverse = function (r) {
              var C = r[0] / 63.78137,
                  D = this.c,
                  A = this.n;
              r = D - r[1] / 63.78137;
              var u = c(A) * Math.sqrt(C * C + r * r),
                  n = Math.atan2(C, Math.abs(r)) * c(r);
              0 > r * A && (n -= Math.PI * c(C) * c(r));
              return [n / A / f, (2 * Math.atan(Math.pow(D / u, 1 / A)) - v) / f];
            };

            return D;
          }();
        });
        H(f, "Maps/Projections/EqualEarth.js", [], function () {
          var c = Math.sqrt(3) / 2;
          return function () {
            function f() {
              this.bounds = {
                x1: -200.37508342789243,
                x2: 200.37508342789243,
                y1: -97.52595454902263,
                y2: 97.52595454902263
              };
            }

            f.prototype.forward = function (f) {
              var v = Math.PI / 180,
                  r = Math.asin(c * Math.sin(f[1] * v)),
                  C = r * r,
                  F = C * C * C;
              return [f[0] * v * Math.cos(r) * 74.03120656864502 / (c * (1.340264 + 3 * -.081106 * C + F * (7 * .000893 + .034164 * C))), 74.03120656864502 * r * (1.340264 + -.081106 * C + F * (.000893 + .003796 * C))];
            };

            f.prototype.inverse = function (f) {
              var v = f[0] / 74.03120656864502;
              f = f[1] / 74.03120656864502;
              var r = 180 / Math.PI,
                  C = f,
                  F;

              for (F = 0; 12 > F; ++F) {
                var A = C * C;
                var u = A * A * A;
                var n = C * (1.340264 + -.081106 * A + u * (.000893 + .003796 * A)) - f;
                A = 1.340264 + 3 * -.081106 * A + u * (7 * .000893 + .034164 * A);
                C -= n /= A;
                if (1e-9 > Math.abs(n)) break;
              }

              A = C * C;
              return [r * c * v * (1.340264 + 3 * -.081106 * A + A * A * A * (7 * .000893 + .034164 * A)) / Math.cos(C), r * Math.asin(Math.sin(C) / c)];
            };

            return f;
          }();
        });
        H(f, "Maps/Projections/Miller.js", [], function () {
          var c = Math.PI / 4,
              f = Math.PI / 180;
          return function () {
            function v() {
              this.bounds = {
                x1: -200.37508342789243,
                x2: 200.37508342789243,
                y1: -146.91480769173063,
                y2: 146.91480769173063
              };
            }

            v.prototype.forward = function (v) {
              return [v[0] * f * 63.78137, 79.7267125 * Math.log(Math.tan(c + .4 * v[1] * f))];
            };

            v.prototype.inverse = function (v) {
              return [v[0] / 63.78137 / f, 2.5 * (Math.atan(Math.exp(v[1] / 63.78137 * .8)) - c) / f];
            };

            return v;
          }();
        });
        H(f, "Maps/Projections/Orthographic.js", [], function () {
          var c = Math.PI / 180;
          return function () {
            function f() {
              this.antimeridianCutting = !1;
              this.bounds = {
                x1: -63.78460826781007,
                x2: 63.78460826781007,
                y1: -63.78460826781007,
                y2: 63.78460826781007
              };
            }

            f.prototype.forward = function (f) {
              var v = f[0];
              f = f[1] * c;
              f = [Math.cos(f) * Math.sin(v * c) * 63.78460826781007, 63.78460826781007 * Math.sin(f)];
              if (-90 > v || 90 < v) f.outside = !0;
              return f;
            };

            f.prototype.inverse = function (f) {
              var v = f[0] / 63.78460826781007;
              f = f[1] / 63.78460826781007;
              var r = Math.sqrt(v * v + f * f),
                  C = Math.asin(r),
                  F = Math.sin(C);
              return [Math.atan2(v * F, r * Math.cos(C)) / c, Math.asin(r && f * F / r) / c];
            };

            return f;
          }();
        });
        H(f, "Maps/Projections/WebMercator.js", [], function () {
          var c = Math.PI / 180;
          return function () {
            function f() {
              this.bounds = {
                x1: -200.37508342789243,
                x2: 200.37508342789243,
                y1: -200.3750834278071,
                y2: 200.3750834278071
              };
              this.maxLatitude = 85.0511287798;
            }

            f.prototype.forward = function (f) {
              var v = Math.sin(f[1] * c);
              v = [63.78137 * f[0] * c, 63.78137 * Math.log((1 + v) / (1 - v)) / 2];
              85.0511287798 < Math.abs(f[1]) && (v.outside = !0);
              return v;
            };

            f.prototype.inverse = function (f) {
              return [f[0] / (63.78137 * c), (2 * Math.atan(Math.exp(f[1] / 63.78137)) - Math.PI / 2) / c];
            };

            return f;
          }();
        });
        H(f, "Maps/Projections/ProjectionRegistry.js", [f["Maps/Projections/LambertConformalConic.js"], f["Maps/Projections/EqualEarth.js"], f["Maps/Projections/Miller.js"], f["Maps/Projections/Orthographic.js"], f["Maps/Projections/WebMercator.js"]], function (c, f, v, D, r) {
          return {
            EqualEarth: f,
            LambertConformalConic: c,
            Miller: v,
            Orthographic: D,
            WebMercator: r
          };
        });
        H(f, "Maps/Projection.js", [f["Core/Geometry/PolygonClip.js"], f["Maps/Projections/ProjectionRegistry.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = this && this.__spreadArray || function (c, d, b) {
            if (b || 2 === arguments.length) for (var f = 0, k = d.length, n; f < k; f++) {
              !n && f in d || (n || (n = Array.prototype.slice.call(d, 0, f)), n[f] = d[f]);
            }
            return c.concat(n || Array.prototype.slice.call(d));
          },
              r = c.clipLineString,
              C = c.clipPolygon,
              F = v.clamp,
              A = v.erase,
              u = 2 * Math.PI / 360,
              n = function n(c) {
            -180 > c && (c += 360);
            180 < c && (c -= 360);
            return c;
          };

          return function () {
            function c(d) {
              void 0 === d && (d = {});
              this.hasGeoProjection = this.hasCoordinates = !1;
              this.maxLatitude = 90;
              this.options = d;
              var b = d.name,
                  f = d.projectedBounds,
                  k = d.rotation;
              this.rotator = k ? this.getRotator(k) : void 0;
              if (b = b ? c.registry[b] : void 0) this.def = new b(d);
              var n = this.def,
                  r = this.rotator;
              n && (this.maxLatitude = n.maxLatitude || 90, this.hasGeoProjection = !0);
              r && n ? (this.forward = function (b) {
                return n.forward(r.forward(b));
              }, this.inverse = function (b) {
                return r.inverse(n.inverse(b));
              }) : n ? (this.forward = function (b) {
                return n.forward(b);
              }, this.inverse = function (b) {
                return n.inverse(b);
              }) : r && (this.forward = r.forward, this.inverse = r.inverse);
              this.bounds = "world" === f ? n && n.bounds : f;
            }

            c.add = function (d, b) {
              c.registry[d] = b;
            };

            c.greatCircle = function (c, b, f) {
              var d = Math.atan2,
                  h = Math.cos,
                  k = Math.sin,
                  n = Math.sqrt,
                  t = c[1] * u,
                  q = c[0] * u,
                  l = b[1] * u,
                  g = b[0] * u,
                  r = l - t,
                  a = g - q;
              r = k(r / 2) * k(r / 2) + h(t) * h(l) * k(a / 2) * k(a / 2);
              r = 2 * d(n(r), n(1 - r));
              var B = Math.round(6371E3 * r / 5E5);
              a = [];
              f && a.push(c);
              if (1 < B) for (B = c = 1 / B; .999 > B; B += c) {
                var e = k((1 - B) * r) / k(r),
                    v = k(B * r) / k(r),
                    m = e * h(t) * h(q) + v * h(l) * h(g),
                    x = e * h(t) * k(q) + v * h(l) * k(g);
                e = e * k(t) + v * k(l);
                e = d(e, n(m * m + x * x));
                m = d(x, m);
                a.push([m / u, e / u]);
              }
              f && a.push(b);
              return a;
            };

            c.insertGreatCircles = function (d) {
              for (var b = d.length - 1; b--;) {
                if (10 < Math.max(Math.abs(d[b][0] - d[b + 1][0]), Math.abs(d[b][1] - d[b + 1][1]))) {
                  var f = c.greatCircle(d[b], d[b + 1]);
                  f.length && d.splice.apply(d, D([b + 1, 0], f, !1));
                }
              }
            };

            c.toString = function (c) {
              c = c || {};
              var b = c.rotation;
              return [c.name, b && b.join(",")].join(";");
            };

            c.prototype.lineIntersectsBounds = function (c) {
              var b = this.bounds || {},
                  d = b.x2,
                  f = b.y1,
                  k = b.y2,
                  n = function n(b, c, d) {
                var f = b[0];
                b = b[1];
                var h = c ? 0 : 1;
                if ("number" === typeof d && f[c] >= d !== b[c] >= d) return f = f[h] + (d - f[c]) / (b[c] - f[c]) * (b[h] - f[h]), c ? [f, d] : [d, f];
              },
                  r = c[0];

              if (b = n(c, 0, b.x1)) r = b, c[1] = b;else if (b = n(c, 0, d)) r = b, c[1] = b;
              if (b = n(c, 1, f)) r = b;else if (b = n(c, 1, k)) r = b;
              return r;
            };

            c.prototype.getRotator = function (c) {
              var b = c[0] * u,
                  d = (c[1] || 0) * u;
              c = (c[2] || 0) * u;
              var f = Math.cos(d),
                  k = Math.sin(d),
                  n = Math.cos(c),
                  r = Math.sin(c);
              if (0 !== b || 0 !== d || 0 !== c) return {
                forward: function forward(c) {
                  var d = c[0] * u + b,
                      h = c[1] * u,
                      g = Math.cos(h);
                  c = Math.cos(d) * g;
                  d = Math.sin(d) * g;
                  h = Math.sin(h);
                  g = h * f + c * k;
                  return [Math.atan2(d * n - g * r, c * f - h * k) / u, Math.asin(g * n + d * r) / u];
                },
                inverse: function inverse(c) {
                  var d = c[0] * u,
                      h = c[1] * u,
                      g = Math.cos(h);
                  c = Math.cos(d) * g;
                  d = Math.sin(d) * g;
                  h = Math.sin(h);
                  g = h * n - d * r;
                  return [(Math.atan2(d * n + h * r, c * f + g * k) - b) / u, Math.asin(g * f - c * k) / u];
                }
              };
            };

            c.prototype.forward = function (c) {
              return c;
            };

            c.prototype.inverse = function (c) {
              return c;
            };

            c.prototype.cutOnAntimeridian = function (d, b) {
              var f = [],
                  k = [d];
              d.forEach(function (a, c) {
                var e = d[c - 1];

                if (!c) {
                  if (!b) return;
                  e = d[d.length - 1];
                }

                var g = e[0],
                    h = a[0];
                (-90 > g || 90 < g) && (-90 > h || 90 < h) && 0 < g !== 0 < h && (h = F((180 - (g + 360) % 360) / ((h + 360) % 360 - (g + 360) % 360), 0, 1), f.push({
                  i: c,
                  lat: e[1] + h * (a[1] - e[1]),
                  direction: 0 > g ? 1 : -1,
                  previousLonLat: e,
                  lonLat: a
                }));
              });
              if (f.length) if (b) {
                if (1 === f.length % 2) {
                  var r = f.slice().sort(function (a, b) {
                    return Math.abs(b.lat) - Math.abs(a.lat);
                  })[0];
                  A(f, r);
                }

                for (var u = f.length - 2; 0 <= u;) {
                  var y = f[u].i,
                      t = n(180 + .000001 * f[u].direction),
                      q = n(180 - .000001 * f[u].direction);
                  y = d.splice.apply(d, D([y, f[u + 1].i - y], c.greatCircle([t, f[u].lat], [t, f[u + 1].lat], !0), !1));
                  y.push.apply(y, c.greatCircle([q, f[u + 1].lat], [q, f[u].lat], !0));
                  k.push(y);
                  u -= 2;
                }

                if (r) for (t = 0; t < k.length; t++) {
                  u = r.direction;
                  var l = r.lat;
                  q = k[t];
                  y = q.indexOf(r.lonLat);

                  if (-1 < y) {
                    t = (0 > l ? -1 : 1) * this.maxLatitude;
                    var g = n(180 + .000001 * u),
                        w = n(180 - .000001 * u);
                    l = c.greatCircle([g, l], [g, t], !0);

                    for (g += 120 * u; -180 < g && 180 > g; g += 120 * u) {
                      l.push([g, t]);
                    }

                    l.push.apply(l, c.greatCircle([w, t], [w, r.lat], !0));
                    q.splice.apply(q, D([y, 0], l, !1));
                    break;
                  }
                }
              } else for (u = f.length; u--;) {
                y = f[u].i, y = d.splice(y, d.length, [n(180 + .000001 * f[u].direction), f[u].lat]), y.unshift([n(180 - .000001 * f[u].direction), f[u].lat]), k.push(y);
              }
              return k;
            };

            c.prototype.path = function (d) {
              var b = this,
                  f = this.bounds,
                  k = this.def,
                  n = this.rotator,
                  u = [],
                  y = "Polygon" === d.type || "MultiPolygon" === d.type,
                  t = this.hasGeoProjection,
                  q = !k || !1 !== k.antimeridianCutting,
                  l = q ? n : void 0,
                  g = q ? k || this : this,
                  w;
              f && (w = [[f.x1, f.y1], [f.x2, f.y1], [f.x2, f.y2], [f.x1, f.y2]]);

              var a = function a(_a11) {
                _a11 = _a11.map(function (a) {
                  if (q) {
                    l && (a = l.forward(a));
                    var b = a[0];
                    .000001 > Math.abs(b - 180) && (b = 180 > b ? 179.999999 : 180.000001);
                    a = [b, a[1]];
                  }

                  return a;
                });
                var d = [_a11];
                t && (c.insertGreatCircles(_a11), q && (d = b.cutOnAntimeridian(_a11, y)));
                d.forEach(function (a) {
                  if (!(2 > a.length)) {
                    var b = !1,
                        d = !1,
                        e = function e(a) {
                      b ? u.push(["L", a[0], a[1]]) : (u.push(["M", a[0], a[1]]), b = !0);
                    },
                        h = !1,
                        k = !1,
                        l = a.map(function (a) {
                      a = g.forward(a);
                      a.outside ? h = !0 : k = !0;
                      Infinity === a[1] ? a[1] = 1E10 : -Infinity === a[1] && (a[1] = -1E10);
                      return a;
                    });

                    if (q) {
                      y && l.push(l[0]);

                      if (h) {
                        if (!k) return;
                        if (w) if (y) l = C(l, w);else if (f) {
                          r(l, w).forEach(function (a) {
                            b = !1;
                            a.forEach(e);
                          });
                          return;
                        }
                      }

                      l.forEach(e);
                    } else for (var p = 0; p < l.length; p++) {
                      var n = a[p],
                          z = l[p];
                      if (z.outside) d = !0;else {
                        if (y && !B) {
                          var B = n;
                          a.push(n);
                          l.push(z);
                        }

                        d && v && (y && t ? c.greatCircle(v, n).forEach(function (a) {
                          return e(g.forward(a));
                        }) : b = !1);
                        e(z);
                        var v = n;
                        d = !1;
                      }
                    }
                  }
                });
              };

              "LineString" === d.type ? a(d.coordinates) : "MultiLineString" === d.type ? d.coordinates.forEach(function (b) {
                return a(b);
              }) : "Polygon" === d.type ? (d.coordinates.forEach(function (b) {
                return a(b);
              }), u.length && u.push(["Z"])) : "MultiPolygon" === d.type && (d.coordinates.forEach(function (b) {
                b.forEach(function (b) {
                  return a(b);
                });
              }), u.length && u.push(["Z"]));
              return u;
            };

            c.registry = f;
            return c;
          }();
        });
        H(f, "Maps/MapView.js", [f["Maps/MapViewOptionsDefault.js"], f["Maps/MapViewInsetsOptionsDefault.js"], f["Extensions/GeoJSON.js"], f["Core/Chart/MapChart.js"], f["Maps/MapUtilities.js"], f["Maps/Projection.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F) {
          var A = this && this.__extends || function () {
            var _a12 = function a(b, c) {
              _a12 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var c in b) {
                  b.hasOwnProperty(c) && (a[c] = b[c]);
                }
              };

              return _a12(b, c);
            };

            return function (b, c) {
              function d() {
                this.constructor = b;
              }

              _a12(b, c);

              b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
          }(),
              u = this && this.__spreadArray || function (a, b, c) {
            if (c || 2 === arguments.length) for (var d = 0, e = b.length, f; d < e; d++) {
              !f && d in b || (f || (f = Array.prototype.slice.call(b, 0, d)), f[d] = b[d]);
            }
            return a.concat(f || Array.prototype.slice.call(b));
          },
              n = v.topo2geo,
              k = D.maps,
              d = r.boundsFromPath,
              b = r.pointInPolygon,
              h = F.addEvent,
              p = F.clamp,
              z = F.fireEvent,
              E = F.isArray,
              y = F.isNumber,
              t = F.isObject,
              q = F.isString,
              l = F.merge,
              g = F.pick,
              w = F.relativeLength,
              a = function a(_a13, b) {
            return Math.log(400.979322 / Math.max((_a13.x2 - _a13.x1) / (b.width / 256), (_a13.y2 - _a13.y1) / (b.height / 256))) / Math.log(2);
          },
              B = function () {
            function d(a, b) {
              var f = this;
              this.insets = [];
              this.padding = [0, 0, 0, 0];
              this.eventsToUnbind = [];
              var g;

              if (!(this instanceof e)) {
                var k = u([a.options.chart.map], (a.options.series || []).map(function (a) {
                  return a.mapData;
                }), !0).map(function (a) {
                  return f.getGeoMap(a);
                }),
                    m = [];
                k.forEach(function (a) {
                  a && (g || (g = a["hc-recommended-mapview"]), a.bbox && (a = a.bbox, m.push({
                    x1: a[0],
                    y1: a[1],
                    x2: a[2],
                    y2: a[3]
                  })));
                });
                var p = m.length && d.compositeBounds(m);

                if (p) {
                  var n = p.x1;
                  var q = p.y1,
                      t = p.x2;
                  p = p.y2;
                  n = 180 < t - n && 90 < p - q ? {
                    name: "EqualEarth"
                  } : {
                    name: "LambertConformalConic",
                    parallels: [q, p],
                    rotation: [-(n + t) / 2]
                  };
                }

                this.geoMap = k[0];
              }

              this.userOptions = b || {};
              k = l(c, {
                projection: n
              }, g, b);
              p = g && g.insets;
              b = b && b.insets;
              p && b && (k.insets = d.mergeInsets(p, b));
              this.chart = a;
              this.center = k.center;
              this.options = k;
              this.projection = new C(k.projection);
              this.playingField = a.plotBox;
              this.zoom = k.zoom || 0;
              this.createInsets();
              this.eventsToUnbind.push(h(a, "afterSetChartSize", function () {
                f.playingField = f.getField();
                if (void 0 === f.minZoom || f.minZoom === f.zoom) f.fitToBounds(void 0, void 0, !1), !f.chart.hasRendered && y(f.userOptions.zoom) && (f.zoom = f.userOptions.zoom), f.userOptions.center && l(!0, f.center, f.userOptions.center);
              }));
              this.setUpEvents();
            }

            d.mergeInsets = function (a, b) {
              var c = function c(a) {
                var b = {};
                a.forEach(function (a, c) {
                  b[a && a.id || "i".concat(c)] = a;
                });
                return b;
              },
                  d = l(c(a), c(b));

              return Object.keys(d).map(function (a) {
                return d[a];
              });
            };

            d.prototype.createInsets = function () {
              var a = this,
                  b = this.options,
                  c = b.insets;
              c && c.forEach(function (c) {
                c = new e(a, l(b.insetOptions, c));
                a.insets.push(c);
              });
            };

            d.prototype.fitToBounds = function (b, c, d, e) {
              void 0 === d && (d = !0);
              var f = b || this.getProjectedBounds();

              if (f) {
                var h = g(c, b ? 0 : this.options.padding);
                c = this.getField(!1);
                h = E(h) ? h : [h, h, h, h];
                this.padding = [w(h[0], c.height), w(h[1], c.width), w(h[2], c.height), w(h[3], c.width)];
                this.playingField = this.getField();
                c = a(f, this.playingField);
                b || (this.minZoom = c);
                b = this.projection.inverse([(f.x2 + f.x1) / 2, (f.y2 + f.y1) / 2]);
                this.setView(b, c, d, e);
              }
            };

            d.prototype.getField = function (a) {
              void 0 === a && (a = !0);
              a = a ? this.padding : [0, 0, 0, 0];
              return {
                x: a[3],
                y: a[0],
                width: this.chart.plotWidth - a[1] - a[3],
                height: this.chart.plotHeight - a[0] - a[2]
              };
            };

            d.prototype.getGeoMap = function (a) {
              if (q(a)) return k[a];

              if (t(a, !0)) {
                if ("FeatureCollection" === a.type) return a;
                if ("Topology" === a.type) return n(a);
              }
            };

            d.prototype.getMapBBox = function () {
              var a = this.getProjectedBounds(),
                  b = this.getScale();

              if (a) {
                var c = this.padding,
                    d = this.projectedUnitsToPixels({
                  x: a.x1,
                  y: a.y2
                });
                return {
                  width: (a.x2 - a.x1) * b + c[1] + c[3],
                  height: (a.y2 - a.y1) * b + c[0] + c[2],
                  x: d.x - c[3],
                  y: d.y - c[0]
                };
              }
            };

            d.prototype.getProjectedBounds = function () {
              var a = this.chart.series.reduce(function (a, b) {
                var c = b.getProjectedBounds && b.getProjectedBounds();
                c && !1 !== b.options.affectsMapView && a.push(c);
                return a;
              }, []);
              return this.projection.bounds || d.compositeBounds(a);
            };

            d.prototype.getScale = function () {
              return 256 / 400.979322 * Math.pow(2, this.zoom);
            };

            d.prototype.getSVGTransform = function () {
              var a = this.playingField,
                  b = a.x,
                  c = a.y,
                  d = a.width;
              a = a.height;
              var e = this.projection.forward(this.center),
                  f = this.projection.hasCoordinates ? -1 : 1,
                  g = this.getScale();
              f *= g;
              return {
                scaleX: g,
                scaleY: f,
                translateX: b + d / 2 - e[0] * g,
                translateY: c + a / 2 - e[1] * f
              };
            };

            d.prototype.lonLatToPixels = function (a) {
              if (a = this.lonLatToProjectedUnits(a)) return this.projectedUnitsToPixels(a);
            };

            d.prototype.lonLatToProjectedUnits = function (a) {
              var c = this.chart,
                  d = c.mapTransforms;

              if (d) {
                for (var e in d) {
                  if (Object.hasOwnProperty.call(d, e) && d[e].hitZone) {
                    var f = c.transformFromLatLon(a, d[e]);
                    if (f && b(f, d[e].hitZone.coordinates[0])) return f;
                  }
                }

                return c.transformFromLatLon(a, d["default"]);
              }

              d = 0;

              for (e = this.insets; d < e.length; d++) {
                if (c = e[d], c.options.geoBounds && b({
                  x: a.lon,
                  y: a.lat
                }, c.options.geoBounds.coordinates[0])) return a = c.projection.forward([a.lon, a.lat]), a = c.projectedUnitsToPixels({
                  x: a[0],
                  y: a[1]
                }), this.pixelsToProjectedUnits(a);
              }

              a = this.projection.forward([a.lon, a.lat]);
              if (!a.outside) return {
                x: a[0],
                y: a[1]
              };
            };

            d.prototype.projectedUnitsToLonLat = function (a) {
              var c = this.chart,
                  d = c.mapTransforms;

              if (d) {
                for (var e in d) {
                  if (Object.hasOwnProperty.call(d, e) && d[e].hitZone && b(a, d[e].hitZone.coordinates[0])) return c.transformToLatLon(a, d[e]);
                }

                return c.transformToLatLon(a, d["default"]);
              }

              d = this.projectedUnitsToPixels(a);
              e = 0;

              for (var f = this.insets; e < f.length; e++) {
                if (c = f[e], c.hitZone && b(d, c.hitZone.coordinates[0])) return a = c.pixelsToProjectedUnits(d), a = c.projection.inverse([a.x, a.y]), {
                  lon: a[0],
                  lat: a[1]
                };
              }

              a = this.projection.inverse([a.x, a.y]);
              return {
                lon: a[0],
                lat: a[1]
              };
            };

            d.prototype.redraw = function (a) {
              this.chart.series.forEach(function (a) {
                a.useMapGeometry && (a.isDirty = !0);
              });
              this.chart.redraw(a);
            };

            d.prototype.setView = function (a, b, c, d) {
              void 0 === c && (c = !0);
              a && (this.center = a);
              "number" === typeof b && ("number" === typeof this.minZoom && (b = Math.max(b, this.minZoom)), "number" === typeof this.options.maxZoom && (b = Math.min(b, this.options.maxZoom)), y(b) && (this.zoom = b));
              var e = this.getProjectedBounds();

              if (e) {
                a = this.projection.forward(this.center);
                var f = this.playingField;
                b = f.x;
                var g = f.y,
                    h = f.width;
                f = f.height;
                var k = this.getScale(),
                    l = this.projectedUnitsToPixels({
                  x: e.x1,
                  y: e.y1
                }),
                    m = this.projectedUnitsToPixels({
                  x: e.x2,
                  y: e.y2
                });
                e = [(e.x1 + e.x2) / 2, (e.y1 + e.y2) / 2];
                var p = l.x,
                    n = m.y;
                m = m.x;
                l = l.y;
                m - p < h ? a[0] = e[0] : p < b && m < b + h ? a[0] += Math.max(p - b, m - h - b) / k : m > b + h && p > b && (a[0] += Math.min(m - h - b, p - b) / k);
                l - n < f ? a[1] = e[1] : n < g && l < g + f ? a[1] -= Math.max(n - g, l - f - g) / k : l > g + f && n > g && (a[1] -= Math.min(l - f - g, n - g) / k);
                this.center = this.projection.inverse(a);
                this.insets.forEach(function (a) {
                  a.options.field && (a.hitZone = a.getHitZone(), a.playingField = a.getField());
                });
                this.render();
              }

              z(this, "afterSetView");
              c && this.redraw(d);
            };

            d.prototype.projectedUnitsToPixels = function (a) {
              var b = this.getScale(),
                  c = this.projection.forward(this.center),
                  d = this.playingField;
              return {
                x: d.x + d.width / 2 - b * (c[0] - a.x),
                y: d.y + d.height / 2 + b * (c[1] - a.y)
              };
            };

            d.prototype.pixelsToLonLat = function (a) {
              return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(a));
            };

            d.prototype.pixelsToProjectedUnits = function (a) {
              var b = a.x;
              a = a.y;
              var c = this.getScale(),
                  d = this.projection.forward(this.center),
                  e = this.playingField;
              return {
                x: d[0] + (b - (e.x + e.width / 2)) / c,
                y: d[1] - (a - (e.y + e.height / 2)) / c
              };
            };

            d.prototype.setUpEvents = function () {
              var b = this,
                  c = this.chart,
                  d,
                  e,
                  f,
                  g = function g(_g) {
                var h = c.pointer.pinchDown,
                    k = b.projection,
                    l = c.mouseDownX,
                    m = c.mouseDownY;
                1 === h.length && (l = h[0].chartX, m = h[0].chartY);

                if ("number" === typeof l && "number" === typeof m) {
                  var n = "" + l + ",".concat(m),
                      q = _g.originalEvent;
                  h = q.chartX;
                  q = q.chartY;
                  n !== e && (e = n, d = b.projection.forward(b.center), f = (b.projection.options.rotation || [0, 0]).slice());
                  n = (n = k.def && k.def.bounds) && a(n, b.playingField) || -Infinity;
                  "Orthographic" === k.options.name && (b.minZoom || Infinity) < 1.1 * n ? (k = 440 / (b.getScale() * Math.min(c.plotWidth, c.plotHeight)), f && (l = (l - h) * k - f[0], m = p(-f[1] - (m - q) * k, -80, 80), h = b.zoom, b.update({
                    projection: {
                      rotation: [-l, -m]
                    }
                  }, !1), b.zoom = h, c.redraw(!1))) : (k = b.getScale(), m = b.projection.inverse([d[0] + (l - h) / k, d[1] - (m - q) / k]), b.setView(m, void 0, !0, !1));

                  _g.preventDefault();
                }
              };

              h(c, "pan", g);
              h(c, "touchpan", g);
              h(c, "selection", function (a) {
                if (a.resetSelection) b.zoomBy();else {
                  var d = a.x - c.plotLeft,
                      e = a.y - c.plotTop,
                      f = b.pixelsToProjectedUnits({
                    x: d,
                    y: e
                  }),
                      g = f.y;
                  f = f.x;
                  d = b.pixelsToProjectedUnits({
                    x: d + a.width,
                    y: e + a.height
                  });
                  b.fitToBounds({
                    x1: f,
                    y1: g,
                    x2: d.x,
                    y2: d.y
                  }, void 0, !0, a.originalEvent.touches ? !1 : void 0);
                  /^touch/.test(a.originalEvent.type) || c.showResetZoom();
                  a.preventDefault();
                }
              });
            };

            d.prototype.render = function () {
              this.group || (this.group = this.chart.renderer.g("map-view").attr({
                zIndex: 4
              }).add());
            };

            d.prototype.update = function (a, b, c) {
              void 0 === b && (b = !0);
              var d = a.projection;
              d = d && C.toString(d) !== C.toString(this.options.projection);
              var e = !1;
              l(!0, this.userOptions, a);
              l(!0, this.options, a);
              "insets" in a && (this.insets.forEach(function (a) {
                return a.destroy();
              }), this.insets.length = 0, e = !0);
              if (d || e) this.chart.series.forEach(function (a) {
                var b = a.transformGroups;
                a.clearBounds && a.clearBounds();
                a.isDirty = !0;
                a.isDirtyData = !0;
                if (e && b) for (; 1 < b.length;) {
                  (a = b.pop()) && a.destroy();
                }
              }), d && (this.projection = new C(this.options.projection)), e && this.createInsets(), a.center || y(a.zoom) || this.fitToBounds(void 0, void 0, !1);
              (a.center || y(a.zoom)) && this.setView(this.options.center, a.zoom, !1);
              b && this.chart.redraw(c);
            };

            d.prototype.zoomBy = function (a, b, c, d) {
              var e = this.chart,
                  f = this.projection.forward(this.center);
              b = b ? this.projection.forward(b) : [];
              var g = b[0],
                  h = b[1];
              "number" === typeof a ? (a = this.zoom + a, b = void 0, c && (g = c[0], h = c[1], c = this.getScale(), g = g - e.plotLeft - e.plotWidth / 2, e = h - e.plotTop - e.plotHeight / 2, g = f[0] + g / c, h = f[1] + e / c), "number" === typeof g && "number" === typeof h && (c = 1 - Math.pow(2, this.zoom) / Math.pow(2, a), g = f[0] - g, e = f[1] - h, f[0] -= g * c, f[1] += e * c, b = this.projection.inverse(f)), this.setView(b, a, void 0, d)) : this.fitToBounds(void 0, void 0, void 0, d);
            };

            d.compositeBounds = function (a) {
              if (a.length) return a.slice(1).reduce(function (a, b) {
                a.x1 = Math.min(a.x1, b.x1);
                a.y1 = Math.min(a.y1, b.y1);
                a.x2 = Math.max(a.x2, b.x2);
                a.y2 = Math.max(a.y2, b.y2);
                return a;
              }, l(a[0]));
            };

            return d;
          }(),
              e = function (a) {
            function c(b, c) {
              var e = a.call(this, b.chart, c) || this;
              e.id = c.id;
              e.mapView = b;
              e.options = l(f, c);
              e.allBounds = [];
              e.options.geoBounds && (b = b.projection.path(e.options.geoBounds), e.geoBoundsProjectedBox = d(b), e.geoBoundsProjectedPolygon = b.map(function (a) {
                return [a[1] || 0, a[2] || 0];
              }));
              return e;
            }

            A(c, a);

            c.prototype.getField = function (b) {
              void 0 === b && (b = !0);
              var c = this.hitZone;

              if (c) {
                var d = b ? this.padding : [0, 0, 0, 0];
                c = c.coordinates[0];
                var e = c.map(function (a) {
                  return a[0];
                }),
                    f = c.map(function (a) {
                  return a[1];
                });
                c = Math.min.apply(0, e) + d[3];
                e = Math.max.apply(0, e) - d[1];
                var g = Math.min.apply(0, f) + d[0];
                d = Math.max.apply(0, f) - d[2];
                if (y(c) && y(g)) return {
                  x: c,
                  y: g,
                  width: e - c,
                  height: d - g
                };
              }

              return a.prototype.getField.call(this, b);
            };

            c.prototype.getHitZone = function () {
              var a = this.chart,
                  b = this.mapView,
                  c = this.options,
                  d = (c.field || {}).coordinates;

              if (d) {
                d = d[0];

                if ("percent" === c.units) {
                  var e = "mapBoundingBox" === c.relativeTo && b.getMapBBox() || l(a.plotBox, {
                    x: 0,
                    y: 0
                  });
                  d = d.map(function (a) {
                    return [w("" + a[0] + "%", e.width, e.x), w("" + a[1] + "%", e.height, e.y)];
                  });
                }

                return {
                  type: "Polygon",
                  coordinates: [d]
                };
              }
            };

            c.prototype.getProjectedBounds = function () {
              return B.compositeBounds(this.allBounds);
            };

            c.prototype.isInside = function (a) {
              var c = this.geoBoundsProjectedBox,
                  d = this.geoBoundsProjectedPolygon;
              return !!(c && a.x >= c.x1 && a.x <= c.x2 && a.y >= c.y1 && a.y <= c.y2 && d && b(a, d));
            };

            c.prototype.render = function () {
              var a = this.chart,
                  b = this.mapView,
                  c = this.options,
                  d = c.borderPath || c.field;

              if (d && b.group) {
                var e = !0;
                this.border || (this.border = a.renderer.path().addClass("highcharts-mapview-inset-border").add(b.group), e = !1);
                a.styledMode || this.border.attr({
                  stroke: c.borderColor,
                  "stroke-width": c.borderWidth
                });
                var f = Math.round(this.border.strokeWidth()) % 2 / 2,
                    g = "mapBoundingBox" === c.relativeTo && b.getMapBBox() || b.playingField;
                b = (d.coordinates || []).reduce(function (b, d) {
                  return d.reduce(function (b, d, e) {
                    var h = d[0];
                    d = d[1];
                    "percent" === c.units && (h = a.plotLeft + w("" + h + "%", g.width, g.x), d = a.plotTop + w("" + d + "%", g.height, g.y));
                    h = Math.floor(h) + f;
                    d = Math.floor(d) + f;
                    b.push(0 === e ? ["M", h, d] : ["L", h, d]);
                    return b;
                  }, b);
                }, []);
                this.border[e ? "animate" : "attr"]({
                  d: b
                });
              }
            };

            c.prototype.destroy = function () {
              this.border && (this.border = this.border.destroy());
              this.eventsToUnbind.forEach(function (a) {
                return a();
              });
            };

            c.prototype.setUpEvents = function () {};

            return c;
          }(B);

          h(D, "afterInit", function () {
            this.mapView = new B(this, this.options.mapView);
          });
          return B;
        });
        H(f, "Series/Map/MapSeries.js", [f["Core/Animation/AnimationUtilities.js"], f["Series/ColorMapComposition.js"], f["Series/CenteredUtilities.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Chart/MapChart.js"], f["Series/Map/MapPoint.js"], f["Maps/MapView.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F, A, u, n, k, d) {
          var b = this && this.__extends || function () {
            var _a14 = function a(b, c) {
              _a14 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var c in b) {
                  b.hasOwnProperty(c) && (a[c] = b[c]);
                }
              };

              return _a14(b, c);
            };

            return function (b, c) {
              function d() {
                this.constructor = b;
              }

              _a14(b, c);

              b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
          }(),
              h = c.animObject;

          c = D.noop;
          var p = C.splitPath;
          C = n.seriesTypes;
          var z = C.column,
              E = C.scatter;
          C = d.extend;
          var y = d.find,
              t = d.fireEvent,
              q = d.getNestedProperty,
              l = d.isArray,
              g = d.isNumber,
              w = d.isObject,
              a = d.merge,
              B = d.objectEach,
              e = d.pick,
              G = d.splat;

          d = function (c) {
            function d() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.chart = void 0;
              a.data = void 0;
              a.group = void 0;
              a.joinBy = void 0;
              a.options = void 0;
              a.points = void 0;
              a.processedData = [];
              return a;
            }

            b(d, c);

            d.prototype.animate = function (a) {
              var b = this.chart,
                  c = this.group,
                  d = h(this.options.animation);
              b.renderer.isSVG && (a ? c.attr({
                translateX: b.plotLeft + b.plotWidth / 2,
                translateY: b.plotTop + b.plotHeight / 2,
                scaleX: .001,
                scaleY: .001
              }) : c.animate({
                translateX: b.plotLeft,
                translateY: b.plotTop,
                scaleX: 1,
                scaleY: 1
              }, d));
            };

            d.prototype.animateDrilldown = function (a) {
              var b = this.chart,
                  c = this.group;
              b.renderer.isSVG && (a ? c.attr({
                translateX: b.plotLeft + b.plotWidth / 2,
                translateY: b.plotTop + b.plotHeight / 2,
                scaleX: .1,
                scaleY: .1,
                opacity: .01
              }) : (c.animate({
                translateX: b.plotLeft,
                translateY: b.plotTop,
                scaleX: 1,
                scaleY: 1,
                opacity: 1
              }, this.chart.options.drilldown.animation), b.drilldown && b.drilldown.fadeInGroup(this.dataLabelsGroup)));
            };

            d.prototype.animateDrillupFrom = function () {
              var a = this.chart;
              a.renderer.isSVG && this.group.animate({
                translateX: a.plotLeft + a.plotWidth / 2,
                translateY: a.plotTop + a.plotHeight / 2,
                scaleX: .1,
                scaleY: .1,
                opacity: .01
              });
            };

            d.prototype.animateDrillupTo = function (a) {
              z.prototype.animateDrillupTo.call(this, a);
            };

            d.prototype.clearBounds = function () {
              this.points.forEach(function (a) {
                delete a.bounds;
                delete a.insetIndex;
                delete a.projectedPath;
              });
              delete this.bounds;
            };

            d.prototype.doFullTranslate = function () {
              return !(!(this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML) && this.hasRendered);
            };

            d.prototype.drawMapDataLabels = function () {
              u.prototype.drawDataLabels.call(this);
              this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            };

            d.prototype.drawPoints = function () {
              var a = this,
                  b = this,
                  c = this.chart,
                  d = this.group,
                  f = this.transformGroups,
                  g = void 0 === f ? [] : f,
                  h = c.mapView,
                  k = c.renderer;
              h && (this.transformGroups = g, g[0] || (g[0] = k.g().add(d)), h.insets.forEach(function (a, b) {
                g[b + 1] || g.push(k.g().add(d));
              }), this.doFullTranslate() && (this.points.forEach(function (b) {
                var d = b.graphic,
                    e = b.shapeArgs;
                b.group = g["number" === typeof b.insetIndex ? b.insetIndex + 1 : 0];
                d && d.parentGroup !== b.group && d.add(b.group);
                e && c.hasRendered && !c.styledMode && (e.fill = a.pointAttribs(b, b.state).fill);
              }), z.prototype.drawPoints.apply(this), this.points.forEach(function (d) {
                var f = d.graphic;

                if (f) {
                  var g = f.animate,
                      h = "";
                  d.name && (h += "highcharts-name-" + d.name.replace(/ /g, "-").toLowerCase());
                  d.properties && d.properties["hc-key"] && (h += " highcharts-key-" + d.properties["hc-key"].toString().toLowerCase());
                  h && f.addClass(h);
                  c.styledMode && f.css(a.pointAttribs(d, d.selected && "select" || void 0));

                  f.animate = function (a, d, h) {
                    var k = !1;

                    if (a["stroke-width"]) {
                      var l = e(b.getStrokeWidth(b.options), 1) / (c.mapView && c.mapView.getScale() || 1);
                      "inherit" === f["stroke-width"] && (f["stroke-width"] = l);
                      "inherit" === a["stroke-width"] && (a["stroke-width"] = l, k = !0);
                    }

                    return g.call(f, a, d, k ? function () {
                      f.attr({
                        "stroke-width": "inherit"
                      });
                      h && h.apply(this, arguments);
                    } : h);
                  };
                }
              })), g.forEach(function (b, d) {
                var f = (0 === d ? h : h.insets[d - 1]).getSVGTransform(),
                    g = e(a.getStrokeWidth(a.options), 1),
                    l = f.scaleX,
                    m = 0 < f.scaleY ? 1 : -1;

                if (k.globalAnimation && c.hasRendered) {
                  var p = Number(b.attr("translateX")),
                      n = Number(b.attr("translateY")),
                      q = Number(b.attr("scaleX"));
                  b.attr({
                    animator: 0
                  }).animate({
                    animator: 1
                  }, {
                    step: function step(a, c) {
                      a = q + (l - q) * c.pos;
                      b.attr({
                        translateX: p + (f.translateX - p) * c.pos,
                        translateY: n + (f.translateY - n) * c.pos,
                        scaleX: a,
                        scaleY: a * m
                      });
                      b.element.setAttribute("stroke-width", g / a);
                    }
                  });
                } else b.attr(f), b.element.setAttribute("stroke-width", g / l);
              }), this.drawMapDataLabels());
            };

            d.prototype.getProjectedBounds = function () {
              if (!this.bounds && this.chart.mapView) {
                var a = this.chart.mapView,
                    b = a.insets,
                    c = a.projection,
                    d = [];
                (this.points || []).forEach(function (a) {
                  if (a.path || a.geometry) {
                    "string" === typeof a.path ? a.path = p(a.path) : l(a.path) && "M" === a.path[0] && (a.path = k.prototype.pathToSegments(a.path));

                    if (!a.bounds) {
                      var f = a.getProjectedBounds(c);

                      if (f) {
                        a.labelrank = e(a.labelrank, (f.x2 - f.x1) * (f.y2 - f.y1));
                        var h = f.midX,
                            m = f.midY;

                        if (b && g(h) && g(m)) {
                          var n = y(b, function (a) {
                            return a.isInside({
                              x: h,
                              y: m
                            });
                          });
                          n && (delete a.projectedPath, (f = a.getProjectedBounds(n.projection)) && n.allBounds.push(f), a.insetIndex = b.indexOf(n));
                        }

                        a.bounds = f;
                      }
                    }

                    a.bounds && void 0 === a.insetIndex && d.push(a.bounds);
                  }
                });
                this.bounds = A.compositeBounds(d);
              }

              return this.bounds;
            };

            d.prototype.getStrokeWidth = function (a) {
              var b = this.pointAttrToOptions;
              return a[b && b["stroke-width"] || "borderWidth"];
            };

            d.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            d.prototype.pointAttribs = function (b, c) {
              var d = b.series.chart,
                  f = d.mapView;
              d = d.styledMode ? this.colorAttribs(b) : z.prototype.pointAttribs.call(this, b, c);
              var h = this.getStrokeWidth(b.options);
              c && (b = a(this.options.states[c], b.options.states && b.options.states[c] || {}), h = this.getStrokeWidth(b));
              h && f && (h /= f.getScale());
              b = this.getStrokeWidth(this.options);
              d.dashstyle && f && g(b) && (h = b / f.getScale());
              d["stroke-width"] = e(h, "inherit");
              return d;
            };

            d.prototype.updateData = function () {
              return this.processedData ? !1 : c.prototype.updateData.apply(this, arguments);
            };

            d.prototype.setData = function (a, b, d, e) {
              void 0 === b && (b = !0);
              delete this.bounds;
              c.prototype.setData.call(this, a, !1, void 0, e);
              this.processData();
              this.generatePoints();
              b && this.chart.redraw(d);
            };

            d.prototype.processData = function () {
              var b = this.options,
                  c = b.data,
                  d = this.chart.options.chart,
                  e = this.joinBy,
                  f = b.keys || this.pointArrayMap,
                  h = [],
                  k = {},
                  m = this.chart.mapView;
              m = m && (w(b.mapData, !0) ? m.getGeoMap(b.mapData) : m.geoMap);
              var p = this.chart.mapTransforms;
              (this.chart.mapTransforms = p = d.mapTransforms || m && m["hc-transform"] || p) && B(p, function (a) {
                a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation));
              });
              if (l(b.mapData)) var n = b.mapData;else m && "FeatureCollection" === m.type && (this.mapTitle = m.title, n = D.geojson(m, this.type, this));
              var t = this.processedData = [];
              c && c.forEach(function (a, d) {
                var h = 0;
                if (g(a)) t[d] = {
                  value: a
                };else if (l(a)) {
                  t[d] = {};
                  !b.keys && a.length > f.length && "string" === typeof a[0] && (t[d]["hc-key"] = a[0], ++h);

                  for (var k = 0; k < f.length; ++k, ++h) {
                    f[k] && "undefined" !== typeof a[h] && (0 < f[k].indexOf(".") ? F.prototype.setNestedProperty(t[d], a[h], f[k]) : t[d][f[k]] = a[h]);
                  }
                } else t[d] = c[d];
                e && "_i" === e[0] && (t[d]._i = d);
              });

              if (n) {
                this.mapData = n;
                this.mapMap = {};

                for (p = 0; p < n.length; p++) {
                  d = n[p], m = d.properties, d._i = p, e[0] && m && m[e[0]] && (d[e[0]] = m[e[0]]), k[d[e[0]]] = d;
                }

                this.mapMap = k;

                if (e[1]) {
                  var r = e[1];
                  t.forEach(function (a) {
                    a = q(r, a);
                    k[a] && h.push(k[a]);
                  });
                }

                if (b.allAreas) {
                  if (e[1]) {
                    var u = e[1];
                    t.forEach(function (a) {
                      h.push(q(u, a));
                    });
                  }

                  var y = "|" + h.map(function (a) {
                    return a && a[e[0]];
                  }).join("|") + "|";
                  n.forEach(function (b) {
                    e[0] && -1 !== y.indexOf("|" + b[e[0]] + "|") || t.push(a(b, {
                      value: null
                    }));
                  });
                }
              }

              this.processedXData = Array(t.length);
            };

            d.prototype.setOptions = function (a) {
              a = u.prototype.setOptions.call(this, a);
              var b = a.joinBy;
              null === b && (b = "_i");
              b = this.joinBy = G(b);
              b[1] || (b[1] = b[0]);
              return a;
            };

            d.prototype.translate = function () {
              var a = this.doFullTranslate(),
                  b = this.chart.mapView,
                  c = b && b.projection;
              !this.chart.hasRendered || !this.isDirtyData && this.hasRendered || (this.processData(), this.generatePoints(), delete this.bounds, !b || b.userOptions.center || g(b.userOptions.zoom) ? this.getProjectedBounds() : b.fitToBounds(void 0, void 0, !1));

              if (b) {
                var d = b.getSVGTransform();
                this.points.forEach(function (e) {
                  var f = g(e.insetIndex) && b.insets[e.insetIndex].getSVGTransform() || d;
                  f && e.bounds && g(e.bounds.midX) && g(e.bounds.midY) && (e.plotX = e.bounds.midX * f.scaleX + f.translateX, e.plotY = e.bounds.midY * f.scaleY + f.translateY);
                  a && (e.shapeType = "path", e.shapeArgs = {
                    d: F.getProjectedPath(e, c)
                  });
                });
              }

              t(this, "afterTranslate");
            };

            d.defaultOptions = a(E.defaultOptions, {
              affectsMapView: !0,
              animation: !1,
              dataLabels: {
                crop: !1,
                formatter: function formatter() {
                  var a = this.series.chart.numberFormatter,
                      b = this.point.value;
                  return g(b) ? a(b, -1) : "";
                },
                inside: !0,
                overflow: !1,
                padding: 0,
                verticalAlign: "middle"
              },
              marker: null,
              nullColor: "#f7f7f7",
              stickyTracking: !1,
              tooltip: {
                followPointer: !0,
                pointFormat: "{point.name}: {point.value}<br/>"
              },
              turboThreshold: 0,
              allAreas: !0,
              borderColor: "#cccccc",
              borderWidth: 1,
              joinBy: "hc-key",
              states: {
                hover: {
                  halo: null,
                  brightness: .2
                },
                normal: {
                  animation: !0
                },
                select: {
                  color: "#cccccc"
                },
                inactive: {
                  opacity: 1
                }
              }
            });
            return d;
          }(E);

          C(d.prototype, {
            type: "map",
            axisTypes: f.seriesMembers.axisTypes,
            colorAttribs: f.seriesMembers.colorAttribs,
            colorKey: f.seriesMembers.colorKey,
            directTouch: !0,
            drawDataLabels: c,
            drawGraph: c,
            drawLegendSymbol: r.drawRectangle,
            forceDL: !0,
            getCenter: v.getCenter,
            getExtremesFromAll: !0,
            getSymbol: c,
            isCartesian: !1,
            parallelArrays: f.seriesMembers.parallelArrays,
            pointArrayMap: f.seriesMembers.pointArrayMap,
            pointClass: F,
            preserveAspectRatio: !0,
            searchPoint: c,
            trackerGroups: f.seriesMembers.trackerGroups,
            useMapGeometry: !0
          });
          f.compose(d);
          n.registerSeriesType("map", d);
          "";
          return d;
        });
        H(f, "Series/MapLine/MapLineSeries.js", [f["Series/Map/MapSeries.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = this && this.__extends || function () {
            var _c21 = function c(f, n) {
              _c21 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, d) {
                c.__proto__ = d;
              } || function (c, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (c[b] = d[b]);
                }
              };

              return _c21(f, n);
            };

            return function (f, n) {
              function k() {
                this.constructor = f;
              }

              _c21(f, n);

              f.prototype = null === n ? Object.create(n) : (k.prototype = n.prototype, new k());
            };
          }(),
              r = f.series,
              C = v.extend,
              F = v.merge;

          v = function (f) {
            function r() {
              var c = null !== f && f.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            D(r, f);

            r.prototype.pointAttribs = function (f, k) {
              f = c.prototype.pointAttribs.call(this, f, k);
              f.fill = this.options.fillColor;
              return f;
            };

            r.defaultOptions = F(c.defaultOptions, {
              lineWidth: 1,
              fillColor: "none"
            });
            return r;
          }(c);

          C(v.prototype, {
            type: "mapline",
            colorProp: "stroke",
            drawLegendSymbol: r.prototype.drawLegendSymbol,
            pointAttrToOptions: {
              stroke: "color",
              "stroke-width": "lineWidth"
            }
          });
          f.registerSeriesType("mapline", v);
          "";
          return v;
        });
        H(f, "Series/MapPoint/MapPointPoint.js", [f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = this && this.__extends || function () {
            var _c22 = function c(f, r) {
              _c22 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, f) {
                c.__proto__ = f;
              } || function (c, f) {
                for (var n in f) {
                  f.hasOwnProperty(n) && (c[n] = f[n]);
                }
              };

              return _c22(f, r);
            };

            return function (f, r) {
              function v() {
                this.constructor = f;
              }

              _c22(f, r);

              f.prototype = null === r ? Object.create(r) : (v.prototype = r.prototype, new v());
            };
          }(),
              D = f.isNumber;

          return function (c) {
            function f() {
              var f = null !== c && c.apply(this, arguments) || this;
              f.options = void 0;
              f.series = void 0;
              return f;
            }

            v(f, c);

            f.prototype.isValid = function () {
              return !!(this.options.geometry || D(this.x) && D(this.y) || D(this.options.lon) && D(this.options.lat));
            };

            return f;
          }(c.seriesTypes.scatter.prototype.pointClass);
        });
        H(f, "Series/MapPoint/MapPointSeries.js", [f["Core/Globals.js"], f["Series/MapPoint/MapPointPoint.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = this && this.__extends || function () {
            var _c23 = function c(d, b) {
              _c23 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _c23(d, b);
            };

            return function (d, b) {
              function f() {
                this.constructor = d;
              }

              _c23(d, b);

              d.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());
            };
          }();

          c = c.noop;
          var C = v.seriesTypes.scatter,
              F = D.extend,
              A = D.fireEvent,
              u = D.isNumber,
              n = D.merge;

          D = function (c) {
            function d() {
              var b = null !== c && c.apply(this, arguments) || this;
              b.chart = void 0;
              b.data = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            r(d, c);

            d.prototype.drawDataLabels = function () {
              c.prototype.drawDataLabels.call(this);
              this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            };

            d.prototype.projectPoint = function (b) {
              var c = this.chart.mapView;

              if (c) {
                var d = b.geometry,
                    f = b.lon;
                b = b.lat;
                d = d && "Point" === d.type && d.coordinates;
                u(f) && u(b) && (d = [f, b]);
                if (d) return c.lonLatToProjectedUnits({
                  lon: d[0],
                  lat: d[1]
                });
              }
            };

            d.prototype.translate = function () {
              var b = this,
                  c = this.chart.mapView;
              this.processedXData || this.processData();
              this.generatePoints();
              this.getProjectedBounds && this.isDirtyData && (delete this.bounds, this.getProjectedBounds());

              if (c) {
                var d = c.projection.hasCoordinates;
                this.points.forEach(function (f) {
                  var h = f.x;
                  h = void 0 === h ? void 0 : h;
                  var k = f.y;
                  k = void 0 === k ? void 0 : k;
                  var p = b.projectPoint(f.options);
                  p ? (h = p.x, k = p.y) : f.bounds && (h = f.bounds.midX, k = f.bounds.midY);
                  u(h) && u(k) ? (h = c.projectedUnitsToPixels({
                    x: h,
                    y: k
                  }), f.plotX = h.x, f.plotY = d ? h.y : b.chart.plotHeight - h.y) : f.y = f.plotX = f.plotY = void 0;
                  f.isInside = b.isPointInside(f);
                  f.zone = b.zones.length ? f.getZone() : void 0;
                });
              }

              A(this, "afterTranslate");
            };

            d.defaultOptions = n(C.defaultOptions, {
              dataLabels: {
                crop: !1,
                defer: !1,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.name;
                },
                overflow: !1,
                style: {
                  color: "#000000"
                }
              }
            });
            return d;
          }(C);

          F(D.prototype, {
            type: "mappoint",
            axisTypes: ["colorAxis"],
            forceDL: !0,
            isCartesian: !1,
            pointClass: f,
            searchPoint: c,
            useMapGeometry: !0
          });
          v.registerSeriesType("mappoint", D);
          "";
          return D;
        });
        H(f, "Series/Bubble/BubbleLegendDefaults.js", [], function () {
          return {
            borderColor: void 0,
            borderWidth: 2,
            className: void 0,
            color: void 0,
            connectorClassName: void 0,
            connectorColor: void 0,
            connectorDistance: 60,
            connectorWidth: 1,
            enabled: !1,
            labels: {
              className: void 0,
              allowOverlap: !1,
              format: "",
              formatter: void 0,
              align: "right",
              style: {
                fontSize: "10px",
                color: "#000000"
              },
              x: 0,
              y: 0
            },
            maxSize: 60,
            minSize: 10,
            legendIndex: 0,
            ranges: {
              value: void 0,
              borderColor: void 0,
              color: void 0,
              connectorColor: void 0
            },
            sizeBy: "area",
            sizeByAbsoluteValue: !1,
            zIndex: 1,
            zThreshold: 0
          };
        });
        H(f, "Series/Bubble/BubbleLegendItem.js", [f["Core/Color/Color.js"], f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = c.parse,
              C = v.noop,
              F = D.arrayMax,
              A = D.arrayMin,
              u = D.isNumber,
              n = D.merge,
              k = D.pick,
              d = D.stableSort;
          "";
          return function () {
            function b(b, c) {
              this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;
              this.setState = C;
              this.init(b, c);
            }

            b.prototype.init = function (b, c) {
              this.options = b;
              this.visible = !0;
              this.chart = c.chart;
              this.legend = c;
            };

            b.prototype.addToLegend = function (b) {
              b.splice(this.options.legendIndex, 0, this);
            };

            b.prototype.drawLegendSymbol = function (b) {
              var c = this.chart,
                  f = this.options,
                  h = k(b.options.itemDistance, 20),
                  n = f.ranges,
                  t = f.connectorDistance;
              this.fontMetrics = c.renderer.fontMetrics(f.labels.style.fontSize);
              n && n.length && u(n[0].value) ? (d(n, function (b, c) {
                return c.value - b.value;
              }), this.ranges = n, this.setOptions(), this.render(), b = this.getMaxLabelSize(), n = this.ranges[0].radius, c = 2 * n, t = t - n + b.width, t = 0 < t ? t : 0, this.maxLabel = b, this.movementX = "left" === f.labels.align ? t : 0, this.legendItemWidth = c + t + h, this.legendItemHeight = c + this.fontMetrics.h / 2) : b.options.bubbleLegend.autoRanges = !0;
            };

            b.prototype.setOptions = function () {
              var b = this.ranges,
                  c = this.options,
                  d = this.chart.series[c.seriesIndex],
                  f = this.legend.baseline,
                  u = {
                zIndex: c.zIndex,
                "stroke-width": c.borderWidth
              },
                  t = {
                zIndex: c.zIndex,
                "stroke-width": c.connectorWidth
              },
                  q = {
                align: this.legend.options.rtl || "left" === c.labels.align ? "right" : "left",
                zIndex: c.zIndex
              },
                  l = d.options.marker.fillOpacity,
                  g = this.chart.styledMode;
              b.forEach(function (h, a) {
                g || (u.stroke = k(h.borderColor, c.borderColor, d.color), u.fill = k(h.color, c.color, 1 !== l ? r(d.color).setOpacity(l).get("rgba") : d.color), t.stroke = k(h.connectorColor, c.connectorColor, d.color));
                b[a].radius = this.getRangeRadius(h.value);
                b[a] = n(b[a], {
                  center: b[0].radius - b[a].radius + f
                });
                g || n(!0, b[a], {
                  bubbleAttribs: n(u),
                  connectorAttribs: n(t),
                  labelAttribs: q
                });
              }, this);
            };

            b.prototype.getRangeRadius = function (b) {
              var c = this.options;
              return this.chart.series[this.options.seriesIndex].getRadius.call(this, c.ranges[c.ranges.length - 1].value, c.ranges[0].value, c.minSize, c.maxSize, b);
            };

            b.prototype.render = function () {
              var b = this.chart.renderer,
                  c = this.options.zThreshold;
              this.symbols || (this.symbols = {
                connectors: [],
                bubbleItems: [],
                labels: []
              });
              this.legendSymbol = b.g("bubble-legend");
              this.legendItem = b.g("bubble-legend-item");
              this.legendSymbol.translateX = 0;
              this.legendSymbol.translateY = 0;
              this.ranges.forEach(function (b) {
                b.value >= c && this.renderRange(b);
              }, this);
              this.legendSymbol.add(this.legendItem);
              this.legendItem.add(this.legendGroup);
              this.hideOverlappingLabels();
            };

            b.prototype.renderRange = function (b) {
              var c = this.options,
                  d = c.labels,
                  f = this.chart,
                  h = f.series[c.seriesIndex],
                  k = f.renderer,
                  n = this.symbols;
              f = n.labels;
              var l = b.center,
                  g = Math.abs(b.radius),
                  r = c.connectorDistance || 0,
                  a = d.align,
                  u = c.connectorWidth,
                  e = this.ranges[0].radius || 0,
                  v = l - g - c.borderWidth / 2 + u / 2,
                  m = this.fontMetrics;
              m = m.f / 2 - (m.h - m.f) / 2;
              var x = k.styledMode;
              r = this.legend.options.rtl || "left" === a ? -r : r;
              "center" === a && (r = 0, c.connectorDistance = 0, b.labelAttribs.align = "center");
              a = v + c.labels.y;
              var A = e + r + c.labels.x;
              n.bubbleItems.push(k.circle(e, l + ((v % 1 ? 1 : .5) - (u % 2 ? 0 : .5)), g).attr(x ? {} : b.bubbleAttribs).addClass((x ? "highcharts-color-" + h.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (c.className || "")).add(this.legendSymbol));
              n.connectors.push(k.path(k.crispLine([["M", e, v], ["L", e + r, v]], c.connectorWidth)).attr(x ? {} : b.connectorAttribs).addClass((x ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (c.connectorClassName || "")).add(this.legendSymbol));
              b = k.text(this.formatLabel(b), A, a + m).attr(x ? {} : b.labelAttribs).css(x ? {} : d.style).addClass("highcharts-bubble-legend-labels " + (c.labels.className || "")).add(this.legendSymbol);
              f.push(b);
              b.placed = !0;
              b.alignAttr = {
                x: A,
                y: a + m
              };
            };

            b.prototype.getMaxLabelSize = function () {
              var b, c;
              this.symbols.labels.forEach(function (d) {
                c = d.getBBox(!0);
                b = b ? c.width > b.width ? c : b : c;
              });
              return b || {};
            };

            b.prototype.formatLabel = function (b) {
              var c = this.options,
                  d = c.labels.formatter;
              c = c.labels.format;
              var h = this.chart.numberFormatter;
              return c ? f.format(c, b) : d ? d.call(b) : h(b.value, 1);
            };

            b.prototype.hideOverlappingLabels = function () {
              var b = this.chart,
                  c = this.symbols;
              !this.options.labels.allowOverlap && c && (b.hideOverlappingLabels(c.labels), c.labels.forEach(function (b, d) {
                b.newOpacity ? b.newOpacity !== b.oldOpacity && c.connectors[d].show() : c.connectors[d].hide();
              }));
            };

            b.prototype.getRanges = function () {
              var b = this.legend.bubbleLegend,
                  c = b.options.ranges,
                  d,
                  f = Number.MAX_VALUE,
                  r = -Number.MAX_VALUE;
              b.chart.series.forEach(function (b) {
                b.isBubble && !b.ignoreSeries && (d = b.zData.filter(u), d.length && (f = k(b.options.zMin, Math.min(f, Math.max(A(d), !1 === b.options.displayNegative ? b.options.zThreshold : -Number.MAX_VALUE))), r = k(b.options.zMax, Math.max(r, F(d)))));
              });
              var t = f === r ? [{
                value: r
              }] : [{
                value: f
              }, {
                value: (f + r) / 2
              }, {
                value: r,
                autoRanges: !0
              }];
              c.length && c[0].radius && t.reverse();
              t.forEach(function (b, d) {
                c && c[d] && (t[d] = n(c[d], b));
              });
              return t;
            };

            b.prototype.predictBubbleSizes = function () {
              var b = this.chart,
                  c = this.fontMetrics,
                  d = b.legend.options,
                  f = d.floating,
                  k = (d = "horizontal" === d.layout) ? b.legend.lastLineHeight : 0,
                  n = b.plotSizeX,
                  q = b.plotSizeY,
                  l = b.series[this.options.seriesIndex],
                  g = l.getPxExtremes();
              b = Math.ceil(g.minPxSize);
              g = Math.ceil(g.maxPxSize);
              var r = Math.min(q, n);
              l = l.options.maxSize;
              if (f || !/%$/.test(l)) c = g;else if (l = parseFloat(l), c = (r + k - c.h / 2) * l / 100 / (l / 100 + 1), d && q - c >= n || !d && n - c >= q) c = g;
              return [b, Math.ceil(c)];
            };

            b.prototype.updateRanges = function (b, c) {
              var d = this.legend.options.bubbleLegend;
              d.minSize = b;
              d.maxSize = c;
              d.ranges = this.getRanges();
            };

            b.prototype.correctSizes = function () {
              var b = this.legend,
                  c = this.chart.series[this.options.seriesIndex].getPxExtremes();
              1 < Math.abs(Math.ceil(c.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, c.maxPxSize), b.render());
            };

            return b;
          }();
        });
        H(f, "Series/Bubble/BubbleLegendComposition.js", [f["Series/Bubble/BubbleLegendDefaults.js"], f["Series/Bubble/BubbleLegendItem.js"], f["Core/DefaultOptions.js"], f["Core/Utilities.js"]], function (c, f, v, D) {
          var r = v.setOptions,
              C = D.addEvent,
              F = D.objectEach,
              A = D.wrap,
              u;

          (function (n) {
            function k(c, f, h) {
              var k = this.legend,
                  g = 0 <= d(this);

              if (k && k.options.enabled && k.bubbleLegend && k.options.bubbleLegend.autoRanges && g) {
                var n = k.bubbleLegend.options;
                g = k.bubbleLegend.predictBubbleSizes();
                k.bubbleLegend.updateRanges(g[0], g[1]);
                n.placed || (k.group.placed = !1, k.allItems.forEach(function (a) {
                  a.legendGroup.translateY = null;
                }));
                k.render();
                this.getMargins();
                this.axes.forEach(function (a) {
                  a.visible && a.render();
                  n.placed || (a.setScale(), a.updateNames(), F(a.ticks, function (a) {
                    a.isNew = !0;
                    a.isNewLabel = !0;
                  }));
                });
                n.placed = !0;
                this.getMargins();
                c.call(this, f, h);
                k.bubbleLegend.correctSizes();
                u(k, b(k));
              } else c.call(this, f, h), k && k.options.enabled && k.bubbleLegend && (k.render(), u(k, b(k)));
            }

            function d(b) {
              b = b.series;

              for (var c = 0; c < b.length;) {
                if (b[c] && b[c].isBubble && b[c].visible && b[c].zData.length) return c;
                c++;
              }

              return -1;
            }

            function b(b) {
              b = b.allItems;
              var c = [],
                  d = b.length,
                  f,
                  g = 0;

              for (f = 0; f < d; f++) {
                if (b[f].legendItemHeight && (b[f].itemHeight = b[f].legendItemHeight), b[f] === b[d - 1] || b[f + 1] && b[f]._legendItemPos[1] !== b[f + 1]._legendItemPos[1]) {
                  c.push({
                    height: 0
                  });
                  var h = c[c.length - 1];

                  for (g; g <= f; g++) {
                    b[g].itemHeight > h.height && (h.height = b[g].itemHeight);
                  }

                  h.step = f;
                }
              }

              return c;
            }

            function h(b) {
              var c = this.bubbleLegend,
                  h = this.options,
                  k = h.bubbleLegend,
                  g = d(this.chart);
              c && c.ranges && c.ranges.length && (k.ranges.length && (k.autoRanges = !!k.ranges[0].autoRanges), this.destroyItem(c));
              0 <= g && h.enabled && k.enabled && (k.seriesIndex = g, this.bubbleLegend = new f(k, this), this.bubbleLegend.addToLegend(b.allItems));
            }

            function p() {
              var b = this.chart,
                  c = this.visible,
                  f = this.chart.legend;
              f && f.bubbleLegend && (this.visible = !c, this.ignoreSeries = c, b = 0 <= d(b), f.bubbleLegend.visible !== b && (f.update({
                bubbleLegend: {
                  enabled: b
                }
              }), f.bubbleLegend.visible = b), this.visible = c);
            }

            function u(b, c) {
              var d = b.options.rtl,
                  f,
                  g,
                  h,
                  a = 0;
              b.allItems.forEach(function (b, e) {
                f = b.legendGroup.translateX;
                g = b._legendItemPos[1];
                if ((h = b.movementX) || d && b.ranges) h = d ? f - b.options.maxSize / 2 : f + h, b.legendGroup.attr({
                  translateX: h
                });
                e > c[a].step && a++;
                b.legendGroup.attr({
                  translateY: Math.round(g + c[a].height / 2)
                });
                b._legendItemPos[1] = g + c[a].height / 2;
              });
            }

            var v = [];

            n.compose = function (b, d, f) {
              -1 === v.indexOf(b) && (v.push(b), r({
                legend: {
                  bubbleLegend: c
                }
              }), A(b.prototype, "drawChartBox", k));
              -1 === v.indexOf(d) && (v.push(d), C(d, "afterGetAllItems", h));
              -1 === v.indexOf(f) && (v.push(f), C(f, "legendItemClick", p));
            };
          })(u || (u = {}));

          return u;
        });
        H(f, "Series/Bubble/BubblePoint.js", [f["Core/Series/Point.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v) {
          var D = this && this.__extends || function () {
            var _c24 = function c(f, r) {
              _c24 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, f) {
                c.__proto__ = f;
              } || function (c, f) {
                for (var n in f) {
                  f.hasOwnProperty(n) && (c[n] = f[n]);
                }
              };

              return _c24(f, r);
            };

            return function (f, r) {
              function v() {
                this.constructor = f;
              }

              _c24(f, r);

              f.prototype = null === r ? Object.create(r) : (v.prototype = r.prototype, new v());
            };
          }();

          v = v.extend;

          f = function (f) {
            function r() {
              var c = null !== f && f.apply(this, arguments) || this;
              c.options = void 0;
              c.series = void 0;
              return c;
            }

            D(r, f);

            r.prototype.haloPath = function (f) {
              return c.prototype.haloPath.call(this, 0 === f ? 0 : (this.marker ? this.marker.radius || 0 : 0) + f);
            };

            return r;
          }(f.seriesTypes.scatter.prototype.pointClass);

          v(f.prototype, {
            ttBelow: !1
          });
          return f;
        });
        H(f, "Series/Bubble/BubbleSeries.js", [f["Core/Axis/Axis.js"], f["Series/Bubble/BubbleLegendComposition.js"], f["Series/Bubble/BubblePoint.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F, A) {
          var u = this && this.__extends || function () {
            var _b13 = function b(c, d) {
              _b13 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var c in a) {
                  a.hasOwnProperty(c) && (b[c] = a[c]);
                }
              };

              return _b13(c, d);
            };

            return function (c, d) {
              function f() {
                this.constructor = c;
              }

              _b13(c, d);

              c.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
            };
          }(),
              n = D.parse;

          D = r.noop;
          var k = F.seriesTypes;
          r = k.column;
          var d = k.scatter;
          k = A.addEvent;
          var b = A.arrayMax,
              h = A.arrayMin,
              p = A.clamp,
              z = A.extend,
              E = A.isNumber,
              y = A.merge,
              t = A.pick;

          A = function (c) {
            function k() {
              var b = null !== c && c.apply(this, arguments) || this;
              b.data = void 0;
              b.maxPxSize = void 0;
              b.minPxSize = void 0;
              b.options = void 0;
              b.points = void 0;
              b.radii = void 0;
              b.yData = void 0;
              b.zData = void 0;
              return b;
            }

            u(k, c);

            k.prototype.animate = function (b) {
              !b && this.points.length < this.options.animationLimit && this.points.forEach(function (b) {
                var a = b.graphic;
                a && a.width && (this.hasRendered || a.attr({
                  x: b.plotX,
                  y: b.plotY,
                  width: 1,
                  height: 1
                }), a.animate(this.markerAttribs(b), this.options.animation));
              }, this);
            };

            k.prototype.getRadii = function () {
              var b = this,
                  c = this.zData,
                  a = this.yData,
                  d = [],
                  e = this.chart.bubbleZExtremes;
              var f = this.getPxExtremes();
              var h = f.minPxSize,
                  k = f.maxPxSize;

              if (!e) {
                var l = Number.MAX_VALUE,
                    n = -Number.MAX_VALUE,
                    p;
                this.chart.series.forEach(function (a) {
                  a.bubblePadding && (a.visible || !b.chart.options.chart.ignoreHiddenSeries) && (a = (a.onPoint || a).getZExtremes()) && (l = Math.min(l || a.zMin, a.zMin), n = Math.max(n || a.zMax, a.zMax), p = !0);
                });
                p ? (e = {
                  zMin: l,
                  zMax: n
                }, this.chart.bubbleZExtremes = e) : e = {
                  zMin: 0,
                  zMax: 0
                };
              }

              var q = 0;

              for (f = c.length; q < f; q++) {
                var t = c[q];
                d.push(this.getRadius(e.zMin, e.zMax, h, k, t, a && a[q]));
              }

              this.radii = d;
            };

            k.prototype.getRadius = function (b, c, a, d, e, f) {
              var g = this.options,
                  h = "width" !== g.sizeBy,
                  k = g.zThreshold,
                  l = c - b,
                  n = .5;
              if (null === f || null === e) return null;

              if (E(e)) {
                g.sizeByAbsoluteValue && (e = Math.abs(e - k), l = Math.max(c - k, Math.abs(b - k)), b = 0);
                if (e < b) return a / 2 - 1;
                0 < l && (n = (e - b) / l);
              }

              h && 0 <= n && (n = Math.sqrt(n));
              return Math.ceil(a + n * (d - a)) / 2;
            };

            k.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            k.prototype.pointAttribs = function (b, c) {
              var a = this.options.marker.fillOpacity;
              b = C.prototype.pointAttribs.call(this, b, c);
              1 !== a && (b.fill = n(b.fill).setOpacity(a).get("rgba"));
              return b;
            };

            k.prototype.translate = function () {
              c.prototype.translate.call(this);
              this.getRadii();
              this.translateBubble();
            };

            k.prototype.translateBubble = function () {
              for (var b = this.data, c = this.radii, a = this.getPxExtremes().minPxSize, d = b.length; d--;) {
                var e = b[d],
                    f = c ? c[d] : 0;
                E(f) && f >= a / 2 ? (e.marker = z(e.marker, {
                  radius: f,
                  width: 2 * f,
                  height: 2 * f
                }), e.dlBox = {
                  x: e.plotX - f,
                  y: e.plotY - f,
                  width: 2 * f,
                  height: 2 * f
                }) : (e.shapeArgs = e.dlBox = void 0, e.plotY = 0, e.marker = {
                  width: 0,
                  height: 0
                });
              }
            };

            k.prototype.getPxExtremes = function () {
              var b = Math.min(this.chart.plotWidth, this.chart.plotHeight),
                  c = function c(a) {
                if ("string" === typeof a) {
                  var c = /%$/.test(a);
                  a = parseInt(a, 10);
                }

                return c ? b * a / 100 : a;
              },
                  a = c(t(this.options.minSize, 8));

              c = Math.max(c(t(this.options.maxSize, "20%")), a);
              return {
                minPxSize: a,
                maxPxSize: c
              };
            };

            k.prototype.getZExtremes = function () {
              var c = this.options,
                  d = (this.zData || []).filter(E);

              if (d.length) {
                var a = t(c.zMin, p(h(d), !1 === c.displayNegative ? c.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
                c = t(c.zMax, b(d));
                if (E(a) && E(c)) return {
                  zMin: a,
                  zMax: c
                };
              }
            };

            k.compose = f.compose;
            k.defaultOptions = y(d.defaultOptions, {
              dataLabels: {
                formatter: function formatter() {
                  var b = this.series.chart.numberFormatter,
                      c = this.point.z;
                  return E(c) ? b(c, -1) : "";
                },
                inside: !0,
                verticalAlign: "middle"
              },
              animationLimit: 250,
              marker: {
                lineColor: null,
                lineWidth: 1,
                fillOpacity: .5,
                radius: null,
                states: {
                  hover: {
                    radiusPlus: 0
                  }
                },
                symbol: "circle"
              },
              minSize: 8,
              maxSize: "20%",
              softThreshold: !1,
              states: {
                hover: {
                  halo: {
                    size: 5
                  }
                }
              },
              tooltip: {
                pointFormat: "({point.x}, {point.y}), Size: {point.z}"
              },
              turboThreshold: 0,
              zThreshold: 0,
              zoneAxis: "z"
            });
            return k;
          }(d);

          z(A.prototype, {
            alignDataLabel: r.prototype.alignDataLabel,
            applyZones: D,
            bubblePadding: !0,
            buildKDTree: D,
            directTouch: !0,
            isBubble: !0,
            pointArrayMap: ["y", "z"],
            pointClass: v,
            parallelArrays: ["x", "y", "z"],
            trackerGroups: ["group", "dataLabelsGroup"],
            specialGroup: "group",
            zoneAxis: "z"
          });
          k(A, "updatedData", function (b) {
            delete b.target.chart.bubbleZExtremes;
          });

          c.prototype.beforePadding = function () {
            var b = this,
                c = this.len,
                d = this.chart,
                f = 0,
                a = c,
                h = this.isXAxis,
                e = h ? "xData" : "yData",
                k = this.min,
                m = this.max - k,
                n = c / m,
                p;
            this.series.forEach(function (c) {
              if (c.bubblePadding && (c.visible || !d.options.chart.ignoreHiddenSeries)) {
                p = b.allowZoomOutside = !0;
                var g = c[e];
                h && ((c.onPoint || c).getRadii(0, 0, c), c.onPoint && (c.radii = c.onPoint.radii));
                if (0 < m) for (var l = g.length; l--;) {
                  if (E(g[l]) && b.dataMin <= g[l] && g[l] <= b.max) {
                    var q = c.radii && c.radii[l] || 0;
                    f = Math.min((g[l] - k) * n - q, f);
                    a = Math.max((g[l] - k) * n + q, a);
                  }
                }
              }
            });
            p && 0 < m && !this.logarithmic && (a -= c, n *= (c + Math.max(0, f) - Math.min(a, c)) / c, [["min", "userMin", f], ["max", "userMax", a]].forEach(function (a) {
              "undefined" === typeof t(b.options[a[0]], b[a[1]]) && (b[a[0]] += a[2] / n);
            }));
          };

          F.registerSeriesType("bubble", A);
          "";
          "";
          return A;
        });
        H(f, "Series/MapBubble/MapBubblePoint.js", [f["Series/Map/MapPoint.js"], f["Core/Series/SeriesRegistry.js"]], function (c, f) {
          var v = this && this.__extends || function () {
            var _c25 = function c(f, r) {
              _c25 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, f) {
                c.__proto__ = f;
              } || function (c, f) {
                for (var n in f) {
                  f.hasOwnProperty(n) && (c[n] = f[n]);
                }
              };

              return _c25(f, r);
            };

            return function (f, r) {
              function v() {
                this.constructor = f;
              }

              _c25(f, r);

              f.prototype = null === r ? Object.create(r) : (v.prototype = r.prototype, new v());
            };
          }();

          f = f.seriesTypes;
          var D = f.map;
          return function (f) {
            function r() {
              var r = null !== f && f.apply(this, arguments) || this;
              r.applyOptions = D.prototype.pointClass.prototype.applyOptions;
              r.getProjectedBounds = c.prototype.getProjectedBounds;
              return r;
            }

            v(r, f);

            r.prototype.isValid = function () {
              return "number" === typeof this.z;
            };

            return r;
          }(f.bubble.prototype.pointClass);
        });
        H(f, "Series/MapBubble/MapBubbleSeries.js", [f["Series/Bubble/BubbleSeries.js"], f["Series/MapBubble/MapBubblePoint.js"], f["Series/Map/MapSeries.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f, v, D, r) {
          var C = this && this.__extends || function () {
            var _c26 = function c(f, d) {
              _c26 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (b[d] = c[d]);
                }
              };

              return _c26(f, d);
            };

            return function (f, d) {
              function b() {
                this.constructor = f;
              }

              _c26(f, d);

              f.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              F = D.seriesTypes.mappoint,
              A = r.extend,
              u = r.merge;

          r = function (f) {
            function k() {
              var c = null !== f && f.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            C(k, f);

            k.prototype.searchPoint = function (c, b) {
              return this.searchKDTree({
                clientX: c.chartX - this.chart.plotLeft,
                plotY: c.chartY - this.chart.plotTop
              }, b, c);
            };

            k.prototype.translate = function () {
              F.prototype.translate.call(this);
              this.getRadii();
              this.translateBubble();
            };

            k.compose = c.compose;
            k.defaultOptions = u(c.defaultOptions, {
              lineWidth: 0,
              animationLimit: 500,
              joinBy: "hc-key",
              tooltip: {
                pointFormat: "{point.name}: {point.z}"
              }
            });
            return k;
          }(c);

          A(r.prototype, {
            type: "mapbubble",
            axisTypes: ["colorAxis"],
            getProjectedBounds: v.prototype.getProjectedBounds,
            isCartesian: !1,
            pointArrayMap: ["z"],
            pointClass: f,
            processData: v.prototype.processData,
            projectPoint: F.prototype.projectPoint,
            setData: v.prototype.setData,
            setOptions: v.prototype.setOptions,
            updateData: v.prototype.updateData,
            useMapGeometry: !0,
            xyFromShape: !0
          });
          D.registerSeriesType("mapbubble", r);
          "";
          return r;
        });
        H(f, "Series/Heatmap/HeatmapPoint.js", [f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function (c, f) {
          var v = this && this.__extends || function () {
            var _c27 = function c(f, n) {
              _c27 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, d) {
                c.__proto__ = d;
              } || function (c, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (c[b] = d[b]);
                }
              };

              return _c27(f, n);
            };

            return function (f, n) {
              function k() {
                this.constructor = f;
              }

              _c27(f, n);

              f.prototype = null === n ? Object.create(n) : (k.prototype = n.prototype, new k());
            };
          }(),
              D = f.clamp,
              r = f.defined,
              C = f.extend,
              F = f.pick;

          c = function (c) {
            function f() {
              var f = null !== c && c.apply(this, arguments) || this;
              f.options = void 0;
              f.series = void 0;
              f.value = void 0;
              f.x = void 0;
              f.y = void 0;
              return f;
            }

            v(f, c);

            f.prototype.applyOptions = function (f, k) {
              f = c.prototype.applyOptions.call(this, f, k);
              f.formatPrefix = f.isNull || null === f.value ? "null" : "point";
              return f;
            };

            f.prototype.getCellAttributes = function () {
              var c = this.series,
                  f = c.options,
                  d = (f.colsize || 1) / 2,
                  b = (f.rowsize || 1) / 2,
                  h = c.xAxis,
                  p = c.yAxis,
                  u = this.options.marker || c.options.marker;
              c = c.pointPlacementToXValue();
              var v = F(this.pointPadding, f.pointPadding, 0),
                  y = {
                x1: D(Math.round(h.len - h.translate(this.x - d, !1, !0, !1, !0, -c)), -h.len, 2 * h.len),
                x2: D(Math.round(h.len - h.translate(this.x + d, !1, !0, !1, !0, -c)), -h.len, 2 * h.len),
                y1: D(Math.round(p.translate(this.y - b, !1, !0, !1, !0)), -p.len, 2 * p.len),
                y2: D(Math.round(p.translate(this.y + b, !1, !0, !1, !0)), -p.len, 2 * p.len)
              };
              [["width", "x"], ["height", "y"]].forEach(function (b) {
                var c = b[0];
                b = b[1];
                var d = b + "1",
                    f = b + "2",
                    h = Math.abs(y[d] - y[f]),
                    a = u && u.lineWidth || 0,
                    k = Math.abs(y[d] + y[f]) / 2;
                c = u && u[c];
                r(c) && c < h && (c = c / 2 + a / 2, y[d] = k - c, y[f] = k + c);
                v && ("y" === b && (d = f, f = b + "1"), y[d] += v, y[f] -= v);
              });
              return y;
            };

            f.prototype.haloPath = function (c) {
              if (!c) return [];
              var f = this.shapeArgs;
              return ["M", f.x - c, f.y - c, "L", f.x - c, f.y + f.height + c, f.x + f.width + c, f.y + f.height + c, f.x + f.width + c, f.y - c, "Z"];
            };

            f.prototype.isValid = function () {
              return Infinity !== this.value && -Infinity !== this.value;
            };

            return f;
          }(c.seriesTypes.scatter.prototype.pointClass);

          C(c.prototype, {
            dataLabelOnNull: !0,
            moveToTopOnHover: !0,
            ttBelow: !1
          });
          return c;
        });
        H(f, "Series/Heatmap/HeatmapSeries.js", [f["Core/Color/Color.js"], f["Series/ColorMapComposition.js"], f["Series/Heatmap/HeatmapPoint.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Utilities.js"]], function (c, f, v, D, r, C, F) {
          var A = this && this.__extends || function () {
            var _b14 = function b(c, d) {
              _b14 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, c) {
                b.__proto__ = c;
              } || function (b, c) {
                for (var a in c) {
                  c.hasOwnProperty(a) && (b[a] = c[a]);
                }
              };

              return _b14(c, d);
            };

            return function (c, d) {
              function f() {
                this.constructor = c;
              }

              _b14(c, d);

              c.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
            };
          }(),
              u = r.series,
              n = r.seriesTypes,
              k = n.column,
              d = n.scatter,
              b = C.prototype.symbols,
              h = F.extend,
              p = F.fireEvent,
              z = F.isNumber,
              E = F.merge,
              y = F.pick;

          C = function (f) {
            function k() {
              var b = null !== f && f.apply(this, arguments) || this;
              b.colorAxis = void 0;
              b.data = void 0;
              b.options = void 0;
              b.points = void 0;
              b.valueMax = NaN;
              b.valueMin = NaN;
              return b;
            }

            A(k, f);

            k.prototype.drawPoints = function () {
              var b = this;
              if ((this.options.marker || {}).enabled || this._hasPointMarkers) u.prototype.drawPoints.call(this), this.points.forEach(function (c) {
                c.graphic && (c.graphic[b.chart.styledMode ? "css" : "animate"](b.colorAttribs(c)), null === c.value && c.graphic.addClass("highcharts-null-point"));
              });
            };

            k.prototype.getExtremes = function () {
              var b = u.prototype.getExtremes.call(this, this.valueData),
                  c = b.dataMin;
              b = b.dataMax;
              z(c) && (this.valueMin = c);
              z(b) && (this.valueMax = b);
              return u.prototype.getExtremes.call(this);
            };

            k.prototype.getValidPoints = function (b, c) {
              return u.prototype.getValidPoints.call(this, b, c, !0);
            };

            k.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            k.prototype.init = function () {
              u.prototype.init.apply(this, arguments);
              var c = this.options;
              c.pointRange = y(c.pointRange, c.colsize || 1);
              this.yAxis.axisPointRange = c.rowsize || 1;
              b.ellipse = b.circle;
              c.marker && (c.marker.r = c.borderRadius);
            };

            k.prototype.markerAttribs = function (b, c) {
              var d = b.marker || {},
                  a = this.options.marker || {},
                  f = b.shapeArgs || {},
                  e = {};
              if (b.hasImage) return {
                x: b.plotX,
                y: b.plotY
              };

              if (c) {
                var g = a.states[c] || {};
                var h = d.states && d.states[c] || {};
                [["width", "x"], ["height", "y"]].forEach(function (a) {
                  e[a[0]] = (h[a[0]] || g[a[0]] || f[a[0]]) + (h[a[0] + "Plus"] || g[a[0] + "Plus"] || 0);
                  e[a[1]] = f[a[1]] + (f[a[0]] - e[a[0]]) / 2;
                });
              }

              return c ? e : f;
            };

            k.prototype.pointAttribs = function (b, d) {
              var f = u.prototype.pointAttribs.call(this, b, d),
                  a = this.options || {},
                  g = this.chart.options.plotOptions || {},
                  e = g.series || {},
                  h = g.heatmap || {};
              g = b && b.options.borderColor || a.borderColor || h.borderColor || e.borderColor;
              e = b && b.options.borderWidth || a.borderWidth || h.borderWidth || e.borderWidth || f["stroke-width"];
              f.stroke = b && b.marker && b.marker.lineColor || a.marker && a.marker.lineColor || g || this.color;
              f["stroke-width"] = e;
              d && (b = E(a.states[d], a.marker && a.marker.states[d], b && b.options.states && b.options.states[d] || {}), d = b.brightness, f.fill = b.color || c.parse(f.fill).brighten(d || 0).get(), f.stroke = b.lineColor);
              return f;
            };

            k.prototype.setClip = function (b) {
              var c = this.chart;
              u.prototype.setClip.apply(this, arguments);
              (!1 !== this.options.clip || b) && this.markerGroup.clip((b || this.clipBox) && this.sharedClipKey ? c.sharedClips[this.sharedClipKey] : c.clipRect);
            };

            k.prototype.translate = function () {
              var c = this.options,
                  d = c.marker && c.marker.symbol || "rect",
                  f = b[d] ? d : "rect",
                  a = -1 !== ["circle", "square"].indexOf(f);
              this.generatePoints();
              this.points.forEach(function (g) {
                var e = g.getCellAttributes(),
                    k = {};
                k.x = Math.min(e.x1, e.x2);
                k.y = Math.min(e.y1, e.y2);
                k.width = Math.max(Math.abs(e.x2 - e.x1), 0);
                k.height = Math.max(Math.abs(e.y2 - e.y1), 0);
                var l = g.hasImage = 0 === (g.marker && g.marker.symbol || d || "").indexOf("url");

                if (a) {
                  var n = Math.abs(k.width - k.height);
                  k.x = Math.min(e.x1, e.x2) + (k.width < k.height ? 0 : n / 2);
                  k.y = Math.min(e.y1, e.y2) + (k.width < k.height ? n / 2 : 0);
                  k.width = k.height = Math.min(k.width, k.height);
                }

                n = {
                  plotX: (e.x1 + e.x2) / 2,
                  plotY: (e.y1 + e.y2) / 2,
                  clientX: (e.x1 + e.x2) / 2,
                  shapeType: "path",
                  shapeArgs: E(!0, k, {
                    d: b[f](k.x, k.y, k.width, k.height, {
                      r: c.borderRadius
                    })
                  })
                };
                l && (g.marker = {
                  width: k.width,
                  height: k.height
                });
                h(g, n);
              });
              p(this, "afterTranslate");
            };

            k.defaultOptions = E(d.defaultOptions, {
              animation: !1,
              borderRadius: 0,
              borderWidth: 0,
              nullColor: "#f7f7f7",
              dataLabels: {
                formatter: function formatter() {
                  var b = this.series.chart.numberFormatter,
                      c = this.point.value;
                  return z(c) ? b(c, -1) : "";
                },
                inside: !0,
                verticalAlign: "middle",
                crop: !1,
                overflow: !1,
                padding: 0
              },
              marker: {
                symbol: "rect",
                radius: 0,
                lineColor: void 0,
                states: {
                  hover: {
                    lineWidthPlus: 0
                  },
                  select: {}
                }
              },
              clip: !0,
              pointRange: null,
              tooltip: {
                pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
              },
              states: {
                hover: {
                  halo: !1,
                  brightness: .2
                }
              }
            });
            return k;
          }(d);

          h(C.prototype, {
            axisTypes: f.seriesMembers.axisTypes,
            colorKey: f.seriesMembers.colorKey,
            directTouch: !0,
            getExtremesFromAll: !0,
            parallelArrays: f.seriesMembers.parallelArrays,
            pointArrayMap: ["y", "value"],
            pointClass: v,
            trackerGroups: f.seriesMembers.trackerGroups,
            alignDataLabel: k.prototype.alignDataLabel,
            colorAttribs: f.seriesMembers.colorAttribs,
            drawLegendSymbol: D.drawRectangle,
            getSymbol: u.prototype.getSymbol
          });
          f.compose(C);
          r.registerSeriesType("heatmap", C);
          "";
          "";
          return C;
        });
        H(f, "masters/modules/map.src.js", [f["Core/Globals.js"], f["Core/Axis/Color/ColorAxis.js"], f["Series/MapBubble/MapBubbleSeries.js"], f["Core/Chart/MapChart.js"], f["Maps/MapView.js"], f["Maps/Projection.js"]], function (c, f, v, D, r, C) {
          c.ColorAxis = f;
          c.MapChart = D;
          c.mapChart = c.Map = D.mapChart;
          c.MapView = r;
          c.maps = D.maps;
          c.Projection = C;
          f.compose(c.Chart, c.Fx, c.Legend, c.Series);
          v.compose(c.Chart, c.Legend, c.Series);
        });
        H(f, "masters/highmaps.src.js", [f["masters/highcharts.src.js"]], function (c) {
          c.product = "Highmaps";
          return c;
        });
        f["masters/highmaps.src.js"]._modules = f;
        return f["masters/highmaps.src.js"];
      }); //# sourceMappingURL=highmaps.js.map

      /***/

    }
  }]);
})();
//# sourceMappingURL=default~views-others-others-module~views-video-verification-video-verification-module-es5.js.map