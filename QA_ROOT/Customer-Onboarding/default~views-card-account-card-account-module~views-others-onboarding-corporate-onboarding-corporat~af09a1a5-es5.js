(function () {
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  (window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~views-card-account-card-account-module~views-others-onboarding-corporate-onboarding-corporat~af09a1a5"], {
    /***/
    "5ZEx":
    /*!**********************************************!*\
      !*** ./node_modules/highcharts/highstock.js ***!
      \**********************************************/

    /*! no static exports found */

    /***/
    function ZEx(module, exports, __webpack_require__) {
      "use strict";

      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*
      Highstock JS v9.2.2 (2021-08-24)
      (c) 2009-2021 Torstein Honsi
      License: www.highcharts.com/license
      */


      (function (W, M) {
        true && module.exports ? (M["default"] = M, module.exports = W.document ? M(W) : M) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return M(W);
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
      })("undefined" !== typeof window ? window : this, function (W) {
        function M(d, B, E, G) {
          d.hasOwnProperty(B) || (d[B] = G.apply(null, E));
        }

        var d = {};
        M(d, "Core/Globals.js", [], function () {
          var d = "undefined" !== typeof W ? W : "undefined" !== typeof window ? window : {},
              B;

          (function (c) {
            c.SVG_NS = "http://www.w3.org/2000/svg";
            c.product = "Highcharts";
            c.version = "9.2.2";
            c.win = d;
            c.doc = c.win.document;
            c.svg = c.doc && c.doc.createElementNS && !!c.doc.createElementNS(c.SVG_NS, "svg").createSVGRect;
            c.userAgent = c.win.navigator && c.win.navigator.userAgent || "";
            c.isChrome = -1 !== c.userAgent.indexOf("Chrome");
            c.isFirefox = -1 !== c.userAgent.indexOf("Firefox");
            c.isMS = /(edge|msie|trident)/i.test(c.userAgent) && !c.win.opera;
            c.isSafari = !c.isChrome && -1 !== c.userAgent.indexOf("Safari");
            c.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(c.userAgent);
            c.isWebKit = -1 !== c.userAgent.indexOf("AppleWebKit");
            c.deg2rad = 2 * Math.PI / 360;
            c.hasBidiBug = c.isFirefox && 4 > parseInt(c.userAgent.split("Firefox/")[1], 10);
            c.hasTouch = !!c.win.TouchEvent;
            c.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];

            c.noop = function () {};

            c.supportsPassiveEvents = function () {
              var d = !1;

              if (!c.isMS) {
                var B = Object.defineProperty({}, "passive", {
                  get: function get() {
                    d = !0;
                  }
                });
                c.win.addEventListener && c.win.removeEventListener && (c.win.addEventListener("testPassive", c.noop, B), c.win.removeEventListener("testPassive", c.noop, B));
              }

              return d;
            }();

            c.charts = [];
            c.dateFormats = {};
            c.seriesTypes = {};
            c.symbolSizes = {};
            c.chartCount = 0;
          })(B || (B = {}));

          "";
          return B;
        });
        M(d, "Core/Utilities.js", [d["Core/Globals.js"]], function (c) {
          function d(e, b, l, f) {
            var q = b ? "Highcharts error" : "Highcharts warning";
            32 === e && (e = q + ": Deprecated member");
            var v = k(e),
                P = v ? q + " #" + e + ": www.highcharts.com/errors/" + e + "/" : e.toString();

            if ("undefined" !== typeof f) {
              var I = "";
              v && (P += "?");
              N(f, function (e, u) {
                I += "\n - " + u + ": " + e;
                v && (P += encodeURI(u) + "=" + encodeURI(e));
              });
              P += I;
            }

            x(c, "displayError", {
              chart: l,
              code: e,
              message: P,
              params: f
            }, function () {
              if (b) throw Error(P);
              w.console && -1 === d.messages.indexOf(P) && console.warn(P);
            });
            d.messages.push(P);
          }

          function E(e, b) {
            var l = {};
            N(e, function (q, p) {
              if (K(e[p], !0) && !e.nodeType && b[p]) q = E(e[p], b[p]), Object.keys(q).length && (l[p] = q);else if (K(e[p]) || e[p] !== b[p]) l[p] = e[p];
            });
            return l;
          }

          function G(e, b) {
            return parseInt(e, b || 10);
          }

          function C(e) {
            return "string" === typeof e;
          }

          function D(e) {
            e = Object.prototype.toString.call(e);
            return "[object Array]" === e || "[object Array Iterator]" === e;
          }

          function K(e, b) {
            return !!e && "object" === typeof e && (!b || !D(e));
          }

          function A(e) {
            return K(e) && "number" === typeof e.nodeType;
          }

          function r(e) {
            var b = e && e.constructor;
            return !(!K(e, !0) || A(e) || !b || !b.name || "Object" === b.name);
          }

          function k(e) {
            return "number" === typeof e && !isNaN(e) && Infinity > e && -Infinity < e;
          }

          function h(e) {
            return "undefined" !== typeof e && null !== e;
          }

          function a(e, b, l) {
            var q;
            C(b) ? h(l) ? e.setAttribute(b, l) : e && e.getAttribute && ((q = e.getAttribute(b)) || "class" !== b || (q = e.getAttribute(b + "Name"))) : N(b, function (b, l) {
              e.setAttribute(l, b);
            });
            return q;
          }

          function g(e, b) {
            var l;
            e || (e = {});

            for (l in b) {
              e[l] = b[l];
            }

            return e;
          }

          function y() {
            for (var e = arguments, b = e.length, l = 0; l < b; l++) {
              var f = e[l];
              if ("undefined" !== typeof f && null !== f) return f;
            }
          }

          function n(e, b) {
            c.isMS && !c.svg && b && "undefined" !== typeof b.opacity && (b.filter = "alpha(opacity=" + 100 * b.opacity + ")");
            g(e.style, b);
          }

          function t(e, b, l, f, p) {
            e = H.createElement(e);
            b && g(e, b);
            p && n(e, {
              padding: "0",
              border: "none",
              margin: "0"
            });
            l && n(e, l);
            f && f.appendChild(e);
            return e;
          }

          function O(b, q) {
            return parseFloat(b.toPrecision(q || 14));
          }

          function m(b, q, l) {
            var e = c.getStyle || m;
            if ("width" === q) return q = Math.min(b.offsetWidth, b.scrollWidth), l = b.getBoundingClientRect && b.getBoundingClientRect().width, l < q && l >= q - 1 && (q = Math.floor(l)), Math.max(0, q - (e(b, "padding-left", !0) || 0) - (e(b, "padding-right", !0) || 0));
            if ("height" === q) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (e(b, "padding-top", !0) || 0) - (e(b, "padding-bottom", !0) || 0));
            w.getComputedStyle || d(27, !0);

            if (b = w.getComputedStyle(b, void 0)) {
              var p = b.getPropertyValue(q);
              y(l, "opacity" !== q) && (p = G(p));
            }

            return p;
          }

          function N(b, q, l) {
            for (var e in b) {
              Object.hasOwnProperty.call(b, e) && q.call(l || b[e], b[e], e, b);
            }
          }

          function L(b, q, l) {
            function e(e, l) {
              var u = b.removeEventListener || c.removeEventListenerPolyfill;
              u && u.call(b, e, l, !1);
            }

            function p(l) {
              var J;

              if (b.nodeName) {
                if (q) {
                  var u = {};
                  u[q] = !0;
                } else u = l;

                N(u, function (u, b) {
                  if (l[b]) for (J = l[b].length; J--;) {
                    e(b, l[b][J].fn);
                  }
                });
              }
            }

            var f = "function" === typeof b && b.prototype || b;

            if (Object.hasOwnProperty.call(f, "hcEvents")) {
              var P = f.hcEvents;
              q ? (f = P[q] || [], l ? (P[q] = f.filter(function (b) {
                return l !== b.fn;
              }), e(q, l)) : (p(P), P[q] = [])) : (p(P), delete f.hcEvents);
            }
          }

          function x(b, q, l, f) {
            l = l || {};

            if (H.createEvent && (b.dispatchEvent || b.fireEvent && b !== c)) {
              var e = H.createEvent("Events");
              e.initEvent(q, !0, !0);
              l = g(e, l);
              b.dispatchEvent ? b.dispatchEvent(l) : b.fireEvent(q, l);
            } else if (b.hcEvents) {
              l.target || g(l, {
                preventDefault: function preventDefault() {
                  l.defaultPrevented = !0;
                },
                target: b,
                type: q
              });
              e = [];

              for (var v = b, P = !1; v.hcEvents;) {
                Object.hasOwnProperty.call(v, "hcEvents") && v.hcEvents[q] && (e.length && (P = !0), e.unshift.apply(e, v.hcEvents[q])), v = Object.getPrototypeOf(v);
              }

              P && e.sort(function (b, e) {
                return b.order - e.order;
              });
              e.forEach(function (e) {
                !1 === e.fn.call(b, l) && l.preventDefault();
              });
            }

            f && !l.defaultPrevented && f.call(b, l);
          }

          var R = c.charts,
              H = c.doc,
              w = c.win;
          (d || (d = {})).messages = [];
          var f;

          Math.easeInOutSine = function (b) {
            return -.5 * (Math.cos(Math.PI * b) - 1);
          };

          var b = Array.prototype.find ? function (b, q) {
            return b.find(q);
          } : function (b, q) {
            var e,
                f = b.length;

            for (e = 0; e < f; e++) {
              if (q(b[e], e)) return b[e];
            }
          };
          N({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function (b, q) {
            c[q] = function (e) {
              var l;
              d(32, !1, void 0, (l = {}, l["Highcharts." + q] = "use Array." + b, l));
              return Array.prototype[b].apply(e, [].slice.call(arguments, 1));
            };
          });

          var v,
              F = function () {
            var b = Math.random().toString(36).substring(2, 9) + "-",
                q = 0;
            return function () {
              return "highcharts-" + (v ? "" : b) + q++;
            };
          }();

          w.jQuery && (w.jQuery.fn.highcharts = function () {
            var b = [].slice.call(arguments);
            if (this[0]) return b[0] ? (new c[C(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : R[a(this[0], "data-highcharts-chart")];
          });
          b = {
            addEvent: function addEvent(b, q, l, f) {
              void 0 === f && (f = {});
              var e = "function" === typeof b && b.prototype || b;
              Object.hasOwnProperty.call(e, "hcEvents") || (e.hcEvents = {});
              e = e.hcEvents;
              c.Point && b instanceof c.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
              var v = b.addEventListener || c.addEventListenerPolyfill;
              v && v.call(b, q, l, c.supportsPassiveEvents ? {
                passive: void 0 === f.passive ? -1 !== q.indexOf("touch") : f.passive,
                capture: !1
              } : !1);
              e[q] || (e[q] = []);
              e[q].push({
                fn: l,
                order: "number" === typeof f.order ? f.order : Infinity
              });
              e[q].sort(function (b, e) {
                return b.order - e.order;
              });
              return function () {
                L(b, q, l);
              };
            },
            arrayMax: function arrayMax(b) {
              for (var e = b.length, l = b[0]; e--;) {
                b[e] > l && (l = b[e]);
              }

              return l;
            },
            arrayMin: function arrayMin(b) {
              for (var e = b.length, l = b[0]; e--;) {
                b[e] < l && (l = b[e]);
              }

              return l;
            },
            attr: a,
            clamp: function clamp(b, q, l) {
              return b > q ? b < l ? b : l : q;
            },
            cleanRecursively: E,
            clearTimeout: function (_clearTimeout) {
              function clearTimeout(_x) {
                return _clearTimeout.apply(this, arguments);
              }

              clearTimeout.toString = function () {
                return _clearTimeout.toString();
              };

              return clearTimeout;
            }(function (b) {
              h(b) && clearTimeout(b);
            }),
            correctFloat: O,
            createElement: t,
            css: n,
            defined: h,
            destroyObjectProperties: function destroyObjectProperties(b, q) {
              N(b, function (e, f) {
                e && e !== q && e.destroy && e.destroy();
                delete b[f];
              });
            },
            discardElement: function discardElement(b) {
              f || (f = t("div"));
              b && f.appendChild(b);
              f.innerHTML = "";
            },
            erase: function erase(b, q) {
              for (var e = b.length; e--;) {
                if (b[e] === q) {
                  b.splice(e, 1);
                  break;
                }
              }
            },
            error: d,
            extend: g,
            extendClass: function extendClass(b, q) {
              var e = function e() {};

              e.prototype = new b();
              g(e.prototype, q);
              return e;
            },
            find: b,
            fireEvent: x,
            getMagnitude: function getMagnitude(b) {
              return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
            },
            getNestedProperty: function getNestedProperty(b, q) {
              for (b = b.split("."); b.length && h(q);) {
                var e = b.shift();
                if ("undefined" === typeof e || "__proto__" === e) return;
                q = q[e];
                if (!h(q) || "function" === typeof q || "number" === typeof q.nodeType || q === w) return;
              }

              return q;
            },
            getStyle: m,
            inArray: function inArray(b, q, l) {
              d(32, !1, void 0, {
                "Highcharts.inArray": "use Array.indexOf"
              });
              return q.indexOf(b, l);
            },
            isArray: D,
            isClass: r,
            isDOMElement: A,
            isFunction: function isFunction(b) {
              return "function" === typeof b;
            },
            isNumber: k,
            isObject: K,
            isString: C,
            keys: function keys(b) {
              d(32, !1, void 0, {
                "Highcharts.keys": "use Object.keys"
              });
              return Object.keys(b);
            },
            merge: function merge() {
              var b,
                  q = arguments,
                  l = {},
                  f = function f(b, e) {
                "object" !== typeof b && (b = {});
                N(e, function (l, J) {
                  "__proto__" !== J && "constructor" !== J && (!K(l, !0) || r(l) || A(l) ? b[J] = e[J] : b[J] = f(b[J] || {}, l));
                });
                return b;
              };

              !0 === q[0] && (l = q[1], q = Array.prototype.slice.call(q, 2));
              var p = q.length;

              for (b = 0; b < p; b++) {
                l = f(l, q[b]);
              }

              return l;
            },
            normalizeTickInterval: function normalizeTickInterval(b, q, l, f, p) {
              var e = b;
              l = y(l, 1);
              var P = b / l;
              q || (q = p ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === f && (1 === l ? q = q.filter(function (b) {
                return 0 === b % 1;
              }) : .1 >= l && (q = [1 / l])));

              for (f = 0; f < q.length && !(e = q[f], p && e * l >= b || !p && P <= (q[f] + (q[f + 1] || q[f])) / 2); f++) {
                ;
              }

              return e = O(e * l, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: N,
            offset: function offset(b) {
              var e = H.documentElement;
              b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
              };
              return {
                top: b.top + (w.pageYOffset || e.scrollTop) - (e.clientTop || 0),
                left: b.left + (w.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),
                width: b.width,
                height: b.height
              };
            },
            pad: function pad(b, q, l) {
              return Array((q || 2) + 1 - String(b).replace("-", "").length).join(l || "0") + b;
            },
            pick: y,
            pInt: G,
            relativeLength: function relativeLength(b, q, l) {
              return /%$/.test(b) ? q * parseFloat(b) / 100 + (l || 0) : parseFloat(b);
            },
            removeEvent: L,
            splat: function splat(b) {
              return D(b) ? b : [b];
            },
            stableSort: function stableSort(b, q) {
              var e = b.length,
                  f,
                  p;

              for (p = 0; p < e; p++) {
                b[p].safeI = p;
              }

              b.sort(function (b, e) {
                f = q(b, e);
                return 0 === f ? b.safeI - e.safeI : f;
              });

              for (p = 0; p < e; p++) {
                delete b[p].safeI;
              }
            },
            syncTimeout: function syncTimeout(b, q, l) {
              if (0 < q) return setTimeout(b, q, l);
              b.call(0, l);
              return -1;
            },
            timeUnits: {
              millisecond: 1,
              second: 1E3,
              minute: 6E4,
              hour: 36E5,
              day: 864E5,
              week: 6048E5,
              month: 24192E5,
              year: 314496E5
            },
            uniqueKey: F,
            useSerialIds: function useSerialIds(b) {
              return v = y(b, v);
            },
            wrap: function wrap(b, q, l) {
              var e = b[q];

              b[q] = function () {
                var b = Array.prototype.slice.call(arguments),
                    q = arguments,
                    f = this;

                f.proceed = function () {
                  e.apply(f, arguments.length ? arguments : q);
                };

                b.unshift(e);
                b = l.apply(this, b);
                f.proceed = null;
                return b;
              };
            }
          };
          "";
          return b;
        });
        M(d, "Core/Color/Palette.js", [], function () {
          return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            backgroundColor: "#ffffff",
            neutralColor100: "#000000",
            neutralColor80: "#333333",
            neutralColor60: "#666666",
            neutralColor40: "#999999",
            neutralColor20: "#cccccc",
            neutralColor10: "#e6e6e6",
            neutralColor5: "#f2f2f2",
            neutralColor3: "#f7f7f7",
            highlightColor100: "#003399",
            highlightColor80: "#335cad",
            highlightColor60: "#6685c2",
            highlightColor20: "#ccd6eb",
            highlightColor10: "#e6ebf5",
            positiveColor: "#06b535",
            negativeColor: "#f21313"
          };
        });
        M(d, "Core/Chart/ChartDefaults.js", [d["Core/Color/Palette.js"]], function (c) {
          return {
            panning: {
              enabled: !1,
              type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: c.highlightColor80,
            backgroundColor: c.backgroundColor,
            plotBorderColor: c.neutralColor20
          };
        });
        M(d, "Core/Color/Color.js", [d["Core/Globals.js"], d["Core/Utilities.js"]], function (c, d) {
          var B = d.isNumber,
              G = d.merge,
              C = d.pInt;

          d = function () {
            function d(B) {
              this.rgba = [NaN, NaN, NaN, NaN];
              this.input = B;
              var A = c.Color;
              if (A && A !== d) return new A(B);
              if (!(this instanceof d)) return new d(B);
              this.init(B);
            }

            d.parse = function (c) {
              return c ? new d(c) : d.None;
            };

            d.prototype.init = function (c) {
              var A;
              if ("object" === typeof c && "undefined" !== typeof c.stops) this.stops = c.stops.map(function (a) {
                return new d(a[1]);
              });else if ("string" === typeof c) {
                this.input = c = d.names[c.toLowerCase()] || c;

                if ("#" === c.charAt(0)) {
                  var r = c.length;
                  var k = parseInt(c.substr(1), 16);
                  7 === r ? A = [(k & 16711680) >> 16, (k & 65280) >> 8, k & 255, 1] : 4 === r && (A = [(k & 3840) >> 4 | (k & 3840) >> 8, (k & 240) >> 4 | k & 240, (k & 15) << 4 | k & 15, 1]);
                }

                if (!A) for (k = d.parsers.length; k-- && !A;) {
                  var h = d.parsers[k];
                  (r = h.regex.exec(c)) && (A = h.parse(r));
                }
              }
              A && (this.rgba = A);
            };

            d.prototype.get = function (c) {
              var d = this.input,
                  r = this.rgba;

              if ("object" === typeof d && "undefined" !== typeof this.stops) {
                var k = G(d);
                k.stops = [].slice.call(k.stops);
                this.stops.forEach(function (h, a) {
                  k.stops[a] = [k.stops[a][0], h.get(c)];
                });
                return k;
              }

              return r && B(r[0]) ? "rgb" === c || !c && 1 === r[3] ? "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")" : "a" === c ? "" + r[3] : "rgba(" + r.join(",") + ")" : d;
            };

            d.prototype.brighten = function (c) {
              var d = this.rgba;
              if (this.stops) this.stops.forEach(function (k) {
                k.brighten(c);
              });else if (B(c) && 0 !== c) for (var r = 0; 3 > r; r++) {
                d[r] += C(255 * c), 0 > d[r] && (d[r] = 0), 255 < d[r] && (d[r] = 255);
              }
              return this;
            };

            d.prototype.setOpacity = function (c) {
              this.rgba[3] = c;
              return this;
            };

            d.prototype.tweenTo = function (c, d) {
              var r = this.rgba,
                  k = c.rgba;
              if (!B(r[0]) || !B(k[0])) return c.input || "none";
              c = 1 !== k[3] || 1 !== r[3];
              return (c ? "rgba(" : "rgb(") + Math.round(k[0] + (r[0] - k[0]) * (1 - d)) + "," + Math.round(k[1] + (r[1] - k[1]) * (1 - d)) + "," + Math.round(k[2] + (r[2] - k[2]) * (1 - d)) + (c ? "," + (k[3] + (r[3] - k[3]) * (1 - d)) : "") + ")";
            };

            d.names = {
              white: "#ffffff",
              black: "#000000"
            };
            d.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(c) {
                return [C(c[1]), C(c[2]), C(c[3]), parseFloat(c[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(c) {
                return [C(c[1]), C(c[2]), C(c[3]), 1];
              }
            }];
            d.None = new d("");
            return d;
          }();

          "";
          return d;
        });
        M(d, "Core/Time.js", [d["Core/Globals.js"], d["Core/Utilities.js"]], function (c, d) {
          var B = c.win,
              G = d.defined,
              C = d.error,
              D = d.extend,
              K = d.isObject,
              A = d.merge,
              r = d.objectEach,
              k = d.pad,
              h = d.pick,
              a = d.splat,
              g = d.timeUnits,
              y = c.isSafari && B.Intl && B.Intl.DateTimeFormat.prototype.formatRange,
              n = c.isSafari && B.Intl && !B.Intl.DateTimeFormat.prototype.formatRange;

          d = function () {
            function t(a) {
              this.options = {};
              this.variableTimezone = this.useUTC = !1;
              this.Date = B.Date;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.update(a);
            }

            t.prototype.get = function (a, m) {
              if (this.variableTimezone || this.timezoneOffset) {
                var g = m.getTime(),
                    h = g - this.getTimezoneOffset(m);
                m.setTime(h);
                a = m["getUTC" + a]();
                m.setTime(g);
                return a;
              }

              return this.useUTC ? m["getUTC" + a]() : m["get" + a]();
            };

            t.prototype.set = function (a, m, g) {
              if (this.variableTimezone || this.timezoneOffset) {
                if ("Milliseconds" === a || "Seconds" === a || "Minutes" === a && 0 === this.getTimezoneOffset(m) % 36E5) return m["setUTC" + a](g);
                var h = this.getTimezoneOffset(m);
                h = m.getTime() - h;
                m.setTime(h);
                m["setUTC" + a](g);
                a = this.getTimezoneOffset(m);
                h = m.getTime() + a;
                return m.setTime(h);
              }

              return this.useUTC || y && "FullYear" === a ? m["setUTC" + a](g) : m["set" + a](g);
            };

            t.prototype.update = function (a) {
              var g = h(a && a.useUTC, !0);
              this.options = a = A(!0, this.options || {}, a);
              this.Date = a.Date || B.Date || Date;
              this.timezoneOffset = (this.useUTC = g) && a.timezoneOffset;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.variableTimezone = g && !(!a.getTimezoneOffset && !a.timezone);
            };

            t.prototype.makeTime = function (a, g, t, k, x, y) {
              if (this.useUTC) {
                var m = this.Date.UTC.apply(0, arguments);
                var w = this.getTimezoneOffset(m);
                m += w;
                var f = this.getTimezoneOffset(m);
                w !== f ? m += f - w : w - 36E5 !== this.getTimezoneOffset(m - 36E5) || n || (m -= 36E5);
              } else m = new this.Date(a, g, h(t, 1), h(k, 0), h(x, 0), h(y, 0)).getTime();

              return m;
            };

            t.prototype.timezoneOffsetFunction = function () {
              var a = this,
                  g = this.options,
                  h = g.moment || B.moment;
              if (!this.useUTC) return function (a) {
                return 6E4 * new Date(a.toString()).getTimezoneOffset();
              };

              if (g.timezone) {
                if (h) return function (a) {
                  return 6E4 * -h.tz(a, g.timezone).utcOffset();
                };
                C(25);
              }

              return this.useUTC && g.getTimezoneOffset ? function (a) {
                return 6E4 * g.getTimezoneOffset(a.valueOf());
              } : function () {
                return 6E4 * (a.timezoneOffset || 0);
              };
            };

            t.prototype.dateFormat = function (a, g, n) {
              if (!G(g) || isNaN(g)) return c.defaultOptions.lang && c.defaultOptions.lang.invalidDate || "";
              a = h(a, "%Y-%m-%d %H:%M:%S");
              var m = this,
                  x = new this.Date(g),
                  t = this.get("Hours", x),
                  H = this.get("Day", x),
                  w = this.get("Date", x),
                  f = this.get("Month", x),
                  b = this.get("FullYear", x),
                  v = c.defaultOptions.lang,
                  F = v && v.weekdays,
                  e = v && v.shortWeekdays;
              x = D({
                a: e ? e[H] : F[H].substr(0, 3),
                A: F[H],
                d: k(w),
                e: k(w, 2, " "),
                w: H,
                b: v.shortMonths[f],
                B: v.months[f],
                m: k(f + 1),
                o: f + 1,
                y: b.toString().substr(2, 2),
                Y: b,
                H: k(t),
                k: t,
                I: k(t % 12 || 12),
                l: t % 12 || 12,
                M: k(this.get("Minutes", x)),
                p: 12 > t ? "AM" : "PM",
                P: 12 > t ? "am" : "pm",
                S: k(x.getSeconds()),
                L: k(Math.floor(g % 1E3), 3)
              }, c.dateFormats);
              r(x, function (b, e) {
                for (; -1 !== a.indexOf("%" + e);) {
                  a = a.replace("%" + e, "function" === typeof b ? b.call(m, g) : b);
                }
              });
              return n ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;
            };

            t.prototype.resolveDTLFormat = function (g) {
              return K(g, !0) ? g : (g = a(g), {
                main: g[0],
                from: g[1],
                to: g[2]
              });
            };

            t.prototype.getTimeTicks = function (a, m, n, t) {
              var x = this,
                  k = [],
                  H = {},
                  w = new x.Date(m),
                  f = a.unitRange,
                  b = a.count || 1,
                  v;
              t = h(t, 1);

              if (G(m)) {
                x.set("Milliseconds", w, f >= g.second ? 0 : b * Math.floor(x.get("Milliseconds", w) / b));
                f >= g.second && x.set("Seconds", w, f >= g.minute ? 0 : b * Math.floor(x.get("Seconds", w) / b));
                f >= g.minute && x.set("Minutes", w, f >= g.hour ? 0 : b * Math.floor(x.get("Minutes", w) / b));
                f >= g.hour && x.set("Hours", w, f >= g.day ? 0 : b * Math.floor(x.get("Hours", w) / b));
                f >= g.day && x.set("Date", w, f >= g.month ? 1 : Math.max(1, b * Math.floor(x.get("Date", w) / b)));

                if (f >= g.month) {
                  x.set("Month", w, f >= g.year ? 0 : b * Math.floor(x.get("Month", w) / b));
                  var F = x.get("FullYear", w);
                }

                f >= g.year && x.set("FullYear", w, F - F % b);
                f === g.week && (F = x.get("Day", w), x.set("Date", w, x.get("Date", w) - F + t + (F < t ? -7 : 0)));
                F = x.get("FullYear", w);
                t = x.get("Month", w);
                var e = x.get("Date", w),
                    q = x.get("Hours", w);
                m = w.getTime();
                !x.variableTimezone && x.useUTC || !G(n) || (v = n - m > 4 * g.month || x.getTimezoneOffset(m) !== x.getTimezoneOffset(n));
                m = w.getTime();

                for (w = 1; m < n;) {
                  k.push(m), m = f === g.year ? x.makeTime(F + w * b, 0) : f === g.month ? x.makeTime(F, t + w * b) : !v || f !== g.day && f !== g.week ? v && f === g.hour && 1 < b ? x.makeTime(F, t, e, q + w * b) : m + f * b : x.makeTime(F, t, e + w * b * (f === g.day ? 1 : 7)), w++;
                }

                k.push(m);
                f <= g.hour && 1E4 > k.length && k.forEach(function (b) {
                  0 === b % 18E5 && "000000000" === x.dateFormat("%H%M%S%L", b) && (H[b] = "day");
                });
              }

              k.info = D(a, {
                higherRanks: H,
                totalRange: f * b
              });
              return k;
            };

            t.prototype.getDateFormat = function (a, m, h, n) {
              var t = this.dateFormat("%m-%d %H:%M:%S.%L", m),
                  k = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
              },
                  H = "millisecond";

              for (w in g) {
                if (a === g.week && +this.dateFormat("%w", m) === h && "00:00:00.000" === t.substr(6)) {
                  var w = "week";
                  break;
                }

                if (g[w] > a) {
                  w = H;
                  break;
                }

                if (k[w] && t.substr(k[w]) !== "01-01 00:00:00.000".substr(k[w])) break;
                "week" !== w && (H = w);
              }

              if (w) var f = this.resolveDTLFormat(n[w]).main;
              return f;
            };

            return t;
          }();

          "";
          return d;
        });
        M(d, "Core/DefaultOptions.js", [d["Core/Chart/ChartDefaults.js"], d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Color/Palette.js"], d["Core/Time.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D) {
          d = d.parse;
          var B = D.merge,
              A = {
            colors: G.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
              loading: "Loading...",
              months: "January February March April May June July August September October November December".split(" "),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
              weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
              decimalPoint: ".",
              numericSymbols: "kMGTPE".split(""),
              resetZoom: "Reset zoom",
              resetZoomTitle: "Reset zoom level 1:1",
              thousandsSep: " "
            },
            global: {},
            time: {
              Date: void 0,
              getTimezoneOffset: void 0,
              timezone: void 0,
              timezoneOffset: 0,
              useUTC: !0
            },
            chart: c,
            title: {
              text: "Chart title",
              align: "center",
              margin: 15,
              widthAdjust: -44
            },
            subtitle: {
              text: "",
              align: "center",
              widthAdjust: -44
            },
            caption: {
              margin: 15,
              text: "",
              align: "left",
              verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
              style: {
                position: "absolute",
                color: G.neutralColor80
              }
            },
            legend: {
              enabled: !0,
              align: "center",
              alignColumns: !0,
              className: "highcharts-no-tooltip",
              layout: "horizontal",
              labelFormatter: function labelFormatter() {
                return this.name;
              },
              borderColor: G.neutralColor40,
              borderRadius: 0,
              navigation: {
                activeColor: G.highlightColor100,
                inactiveColor: G.neutralColor20
              },
              itemStyle: {
                color: G.neutralColor80,
                cursor: "pointer",
                fontSize: "12px",
                fontWeight: "bold",
                textOverflow: "ellipsis"
              },
              itemHoverStyle: {
                color: G.neutralColor100
              },
              itemHiddenStyle: {
                color: G.neutralColor20
              },
              shadow: !1,
              itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
              },
              squareSymbol: !0,
              symbolPadding: 5,
              verticalAlign: "bottom",
              x: 0,
              y: 0,
              title: {
                style: {
                  fontWeight: "bold"
                }
              }
            },
            loading: {
              labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
              },
              style: {
                position: "absolute",
                backgroundColor: G.backgroundColor,
                opacity: .5,
                textAlign: "center"
              }
            },
            tooltip: {
              enabled: !0,
              animation: E.svg,
              borderRadius: 3,
              dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
              },
              footerFormat: "",
              headerShape: "callout",
              hideDelay: 500,
              padding: 8,
              shape: "callout",
              shared: !1,
              snap: E.isTouchDevice ? 25 : 10,
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
              backgroundColor: d(G.neutralColor3).setOpacity(.85).get(),
              borderWidth: 1,
              shadow: !0,
              stickOnContact: !1,
              style: {
                color: G.neutralColor80,
                cursor: "default",
                fontSize: "12px",
                whiteSpace: "nowrap"
              },
              useHTML: !1
            },
            credits: {
              enabled: !0,
              href: "https://www.highcharts.com?credits",
              position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
              },
              style: {
                cursor: "pointer",
                color: G.neutralColor40,
                fontSize: "9px"
              },
              text: "Highcharts.com"
            }
          };
          A.chart.styledMode = !1;
          "";
          var r = new C(B(A.global, A.time));
          c = {
            defaultOptions: A,
            defaultTime: r,
            getOptions: function getOptions() {
              return A;
            },
            setOptions: function setOptions(k) {
              B(!0, A, k);
              if (k.time || k.global) E.time ? E.time.update(B(A.global, A.time, k.global, k.time)) : E.time = r;
              return A;
            }
          };
          "";
          return c;
        });
        M(d, "Core/Animation/Fx.js", [d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = c.parse,
              C = d.win,
              D = E.isNumber,
              K = E.objectEach;
          return function () {
            function c(c, k, h) {
              this.pos = NaN;
              this.options = k;
              this.elem = c;
              this.prop = h;
            }

            c.prototype.dSetter = function () {
              var c = this.paths,
                  k = c && c[0];
              c = c && c[1];
              var h = this.now || 0,
                  a = [];
              if (1 !== h && k && c) {
                if (k.length === c.length && 1 > h) for (var g = 0; g < c.length; g++) {
                  for (var y = k[g], n = c[g], t = [], O = 0; O < n.length; O++) {
                    var m = y[O],
                        N = n[O];
                    D(m) && D(N) && ("A" !== n[0] || 4 !== O && 5 !== O) ? t[O] = m + h * (N - m) : t[O] = N;
                  }

                  a.push(t);
                } else a = c;
              } else a = this.toD || [];
              this.elem.attr("d", a, void 0, !0);
            };

            c.prototype.update = function () {
              var c = this.elem,
                  k = this.prop,
                  h = this.now,
                  a = this.options.step;
              if (this[k + "Setter"]) this[k + "Setter"]();else c.attr ? c.element && c.attr(k, h, null, !0) : c.style[k] = h + this.unit;
              a && a.call(c, h, this);
            };

            c.prototype.run = function (d, k, h) {
              var a = this,
                  g = a.options,
                  y = function y(g) {
                return y.stopped ? !1 : a.step(g);
              },
                  n = C.requestAnimationFrame || function (a) {
                setTimeout(a, 13);
              },
                  t = function t() {
                for (var a = 0; a < c.timers.length; a++) {
                  c.timers[a]() || c.timers.splice(a--, 1);
                }

                c.timers.length && n(t);
              };

              d !== k || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = d, this.end = k, this.unit = h, this.now = this.start, this.pos = 0, y.elem = this.elem, y.prop = this.prop, y() && 1 === c.timers.push(y) && n(t)) : (delete g.curAnim[this.prop], g.complete && 0 === Object.keys(g.curAnim).length && g.complete.call(this.elem));
            };

            c.prototype.step = function (c) {
              var k = +new Date(),
                  h = this.options,
                  a = this.elem,
                  g = h.complete,
                  y = h.duration,
                  n = h.curAnim;
              if (a.attr && !a.element) c = !1;else if (c || k >= y + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                var t = n[this.prop] = !0;
                K(n, function (a) {
                  !0 !== a && (t = !1);
                });
                t && g && g.call(a);
                c = !1;
              } else this.pos = h.easing((k - this.startTime) / y), this.now = this.start + (this.end - this.start) * this.pos, this.update(), c = !0;
              return c;
            };

            c.prototype.initPath = function (c, k, h) {
              function a(a, g) {
                for (; a.length < L;) {
                  var m = a[0],
                      w = g[L - a.length];
                  w && "M" === m[0] && (a[0] = "C" === w[0] ? ["C", m[1], m[2], m[1], m[2], m[1], m[2]] : ["L", m[1], m[2]]);
                  a.unshift(m);
                  t && (m = a.pop(), a.push(a[a.length - 1], m));
                }
              }

              function g(a, g) {
                for (; a.length < L;) {
                  if (g = a[Math.floor(a.length / O) - 1].slice(), "C" === g[0] && (g[1] = g[5], g[2] = g[6]), t) {
                    var m = a[Math.floor(a.length / O)].slice();
                    a.splice(a.length / 2, 0, g, m);
                  } else a.push(g);
                }
              }

              var y = c.startX,
                  n = c.endX;
              h = h.slice();
              var t = c.isArea,
                  O = t ? 2 : 1;
              k = k && k.slice();
              if (!k) return [h, h];

              if (y && n && n.length) {
                for (c = 0; c < y.length; c++) {
                  if (y[c] === n[0]) {
                    var m = c;
                    break;
                  } else if (y[0] === n[n.length - y.length + c]) {
                    m = c;
                    var N = !0;
                    break;
                  } else if (y[y.length - 1] === n[n.length - y.length + c]) {
                    m = y.length - c;
                    break;
                  }
                }

                "undefined" === typeof m && (k = []);
              }

              if (k.length && D(m)) {
                var L = h.length + m * O;
                N ? (a(k, h), g(h, k)) : (a(h, k), g(k, h));
              }

              return [k, h];
            };

            c.prototype.fillSetter = function () {
              c.prototype.strokeSetter.apply(this, arguments);
            };

            c.prototype.strokeSetter = function () {
              this.elem.attr(this.prop, B(this.start).tweenTo(B(this.end), this.pos), null, !0);
            };

            c.timers = [];
            return c;
          }();
        });
        M(d, "Core/Animation/AnimationUtilities.js", [d["Core/Animation/Fx.js"], d["Core/Utilities.js"]], function (c, d) {
          function B(a) {
            return r(a) ? k({
              duration: 500,
              defer: 0
            }, a) : {
              duration: a ? 500 : 0,
              defer: 0
            };
          }

          function G(a, h) {
            for (var g = c.timers.length; g--;) {
              c.timers[g].elem !== a || h && h !== c.timers[g].prop || (c.timers[g].stopped = !0);
            }
          }

          var C = d.defined,
              D = d.getStyle,
              K = d.isArray,
              A = d.isNumber,
              r = d.isObject,
              k = d.merge,
              h = d.objectEach,
              a = d.pick;
          return {
            animate: function animate(a, y, n) {
              var g,
                  O = "",
                  m,
                  N;

              if (!r(n)) {
                var L = arguments;
                n = {
                  duration: L[2],
                  easing: L[3],
                  complete: L[4]
                };
              }

              A(n.duration) || (n.duration = 400);
              n.easing = "function" === typeof n.easing ? n.easing : Math[n.easing] || Math.easeInOutSine;
              n.curAnim = k(y);
              h(y, function (h, t) {
                G(a, t);
                N = new c(a, n, t);
                m = void 0;
                "d" === t && K(y.d) ? (N.paths = N.initPath(a, a.pathArray, y.d), N.toD = y.d, g = 0, m = 1) : a.attr ? g = a.attr(t) : (g = parseFloat(D(a, t)) || 0, "opacity" !== t && (O = "px"));
                m || (m = h);
                "string" === typeof m && m.match("px") && (m = m.replace(/px/g, ""));
                N.run(g, m, O);
              });
            },
            animObject: B,
            getDeferredAnimation: function getDeferredAnimation(a, h, n) {
              var g = B(h),
                  k = 0,
                  m = 0;
              (n ? [n] : a.series).forEach(function (a) {
                a = B(a.options.animation);
                k = h && C(h.defer) ? g.defer : Math.max(k, a.duration + a.defer);
                m = Math.min(g.duration, a.duration);
              });
              a.renderer.forExport && (k = 0);
              return {
                defer: Math.max(0, k - m),
                duration: Math.min(k, m)
              };
            },
            setAnimation: function setAnimation(g, h) {
              h.renderer.globalAnimation = a(g, h.options.chart.animation, !0);
            },
            stop: G
          };
        });
        M(d, "Core/Renderer/HTML/AST.js", [d["Core/Globals.js"], d["Core/Utilities.js"]], function (c, d) {
          var B = c.SVG_NS,
              G = d.attr,
              C = d.createElement,
              D = d.discardElement,
              K = d.error,
              A = d.isString,
              r = d.objectEach,
              k = d.splat;

          try {
            var h = !!new DOMParser().parseFromString("", "text/html");
          } catch (a) {
            h = !1;
          }

          d = function () {
            function a(a) {
              this.nodes = "string" === typeof a ? this.parseMarkup(a) : a;
            }

            a.filterUserAttributes = function (g) {
              r(g, function (h, n) {
                var t = !0;
                -1 === a.allowedAttributes.indexOf(n) && (t = !1);
                -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(n) && (t = A(h) && a.allowedReferences.some(function (a) {
                  return 0 === h.indexOf(a);
                }));
                t || (K("Highcharts warning: Invalid attribute '" + n + "' in config"), delete g[n]);
              });
              return g;
            };

            a.setElementHTML = function (g, h) {
              g.innerHTML = "";
              h && new a(h).addToDOM(g);
            };

            a.prototype.addToDOM = function (g) {
              function h(g, t) {
                var n;
                k(g).forEach(function (g) {
                  var m = g.tagName,
                      k = g.textContent ? c.doc.createTextNode(g.textContent) : void 0;
                  if (m) if ("#text" === m) var x = k;else if (-1 !== a.allowedTags.indexOf(m)) {
                    m = c.doc.createElementNS("svg" === m ? B : t.namespaceURI || B, m);
                    var y = g.attributes || {};
                    r(g, function (a, g) {
                      "tagName" !== g && "attributes" !== g && "children" !== g && "textContent" !== g && (y[g] = a);
                    });
                    G(m, a.filterUserAttributes(y));
                    k && m.appendChild(k);
                    h(g.children || [], m);
                    x = m;
                  } else K("Highcharts warning: Invalid tagName '" + m + "' in config");
                  x && t.appendChild(x);
                  n = x;
                });
                return n;
              }

              return h(this.nodes, g);
            };

            a.prototype.parseMarkup = function (a) {
              var g = [];
              a = a.trim();
              if (h) a = new DOMParser().parseFromString(a, "text/html");else {
                var n = C("div");
                n.innerHTML = a;
                a = {
                  body: n
                };
              }

              var t = function t(a, g) {
                var m = a.nodeName.toLowerCase(),
                    h = {
                  tagName: m
                };
                "#text" === m && (h.textContent = a.textContent || "");

                if (m = a.attributes) {
                  var n = {};
                  [].forEach.call(m, function (a) {
                    n[a.name] = a.value;
                  });
                  h.attributes = n;
                }

                if (a.childNodes.length) {
                  var k = [];
                  [].forEach.call(a.childNodes, function (a) {
                    t(a, k);
                  });
                  k.length && (h.children = k);
                }

                g.push(h);
              };

              [].forEach.call(a.body.childNodes, function (a) {
                return t(a, g);
              });
              n && D(n);
              return g;
            };

            a.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            a.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            a.allowedTags = "a b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            return a;
          }();

          "";
          return d;
        });
        M(d, "Core/FormatUtilities.js", [d["Core/DefaultOptions.js"], d["Core/Utilities.js"]], function (c, d) {
          function B(k, h, a, g) {
            k = +k || 0;
            h = +h;
            var y = G.lang,
                n = (k.toString().split(".")[1] || "").split("e")[0].length,
                t = k.toString().split("e"),
                c = h;
            if (-1 === h) h = Math.min(n, 20);else if (!K(h)) h = 2;else if (h && t[1] && 0 > t[1]) {
              var m = h + +t[1];
              0 <= m ? (t[0] = (+t[0]).toExponential(m).split("e")[0], h = m) : (t[0] = t[0].split(".")[0] || 0, k = 20 > h ? (t[0] * Math.pow(10, t[1])).toFixed(h) : 0, t[1] = 0);
            }
            m = (Math.abs(t[1] ? t[0] : k) + Math.pow(10, -Math.max(h, n) - 1)).toFixed(h);
            n = String(r(m));
            var d = 3 < n.length ? n.length % 3 : 0;
            a = A(a, y.decimalPoint);
            g = A(g, y.thousandsSep);
            k = (0 > k ? "-" : "") + (d ? n.substr(0, d) + g : "");
            k = 0 > +t[1] && !c ? "0" : k + n.substr(d).replace(/(\d{3})(?=\d)/g, "$1" + g);
            h && (k += a + m.slice(-h));
            t[1] && 0 !== +k && (k += "e" + t[1]);
            return k;
          }

          var G = c.defaultOptions,
              C = c.defaultTime,
              D = d.getNestedProperty,
              K = d.isNumber,
              A = d.pick,
              r = d.pInt;
          return {
            dateFormat: function dateFormat(k, h, a) {
              return C.dateFormat(k, h, a);
            },
            format: function format(k, h, a) {
              var g = "{",
                  y = !1,
                  n = /f$/,
                  t = /\.([0-9])/,
                  c = G.lang,
                  m = a && a.time || C;
              a = a && a.numberFormatter || B;

              for (var d = []; k;) {
                var L = k.indexOf(g);
                if (-1 === L) break;
                var x = k.slice(0, L);

                if (y) {
                  x = x.split(":");
                  g = D(x.shift() || "", h);
                  if (x.length && "number" === typeof g) if (x = x.join(":"), n.test(x)) {
                    var r = parseInt((x.match(t) || ["", "-1"])[1], 10);
                    null !== g && (g = a(g, r, c.decimalPoint, -1 < x.indexOf(",") ? c.thousandsSep : ""));
                  } else g = m.dateFormat(x, g);
                  d.push(g);
                } else d.push(x);

                k = k.slice(L + 1);
                g = (y = !y) ? "}" : "{";
              }

              d.push(k);
              return d.join("");
            },
            numberFormat: B
          };
        });
        M(d, "Core/Renderer/RendererUtilities.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.clamp,
              E = c.pick,
              G = c.stableSort,
              C;

          (function (c) {
            function B(c, r, k) {
              var h = c,
                  a = h.reducedLen || r,
                  g = function g(a, _g) {
                return (_g.rank || 0) - (a.rank || 0);
              },
                  y = function y(a, g) {
                return a.target - g.target;
              },
                  n,
                  t = !0,
                  O = [],
                  m = 0;

              for (n = c.length; n--;) {
                m += c[n].size;
              }

              if (m > a) {
                G(c, g);

                for (m = n = 0; m <= a;) {
                  m += c[n].size, n++;
                }

                O = c.splice(n - 1, c.length);
              }

              G(c, y);

              for (c = c.map(function (a) {
                return {
                  size: a.size,
                  targets: [a.target],
                  align: E(a.align, .5)
                };
              }); t;) {
                for (n = c.length; n--;) {
                  a = c[n], g = (Math.min.apply(0, a.targets) + Math.max.apply(0, a.targets)) / 2, a.pos = d(g - a.size * a.align, 0, r - a.size);
                }

                n = c.length;

                for (t = !1; n--;) {
                  0 < n && c[n - 1].pos + c[n - 1].size > c[n].pos && (c[n - 1].size += c[n].size, c[n - 1].targets = c[n - 1].targets.concat(c[n].targets), c[n - 1].align = .5, c[n - 1].pos + c[n - 1].size > r && (c[n - 1].pos = r - c[n - 1].size), c.splice(n, 1), t = !0);
                }
              }

              h.push.apply(h, O);
              n = 0;
              c.some(function (a) {
                var g = 0;
                return (a.targets || []).some(function () {
                  h[n].pos = a.pos + g;
                  if ("undefined" !== typeof k && Math.abs(h[n].pos - h[n].target) > k) return h.slice(0, n + 1).forEach(function (a) {
                    return delete a.pos;
                  }), h.reducedLen = (h.reducedLen || r) - .1 * r, h.reducedLen > .1 * r && B(h, r, k), !0;
                  g += h[n].size;
                  n++;
                  return !1;
                });
              });
              G(h, y);
              return h;
            }

            c.distribute = B;
          })(C || (C = {}));

          return C;
        });
        M(d, "Core/Renderer/SVG/SVGElement.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Renderer/HTML/AST.js"], d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Color/Palette.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D) {
          var B = c.animate,
              A = c.animObject,
              r = c.stop,
              k = G.deg2rad,
              h = G.doc,
              a = G.noop,
              g = G.svg,
              y = G.SVG_NS,
              n = G.win,
              t = D.addEvent,
              O = D.attr,
              m = D.createElement,
              N = D.css,
              L = D.defined,
              x = D.erase,
              R = D.extend,
              H = D.fireEvent,
              w = D.isArray,
              f = D.isFunction,
              b = D.isNumber,
              v = D.isString,
              F = D.merge,
              e = D.objectEach,
              q = D.pick,
              l = D.pInt,
              I = D.syncTimeout,
              p = D.uniqueKey;

          c = function () {
            function z() {
              this.element = void 0;
              this.onEvents = {};
              this.opacity = 1;
              this.renderer = void 0;
              this.SVG_NS = y;
              this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }

            z.prototype._defaultGetter = function (b) {
              b = q(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
              /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
              return b;
            };

            z.prototype._defaultSetter = function (b, e, J) {
              J.setAttribute(e, b);
            };

            z.prototype.add = function (b) {
              var e = this.renderer,
                  J = this.element;
              b && (this.parentGroup = b);
              this.parentInverted = b && b.inverted;
              "undefined" !== typeof this.textStr && "text" === this.element.nodeName && e.buildText(this);
              this.added = !0;
              if (!b || b.handleZ || this.zIndex) var u = this.zIndexSetter();
              u || (b ? b.element : e.box).appendChild(J);
              if (this.onAdd) this.onAdd();
              return this;
            };

            z.prototype.addClass = function (b, e) {
              var J = e ? "" : this.attr("class") || "";
              b = (b || "").split(/ /g).reduce(function (b, e) {
                -1 === J.indexOf(e) && b.push(e);
                return b;
              }, J ? [J] : []).join(" ");
              b !== J && this.attr("class", b);
              return this;
            };

            z.prototype.afterSetters = function () {
              this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };

            z.prototype.align = function (b, e, J) {
              var u = {},
                  l = this.renderer,
                  f = l.alignedObjects,
                  p,
                  a,
                  P;

              if (b) {
                if (this.alignOptions = b, this.alignByTranslate = e, !J || v(J)) this.alignTo = p = J || "renderer", x(f, this), f.push(this), J = void 0;
              } else b = this.alignOptions, e = this.alignByTranslate, p = this.alignTo;

              J = q(J, l[p], "scrollablePlotBox" === p ? l.plotBox : void 0, l);
              p = b.align;
              var g = b.verticalAlign;
              l = (J.x || 0) + (b.x || 0);
              f = (J.y || 0) + (b.y || 0);
              "right" === p ? a = 1 : "center" === p && (a = 2);
              a && (l += (J.width - (b.width || 0)) / a);
              u[e ? "translateX" : "x"] = Math.round(l);
              "bottom" === g ? P = 1 : "middle" === g && (P = 2);
              P && (f += (J.height - (b.height || 0)) / P);
              u[e ? "translateY" : "y"] = Math.round(f);
              this[this.placed ? "animate" : "attr"](u);
              this.placed = !0;
              this.alignAttr = u;
              return this;
            };

            z.prototype.alignSetter = function (b) {
              var e = {
                left: "start",
                center: "middle",
                right: "end"
              };
              e[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", e[b]));
            };

            z.prototype.animate = function (b, l, J) {
              var u = this,
                  f = A(q(l, this.renderer.globalAnimation, !0));
              l = f.defer;
              q(h.hidden, h.msHidden, h.webkitHidden, !1) && (f.duration = 0);
              0 !== f.duration ? (J && (f.complete = J), I(function () {
                u.element && B(u, b, f);
              }, l)) : (this.attr(b, void 0, J), e(b, function (b, u) {
                f.step && f.step.call(this, b, {
                  prop: u,
                  pos: 1,
                  elem: this
                });
              }, this));
              return this;
            };

            z.prototype.applyTextOutline = function (b) {
              var e = this.element;
              -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));
              var J = b.split(" ");
              b = J[J.length - 1];

              if ((J = J[0]) && "none" !== J && G.svg) {
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                J = J.replace(/(^[\d\.]+)(.*?)$/g, function (b, u, e) {
                  return 2 * Number(u) + e;
                });
                this.removeTextOutline();
                var u = h.createElementNS(y, "tspan");
                O(u, {
                  "class": "highcharts-text-outline",
                  fill: b,
                  stroke: b,
                  "stroke-width": J,
                  "stroke-linejoin": "round"
                });
                [].forEach.call(e.childNodes, function (b) {
                  var e = b.cloneNode(!0);
                  e.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
                    return e.removeAttribute(b);
                  });
                  u.appendChild(e);
                });
                var l = h.createElementNS(y, "tspan");
                l.textContent = "\u200B";
                ["x", "y"].forEach(function (b) {
                  var u = e.getAttribute(b);
                  u && l.setAttribute(b, u);
                });
                u.appendChild(l);
                e.insertBefore(u, e.firstChild);
              }
            };

            z.prototype.attr = function (b, l, J, u) {
              var f = this.element,
                  q = this.symbolCustomAttribs,
                  p,
                  a = this,
                  v,
                  P;

              if ("string" === typeof b && "undefined" !== typeof l) {
                var g = b;
                b = {};
                b[g] = l;
              }

              "string" === typeof b ? a = (this[b + "Getter"] || this._defaultGetter).call(this, b, f) : (e(b, function (e, l) {
                v = !1;
                u || r(this, l);
                this.symbolName && -1 !== q.indexOf(l) && (p || (this.symbolAttr(b), p = !0), v = !0);
                !this.rotation || "x" !== l && "y" !== l || (this.doTransform = !0);
                v || (P = this[l + "Setter"] || this._defaultSetter, P.call(this, e, l, f), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(l) && this.updateShadows(l, e, P));
              }, this), this.afterSetters());
              J && J.call(this);
              return a;
            };

            z.prototype.clip = function (b) {
              return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
            };

            z.prototype.crisp = function (b, e) {
              e = e || b.strokeWidth || 0;
              var l = Math.round(e) % 2 / 2;
              b.x = Math.floor(b.x || this.x || 0) + l;
              b.y = Math.floor(b.y || this.y || 0) + l;
              b.width = Math.floor((b.width || this.width || 0) - 2 * l);
              b.height = Math.floor((b.height || this.height || 0) - 2 * l);
              L(b.strokeWidth) && (b.strokeWidth = e);
              return b;
            };

            z.prototype.complexColor = function (b, l, J) {
              var u = this.renderer,
                  f,
                  q,
                  a,
                  v,
                  P,
                  g,
                  z,
                  m,
                  I,
                  h,
                  n = [],
                  t;
              H(this.renderer, "complexColor", {
                args: arguments
              }, function () {
                b.radialGradient ? q = "radialGradient" : b.linearGradient && (q = "linearGradient");

                if (q) {
                  a = b[q];
                  P = u.gradients;
                  g = b.stops;
                  I = J.radialReference;
                  w(a) && (b[q] = a = {
                    x1: a[0],
                    y1: a[1],
                    x2: a[2],
                    y2: a[3],
                    gradientUnits: "userSpaceOnUse"
                  });
                  "radialGradient" === q && I && !L(a.gradientUnits) && (v = a, a = F(a, u.getRadialAttr(I, v), {
                    gradientUnits: "userSpaceOnUse"
                  }));
                  e(a, function (b, u) {
                    "id" !== u && n.push(u, b);
                  });
                  e(g, function (b) {
                    n.push(b);
                  });
                  n = n.join(",");
                  if (P[n]) h = P[n].attr("id");else {
                    a.id = h = p();
                    var Q = P[n] = u.createElement(q).attr(a).add(u.defs);
                    Q.radAttr = v;
                    Q.stops = [];
                    g.forEach(function (b) {
                      0 === b[1].indexOf("rgba") ? (f = E.parse(b[1]), z = f.get("rgb"), m = f.get("a")) : (z = b[1], m = 1);
                      b = u.createElement("stop").attr({
                        offset: b[0],
                        "stop-color": z,
                        "stop-opacity": m
                      }).add(Q);
                      Q.stops.push(b);
                    });
                  }
                  t = "url(" + u.url + "#" + h + ")";
                  J.setAttribute(l, t);
                  J.gradient = n;

                  b.toString = function () {
                    return t;
                  };
                }
              });
            };

            z.prototype.css = function (b) {
              var f = this.styles,
                  J = {},
                  u = this.element,
                  q = ["textOutline", "textOverflow", "width"],
                  p = "",
                  a = !f;
              b && b.color && (b.fill = b.color);
              f && e(b, function (b, u) {
                f && f[u] !== b && (J[u] = b, a = !0);
              });

              if (a) {
                f && (b = R(f, J));
                if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === u.nodeName.toLowerCase() && b.width) var v = this.textWidth = l(b.width);
                this.styles = b;
                v && !g && this.renderer.forExport && delete b.width;

                if (u.namespaceURI === this.SVG_NS) {
                  var Q = function Q(b, u) {
                    return "-" + u.toLowerCase();
                  };

                  e(b, function (b, u) {
                    -1 === q.indexOf(u) && (p += u.replace(/([A-Z])/g, Q) + ":" + b + ";");
                  });
                  p && O(u, "style", p);
                } else N(u, b);

                this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
              }

              return this;
            };

            z.prototype.dashstyleSetter = function (b) {
              var e = this["stroke-width"];
              "inherit" === e && (e = 1);

              if (b = b && b.toLowerCase()) {
                var f = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

                for (b = f.length; b--;) {
                  f[b] = "" + l(f[b]) * q(e, NaN);
                }

                b = f.join(",").replace(/NaN/g, "none");
                this.element.setAttribute("stroke-dasharray", b);
              }
            };

            z.prototype.destroy = function () {
              var b = this,
                  l = b.element || {},
                  f = b.renderer,
                  u = l.ownerSVGElement,
                  q = f.isSVG && "SPAN" === l.nodeName && b.parentGroup || void 0;
              l.onclick = l.onmouseout = l.onmouseover = l.onmousemove = l.point = null;
              r(b);

              if (b.clipPath && u) {
                var p = b.clipPath;
                [].forEach.call(u.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
                  -1 < b.getAttribute("clip-path").indexOf(p.element.id) && b.removeAttribute("clip-path");
                });
                b.clipPath = p.destroy();
              }

              if (b.stops) {
                for (u = 0; u < b.stops.length; u++) {
                  b.stops[u].destroy();
                }

                b.stops.length = 0;
                b.stops = void 0;
              }

              b.safeRemoveChild(l);

              for (f.styledMode || b.destroyShadows(); q && q.div && 0 === q.div.childNodes.length;) {
                l = q.parentGroup, b.safeRemoveChild(q.div), delete q.div, q = l;
              }

              b.alignTo && x(f.alignedObjects, b);
              e(b, function (u, e) {
                b[e] && b[e].parentGroup === b && b[e].destroy && b[e].destroy();
                delete b[e];
              });
            };

            z.prototype.destroyShadows = function () {
              (this.shadows || []).forEach(function (b) {
                this.safeRemoveChild(b);
              }, this);
              this.shadows = void 0;
            };

            z.prototype.destroyTextPath = function (b, e) {
              var l = b.getElementsByTagName("text")[0];

              if (l) {
                if (l.removeAttribute("dx"), l.removeAttribute("dy"), e.element.setAttribute("id", ""), this.textPathWrapper && l.getElementsByTagName("textPath").length) {
                  for (b = this.textPathWrapper.element.childNodes; b.length;) {
                    l.appendChild(b[0]);
                  }

                  l.removeChild(this.textPathWrapper.element);
                }
              } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");

              this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };

            z.prototype.dSetter = function (b, e, l) {
              w(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, e, l) {
                return e && e.join ? (l ? b + " " : "") + e.join(" ") : (e || "").toString();
              }, ""));
              /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
              this[e] !== b && (l.setAttribute(e, b), this[e] = b);
            };

            z.prototype.fadeOut = function (b) {
              var e = this;
              e.animate({
                opacity: 0
              }, {
                duration: q(b, 150),
                complete: function complete() {
                  e.attr({
                    y: -9999
                  }).hide();
                }
              });
            };

            z.prototype.fillSetter = function (b, e, l) {
              "string" === typeof b ? l.setAttribute(e, b) : b && this.complexColor(b, e, l);
            };

            z.prototype.getBBox = function (b, e) {
              var l = this.renderer,
                  u = this.element,
                  p = this.styles,
                  a = this.textStr,
                  v = l.cache,
                  g = l.cacheKeys,
                  Q = u.namespaceURI === this.SVG_NS;
              e = q(e, this.rotation, 0);
              var F = l.styledMode ? u && z.prototype.getStyle.call(u, "font-size") : p && p.fontSize,
                  m;

              if (L(a)) {
                var w = a.toString();
                -1 === w.indexOf("<") && (w = w.replace(/[0-9]/g, "0"));
                w += ["", e, F, this.textWidth, p && p.textOverflow, p && p.fontWeight].join();
              }

              w && !b && (m = v[w]);

              if (!m) {
                if (Q || l.forExport) {
                  try {
                    var I = this.fakeTS && function (b) {
                      var e = u.querySelector(".highcharts-text-outline");
                      e && N(e, {
                        display: b
                      });
                    };

                    f(I) && I("none");
                    m = u.getBBox ? R({}, u.getBBox()) : {
                      width: u.offsetWidth,
                      height: u.offsetHeight
                    };
                    f(I) && I("");
                  } catch (Z) {
                    "";
                  }

                  if (!m || 0 > m.width) m = {
                    width: 0,
                    height: 0
                  };
                } else m = this.htmlGetBBox();

                l.isSVG && (b = m.width, l = m.height, Q && (m.height = l = {
                  "11px,17": 14,
                  "13px,20": 16
                }[p && p.fontSize + "," + Math.round(l)] || l), e && (p = e * k, m.width = Math.abs(l * Math.sin(p)) + Math.abs(b * Math.cos(p)), m.height = Math.abs(l * Math.cos(p)) + Math.abs(b * Math.sin(p))));

                if (w && ("" === a || 0 < m.height)) {
                  for (; 250 < g.length;) {
                    delete v[g.shift()];
                  }

                  v[w] || g.push(w);
                  v[w] = m;
                }
              }

              return m;
            };

            z.prototype.getStyle = function (b) {
              return n.getComputedStyle(this.element || this, "").getPropertyValue(b);
            };

            z.prototype.hasClass = function (b) {
              return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
            };

            z.prototype.hide = function (b) {
              b ? this.attr({
                y: -9999
              }) : this.attr({
                visibility: "hidden"
              });
              return this;
            };

            z.prototype.htmlGetBBox = function () {
              return {
                height: 0,
                width: 0,
                x: 0,
                y: 0
              };
            };

            z.prototype.init = function (b, e) {
              this.element = "span" === e ? m(e) : h.createElementNS(this.SVG_NS, e);
              this.renderer = b;
              H(this, "afterInit");
            };

            z.prototype.invert = function (b) {
              this.inverted = b;
              this.updateTransform();
              return this;
            };

            z.prototype.on = function (b, e) {
              var l = this.onEvents;
              if (l[b]) l[b]();
              l[b] = t(this.element, b, e);
              return this;
            };

            z.prototype.opacitySetter = function (b, e, l) {
              this.opacity = b = Number(Number(b).toFixed(3));
              l.setAttribute(e, b);
            };

            z.prototype.removeClass = function (b) {
              return this.attr("class", ("" + this.attr("class")).replace(v(b) ? new RegExp("(^| )" + b + "( |$)") : b, " ").replace(/ +/g, " ").trim());
            };

            z.prototype.removeTextOutline = function () {
              var b = this.element.querySelector("tspan.highcharts-text-outline");
              b && this.safeRemoveChild(b);
            };

            z.prototype.safeRemoveChild = function (b) {
              var e = b.parentNode;
              e && e.removeChild(b);
            };

            z.prototype.setRadialReference = function (b) {
              var e = this.element.gradient && this.renderer.gradients[this.element.gradient];
              this.element.radialReference = b;
              e && e.radAttr && e.animate(this.renderer.getRadialAttr(b, e.radAttr));
              return this;
            };

            z.prototype.setTextPath = function (l, f) {
              var q = this.element,
                  u = this.text ? this.text.element : q,
                  v = {
                textAnchor: "text-anchor"
              },
                  g = !1,
                  z = this.textPathWrapper,
                  m = !z;
              f = F(!0, {
                enabled: !0,
                attributes: {
                  dy: -5,
                  startOffset: "50%",
                  textAnchor: "middle"
                }
              }, f);
              var Q = d.filterUserAttributes(f.attributes);

              if (l && f && f.enabled) {
                z && null === z.element.parentNode ? (m = !0, z = z.destroy()) : z && this.removeTextOutline.call(z.parentGroup);
                this.options && this.options.padding && (Q.dx = -this.options.padding);
                z || (this.textPathWrapper = z = this.renderer.createElement("textPath"), g = !0);
                var w = z.element;
                (f = l.element.getAttribute("id")) || l.element.setAttribute("id", f = p());
                if (m) for (u.setAttribute("y", 0), b(Q.dx) && u.setAttribute("x", -Q.dx), l = [].slice.call(u.childNodes), m = 0; m < l.length; m++) {
                  var I = l[m];
                  I.nodeType !== Node.TEXT_NODE && "tspan" !== I.nodeName || w.appendChild(I);
                }
                g && z && z.add({
                  element: u
                });
                w.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + f);
                L(Q.dy) && (w.parentNode.setAttribute("dy", Q.dy), delete Q.dy);
                L(Q.dx) && (w.parentNode.setAttribute("dx", Q.dx), delete Q.dx);
                e(Q, function (b, u) {
                  w.setAttribute(v[u] || u, b);
                });
                q.removeAttribute("transform");
                this.removeTextOutline.call(z);
                this.text && !this.renderer.styledMode && this.attr({
                  fill: "none",
                  "stroke-width": 0
                });
                this.applyTextOutline = this.updateTransform = a;
              } else z && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(q, l), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

              return this;
            };

            z.prototype.shadow = function (b, l, f) {
              var u = [],
                  q = this.element,
                  p = this.oldShadowOptions,
                  a = {
                color: C.neutralColor100,
                offsetX: this.parentInverted ? -1 : 1,
                offsetY: this.parentInverted ? -1 : 1,
                opacity: .15,
                width: 3
              },
                  J = !1,
                  v;
              !0 === b ? v = a : "object" === typeof b && (v = R(a, b));
              v && (v && p && e(v, function (b, u) {
                b !== p[u] && (J = !0);
              }), J && this.destroyShadows(), this.oldShadowOptions = v);
              if (!v) this.destroyShadows();else if (!this.shadows) {
                var g = v.opacity / v.width;
                var z = this.parentInverted ? "translate(" + v.offsetY + ", " + v.offsetX + ")" : "translate(" + v.offsetX + ", " + v.offsetY + ")";

                for (a = 1; a <= v.width; a++) {
                  var F = q.cloneNode(!1);
                  var m = 2 * v.width + 1 - 2 * a;
                  O(F, {
                    stroke: b.color || C.neutralColor100,
                    "stroke-opacity": g * a,
                    "stroke-width": m,
                    transform: z,
                    fill: "none"
                  });
                  F.setAttribute("class", (F.getAttribute("class") || "") + " highcharts-shadow");
                  f && (O(F, "height", Math.max(O(F, "height") - m, 0)), F.cutHeight = m);
                  l ? l.element.appendChild(F) : q.parentNode && q.parentNode.insertBefore(F, q);
                  u.push(F);
                }

                this.shadows = u;
              }
              return this;
            };

            z.prototype.show = function (b) {
              return this.attr({
                visibility: b ? "inherit" : "visible"
              });
            };

            z.prototype.strokeSetter = function (b, e, l) {
              this[e] = b;
              this.stroke && this["stroke-width"] ? (z.prototype.fillSetter.call(this, this.stroke, "stroke", l), l.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === e && 0 === b && this.hasStroke ? (l.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (l.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
            };

            z.prototype.strokeWidth = function () {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              var b = this.getStyle("stroke-width"),
                  e = 0;
              if (b.indexOf("px") === b.length - 2) e = l(b);else if ("" !== b) {
                var f = h.createElementNS(y, "rect");
                O(f, {
                  width: b,
                  "stroke-width": 0
                });
                this.element.parentNode.appendChild(f);
                e = f.getBBox().width;
                f.parentNode.removeChild(f);
              }
              return e;
            };

            z.prototype.symbolAttr = function (b) {
              var e = this;
              "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (l) {
                e[l] = q(b[l], e[l]);
              });
              e.attr({
                d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)
              });
            };

            z.prototype.textSetter = function (b) {
              b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
            };

            z.prototype.titleSetter = function (b) {
              var e = this.element,
                  l = e.getElementsByTagName("title")[0] || h.createElementNS(this.SVG_NS, "title");
              e.insertBefore ? e.insertBefore(l, e.firstChild) : e.appendChild(l);
              l.textContent = String(q(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };

            z.prototype.toFront = function () {
              var b = this.element;
              b.parentNode.appendChild(b);
              return this;
            };

            z.prototype.translate = function (b, e) {
              return this.attr({
                translateX: b,
                translateY: e
              });
            };

            z.prototype.updateShadows = function (b, e, l) {
              var u = this.shadows;
              if (u) for (var f = u.length; f--;) {
                l.call(u[f], "height" === b ? Math.max(e - (u[f].cutHeight || 0), 0) : "d" === b ? this.d : e, b, u[f]);
              }
            };

            z.prototype.updateTransform = function () {
              var b = this.scaleX,
                  e = this.scaleY,
                  l = this.inverted,
                  u = this.rotation,
                  f = this.matrix,
                  p = this.element,
                  a = this.translateX || 0,
                  v = this.translateY || 0;
              l && (a += this.width, v += this.height);
              a = ["translate(" + a + "," + v + ")"];
              L(f) && a.push("matrix(" + f.join(",") + ")");
              l ? a.push("rotate(90) scale(-1,1)") : u && a.push("rotate(" + u + " " + q(this.rotationOriginX, p.getAttribute("x"), 0) + " " + q(this.rotationOriginY, p.getAttribute("y") || 0) + ")");
              (L(b) || L(e)) && a.push("scale(" + q(b, 1) + " " + q(e, 1) + ")");
              a.length && p.setAttribute("transform", a.join(" "));
            };

            z.prototype.visibilitySetter = function (b, e, l) {
              "inherit" === b ? l.removeAttribute(e) : this[e] !== b && l.setAttribute(e, b);
              this[e] = b;
            };

            z.prototype.xGetter = function (b) {
              "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
              return this._defaultGetter(b);
            };

            z.prototype.zIndexSetter = function (b, e) {
              var f = this.renderer,
                  u = this.parentGroup,
                  q = (u || f).element || f.box,
                  p = this.element;
              f = q === f.box;
              var a = !1;
              var v = this.added;
              var g;
              L(b) ? (p.setAttribute("data-z-index", b), b = +b, this[e] === b && (v = !1)) : L(this[e]) && p.removeAttribute("data-z-index");
              this[e] = b;

              if (v) {
                (b = this.zIndex) && u && (u.handleZ = !0);
                e = q.childNodes;

                for (g = e.length - 1; 0 <= g && !a; g--) {
                  u = e[g];
                  v = u.getAttribute("data-z-index");
                  var z = !L(v);
                  if (u !== p) if (0 > b && z && !f && !g) q.insertBefore(p, e[g]), a = !0;else if (l(v) <= b || z && (!L(b) || 0 <= b)) q.insertBefore(p, e[g + 1] || null), a = !0;
                }

                a || (q.insertBefore(p, e[f ? 3 : 0] || null), a = !0);
              }

              return a;
            };

            return z;
          }();

          c.prototype["stroke-widthSetter"] = c.prototype.strokeSetter;
          c.prototype.yGetter = c.prototype.xGetter;

          c.prototype.matrixSetter = c.prototype.rotationOriginXSetter = c.prototype.rotationOriginYSetter = c.prototype.rotationSetter = c.prototype.scaleXSetter = c.prototype.scaleYSetter = c.prototype.translateXSetter = c.prototype.translateYSetter = c.prototype.verticalAlignSetter = function (b, e) {
            this[e] = b;
            this.doTransform = !0;
          };

          "";
          return c;
        });
        M(d, "Core/Renderer/RendererRegistry.js", [d["Core/Globals.js"]], function (c) {
          var d;

          (function (d) {
            d.rendererTypes = {};
            var B;

            d.getRendererType = function (c) {
              void 0 === c && (c = B);
              return d.rendererTypes[c] || d.rendererTypes[B];
            };

            d.registerRendererType = function (C, D, E) {
              d.rendererTypes[C] = D;
              if (!B || E) B = C, c.Renderer = D;
            };
          })(d || (d = {}));

          return d;
        });
        M(d, "Core/Renderer/SVG/SVGLabel.js", [d["Core/Renderer/SVG/SVGElement.js"], d["Core/Utilities.js"]], function (c, d) {
          var B = this && this.__extends || function () {
            var _k = function k(h, a) {
              _k = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, h) {
                a.__proto__ = h;
              } || function (a, h) {
                for (var g in h) {
                  h.hasOwnProperty(g) && (a[g] = h[g]);
                }
              };

              return _k(h, a);
            };

            return function (h, a) {
              function g() {
                this.constructor = h;
              }

              _k(h, a);

              h.prototype = null === a ? Object.create(a) : (g.prototype = a.prototype, new g());
            };
          }(),
              G = d.defined,
              C = d.extend,
              D = d.isNumber,
              K = d.merge,
              A = d.pick,
              r = d.removeEvent;

          return function (k) {
            function h(a, g, c, n, t, d, m, N, L, x) {
              var y = k.call(this) || this;
              y.paddingLeftSetter = y.paddingSetter;
              y.paddingRightSetter = y.paddingSetter;
              y.init(a, "g");
              y.textStr = g;
              y.x = c;
              y.y = n;
              y.anchorX = d;
              y.anchorY = m;
              y.baseline = L;
              y.className = x;
              y.addClass("button" === x ? "highcharts-no-tooltip" : "highcharts-label");
              x && y.addClass("highcharts-" + x);
              y.text = a.text(void 0, 0, 0, N).attr({
                zIndex: 1
              });
              var H;
              "string" === typeof t && ((H = /^url\((.*?)\)$/.test(t)) || y.renderer.symbols[t]) && (y.symbolKey = t);
              y.bBox = h.emptyBBox;
              y.padding = 3;
              y.baselineOffset = 0;
              y.needsBox = a.styledMode || H;
              y.deferredAttr = {};
              y.alignFactor = 0;
              return y;
            }

            B(h, k);

            h.prototype.alignSetter = function (a) {
              a = {
                left: 0,
                center: .5,
                right: 1
              }[a];
              a !== this.alignFactor && (this.alignFactor = a, this.bBox && D(this.xSetting) && this.attr({
                x: this.xSetting
              }));
            };

            h.prototype.anchorXSetter = function (a, g) {
              this.anchorX = a;
              this.boxAttr(g, Math.round(a) - this.getCrispAdjust() - this.xSetting);
            };

            h.prototype.anchorYSetter = function (a, g) {
              this.anchorY = a;
              this.boxAttr(g, a - this.ySetting);
            };

            h.prototype.boxAttr = function (a, g) {
              this.box ? this.box.attr(a, g) : this.deferredAttr[a] = g;
            };

            h.prototype.css = function (a) {
              if (a) {
                var g = {};
                a = K(a);
                h.textProps.forEach(function (h) {
                  "undefined" !== typeof a[h] && (g[h] = a[h], delete a[h]);
                });
                this.text.css(g);
                var k = ("width" in g);
                "fontSize" in g || "fontWeight" in g ? this.updateTextPadding() : k && this.updateBoxSize();
              }

              return c.prototype.css.call(this, a);
            };

            h.prototype.destroy = function () {
              r(this.element, "mouseenter");
              r(this.element, "mouseleave");
              this.text && this.text.destroy();
              this.box && (this.box = this.box.destroy());
              c.prototype.destroy.call(this);
            };

            h.prototype.fillSetter = function (a, g) {
              a && (this.needsBox = !0);
              this.fill = a;
              this.boxAttr(g, a);
            };

            h.prototype.getBBox = function () {
              this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
              var a = this.padding,
                  g = A(this.paddingLeft, a);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - g,
                y: this.bBox.y - a
              };
            };

            h.prototype.getCrispAdjust = function () {
              return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };

            h.prototype.heightSetter = function (a) {
              this.heightSetting = a;
            };

            h.prototype.onAdd = function () {
              var a = this.textStr;
              this.text.add(this);
              this.attr({
                text: G(a) ? a : "",
                x: this.x,
                y: this.y
              });
              this.box && G(this.anchorX) && this.attr({
                anchorX: this.anchorX,
                anchorY: this.anchorY
              });
            };

            h.prototype.paddingSetter = function (a, g) {
              D(a) ? a !== this[g] && (this[g] = a, this.updateTextPadding()) : this[g] = void 0;
            };

            h.prototype.rSetter = function (a, g) {
              this.boxAttr(g, a);
            };

            h.prototype.shadow = function (a) {
              a && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(a));
              return this;
            };

            h.prototype.strokeSetter = function (a, g) {
              this.stroke = a;
              this.boxAttr(g, a);
            };

            h.prototype["stroke-widthSetter"] = function (a, g) {
              a && (this.needsBox = !0);
              this["stroke-width"] = a;
              this.boxAttr(g, a);
            };

            h.prototype["text-alignSetter"] = function (a) {
              this.textAlign = a;
            };

            h.prototype.textSetter = function (a) {
              "undefined" !== typeof a && this.text.attr({
                text: a
              });
              this.updateTextPadding();
            };

            h.prototype.updateBoxSize = function () {
              var a = this.text.element.style,
                  g = {},
                  k = this.padding,
                  n = this.bBox = D(this.widthSetting) && D(this.heightSetting) && !this.textAlign || !G(this.text.textStr) ? h.emptyBBox : this.text.getBBox();
              this.width = this.getPaddedWidth();
              this.height = (this.heightSetting || n.height || 0) + 2 * k;
              a = this.renderer.fontMetrics(a && a.fontSize, this.text);
              this.baselineOffset = k + Math.min((this.text.firstLineMetrics || a).b, n.height || Infinity);
              this.heightSetting && (this.baselineOffset += (this.heightSetting - a.h) / 2);
              this.needsBox && (this.box || (k = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), k.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), k.add(this)), k = this.getCrispAdjust(), g.x = k, g.y = (this.baseline ? -this.baselineOffset : 0) + k, g.width = Math.round(this.width), g.height = Math.round(this.height), this.box.attr(C(g, this.deferredAttr)), this.deferredAttr = {});
            };

            h.prototype.updateTextPadding = function () {
              var a = this.text;
              this.updateBoxSize();
              var g = this.baseline ? 0 : this.baselineOffset,
                  h = A(this.paddingLeft, this.padding);
              G(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (h += {
                center: .5,
                right: 1
              }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (h !== a.x || g !== a.y) a.attr("x", h), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), "undefined" !== typeof g && a.attr("y", g);
              a.x = h;
              a.y = g;
            };

            h.prototype.widthSetter = function (a) {
              this.widthSetting = D(a) ? a : void 0;
            };

            h.prototype.getPaddedWidth = function () {
              var a = this.padding,
                  g = A(this.paddingLeft, a);
              a = A(this.paddingRight, a);
              return (this.widthSetting || this.bBox.width || 0) + g + a;
            };

            h.prototype.xSetter = function (a) {
              this.x = a;
              this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
              this.xSetting = Math.round(a);
              this.attr("translateX", this.xSetting);
            };

            h.prototype.ySetter = function (a) {
              this.ySetting = this.y = Math.round(a);
              this.attr("translateY", this.ySetting);
            };

            h.emptyBBox = {
              width: 0,
              height: 0,
              x: 0,
              y: 0
            };
            h.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return h;
          }(c);
        });
        M(d, "Core/Renderer/SVG/Symbols.js", [d["Core/Utilities.js"]], function (c) {
          function d(c, d, k, h, a) {
            var g = [];

            if (a) {
              var y = a.start || 0,
                  n = K(a.r, k);
              k = K(a.r, h || k);
              var t = (a.end || 0) - .001;
              h = a.innerR;
              var O = K(a.open, .001 > Math.abs((a.end || 0) - y - 2 * Math.PI)),
                  m = Math.cos(y),
                  N = Math.sin(y),
                  L = Math.cos(t),
                  x = Math.sin(t);
              y = K(a.longArc, .001 > t - y - Math.PI ? 0 : 1);
              g.push(["M", c + n * m, d + k * N], ["A", n, k, 0, y, K(a.clockwise, 1), c + n * L, d + k * x]);
              C(h) && g.push(O ? ["M", c + h * L, d + h * x] : ["L", c + h * L, d + h * x], ["A", h, h, 0, y, C(a.clockwise) ? 1 - a.clockwise : 0, c + h * m, d + h * N]);
              O || g.push(["Z"]);
            }

            return g;
          }

          function E(c, d, k, h, a) {
            return a && a.r ? G(c, d, k, h, a) : [["M", c, d], ["L", c + k, d], ["L", c + k, d + h], ["L", c, d + h], ["Z"]];
          }

          function G(c, d, k, h, a) {
            a = a && a.r || 0;
            return [["M", c + a, d], ["L", c + k - a, d], ["C", c + k, d, c + k, d, c + k, d + a], ["L", c + k, d + h - a], ["C", c + k, d + h, c + k, d + h, c + k - a, d + h], ["L", c + a, d + h], ["C", c, d + h, c, d + h, c, d + h - a], ["L", c, d + a], ["C", c, d, c, d, c + a, d]];
          }

          var C = c.defined,
              D = c.isNumber,
              K = c.pick;
          return {
            arc: d,
            callout: function callout(c, d, k, h, a) {
              var g = Math.min(a && a.r || 0, k, h),
                  y = g + 6,
                  n = a && a.anchorX;
              a = a && a.anchorY || 0;
              var t = G(c, d, k, h, {
                r: g
              });
              if (!D(n)) return t;
              c + n >= k ? a > d + y && a < d + h - y ? t.splice(3, 1, ["L", c + k, a - 6], ["L", c + k + 6, a], ["L", c + k, a + 6], ["L", c + k, d + h - g]) : t.splice(3, 1, ["L", c + k, h / 2], ["L", n, a], ["L", c + k, h / 2], ["L", c + k, d + h - g]) : 0 >= c + n ? a > d + y && a < d + h - y ? t.splice(7, 1, ["L", c, a + 6], ["L", c - 6, a], ["L", c, a - 6], ["L", c, d + g]) : t.splice(7, 1, ["L", c, h / 2], ["L", n, a], ["L", c, h / 2], ["L", c, d + g]) : a && a > h && n > c + y && n < c + k - y ? t.splice(5, 1, ["L", n + 6, d + h], ["L", n, d + h + 6], ["L", n - 6, d + h], ["L", c + g, d + h]) : a && 0 > a && n > c + y && n < c + k - y && t.splice(1, 1, ["L", n - 6, d], ["L", n, d - 6], ["L", n + 6, d], ["L", k - g, d]);
              return t;
            },
            circle: function circle(c, r, k, h) {
              return d(c + k / 2, r + h / 2, k / 2, h / 2, {
                start: .5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1
              });
            },
            diamond: function diamond(c, d, k, h) {
              return [["M", c + k / 2, d], ["L", c + k, d + h / 2], ["L", c + k / 2, d + h], ["L", c, d + h / 2], ["Z"]];
            },
            rect: E,
            roundedRect: G,
            square: E,
            triangle: function triangle(c, d, k, h) {
              return [["M", c + k / 2, d], ["L", c + k, d + h], ["L", c, d + h], ["Z"]];
            },
            "triangle-down": function triangleDown(c, d, k, h) {
              return [["M", c, d], ["L", c + k, d], ["L", c + k / 2, d + h], ["Z"]];
            }
          };
        });
        M(d, "Core/Renderer/SVG/TextBuilder.js", [d["Core/Renderer/HTML/AST.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = d.doc,
              C = d.SVG_NS,
              D = E.attr,
              K = E.isString,
              A = E.objectEach,
              r = E.pick;
          return function () {
            function d(h) {
              var a = h.styles;
              this.renderer = h.renderer;
              this.svgElement = h;
              this.width = h.textWidth;
              this.textLineHeight = a && a.lineHeight;
              this.textOutline = a && a.textOutline;
              this.ellipsis = !(!a || "ellipsis" !== a.textOverflow);
              this.noWrap = !(!a || "nowrap" !== a.whiteSpace);
              this.fontSize = a && a.fontSize;
            }

            d.prototype.buildSVG = function () {
              var h = this.svgElement,
                  a = h.element,
                  g = h.renderer,
                  d = r(h.textStr, "").toString(),
                  n = -1 !== d.indexOf("<"),
                  t = a.childNodes;
              g = this.width && !h.added && g.box;
              var k = /<br.*?>/g,
                  m = [d, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();

              if (m !== h.textCache) {
                h.textCache = m;
                delete h.actualWidth;

                for (m = t.length; m--;) {
                  a.removeChild(t[m]);
                }

                n || this.ellipsis || this.width || -1 !== d.indexOf(" ") && (!this.noWrap || k.test(d)) ? "" !== d && (g && g.appendChild(a), d = new c(d), this.modifyTree(d.nodes), d.addToDOM(h.element), this.modifyDOM(), this.ellipsis && -1 !== (a.textContent || "").indexOf("\u2026") && h.attr("title", this.unescapeEntities(h.textStr || "", ["&lt;", "&gt;"])), g && g.removeChild(a)) : a.appendChild(B.createTextNode(this.unescapeEntities(d)));
                K(this.textOutline) && h.applyTextOutline && h.applyTextOutline(this.textOutline);
              }
            };

            d.prototype.modifyDOM = function () {
              var h = this,
                  a = this.svgElement,
                  g = D(a.element, "x");
              a.firstLineMetrics = void 0;

              for (var c; c = a.element.firstChild;) {
                if (/^[\s\u200B]*$/.test(c.textContent || " ")) a.element.removeChild(c);else break;
              }

              [].forEach.call(a.element.querySelectorAll("tspan.highcharts-br"), function (m, c) {
                m.nextSibling && m.previousSibling && (0 === c && 1 === m.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(void 0, m.previousSibling)), D(m, {
                  dy: h.getLineHeight(m.nextSibling),
                  x: g
                }));
              });
              var d = this.width || 0;

              if (d) {
                var t = function t(m, c) {
                  var n = m.textContent || "",
                      t = n.replace(/([^\^])-/g, "$1- ").split(" "),
                      k = !h.noWrap && (1 < t.length || 1 < a.element.childNodes.length),
                      H = h.getLineHeight(c),
                      w = 0,
                      f = a.actualWidth;
                  if (h.ellipsis) n && h.truncate(m, n, void 0, 0, Math.max(0, d - parseInt(h.fontSize || 12, 10)), function (b, f) {
                    return b.substring(0, f) + "\u2026";
                  });else if (k) {
                    n = [];

                    for (k = []; c.firstChild && c.firstChild !== m;) {
                      k.push(c.firstChild), c.removeChild(c.firstChild);
                    }

                    for (; t.length;) {
                      t.length && !h.noWrap && 0 < w && (n.push(m.textContent || ""), m.textContent = t.join(" ").replace(/- /g, "-")), h.truncate(m, void 0, t, 0 === w ? f || 0 : 0, d, function (b, f) {
                        return t.slice(0, f).join(" ").replace(/- /g, "-");
                      }), f = a.actualWidth, w++;
                    }

                    k.forEach(function (b) {
                      c.insertBefore(b, m);
                    });
                    n.forEach(function (b) {
                      c.insertBefore(B.createTextNode(b), m);
                      b = B.createElementNS(C, "tspan");
                      b.textContent = "\u200B";
                      D(b, {
                        dy: H,
                        x: g
                      });
                      c.insertBefore(b, m);
                    });
                  }
                },
                    k = function k(g) {
                  [].slice.call(g.childNodes).forEach(function (m) {
                    m.nodeType === Node.TEXT_NODE ? t(m, g) : (-1 !== m.className.baseVal.indexOf("highcharts-br") && (a.actualWidth = 0), k(m));
                  });
                };

                k(a.element);
              }
            };

            d.prototype.getLineHeight = function (h) {
              var a;
              h = h.nodeType === Node.TEXT_NODE ? h.parentElement : h;
              this.renderer.styledMode || (a = h && /(px|em)$/.test(h.style.fontSize) ? h.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
              return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a, h || this.svgElement.element).h;
            };

            d.prototype.modifyTree = function (h) {
              var a = this,
                  g = function g(c, d) {
                var t = c.tagName,
                    n = a.renderer.styledMode,
                    m = c.attributes || {};
                if ("b" === t || "strong" === t) n ? m["class"] = "highcharts-strong" : m.style = "font-weight:bold;" + (m.style || "");else if ("i" === t || "em" === t) n ? m["class"] = "highcharts-emphasized" : m.style = "font-style:italic;" + (m.style || "");
                K(m.style) && (m.style = m.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
                "br" === t && (m["class"] = "highcharts-br", c.textContent = "\u200B", (d = h[d + 1]) && d.textContent && (d.textContent = d.textContent.replace(/^ +/gm, "")));
                "#text" !== t && "a" !== t && (c.tagName = "tspan");
                c.attributes = m;
                c.children && c.children.filter(function (a) {
                  return "#text" !== a.tagName;
                }).forEach(g);
              };

              h.forEach(g);
            };

            d.prototype.truncate = function (h, a, g, c, d, t) {
              var n = this.svgElement,
                  m = n.renderer,
                  k = n.rotation,
                  y = [],
                  x = g ? 1 : 0,
                  r = (a || g || "").length,
                  H = r,
                  w,
                  f = function f(b, _f) {
                _f = _f || b;
                var e = h.parentNode;
                if (e && "undefined" === typeof y[_f]) if (e.getSubStringLength) try {
                  y[_f] = c + e.getSubStringLength(0, g ? _f + 1 : _f);
                } catch (q) {
                  "";
                } else m.getSpanWidth && (h.textContent = t(a || g, b), y[_f] = c + m.getSpanWidth(n, h));
                return y[_f];
              };

              n.rotation = 0;
              var b = f(h.textContent.length);

              if (c + b > d) {
                for (; x <= r;) {
                  H = Math.ceil((x + r) / 2), g && (w = t(g, H)), b = f(H, w && w.length - 1), x === r ? x = r + 1 : b > d ? r = H - 1 : x = H;
                }

                0 === r ? h.textContent = "" : a && r === a.length - 1 || (h.textContent = w || t(a || g, H));
              }

              g && g.splice(0, H);
              n.actualWidth = b;
              n.rotation = k;
            };

            d.prototype.unescapeEntities = function (c, a) {
              A(this.renderer.escapes, function (g, h) {
                a && -1 !== a.indexOf(g) || (c = c.toString().replace(new RegExp(g, "g"), h));
              });
              return c;
            };

            return d;
          }();
        });
        M(d, "Core/Renderer/SVG/SVGRenderer.js", [d["Core/Renderer/HTML/AST.js"], d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Color/Palette.js"], d["Core/Renderer/RendererRegistry.js"], d["Core/Renderer/SVG/SVGElement.js"], d["Core/Renderer/SVG/SVGLabel.js"], d["Core/Renderer/SVG/Symbols.js"], d["Core/Renderer/SVG/TextBuilder.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A, r, k) {
          var h = E.charts,
              a = E.deg2rad,
              g = E.doc,
              y = E.isFirefox,
              n = E.isMS,
              t = E.isWebKit,
              O = E.noop,
              m = E.SVG_NS,
              N = E.symbolSizes,
              L = E.win,
              x = k.addEvent,
              R = k.attr,
              H = k.createElement,
              w = k.css,
              f = k.defined,
              b = k.destroyObjectProperties,
              v = k.extend,
              F = k.isArray,
              e = k.isNumber,
              q = k.isObject,
              l = k.isString,
              I = k.merge,
              p = k.pick,
              z = k.pInt,
              P = k.uniqueKey,
              T;

          E = function () {
            function J(b, e, l, f, q, p, a) {
              this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
              this.init(b, e, l, f, q, p, a);
            }

            J.prototype.init = function (b, e, l, f, q, p, a) {
              var u = this.createElement("svg").attr({
                version: "1.1",
                "class": "highcharts-root"
              }),
                  v = u.element;
              a || u.css(this.getStyle(f));
              b.appendChild(v);
              R(b, "dir", "ltr");
              -1 === b.innerHTML.indexOf("xmlns") && R(v, "xmlns", this.SVG_NS);
              this.isSVG = !0;
              this.box = v;
              this.boxWrapper = u;
              this.alignedObjects = [];
              this.url = this.getReferenceURL();
              this.createElement("desc").add().element.appendChild(g.createTextNode("Created with Highcharts 9.2.2"));
              this.defs = this.createElement("defs").add();
              this.allowHTML = p;
              this.forExport = q;
              this.styledMode = a;
              this.gradients = {};
              this.cache = {};
              this.cacheKeys = [];
              this.imgCount = 0;
              this.setSize(e, l, !1);
              var J;
              y && b.getBoundingClientRect && (e = function e() {
                w(b, {
                  left: 0,
                  top: 0
                });
                J = b.getBoundingClientRect();
                w(b, {
                  left: Math.ceil(J.left) - J.left + "px",
                  top: Math.ceil(J.top) - J.top + "px"
                });
              }, e(), this.unSubPixelFix = x(L, "resize", e));
            };

            J.prototype.definition = function (b) {
              return new c([b]).addToDOM(this.defs.element);
            };

            J.prototype.getReferenceURL = function () {
              if ((y || t) && g.getElementsByTagName("base").length) {
                if (!f(T)) {
                  var b = P();
                  b = new c([{
                    tagName: "svg",
                    attributes: {
                      width: 8,
                      height: 8
                    },
                    children: [{
                      tagName: "defs",
                      children: [{
                        tagName: "clipPath",
                        attributes: {
                          id: b
                        },
                        children: [{
                          tagName: "rect",
                          attributes: {
                            width: 4,
                            height: 4
                          }
                        }]
                      }]
                    }, {
                      tagName: "rect",
                      attributes: {
                        id: "hitme",
                        width: 8,
                        height: 8,
                        "clip-path": "url(#" + b + ")",
                        fill: "rgba(0,0,0,0.001)"
                      }
                    }]
                  }]).addToDOM(g.body);
                  w(b, {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    zIndex: 9E5
                  });
                  var e = g.elementFromPoint(6, 6);
                  T = "hitme" === (e && e.id);
                  g.body.removeChild(b);
                }

                if (T) return L.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
              }

              return "";
            };

            J.prototype.getStyle = function (b) {
              return this.style = v({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
              }, b);
            };

            J.prototype.setStyle = function (b) {
              this.boxWrapper.css(this.getStyle(b));
            };

            J.prototype.isHidden = function () {
              return !this.boxWrapper.getBBox().width;
            };

            J.prototype.destroy = function () {
              var e = this.defs;
              this.box = null;
              this.boxWrapper = this.boxWrapper.destroy();
              b(this.gradients || {});
              this.gradients = null;
              e && (this.defs = e.destroy());
              this.unSubPixelFix && this.unSubPixelFix();
              return this.alignedObjects = null;
            };

            J.prototype.createElement = function (b) {
              var e = new this.Element();
              e.init(this, b);
              return e;
            };

            J.prototype.getRadialAttr = function (b, e) {
              return {
                cx: b[0] - b[2] / 2 + (e.cx || 0) * b[2],
                cy: b[1] - b[2] / 2 + (e.cy || 0) * b[2],
                r: (e.r || 0) * b[2]
              };
            };

            J.prototype.buildText = function (b) {
              new r(b).buildSVG();
            };

            J.prototype.getContrast = function (b) {
              b = d.parse(b).rgba;
              b[0] *= 1;
              b[1] *= 1.2;
              b[2] *= .5;
              return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
            };

            J.prototype.button = function (b, e, l, f, q, p, a, J, g, z) {
              var u = this.label(b, e, l, g, void 0, void 0, z, void 0, "button"),
                  F = this.styledMode,
                  m = 0,
                  w = q ? I(q) : {};
              b = w && w.style || {};
              w = c.filterUserAttributes(w);
              u.attr(I({
                padding: 8,
                r: 2
              }, w));

              if (!F) {
                w = I({
                  fill: G.neutralColor3,
                  stroke: G.neutralColor20,
                  "stroke-width": 1,
                  style: {
                    color: G.neutralColor80,
                    cursor: "pointer",
                    fontWeight: "normal"
                  }
                }, {
                  style: b
                }, w);
                var Q = w.style;
                delete w.style;
                p = I(w, {
                  fill: G.neutralColor10
                }, c.filterUserAttributes(p || {}));
                var h = p.style;
                delete p.style;
                a = I(w, {
                  fill: G.highlightColor10,
                  style: {
                    color: G.neutralColor100,
                    fontWeight: "bold"
                  }
                }, c.filterUserAttributes(a || {}));
                var d = a.style;
                delete a.style;
                J = I(w, {
                  style: {
                    color: G.neutralColor20
                  }
                }, c.filterUserAttributes(J || {}));
                var t = J.style;
                delete J.style;
              }

              x(u.element, n ? "mouseover" : "mouseenter", function () {
                3 !== m && u.setState(1);
              });
              x(u.element, n ? "mouseout" : "mouseleave", function () {
                3 !== m && u.setState(m);
              });

              u.setState = function (b) {
                1 !== b && (u.state = m = b);
                u.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
                F || u.attr([w, p, a, J][b || 0]).css([Q, h, d, t][b || 0]);
              };

              F || u.attr(w).css(v({
                cursor: "default"
              }, Q));
              return u.on("touchstart", function (b) {
                return b.stopPropagation();
              }).on("click", function (b) {
                3 !== m && f.call(u, b);
              });
            };

            J.prototype.crispLine = function (b, e, l) {
              void 0 === l && (l = "round");
              var u = b[0],
                  p = b[1];
              f(u[1]) && u[1] === p[1] && (u[1] = p[1] = Math[l](u[1]) - e % 2 / 2);
              f(u[2]) && u[2] === p[2] && (u[2] = p[2] = Math[l](u[2]) + e % 2 / 2);
              return b;
            };

            J.prototype.path = function (b) {
              var e = this.styledMode ? {} : {
                fill: "none"
              };
              F(b) ? e.d = b : q(b) && v(e, b);
              return this.createElement("path").attr(e);
            };

            J.prototype.circle = function (b, e, l) {
              b = q(b) ? b : "undefined" === typeof b ? {} : {
                x: b,
                y: e,
                r: l
              };
              e = this.createElement("circle");

              e.xSetter = e.ySetter = function (b, e, l) {
                l.setAttribute("c" + e, b);
              };

              return e.attr(b);
            };

            J.prototype.arc = function (b, e, l, f, p, a) {
              q(b) ? (f = b, e = f.y, l = f.r, b = f.x) : f = {
                innerR: f,
                start: p,
                end: a
              };
              b = this.symbol("arc", b, e, l, l, f);
              b.r = l;
              return b;
            };

            J.prototype.rect = function (b, e, l, f, p, a) {
              p = q(b) ? b.r : p;
              var u = this.createElement("rect");
              b = q(b) ? b : "undefined" === typeof b ? {} : {
                x: b,
                y: e,
                width: Math.max(l, 0),
                height: Math.max(f, 0)
              };
              this.styledMode || ("undefined" !== typeof a && (b["stroke-width"] = a, b = u.crisp(b)), b.fill = "none");
              p && (b.r = p);

              u.rSetter = function (b, e, l) {
                u.r = b;
                R(l, {
                  rx: b,
                  ry: b
                });
              };

              u.rGetter = function () {
                return u.r || 0;
              };

              return u.attr(b);
            };

            J.prototype.setSize = function (b, e, l) {
              this.width = b;
              this.height = e;
              this.boxWrapper.animate({
                width: b,
                height: e
              }, {
                step: function step() {
                  this.attr({
                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                  });
                },
                duration: p(l, !0) ? void 0 : 0
              });
              this.alignElements();
            };

            J.prototype.g = function (b) {
              var e = this.createElement("g");
              return b ? e.attr({
                "class": "highcharts-" + b
              }) : e;
            };

            J.prototype.image = function (b, e, l, f, p, q) {
              var u = {
                preserveAspectRatio: "none"
              },
                  a = function a(b, e) {
                b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", e) : b.setAttribute("hc-svg-href", e);
              };

              1 < arguments.length && v(u, {
                x: e,
                y: l,
                width: f,
                height: p
              });
              var J = this.createElement("image").attr(u);

              u = function u(e) {
                a(J.element, b);
                q.call(J, e);
              };

              if (q) {
                a(J.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
                var g = new L.Image();
                x(g, "load", u);
                g.src = b;
                g.complete && u({});
              } else a(J.element, b);

              return J;
            };

            J.prototype.symbol = function (b, e, l, q, a, J) {
              var u = this,
                  z = /^url\((.*?)\)$/,
                  m = z.test(b),
                  F = !m && (this.symbols[b] ? b : "circle"),
                  Q = F && this.symbols[F],
                  c;

              if (Q) {
                "number" === typeof e && (c = Q.call(this.symbols, Math.round(e || 0), Math.round(l || 0), q || 0, a || 0, J));
                var I = this.path(c);
                u.styledMode || I.attr("fill", "none");
                v(I, {
                  symbolName: F || void 0,
                  x: e,
                  y: l,
                  width: q,
                  height: a
                });
                J && v(I, J);
              } else if (m) {
                var d = b.match(z)[1];
                var n = I = this.image(d);
                n.imgwidth = p(N[d] && N[d].width, J && J.width);
                n.imgheight = p(N[d] && N[d].height, J && J.height);

                var t = function t(b) {
                  return b.attr({
                    width: b.width,
                    height: b.height
                  });
                };

                ["width", "height"].forEach(function (b) {
                  n[b + "Setter"] = function (b, e) {
                    var l = this["img" + e];
                    this[e] = b;
                    f(l) && (J && "within" === J.backgroundSize && this.width && this.height && (l = Math.round(l * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(e, l), this.alignByTranslate || (b = ((this[e] || 0) - l) / 2, this.attr("width" === e ? {
                      translateX: b
                    } : {
                      translateY: b
                    })));
                  };
                });
                f(e) && n.attr({
                  x: e,
                  y: l
                });
                n.isImg = !0;
                f(n.imgwidth) && f(n.imgheight) ? t(n) : (n.attr({
                  width: 0,
                  height: 0
                }), H("img", {
                  onload: function onload() {
                    var b = h[u.chartIndex];
                    0 === this.width && (w(this, {
                      position: "absolute",
                      top: "-999em"
                    }), g.body.appendChild(this));
                    N[d] = {
                      width: this.width,
                      height: this.height
                    };
                    n.imgwidth = this.width;
                    n.imgheight = this.height;
                    n.element && t(n);
                    this.parentNode && this.parentNode.removeChild(this);
                    u.imgCount--;
                    if (!u.imgCount && b && !b.hasLoaded) b.onload();
                  },
                  src: d
                }), this.imgCount++);
              }

              return I;
            };

            J.prototype.clipRect = function (b, e, l, f) {
              var u = P() + "-",
                  p = this.createElement("clipPath").attr({
                id: u
              }).add(this.defs);
              b = this.rect(b, e, l, f, 0).add(p);
              b.id = u;
              b.clipPath = p;
              b.count = 0;
              return b;
            };

            J.prototype.text = function (b, e, l, p) {
              var u = {};
              if (p && (this.allowHTML || !this.forExport)) return this.html(b, e, l);
              u.x = Math.round(e || 0);
              l && (u.y = Math.round(l));
              f(b) && (u.text = b);
              b = this.createElement("text").attr(u);
              if (!p || this.forExport && !this.allowHTML) b.xSetter = function (b, e, l) {
                for (var f = l.getElementsByTagName("tspan"), u = l.getAttribute(e), p = 0, q; p < f.length; p++) {
                  q = f[p], q.getAttribute(e) === u && q.setAttribute(e, b);
                }

                l.setAttribute(e, b);
              };
              return b;
            };

            J.prototype.fontMetrics = function (b, e) {
              b = !this.styledMode && /px/.test(b) || !L.getComputedStyle ? b || e && e.style && e.style.fontSize || this.style && this.style.fontSize : e && D.prototype.getStyle.call(e, "font-size");
              b = /px/.test(b) ? z(b) : 12;
              e = 24 > b ? b + 3 : Math.round(1.2 * b);
              return {
                h: e,
                b: Math.round(.8 * e),
                f: b
              };
            };

            J.prototype.rotCorr = function (b, e, l) {
              var f = b;
              e && l && (f = Math.max(f * Math.cos(e * a), 4));
              return {
                x: -b / 3 * Math.sin(e * a),
                y: f
              };
            };

            J.prototype.pathToSegments = function (b) {
              for (var f = [], u = [], p = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
              }, q = 0; q < b.length; q++) {
                l(u[0]) && e(b[q]) && u.length === p[u[0].toUpperCase()] && b.splice(q, 0, u[0].replace("M", "L").replace("m", "l")), "string" === typeof b[q] && (u.length && f.push(u.slice(0)), u.length = 0), u.push(b[q]);
              }

              f.push(u.slice(0));
              return f;
            };

            J.prototype.label = function (b, e, l, f, p, q, a, J, v) {
              return new K(this, b, e, l, f, p, q, a, J, v);
            };

            J.prototype.alignElements = function () {
              this.alignedObjects.forEach(function (b) {
                return b.align();
              });
            };

            return J;
          }();

          v(E.prototype, {
            Element: D,
            SVG_NS: m,
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            symbols: A,
            draw: O
          });
          C.registerRendererType("svg", E, !0);
          "";
          return E;
        });
        M(d, "Core/Renderer/HTML/HTMLElement.js", [d["Core/Globals.js"], d["Core/Renderer/SVG/SVGElement.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = this && this.__extends || function () {
            var _a = function a(g, c) {
              _a = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, g) {
                a.__proto__ = g;
              } || function (a, g) {
                for (var m in g) {
                  g.hasOwnProperty(m) && (a[m] = g[m]);
                }
              };

              return _a(g, c);
            };

            return function (g, c) {
              function h() {
                this.constructor = g;
              }

              _a(g, c);

              g.prototype = null === c ? Object.create(c) : (h.prototype = c.prototype, new h());
            };
          }(),
              C = c.isFirefox,
              D = c.isMS,
              K = c.isWebKit,
              A = c.win,
              r = E.css,
              k = E.defined,
              h = E.extend,
              a = E.pick,
              g = E.pInt;

          return function (c) {
            function d() {
              return null !== c && c.apply(this, arguments) || this;
            }

            B(d, c);

            d.compose = function (a) {
              if (-1 === d.composedClasses.indexOf(a)) {
                d.composedClasses.push(a);
                var g = d.prototype,
                    m = a.prototype;
                m.getSpanCorrection = g.getSpanCorrection;
                m.htmlCss = g.htmlCss;
                m.htmlGetBBox = g.htmlGetBBox;
                m.htmlUpdateTransform = g.htmlUpdateTransform;
                m.setSpanRotation = g.setSpanRotation;
              }

              return a;
            };

            d.prototype.getSpanCorrection = function (a, g, m) {
              this.xCorr = -a * m;
              this.yCorr = -g;
            };

            d.prototype.htmlCss = function (g) {
              var c = "SPAN" === this.element.tagName && g && "width" in g,
                  m = a(c && g.width, void 0);

              if (c) {
                delete g.width;
                this.textWidth = m;
                var d = !0;
              }

              g && "ellipsis" === g.textOverflow && (g.whiteSpace = "nowrap", g.overflow = "hidden");
              this.styles = h(this.styles, g);
              r(this.element, g);
              d && this.htmlUpdateTransform();
              return this;
            };

            d.prototype.htmlGetBBox = function () {
              var a = this.element;
              return {
                x: a.offsetLeft,
                y: a.offsetTop,
                width: a.offsetWidth,
                height: a.offsetHeight
              };
            };

            d.prototype.htmlUpdateTransform = function () {
              if (this.added) {
                var a = this.renderer,
                    c = this.element,
                    m = this.translateX || 0,
                    h = this.translateY || 0,
                    d = this.x || 0,
                    n = this.y || 0,
                    y = this.textAlign || "left",
                    H = {
                  left: 0,
                  center: .5,
                  right: 1
                }[y],
                    w = this.styles;
                w = w && w.whiteSpace;
                r(c, {
                  marginLeft: m,
                  marginTop: h
                });
                !a.styledMode && this.shadows && this.shadows.forEach(function (b) {
                  r(b, {
                    marginLeft: m + 1,
                    marginTop: h + 1
                  });
                });
                this.inverted && [].forEach.call(c.childNodes, function (b) {
                  a.invertChild(b, c);
                });

                if ("SPAN" === c.tagName) {
                  var f = this.rotation,
                      b = this.textWidth && g(this.textWidth),
                      v = [f, y, c.innerHTML, this.textWidth, this.textAlign].join(),
                      F = void 0;
                  (F = b !== this.oldTextWidth) && !(F = b > this.oldTextWidth) && ((F = this.textPxLength) || (r(c, {
                    width: "",
                    whiteSpace: w || "nowrap"
                  }), F = c.offsetWidth), F = F > b);
                  F && (/[ \-]/.test(c.textContent || c.innerText) || "ellipsis" === c.style.textOverflow) ? (r(c, {
                    width: b + "px",
                    display: "block",
                    whiteSpace: w || "normal"
                  }), this.oldTextWidth = b, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
                  v !== this.cTT && (F = a.fontMetrics(c.style.fontSize, c).b, !k(f) || f === (this.oldRotation || 0) && y === this.oldAlign || this.setSpanRotation(f, H, F), this.getSpanCorrection(!k(f) && this.textPxLength || c.offsetWidth, F, H, f, y));
                  r(c, {
                    left: d + (this.xCorr || 0) + "px",
                    top: n + (this.yCorr || 0) + "px"
                  });
                  this.cTT = v;
                  this.oldRotation = f;
                  this.oldAlign = y;
                }
              } else this.alignOnAdd = !0;
            };

            d.prototype.setSpanRotation = function (a, g, m) {
              var c = {},
                  h = D && !/Edge/.test(A.navigator.userAgent) ? "-ms-transform" : K ? "-webkit-transform" : C ? "MozTransform" : A.opera ? "-o-transform" : void 0;
              h && (c[h] = c.transform = "rotate(" + a + "deg)", c[h + (C ? "Origin" : "-origin")] = c.transformOrigin = 100 * g + "% " + m + "px", r(this.element, c));
            };

            d.composedClasses = [];
            return d;
          }(d);
        });
        M(d, "Core/Renderer/HTML/HTMLRenderer.js", [d["Core/Renderer/HTML/AST.js"], d["Core/Renderer/SVG/SVGElement.js"], d["Core/Renderer/SVG/SVGRenderer.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var B = this && this.__extends || function () {
            var _c = function c(h, a) {
              _c = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var g in c) {
                  c.hasOwnProperty(g) && (a[g] = c[g]);
                }
              };

              return _c(h, a);
            };

            return function (h, a) {
              function g() {
                this.constructor = h;
              }

              _c(h, a);

              h.prototype = null === a ? Object.create(a) : (g.prototype = a.prototype, new g());
            };
          }(),
              D = G.attr,
              K = G.createElement,
              A = G.extend,
              r = G.pick;

          return function (k) {
            function h() {
              return null !== k && k.apply(this, arguments) || this;
            }

            B(h, k);

            h.compose = function (a) {
              -1 === h.composedClasses.indexOf(a) && (h.composedClasses.push(a), a.prototype.html = h.prototype.html);
              return a;
            };

            h.prototype.html = function (a, g, h) {
              var n = this.createElement("span"),
                  k = n.element,
                  y = n.renderer,
                  m = y.isSVG,
                  N = function N(a, g) {
                ["opacity", "visibility"].forEach(function (c) {
                  a[c + "Setter"] = function (m, w, f) {
                    var b = a.div ? a.div.style : g;
                    d.prototype[c + "Setter"].call(this, m, w, f);
                    b && (b[w] = m);
                  };
                });
                a.addedSetters = !0;
              };

              n.textSetter = function (a) {
                a !== this.textStr && (delete this.bBox, delete this.oldTextWidth, c.setElementHTML(this.element, r(a, "")), this.textStr = a, n.doTransform = !0);
              };

              m && N(n, n.element.style);

              n.xSetter = n.ySetter = n.alignSetter = n.rotationSetter = function (a, g) {
                "align" === g ? n.alignValue = n.textAlign = a : n[g] = a;
                n.doTransform = !0;
              };

              n.afterSetters = function () {
                this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
              };

              n.attr({
                text: a,
                x: Math.round(g),
                y: Math.round(h)
              }).css({
                position: "absolute"
              });
              y.styledMode || n.css({
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
              });
              k.style.whiteSpace = "nowrap";
              n.css = n.htmlCss;
              m && (n.add = function (a) {
                var g = y.box.parentNode,
                    c = [];

                if (this.parentGroup = a) {
                  var m = a.div;

                  if (!m) {
                    for (; a;) {
                      c.push(a), a = a.parentGroup;
                    }

                    c.reverse().forEach(function (a) {
                      function f(b, f) {
                        a[f] = b;
                        "translateX" === f ? F.left = b + "px" : F.top = b + "px";
                        a.doTransform = !0;
                      }

                      var b = D(a.element, "class"),
                          v = a.styles || {};
                      m = a.div = a.div || K("div", b ? {
                        className: b
                      } : void 0, {
                        position: "absolute",
                        left: (a.translateX || 0) + "px",
                        top: (a.translateY || 0) + "px",
                        display: a.display,
                        opacity: a.opacity,
                        cursor: v.cursor,
                        pointerEvents: v.pointerEvents,
                        visibility: a.visibility
                      }, m || g);
                      var F = m.style;
                      A(a, {
                        classSetter: function (b) {
                          return function (e) {
                            this.element.setAttribute("class", e);
                            b.className = e;
                          };
                        }(m),
                        on: function on() {
                          c[0].div && n.on.apply({
                            element: c[0].div,
                            onEvents: a.onEvents
                          }, arguments);
                          return a;
                        },
                        translateXSetter: f,
                        translateYSetter: f
                      });
                      a.addedSetters || N(a);
                    });
                  }
                } else m = g;

                m.appendChild(k);
                n.added = !0;
                n.alignOnAdd && n.htmlUpdateTransform();
                return n;
              });
              return n;
            };

            h.composedClasses = [];
            return h;
          }(E);
        });
        M(d, "Core/Axis/AxisDefaults.js", [d["Core/Color/Palette.js"]], function (c) {
          var d;

          (function (d) {
            d.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: !1
                },
                second: {
                  main: "%H:%M:%S",
                  range: !1
                },
                minute: {
                  main: "%H:%M",
                  range: !1
                },
                hour: {
                  main: "%H:%M",
                  range: !1
                },
                day: {
                  main: "%e. %b"
                },
                week: {
                  main: "%e. %b"
                },
                month: {
                  main: "%b '%y"
                },
                year: {
                  main: "%Y"
                }
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: void 0,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                x: 0,
                zIndex: 7,
                style: {
                  color: c.neutralColor60,
                  cursor: "default",
                  fontSize: "11px"
                }
              },
              maxPadding: .01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minPadding: .01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                  color: c.neutralColor60
                }
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: c.neutralColor5,
              minorGridLineWidth: 1,
              minorTickColor: c.neutralColor40,
              lineColor: c.highlightColor20,
              lineWidth: 1,
              gridLineColor: c.neutralColor10,
              gridLineWidth: void 0,
              tickColor: c.highlightColor20
            };
            d.defaultYAxisOptions = {
              reversedStacks: !0,
              endOnTick: !0,
              maxPadding: .05,
              minPadding: .05,
              tickPixelInterval: 72,
              showLastLabel: !0,
              labels: {
                x: -8
              },
              startOnTick: !0,
              title: {
                rotation: 270,
                text: "Values"
              },
              stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function formatter() {
                  var c = this.axis.chart.numberFormatter;
                  return c(this.total, -1);
                },
                style: {
                  color: c.neutralColor100,
                  fontSize: "11px",
                  fontWeight: "bold",
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
            };
            d.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            d.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            d.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            d.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(d || (d = {}));

          return d;
        });
        M(d, "Core/Foundation.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.addEvent,
              E = c.isFunction,
              G = c.objectEach,
              C = c.removeEvent;
          return {
            registerEventOptions: function registerEventOptions(c, B) {
              c.eventOptions = c.eventOptions || {};
              G(B.events, function (A, r) {
                c.eventOptions[r] !== A && (c.eventOptions[r] && (C(c, r, c.eventOptions[r]), delete c.eventOptions[r]), E(A) && (c.eventOptions[r] = A, d(c, r, A)));
              });
            }
          };
        });
        M(d, "Core/Axis/Tick.js", [d["Core/FormatUtilities.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = d.deg2rad,
              C = E.clamp,
              D = E.correctFloat,
              K = E.defined,
              A = E.destroyObjectProperties,
              r = E.extend,
              k = E.fireEvent,
              h = E.isNumber,
              a = E.merge,
              g = E.objectEach,
              y = E.pick;

          d = function () {
            function d(a, g, c, d, h) {
              this.isNewLabel = this.isNew = !0;
              this.axis = a;
              this.pos = g;
              this.type = c || "";
              this.parameters = h || {};
              this.tickmarkOffset = this.parameters.tickmarkOffset;
              this.options = this.parameters.options;
              k(this, "init");
              c || d || this.addLabel();
            }

            d.prototype.addLabel = function () {
              var a = this,
                  g = a.axis,
                  m = g.options,
                  d = g.chart,
                  n = g.categories,
                  x = g.logarithmic,
                  R = g.names,
                  H = a.pos,
                  w = y(a.options && a.options.labels, m.labels),
                  f = g.tickPositions,
                  b = H === f[0],
                  v = H === f[f.length - 1],
                  F = (!w.step || 1 === w.step) && 1 === g.tickInterval;
              f = f.info;
              var e = a.label,
                  q;
              n = this.parameters.category || (n ? y(n[H], R[H], H) : H);
              x && h(n) && (n = D(x.lin2log(n)));
              if (g.dateTime) if (f) {
                var l = d.time.resolveDTLFormat(m.dateTimeLabelFormats[!m.grid && f.higherRanks[H] || f.unitName]);
                var I = l.main;
              } else h(n) && (I = g.dateTime.getXDateFormat(n, m.dateTimeLabelFormats || {}));
              a.isFirst = b;
              a.isLast = v;
              var p = {
                axis: g,
                chart: d,
                dateTimeLabelFormat: I,
                isFirst: b,
                isLast: v,
                pos: H,
                tick: a,
                tickPositionInfo: f,
                value: n
              };
              k(this, "labelFormat", p);

              var z = function z(b) {
                return w.formatter ? w.formatter.call(b, b) : w.format ? (b.text = g.defaultLabelFormatter.call(b), c.format(w.format, b, d)) : g.defaultLabelFormatter.call(b, b);
              };

              m = z.call(p, p);
              var P = l && l.list;
              a.shortenLabel = P ? function () {
                for (q = 0; q < P.length; q++) {
                  if (r(p, {
                    dateTimeLabelFormat: P[q]
                  }), e.attr({
                    text: z.call(p, p)
                  }), e.getBBox().width < g.getSlotWidth(a) - 2 * w.padding) return;
                }

                e.attr({
                  text: ""
                });
              } : void 0;
              F && g._addedPlotLB && a.moveLabel(m, w);
              K(e) || a.movedLabel ? e && e.textStr !== m && !F && (!e.textWidth || w.style.width || e.styles.width || e.css({
                width: null
              }), e.attr({
                text: m
              }), e.textPxLength = e.getBBox().width) : (a.label = e = a.createLabel({
                x: 0,
                y: 0
              }, m, w), a.rotation = 0);
            };

            d.prototype.createLabel = function (g, c, m) {
              var d = this.axis,
                  h = d.chart;
              if (g = K(c) && m.enabled ? h.renderer.text(c, g.x, g.y, m.useHTML).add(d.labelGroup) : null) h.styledMode || g.css(a(m.style)), g.textPxLength = g.getBBox().width;
              return g;
            };

            d.prototype.destroy = function () {
              A(this, this.axis);
            };

            d.prototype.getPosition = function (a, g, c, d) {
              var m = this.axis,
                  h = m.chart,
                  n = d && h.oldChartHeight || h.chartHeight;
              a = {
                x: a ? D(m.translate(g + c, null, null, d) + m.transB) : m.left + m.offset + (m.opposite ? (d && h.oldChartWidth || h.chartWidth) - m.right - m.left : 0),
                y: a ? n - m.bottom + m.offset - (m.opposite ? m.height : 0) : D(n - m.translate(g + c, null, null, d) - m.transB)
              };
              a.y = C(a.y, -1E5, 1E5);
              k(this, "afterGetPosition", {
                pos: a
              });
              return a;
            };

            d.prototype.getLabelPosition = function (a, g, c, d, h, n, y, H) {
              var m = this.axis,
                  f = m.transA,
                  b = m.isLinked && m.linkedParent ? m.linkedParent.reversed : m.reversed,
                  v = m.staggerLines,
                  F = m.tickRotCorr || {
                x: 0,
                y: 0
              },
                  e = d || m.reserveSpaceDefault ? 0 : -m.labelOffset * ("center" === m.labelAlign ? .5 : 1),
                  q = {},
                  l = h.y;
              K(l) || (l = 0 === m.side ? c.rotation ? -8 : -c.getBBox().height : 2 === m.side ? F.y + 8 : Math.cos(c.rotation * B) * (F.y - c.getBBox(!1, 0).height / 2));
              a = a + h.x + e + F.x - (n && d ? n * f * (b ? -1 : 1) : 0);
              g = g + l - (n && !d ? n * f * (b ? 1 : -1) : 0);
              v && (c = y / (H || 1) % v, m.opposite && (c = v - c - 1), g += m.labelOffset / v * c);
              q.x = a;
              q.y = Math.round(g);
              k(this, "afterGetLabelPosition", {
                pos: q,
                tickmarkOffset: n,
                index: y
              });
              return q;
            };

            d.prototype.getLabelSize = function () {
              return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };

            d.prototype.getMarkPath = function (a, g, c, d, h, n) {
              return n.crispLine([["M", a, g], ["L", a + (h ? 0 : -c), g + (h ? c : 0)]], d);
            };

            d.prototype.handleOverflow = function (a) {
              var g = this.axis,
                  c = g.options.labels,
                  d = a.x,
                  h = g.chart.chartWidth,
                  n = g.chart.spacing,
                  k = y(g.labelLeft, Math.min(g.pos, n[3]));
              n = y(g.labelRight, Math.max(g.isRadial ? 0 : g.pos + g.len, h - n[1]));
              var H = this.label,
                  w = this.rotation,
                  f = {
                left: 0,
                center: .5,
                right: 1
              }[g.labelAlign || H.attr("align")],
                  b = H.getBBox().width,
                  v = g.getSlotWidth(this),
                  F = {},
                  e = v,
                  q = 1,
                  l;
              if (w || "justify" !== c.overflow) 0 > w && d - f * b < k ? l = Math.round(d / Math.cos(w * B) - k) : 0 < w && d + f * b > n && (l = Math.round((h - d) / Math.cos(w * B)));else if (h = d + (1 - f) * b, d - f * b < k ? e = a.x + e * (1 - f) - k : h > n && (e = n - a.x + e * f, q = -1), e = Math.min(v, e), e < v && "center" === g.labelAlign && (a.x += q * (v - e - f * (v - Math.min(b, e)))), b > e || g.autoRotation && (H.styles || {}).width) l = e;
              l && (this.shortenLabel ? this.shortenLabel() : (F.width = Math.floor(l) + "px", (c.style || {}).textOverflow || (F.textOverflow = "ellipsis"), H.css(F)));
            };

            d.prototype.moveLabel = function (a, c) {
              var m = this,
                  d = m.label,
                  h = m.axis,
                  n = h.reversed,
                  k = !1;
              d && d.textStr === a ? (m.movedLabel = d, k = !0, delete m.label) : g(h.ticks, function (g) {
                k || g.isNew || g === m || !g.label || g.label.textStr !== a || (m.movedLabel = g.label, k = !0, g.labelPos = m.movedLabel.xy, delete g.label);
              });

              if (!k && (m.labelPos || d)) {
                var H = m.labelPos || d.xy;
                d = h.horiz ? n ? 0 : h.width + h.left : H.x;
                h = h.horiz ? H.y : n ? h.width + h.left : 0;
                m.movedLabel = m.createLabel({
                  x: d,
                  y: h
                }, a, c);
                m.movedLabel && m.movedLabel.attr({
                  opacity: 0
                });
              }
            };

            d.prototype.render = function (a, g, c) {
              var d = this.axis,
                  m = d.horiz,
                  h = this.pos,
                  n = y(this.tickmarkOffset, d.tickmarkOffset);
              h = this.getPosition(m, h, n, g);
              n = h.x;
              var H = h.y;
              d = m && n === d.pos + d.len || !m && H === d.pos ? -1 : 1;
              m = y(c, this.label && this.label.newOpacity, 1);
              c = y(c, 1);
              this.isActive = !0;
              this.renderGridLine(g, c, d);
              this.renderMark(h, c, d);
              this.renderLabel(h, g, m, a);
              this.isNew = !1;
              k(this, "afterRender");
            };

            d.prototype.renderGridLine = function (a, g, c) {
              var d = this.axis,
                  m = d.options,
                  h = {},
                  n = this.pos,
                  k = this.type,
                  w = y(this.tickmarkOffset, d.tickmarkOffset),
                  f = d.chart.renderer,
                  b = this.gridLine,
                  v = m.gridLineWidth,
                  F = m.gridLineColor,
                  e = m.gridLineDashStyle;
              "minor" === this.type && (v = m.minorGridLineWidth, F = m.minorGridLineColor, e = m.minorGridLineDashStyle);
              b || (d.chart.styledMode || (h.stroke = F, h["stroke-width"] = v || 0, h.dashstyle = e), k || (h.zIndex = 1), a && (g = 0), this.gridLine = b = f.path().attr(h).addClass("highcharts-" + (k ? k + "-" : "") + "grid-line").add(d.gridGroup));
              if (b && (c = d.getPlotLinePath({
                value: n + w,
                lineWidth: b.strokeWidth() * c,
                force: "pass",
                old: a
              }))) b[a || this.isNew ? "attr" : "animate"]({
                d: c,
                opacity: g
              });
            };

            d.prototype.renderMark = function (a, g, c) {
              var d = this.axis,
                  m = d.options,
                  h = d.chart.renderer,
                  n = this.type,
                  k = d.tickSize(n ? n + "Tick" : "tick"),
                  w = a.x;
              a = a.y;
              var f = y(m["minor" !== n ? "tickWidth" : "minorTickWidth"], !n && d.isXAxis ? 1 : 0);
              m = m["minor" !== n ? "tickColor" : "minorTickColor"];
              var b = this.mark,
                  v = !b;
              k && (d.opposite && (k[0] = -k[0]), b || (this.mark = b = h.path().addClass("highcharts-" + (n ? n + "-" : "") + "tick").add(d.axisGroup), d.chart.styledMode || b.attr({
                stroke: m,
                "stroke-width": f
              })), b[v ? "attr" : "animate"]({
                d: this.getMarkPath(w, a, k[0], b.strokeWidth() * c, d.horiz, h),
                opacity: g
              }));
            };

            d.prototype.renderLabel = function (a, g, c, d) {
              var m = this.axis,
                  n = m.horiz,
                  k = m.options,
                  H = this.label,
                  w = k.labels,
                  f = w.step;
              m = y(this.tickmarkOffset, m.tickmarkOffset);
              var b = a.x;
              a = a.y;
              var v = !0;
              H && h(b) && (H.xy = a = this.getLabelPosition(b, a, H, n, w, m, d, f), this.isFirst && !this.isLast && !k.showFirstLabel || this.isLast && !this.isFirst && !k.showLastLabel ? v = !1 : !n || w.step || w.rotation || g || 0 === c || this.handleOverflow(a), f && d % f && (v = !1), v && h(a.y) ? (a.opacity = c, H[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (H.attr("y", -9999), this.isNewLabel = !0));
            };

            d.prototype.replaceMovedLabel = function () {
              var a = this.label,
                  g = this.axis,
                  c = g.reversed;

              if (a && !this.isNew) {
                var d = g.horiz ? c ? g.left : g.width + g.left : a.xy.x;
                c = g.horiz ? a.xy.y : c ? g.width + g.top : g.top;
                a.animate({
                  x: d,
                  y: c,
                  opacity: 0
                }, void 0, a.destroy);
                delete this.label;
              }

              g.isDirty = !0;
              this.label = this.movedLabel;
              delete this.movedLabel;
            };

            return d;
          }();

          "";
          return d;
        });
        M(d, "Core/Axis/Axis.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Axis/AxisDefaults.js"], d["Core/Color/Color.js"], d["Core/Color/Palette.js"], d["Core/DefaultOptions.js"], d["Core/Foundation.js"], d["Core/Globals.js"], d["Core/Axis/Tick.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A, r) {
          var k = c.animObject,
              h = C.defaultOptions,
              a = D.registerEventOptions,
              g = K.deg2rad,
              y = r.arrayMax,
              n = r.arrayMin,
              t = r.clamp,
              O = r.correctFloat,
              m = r.defined,
              N = r.destroyObjectProperties,
              L = r.erase,
              x = r.error,
              R = r.extend,
              H = r.fireEvent,
              w = r.getMagnitude,
              f = r.isArray,
              b = r.isNumber,
              v = r.isString,
              F = r.merge,
              e = r.normalizeTickInterval,
              q = r.objectEach,
              l = r.pick,
              I = r.relativeLength,
              p = r.removeEvent,
              z = r.splat,
              P = r.syncTimeout;

          c = function () {
            function c(b, e) {
              this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
              this.init(b, e);
            }

            c.prototype.init = function (e, f) {
              var u = f.isX;
              this.chart = e;
              this.horiz = e.inverted && !this.isZAxis ? !u : u;
              this.isXAxis = u;
              this.coll = this.coll || (u ? "xAxis" : "yAxis");
              H(this, "init", {
                userOptions: f
              });
              this.opposite = l(f.opposite, this.opposite);
              this.side = l(f.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
              this.setOptions(f);
              var p = this.options,
                  q = p.labels,
                  g = p.type;
              this.userOptions = f;
              this.minPixelPadding = 0;
              this.reversed = l(p.reversed, this.reversed);
              this.visible = p.visible;
              this.zoomEnabled = p.zoomEnabled;
              this.hasNames = "category" === g || !0 === p.categories;
              this.categories = p.categories || this.hasNames;
              this.names || (this.names = [], this.names.keys = {});
              this.plotLinesAndBandsGroups = {};
              this.positiveValuesOnly = !!this.logarithmic;
              this.isLinked = m(p.linkedTo);
              this.ticks = {};
              this.labelEdge = [];
              this.minorTicks = {};
              this.plotLinesAndBands = [];
              this.alternateBands = {};
              this.len = 0;
              this.minRange = this.userMinRange = p.minRange || p.maxZoom;
              this.range = p.range;
              this.offset = p.offset || 0;
              this.min = this.max = null;
              f = l(p.crosshair, z(e.options.tooltip.crosshairs)[u ? 0 : 1]);
              this.crosshair = !0 === f ? {} : f;
              -1 === e.axes.indexOf(this) && (u ? e.axes.splice(e.xAxis.length, 0, this) : e.axes.push(this), e[this.coll].push(this));
              this.series = this.series || [];
              e.inverted && !this.isZAxis && u && "undefined" === typeof this.reversed && (this.reversed = !0);
              this.labelRotation = b(q.rotation) ? q.rotation : void 0;
              a(this, p);
              H(this, "afterInit");
            };

            c.prototype.setOptions = function (b) {
              this.options = F(d.defaultXAxisOptions, "yAxis" === this.coll && d.defaultYAxisOptions, [d.defaultTopAxisOptions, d.defaultRightAxisOptions, d.defaultBottomAxisOptions, d.defaultLeftAxisOptions][this.side], F(h[this.coll], b));
              H(this, "afterSetOptions", {
                userOptions: b
              });
            };

            c.prototype.defaultLabelFormatter = function (e) {
              var a = this.axis;
              e = this.chart.numberFormatter;
              var l = b(this.value) ? this.value : NaN,
                  f = a.chart.time,
                  p = this.dateTimeLabelFormat,
                  q = h.lang,
                  g = q.numericSymbols;
              q = q.numericSymbolMagnitude || 1E3;
              var c = a.logarithmic ? Math.abs(l) : a.tickInterval,
                  v = g && g.length;
              if (a.categories) var J = "" + this.value;else if (p) J = f.dateFormat(p, l);else if (v && 1E3 <= c) for (; v-- && "undefined" === typeof J;) {
                a = Math.pow(q, v + 1), c >= a && 0 === 10 * l % a && null !== g[v] && 0 !== l && (J = e(l / a, -1) + g[v]);
              }
              "undefined" === typeof J && (J = 1E4 <= Math.abs(l) ? e(l, -1) : e(l, -1, void 0, ""));
              return J;
            };

            c.prototype.getSeriesExtremes = function () {
              var e = this,
                  a = e.chart,
                  f;
              H(this, "getSeriesExtremes", null, function () {
                e.hasVisibleSeries = !1;
                e.dataMin = e.dataMax = e.threshold = null;
                e.softThreshold = !e.isXAxis;
                e.stacking && e.stacking.buildStacks();
                e.series.forEach(function (p) {
                  if (p.visible || !a.options.chart.ignoreHiddenSeries) {
                    var u = p.options,
                        q = u.threshold;
                    e.hasVisibleSeries = !0;
                    e.positiveValuesOnly && 0 >= q && (q = null);

                    if (e.isXAxis) {
                      if (u = p.xData, u.length) {
                        u = e.logarithmic ? u.filter(e.validatePositiveValue) : u;
                        f = p.getXExtremes(u);
                        var g = f.min;
                        var c = f.max;
                        b(g) || g instanceof Date || (u = u.filter(b), f = p.getXExtremes(u), g = f.min, c = f.max);
                        u.length && (e.dataMin = Math.min(l(e.dataMin, g), g), e.dataMax = Math.max(l(e.dataMax, c), c));
                      }
                    } else if (p = p.applyExtremes(), b(p.dataMin) && (g = p.dataMin, e.dataMin = Math.min(l(e.dataMin, g), g)), b(p.dataMax) && (c = p.dataMax, e.dataMax = Math.max(l(e.dataMax, c), c)), m(q) && (e.threshold = q), !u.softThreshold || e.positiveValuesOnly) e.softThreshold = !1;
                  }
                });
              });
              H(this, "afterGetSeriesExtremes");
            };

            c.prototype.translate = function (e, a, l, f, p, q) {
              var u = this.linkedParent || this,
                  g = f && u.old ? u.old.min : u.min,
                  c = u.minPixelPadding;
              p = (u.isOrdinal || u.brokenAxis && u.brokenAxis.hasBreaks || u.logarithmic && p) && u.lin2val;
              var v = 1,
                  J = 0;
              f = f && u.old ? u.old.transA : u.transA;
              f || (f = u.transA);
              l && (v *= -1, J = u.len);
              u.reversed && (v *= -1, J -= v * (u.sector || u.len));
              a ? (e = (e * v + J - c) / f + g, p && (e = u.lin2val(e))) : (p && (e = u.val2lin(e)), e = b(g) ? v * (e - g) * f + J + v * c + (b(q) ? f * q : 0) : void 0);
              return e;
            };

            c.prototype.toPixels = function (b, e) {
              return this.translate(b, !1, !this.horiz, null, !0) + (e ? 0 : this.pos);
            };

            c.prototype.toValue = function (b, e) {
              return this.translate(b - (e ? 0 : this.pos), !0, !this.horiz, null, !0);
            };

            c.prototype.getPlotLinePath = function (e) {
              function a(b, e, a) {
                if ("pass" !== F && b < e || b > a) F ? b = t(b, e, a) : P = !0;
                return b;
              }

              var f = this,
                  p = f.chart,
                  q = f.left,
                  g = f.top,
                  c = e.old,
                  v = e.value,
                  J = e.lineWidth,
                  d = c && p.oldChartHeight || p.chartHeight,
                  m = c && p.oldChartWidth || p.chartWidth,
                  h = f.transB,
                  z = e.translatedValue,
                  F = e.force,
                  I,
                  w,
                  n,
                  k,
                  P;
              e = {
                value: v,
                lineWidth: J,
                old: c,
                force: F,
                acrossPanes: e.acrossPanes,
                translatedValue: z
              };
              H(this, "getPlotLinePath", e, function (e) {
                z = l(z, f.translate(v, null, null, c));
                z = t(z, -1E5, 1E5);
                I = n = Math.round(z + h);
                w = k = Math.round(d - z - h);
                b(z) ? f.horiz ? (w = g, k = d - f.bottom, I = n = a(I, q, q + f.width)) : (I = q, n = m - f.right, w = k = a(w, g, g + f.height)) : (P = !0, F = !1);
                e.path = P && !F ? null : p.renderer.crispLine([["M", I, w], ["L", n, k]], J || 1);
              });
              return e.path;
            };

            c.prototype.getLinearTickPositions = function (b, e, a) {
              var l = O(Math.floor(e / b) * b);
              a = O(Math.ceil(a / b) * b);
              var f = [],
                  p;
              O(l + b) === l && (p = 20);
              if (this.single) return [e];

              for (e = l; e <= a;) {
                f.push(e);
                e = O(e + b, p);
                if (e === u) break;
                var u = e;
              }

              return f;
            };

            c.prototype.getMinorTickInterval = function () {
              var b = this.options;
              return !0 === b.minorTicks ? l(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
            };

            c.prototype.getMinorTickPositions = function () {
              var b = this.options,
                  e = this.tickPositions,
                  a = this.minorTickInterval,
                  l = this.pointRangePadding || 0,
                  f = this.min - l;
              l = this.max + l;
              var p = l - f,
                  q = [];

              if (p && p / a < this.len / 3) {
                var g = this.logarithmic;
                if (g) this.paddedTicks.forEach(function (b, e, l) {
                  e && q.push.apply(q, g.getLogTickPositions(a, l[e - 1], l[e], !0));
                });else if (this.dateTime && "auto" === this.getMinorTickInterval()) q = q.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(a), f, l, b.startOfWeek));else for (b = f + (e[0] - f) % a; b <= l && b !== q[0]; b += a) {
                  q.push(b);
                }
              }

              0 !== q.length && this.trimTicks(q);
              return q;
            };

            c.prototype.adjustForMinRange = function () {
              var b = this.options,
                  e = this.logarithmic,
                  a = this.min,
                  f = this.max,
                  p = 0,
                  q,
                  g,
                  c,
                  v;
              this.isXAxis && "undefined" === typeof this.minRange && !e && (m(b.min) || m(b.max) ? this.minRange = null : (this.series.forEach(function (b) {
                c = b.xData;
                v = b.xIncrement ? 1 : c.length - 1;
                if (1 < c.length) for (q = v; 0 < q; q--) {
                  if (g = c[q] - c[q - 1], !p || g < p) p = g;
                }
              }), this.minRange = Math.min(5 * p, this.dataMax - this.dataMin)));

              if (f - a < this.minRange) {
                var d = this.dataMax - this.dataMin >= this.minRange;
                var z = this.minRange;
                var h = (z - f + a) / 2;
                h = [a - h, l(b.min, a - h)];
                d && (h[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                a = y(h);
                f = [a + z, l(b.max, a + z)];
                d && (f[2] = e ? e.log2lin(this.dataMax) : this.dataMax);
                f = n(f);
                f - a < z && (h[0] = f - z, h[1] = l(b.min, f - z), a = y(h));
              }

              this.min = a;
              this.max = f;
            };

            c.prototype.getClosest = function () {
              var b;
              this.categories ? b = 1 : this.series.forEach(function (e) {
                var a = e.closestPointRange,
                    l = e.visible || !e.chart.options.chart.ignoreHiddenSeries;
                !e.noSharedTooltip && m(a) && l && (b = m(b) ? Math.min(b, a) : a);
              });
              return b;
            };

            c.prototype.nameToX = function (b) {
              var e = f(this.categories),
                  a = e ? this.categories : this.names,
                  p = b.options.x;
              b.series.requireSorting = !1;
              m(p) || (p = this.options.uniqueNames ? e ? a.indexOf(b.name) : l(a.keys[b.name], -1) : b.series.autoIncrement());

              if (-1 === p) {
                if (!e) var q = a.length;
              } else q = p;

              "undefined" !== typeof q && (this.names[q] = b.name, this.names.keys[b.name] = q);
              return q;
            };

            c.prototype.updateNames = function () {
              var b = this,
                  e = this.names;
              0 < e.length && (Object.keys(e.keys).forEach(function (b) {
                delete e.keys[b];
              }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {
                e.xIncrement = null;
                if (!e.points || e.isDirtyData) b.max = Math.max(b.max, e.xData.length - 1), e.processData(), e.generatePoints();
                e.data.forEach(function (a, l) {
                  if (a && a.options && "undefined" !== typeof a.name) {
                    var f = b.nameToX(a);
                    "undefined" !== typeof f && f !== a.x && (a.x = f, e.xData[l] = f);
                  }
                });
              }));
            };

            c.prototype.setAxisTranslation = function () {
              var b = this,
                  e = b.max - b.min,
                  a = b.linkedParent,
                  f = !!b.categories,
                  p = b.isXAxis,
                  q = b.axisPointRange || 0,
                  g = 0,
                  c = 0,
                  d = b.transA;

              if (p || f || q) {
                var z = b.getClosest();
                a ? (g = a.minPointOffset, c = a.pointRangePadding) : b.series.forEach(function (e) {
                  var a = f ? 1 : p ? l(e.options.pointRange, z, 0) : b.axisPointRange || 0,
                      u = e.options.pointPlacement;
                  q = Math.max(q, a);
                  if (!b.single || f) e = e.is("xrange") ? !p : p, g = Math.max(g, e && v(u) ? 0 : a / 2), c = Math.max(c, e && "on" === u ? 0 : a);
                });
                a = b.ordinal && b.ordinal.slope && z ? b.ordinal.slope / z : 1;
                b.minPointOffset = g *= a;
                b.pointRangePadding = c *= a;
                b.pointRange = Math.min(q, b.single && f ? 1 : e);
                p && (b.closestPointRange = z);
              }

              b.translationSlope = b.transA = d = b.staticScale || b.len / (e + c || 1);
              b.transB = b.horiz ? b.left : b.bottom;
              b.minPixelPadding = d * g;
              H(this, "afterSetAxisTranslation");
            };

            c.prototype.minFromRange = function () {
              return this.max - this.range;
            };

            c.prototype.setTickInterval = function (a) {
              var f = this,
                  p = f.chart,
                  q = f.logarithmic,
                  g = f.options,
                  c = f.isXAxis,
                  v = f.isLinked,
                  d = g.tickPixelInterval,
                  z = f.categories,
                  h = f.softThreshold,
                  F = g.maxPadding,
                  J = g.minPadding,
                  I = g.tickInterval,
                  n = b(f.threshold) ? f.threshold : null;
              f.dateTime || z || v || this.getTickAmount();
              var k = l(f.userMin, g.min);
              var P = l(f.userMax, g.max);

              if (v) {
                f.linkedParent = p[f.coll][g.linkedTo];
                var y = f.linkedParent.getExtremes();
                f.min = l(y.min, y.dataMin);
                f.max = l(y.max, y.dataMax);
                g.type !== f.linkedParent.options.type && x(11, 1, p);
              } else {
                if (h && m(n)) if (f.dataMin >= n) y = n, J = 0;else if (f.dataMax <= n) {
                  var t = n;
                  F = 0;
                }
                f.min = l(k, y, f.dataMin);
                f.max = l(P, t, f.dataMax);
              }

              q && (f.positiveValuesOnly && !a && 0 >= Math.min(f.min, l(f.dataMin, f.min)) && x(10, 1, p), f.min = O(q.log2lin(f.min), 16), f.max = O(q.log2lin(f.max), 16));
              f.range && m(f.max) && (f.userMin = f.min = k = Math.max(f.dataMin, f.minFromRange()), f.userMax = P = f.max, f.range = null);
              H(f, "foundExtremes");
              f.beforePadding && f.beforePadding();
              f.adjustForMinRange();
              !(z || f.axisPointRange || f.stacking && f.stacking.usePercentage || v) && m(f.min) && m(f.max) && (p = f.max - f.min) && (!m(k) && J && (f.min -= p * J), !m(P) && F && (f.max += p * F));
              b(f.userMin) || (b(g.softMin) && g.softMin < f.min && (f.min = k = g.softMin), b(g.floor) && (f.min = Math.max(f.min, g.floor)));
              b(f.userMax) || (b(g.softMax) && g.softMax > f.max && (f.max = P = g.softMax), b(g.ceiling) && (f.max = Math.min(f.max, g.ceiling)));
              h && m(f.dataMin) && (n = n || 0, !m(k) && f.min < n && f.dataMin >= n ? f.min = f.options.minRange ? Math.min(n, f.max - f.minRange) : n : !m(P) && f.max > n && f.dataMax <= n && (f.max = f.options.minRange ? Math.max(n, f.min + f.minRange) : n));
              b(f.min) && b(f.max) && !this.chart.polar && f.min > f.max && (m(f.options.min) ? f.max = f.min : m(f.options.max) && (f.min = f.max));
              f.tickInterval = f.min === f.max || "undefined" === typeof f.min || "undefined" === typeof f.max ? 1 : v && f.linkedParent && !I && d === f.linkedParent.options.tickPixelInterval ? I = f.linkedParent.tickInterval : l(I, this.tickAmount ? (f.max - f.min) / Math.max(this.tickAmount - 1, 1) : void 0, z ? 1 : (f.max - f.min) * d / Math.max(f.len, d));
              c && !a && (f.series.forEach(function (b) {
                b.forceCrop = b.forceCropping && b.forceCropping();
                b.processData(f.min !== (f.old && f.old.min) || f.max !== (f.old && f.old.max));
              }), H(this, "postProcessData"));
              f.setAxisTranslation();
              H(this, "initialAxisTranslation");
              f.pointRange && !I && (f.tickInterval = Math.max(f.pointRange, f.tickInterval));
              a = l(g.minTickInterval, f.dateTime && !f.series.some(function (b) {
                return b.noSharedTooltip;
              }) ? f.closestPointRange : 0);
              !I && f.tickInterval < a && (f.tickInterval = a);
              f.dateTime || f.logarithmic || I || (f.tickInterval = e(f.tickInterval, void 0, w(f.tickInterval), l(g.allowDecimals, .5 > f.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
              this.tickAmount || (f.tickInterval = f.unsquish());
              this.setTickPositions();
            };

            c.prototype.setTickPositions = function () {
              var b = this.options,
                  e = b.tickPositions,
                  f = this.getMinorTickInterval(),
                  a = this.hasVerticalPanning(),
                  l = "colorAxis" === this.coll,
                  p = (l || !a) && b.startOnTick;
              a = (l || !a) && b.endOnTick;
              l = b.tickPositioner;
              this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
              this.minorTickInterval = "auto" === f && this.tickInterval ? this.tickInterval / 5 : f;
              this.single = this.min === this.max && m(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
              this.tickPositions = f = e && e.slice();
              !f && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? f = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (f = [this.min, this.max], x(19, !1, this.chart)), f.length > this.len && (f = [f[0], f.pop()], f[0] === f[1] && (f.length = 1)), this.tickPositions = f, l && (l = l.apply(this, [this.min, this.max]))) && (this.tickPositions = f = l);
              this.paddedTicks = f.slice(0);
              this.trimTicks(f, p, a);
              this.isLinked || (this.single && 2 > f.length && !this.categories && !this.series.some(function (b) {
                return b.is("heatmap") && "between" === b.options.pointPlacement;
              }) && (this.min -= .5, this.max += .5), e || l || this.adjustTickAmount());
              H(this, "afterSetTickPositions");
            };

            c.prototype.trimTicks = function (b, e, f) {
              var a = b[0],
                  l = b[b.length - 1],
                  p = !this.isOrdinal && this.minPointOffset || 0;
              H(this, "trimTicks");

              if (!this.isLinked) {
                if (e && -Infinity !== a) this.min = a;else for (; this.min - p > b[0];) {
                  b.shift();
                }
                if (f) this.max = l;else for (; this.max + p < b[b.length - 1];) {
                  b.pop();
                }
                0 === b.length && m(a) && !this.options.tickPositions && b.push((l + a) / 2);
              }
            };

            c.prototype.alignToOthers = function () {
              var b = {},
                  e = this.options,
                  f;
              !1 !== this.chart.options.chart.alignTicks && e.alignTicks && !1 !== e.startOnTick && !1 !== e.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (e) {
                var a = e.options;
                a = [e.horiz ? a.left : a.top, a.width, a.height, a.pane].join();
                e.series.length && (b[a] ? f = !0 : b[a] = 1);
              });
              return f;
            };

            c.prototype.getTickAmount = function () {
              var b = this.options,
                  e = b.tickPixelInterval,
                  f = b.tickAmount;
              !m(b.tickInterval) && !f && this.len < e && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (f = 2);
              !f && this.alignToOthers() && (f = Math.ceil(this.len / e) + 1);
              4 > f && (this.finalTickAmt = f, f = 5);
              this.tickAmount = f;
            };

            c.prototype.adjustTickAmount = function () {
              var e = this.options,
                  f = this.tickInterval,
                  a = this.tickPositions,
                  p = this.tickAmount,
                  q = this.finalTickAmt,
                  g = a && a.length,
                  c = l(this.threshold, this.softThreshold ? 0 : null);

              if (this.hasData() && b(this.min) && b(this.max)) {
                if (g < p) {
                  for (; a.length < p;) {
                    a.length % 2 || this.min === c ? a.push(O(a[a.length - 1] + f)) : a.unshift(O(a[0] - f));
                  }

                  this.transA *= (g - 1) / (p - 1);
                  this.min = e.startOnTick ? a[0] : Math.min(this.min, a[0]);
                  this.max = e.endOnTick ? a[a.length - 1] : Math.max(this.max, a[a.length - 1]);
                } else g > p && (this.tickInterval *= 2, this.setTickPositions());

                if (m(q)) {
                  for (f = e = a.length; f--;) {
                    (3 === q && 1 === f % 2 || 2 >= q && 0 < f && f < e - 1) && a.splice(f, 1);
                  }

                  this.finalTickAmt = void 0;
                }
              }
            };

            c.prototype.setScale = function () {
              var b = !1,
                  e = !1;
              this.series.forEach(function (f) {
                b = b || f.isDirtyData || f.isDirty;
                e = e || f.xAxis && f.xAxis.isDirty || !1;
              });
              this.setAxisSize();
              var f = this.len !== (this.old && this.old.len);
              f || b || e || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = f || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
              b && this.panningState && (this.panningState.isDirty = !0);
              H(this, "afterSetScale");
            };

            c.prototype.setExtremes = function (b, e, f, a, p) {
              var q = this,
                  g = q.chart;
              f = l(f, !0);
              q.series.forEach(function (b) {
                delete b.kdTree;
              });
              p = R(p, {
                min: b,
                max: e
              });
              H(q, "setExtremes", p, function () {
                q.userMin = b;
                q.userMax = e;
                q.eventArgs = p;
                f && g.redraw(a);
              });
            };

            c.prototype.zoom = function (b, e) {
              var f = this,
                  a = this.dataMin,
                  p = this.dataMax,
                  q = this.options,
                  g = Math.min(a, l(q.min, a)),
                  c = Math.max(p, l(q.max, p));
              b = {
                newMin: b,
                newMax: e
              };
              H(this, "zoom", b, function (b) {
                var e = b.newMin,
                    l = b.newMax;
                if (e !== f.min || l !== f.max) f.allowZoomOutside || (m(a) && (e < g && (e = g), e > c && (e = c)), m(p) && (l < g && (l = g), l > c && (l = c))), f.displayBtn = "undefined" !== typeof e || "undefined" !== typeof l, f.setExtremes(e, l, !1, void 0, {
                  trigger: "zoom"
                });
                b.zoomed = !0;
              });
              return b.zoomed;
            };

            c.prototype.setAxisSize = function () {
              var b = this.chart,
                  e = this.options,
                  f = e.offsets || [0, 0, 0, 0],
                  a = this.horiz,
                  p = this.width = Math.round(I(l(e.width, b.plotWidth - f[3] + f[1]), b.plotWidth)),
                  q = this.height = Math.round(I(l(e.height, b.plotHeight - f[0] + f[2]), b.plotHeight)),
                  g = this.top = Math.round(I(l(e.top, b.plotTop + f[0]), b.plotHeight, b.plotTop));
              e = this.left = Math.round(I(l(e.left, b.plotLeft + f[3]), b.plotWidth, b.plotLeft));
              this.bottom = b.chartHeight - q - g;
              this.right = b.chartWidth - p - e;
              this.len = Math.max(a ? p : q, 0);
              this.pos = a ? e : g;
            };

            c.prototype.getExtremes = function () {
              var b = this.logarithmic;
              return {
                min: b ? O(b.lin2log(this.min)) : this.min,
                max: b ? O(b.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
              };
            };

            c.prototype.getThreshold = function (b) {
              var e = this.logarithmic,
                  f = e ? e.lin2log(this.min) : this.min;
              e = e ? e.lin2log(this.max) : this.max;
              null === b || -Infinity === b ? b = f : Infinity === b ? b = e : f > b ? b = f : e < b && (b = e);
              return this.translate(b, 0, 1, 0, 1);
            };

            c.prototype.autoLabelAlign = function (b) {
              var e = (l(b, 0) - 90 * this.side + 720) % 360;
              b = {
                align: "center"
              };
              H(this, "autoLabelAlign", b, function (b) {
                15 < e && 165 > e ? b.align = "right" : 195 < e && 345 > e && (b.align = "left");
              });
              return b.align;
            };

            c.prototype.tickSize = function (b) {
              var e = this.options,
                  f = l(e["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
                  a = e["tick" === b ? "tickLength" : "minorTickLength"];

              if (f && a) {
                "inside" === e[b + "Position"] && (a = -a);
                var p = [a, f];
              }

              b = {
                tickSize: p
              };
              H(this, "afterTickSize", b);
              return b.tickSize;
            };

            c.prototype.labelMetrics = function () {
              var b = this.tickPositions && this.tickPositions[0] || 0;
              return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
            };

            c.prototype.unsquish = function () {
              var e = this.options.labels,
                  f = this.horiz,
                  a = this.tickInterval,
                  p = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a),
                  q = e.rotation,
                  c = this.labelMetrics(),
                  v = Math.max(this.max - this.min, 0),
                  d = function d(b) {
                var e = b / (p || 1);
                e = 1 < e ? Math.ceil(e) : 1;
                e * a > v && Infinity !== b && Infinity !== p && v && (e = Math.ceil(v / a));
                return O(e * a);
              },
                  z = a,
                  h,
                  m,
                  F = Number.MAX_VALUE;

              if (f) {
                if (!e.staggerLines && !e.step) if (b(q)) var I = [q];else p < e.autoRotationLimit && (I = e.autoRotation);
                I && I.forEach(function (b) {
                  if (b === q || b && -90 <= b && 90 >= b) {
                    m = d(Math.abs(c.h / Math.sin(g * b)));
                    var e = m + Math.abs(b / 360);
                    e < F && (F = e, h = b, z = m);
                  }
                });
              } else e.step || (z = d(c.h));

              this.autoRotation = I;
              this.labelRotation = l(h, b(q) ? q : 0);
              return z;
            };

            c.prototype.getSlotWidth = function (e) {
              var f = this.chart,
                  a = this.horiz,
                  l = this.options.labels,
                  p = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                  q = f.margin[3];
              if (e && b(e.slotWidth)) return e.slotWidth;
              if (a && 2 > l.step) return l.rotation ? 0 : (this.staggerLines || 1) * this.len / p;

              if (!a) {
                e = l.style.width;
                if (void 0 !== e) return parseInt(String(e), 10);
                if (q) return q - f.spacing[3];
              }

              return .33 * f.chartWidth;
            };

            c.prototype.renderUnsquish = function () {
              var b = this.chart,
                  e = b.renderer,
                  f = this.tickPositions,
                  a = this.ticks,
                  l = this.options.labels,
                  p = l.style,
                  q = this.horiz,
                  g = this.getSlotWidth(),
                  c = Math.max(1, Math.round(g - 2 * l.padding)),
                  d = {},
                  z = this.labelMetrics(),
                  m = p.textOverflow,
                  h = 0;
              v(l.rotation) || (d.rotation = l.rotation || 0);
              f.forEach(function (b) {
                b = a[b];
                b.movedLabel && b.replaceMovedLabel();
                b && b.label && b.label.textPxLength > h && (h = b.label.textPxLength);
              });
              this.maxLabelLength = h;
              if (this.autoRotation) h > c && h > z.h ? d.rotation = this.labelRotation : this.labelRotation = 0;else if (g) {
                var F = c;

                if (!m) {
                  var I = "clip";

                  for (c = f.length; !q && c--;) {
                    var w = f[c];
                    if (w = a[w].label) w.styles && "ellipsis" === w.styles.textOverflow ? w.css({
                      textOverflow: "clip"
                    }) : w.textPxLength > g && w.css({
                      width: g + "px"
                    }), w.getBBox().height > this.len / f.length - (z.h - z.f) && (w.specificTextOverflow = "ellipsis");
                  }
                }
              }
              d.rotation && (F = h > .5 * b.chartHeight ? .33 * b.chartHeight : h, m || (I = "ellipsis"));
              if (this.labelAlign = l.align || this.autoLabelAlign(this.labelRotation)) d.align = this.labelAlign;
              f.forEach(function (b) {
                var e = (b = a[b]) && b.label,
                    f = p.width,
                    l = {};
                e && (e.attr(d), b.shortenLabel ? b.shortenLabel() : F && !f && "nowrap" !== p.whiteSpace && (F < e.textPxLength || "SPAN" === e.element.tagName) ? (l.width = F + "px", m || (l.textOverflow = e.specificTextOverflow || I), e.css(l)) : e.styles && e.styles.width && !l.width && !f && e.css({
                  width: null
                }), delete e.specificTextOverflow, b.rotation = d.rotation);
              }, this);
              this.tickRotCorr = e.rotCorr(z.b, this.labelRotation || 0, 0 !== this.side);
            };

            c.prototype.hasData = function () {
              return this.series.some(function (b) {
                return b.hasData();
              }) || this.options.showEmpty && m(this.min) && m(this.max);
            };

            c.prototype.addTitle = function (b) {
              var e = this.chart.renderer,
                  f = this.horiz,
                  a = this.opposite,
                  l = this.options.title,
                  p = this.chart.styledMode,
                  q;
              this.axisTitle || ((q = l.textAlign) || (q = (f ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: a ? "right" : "left",
                middle: "center",
                high: a ? "left" : "right"
              })[l.align]), this.axisTitle = e.text(l.text || "", 0, 0, l.useHTML).attr({
                zIndex: 7,
                rotation: l.rotation,
                align: q
              }).addClass("highcharts-axis-title"), p || this.axisTitle.css(F(l.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
              p || l.style.width || this.isRadial || this.axisTitle.css({
                width: this.len + "px"
              });
              this.axisTitle[b ? "show" : "hide"](b);
            };

            c.prototype.generateTick = function (b) {
              var e = this.ticks;
              e[b] ? e[b].addLabel() : e[b] = new A(this, b);
            };

            c.prototype.getOffset = function () {
              var b = this,
                  e = this,
                  f = e.chart,
                  a = f.renderer,
                  p = e.options,
                  g = e.tickPositions,
                  c = e.ticks,
                  v = e.horiz,
                  d = e.side,
                  z = f.inverted && !e.isZAxis ? [1, 0, 3, 2][d] : d,
                  h = e.hasData(),
                  F = p.title,
                  I = p.labels,
                  w = f.axisOffset;
              f = f.clipOffset;
              var n = [-1, 1, 1, -1][d],
                  k = p.className,
                  P = e.axisParent,
                  y,
                  t = 0,
                  x = 0,
                  T = 0;
              e.showAxis = y = h || p.showEmpty;
              e.staggerLines = e.horiz && I.staggerLines || void 0;

              if (!e.axisGroup) {
                var r = function r(e, f, l) {
                  return a.g(e).attr({
                    zIndex: l
                  }).addClass("highcharts-" + b.coll.toLowerCase() + f + " " + (b.isRadial ? "highcharts-radial-axis" + f + " " : "") + (k || "")).add(P);
                };

                e.gridGroup = r("grid", "-grid", p.gridZIndex);
                e.axisGroup = r("axis", "", p.zIndex);
                e.labelGroup = r("axis-labels", "-labels", I.zIndex);
              }

              h || e.isLinked ? (g.forEach(function (b) {
                e.generateTick(b);
              }), e.renderUnsquish(), e.reserveSpaceDefault = 0 === d || 2 === d || {
                1: "left",
                3: "right"
              }[d] === e.labelAlign, l(I.reserveSpace, "center" === e.labelAlign ? !0 : null, e.reserveSpaceDefault) && g.forEach(function (b) {
                T = Math.max(c[b].getLabelSize(), T);
              }), e.staggerLines && (T *= e.staggerLines), e.labelOffset = T * (e.opposite ? -1 : 1)) : q(c, function (b, e) {
                b.destroy();
                delete c[e];
              });

              if (F && F.text && !1 !== F.enabled && (e.addTitle(y), y && !1 !== F.reserveSpace)) {
                e.titleOffset = t = e.axisTitle.getBBox()[v ? "height" : "width"];
                var O = F.offset;
                x = m(O) ? 0 : l(F.margin, v ? 5 : 10);
              }

              e.renderLine();
              e.offset = n * l(p.offset, w[d] ? w[d] + (p.margin || 0) : 0);
              e.tickRotCorr = e.tickRotCorr || {
                x: 0,
                y: 0
              };
              F = 0 === d ? -e.labelMetrics().h : 2 === d ? e.tickRotCorr.y : 0;
              h = Math.abs(T) + x;
              T && (h = h - F + n * (v ? l(I.y, e.tickRotCorr.y + 8 * n) : I.x));
              e.axisTitleMargin = l(O, h);
              e.getMaxLabelDimensions && (e.maxLabelDimensions = e.getMaxLabelDimensions(c, g));
              v = this.tickSize("tick");
              w[d] = Math.max(w[d], (e.axisTitleMargin || 0) + t + n * e.offset, h, g && g.length && v ? v[0] + n * e.offset : 0);
              p = p.offset ? 0 : 2 * Math.floor(e.axisLine.strokeWidth() / 2);
              f[z] = Math.max(f[z], p);
              H(this, "afterGetOffset");
            };

            c.prototype.getLinePath = function (b) {
              var e = this.chart,
                  f = this.opposite,
                  a = this.offset,
                  l = this.horiz,
                  p = this.left + (f ? this.width : 0) + a;
              a = e.chartHeight - this.bottom - (f ? this.height : 0) + a;
              f && (b *= -1);
              return e.renderer.crispLine([["M", l ? this.left : p, l ? a : this.top], ["L", l ? e.chartWidth - this.right : p, l ? a : e.chartHeight - this.bottom]], b);
            };

            c.prototype.renderLine = function () {
              this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              }));
            };

            c.prototype.getTitlePosition = function () {
              var b = this.horiz,
                  e = this.left,
                  f = this.top,
                  a = this.len,
                  l = this.options.title,
                  p = b ? e : f,
                  q = this.opposite,
                  g = this.offset,
                  c = l.x,
                  v = l.y,
                  d = this.axisTitle,
                  z = this.chart.renderer.fontMetrics(l.style.fontSize, d);
              d = Math.max(d.getBBox(null, 0).height - z.h - 1, 0);
              a = {
                low: p + (b ? 0 : a),
                middle: p + a / 2,
                high: p + (b ? a : 0)
              }[l.align];
              e = (b ? f + this.height : e) + (b ? 1 : -1) * (q ? -1 : 1) * this.axisTitleMargin + [-d, d, z.f, -d][this.side];
              b = {
                x: b ? a + c : e + (q ? this.width : 0) + g + c,
                y: b ? e + v - (q ? this.height : 0) + g : a + v
              };
              H(this, "afterGetTitlePosition", {
                titlePosition: b
              });
              return b;
            };

            c.prototype.renderMinorTick = function (b, e) {
              var f = this.minorTicks;
              f[b] || (f[b] = new A(this, b, "minor"));
              e && f[b].isNew && f[b].render(null, !0);
              f[b].render(null, !1, 1);
            };

            c.prototype.renderTick = function (b, e, f) {
              var a = this.ticks;
              if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) a[b] || (a[b] = new A(this, b)), f && a[b].isNew && a[b].render(e, !0, -1), a[b].render(e);
            };

            c.prototype.render = function () {
              var e = this,
                  f = e.chart,
                  a = e.logarithmic,
                  l = e.options,
                  p = e.isLinked,
                  g = e.tickPositions,
                  c = e.axisTitle,
                  v = e.ticks,
                  d = e.minorTicks,
                  z = e.alternateBands,
                  h = l.stackLabels,
                  m = l.alternateGridColor,
                  F = e.tickmarkOffset,
                  I = e.axisLine,
                  w = e.showAxis,
                  n = k(f.renderer.globalAnimation),
                  y,
                  t;
              e.labelEdge.length = 0;
              e.overlap = !1;
              [v, d, z].forEach(function (b) {
                q(b, function (b) {
                  b.isActive = !1;
                });
              });

              if (e.hasData() || p) {
                var x = e.chart.hasRendered && e.old && b(e.old.min);
                e.minorTickInterval && !e.categories && e.getMinorTickPositions().forEach(function (b) {
                  e.renderMinorTick(b, x);
                });
                g.length && (g.forEach(function (b, f) {
                  e.renderTick(b, f, x);
                }), F && (0 === e.min || e.single) && (v[-1] || (v[-1] = new A(e, -1, null, !0)), v[-1].render(-1)));
                m && g.forEach(function (b, l) {
                  t = "undefined" !== typeof g[l + 1] ? g[l + 1] + F : e.max - F;
                  0 === l % 2 && b < e.max && t <= e.max + (f.polar ? -F : F) && (z[b] || (z[b] = new K.PlotLineOrBand(e)), y = b + F, z[b].options = {
                    from: a ? a.lin2log(y) : y,
                    to: a ? a.lin2log(t) : t,
                    color: m,
                    className: "highcharts-alternate-grid"
                  }, z[b].render(), z[b].isActive = !0);
                });
                e._addedPlotLB || (e._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function (b) {
                  e.addPlotBandOrLine(b);
                }));
              }

              [v, d, z].forEach(function (b) {
                var e = [],
                    a = n.duration;
                q(b, function (b, f) {
                  b.isActive || (b.render(f, !1, 0), b.isActive = !1, e.push(f));
                });
                P(function () {
                  for (var f = e.length; f--;) {
                    b[e[f]] && !b[e[f]].isActive && (b[e[f]].destroy(), delete b[e[f]]);
                  }
                }, b !== z && f.hasRendered && a ? a : 0);
              });
              I && (I[I.isPlaced ? "animate" : "attr"]({
                d: this.getLinePath(I.strokeWidth())
              }), I.isPlaced = !0, I[w ? "show" : "hide"](w));
              c && w && (l = e.getTitlePosition(), b(l.y) ? (c[c.isNew ? "attr" : "animate"](l), c.isNew = !1) : (c.attr("y", -9999), c.isNew = !0));
              h && h.enabled && e.stacking && e.stacking.renderStackTotals();
              e.old = {
                len: e.len,
                max: e.max,
                min: e.min,
                transA: e.transA,
                userMax: e.userMax,
                userMin: e.userMin
              };
              e.isDirty = !1;
              H(this, "afterRender");
            };

            c.prototype.redraw = function () {
              this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
                b.render();
              }));
              this.series.forEach(function (b) {
                b.isDirty = !0;
              });
            };

            c.prototype.getKeepProps = function () {
              return this.keepProps || c.keepProps;
            };

            c.prototype.destroy = function (b) {
              var e = this,
                  f = e.plotLinesAndBands,
                  a = this.eventOptions;
              H(this, "destroy", {
                keepEvents: b
              });
              b || p(e);
              [e.ticks, e.minorTicks, e.alternateBands].forEach(function (b) {
                N(b);
              });
              if (f) for (b = f.length; b--;) {
                f[b].destroy();
              }
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
                e[b] && (e[b] = e[b].destroy());
              });

              for (var l in e.plotLinesAndBandsGroups) {
                e.plotLinesAndBandsGroups[l] = e.plotLinesAndBandsGroups[l].destroy();
              }

              q(e, function (b, f) {
                -1 === e.getKeepProps().indexOf(f) && delete e[f];
              });
              this.eventOptions = a;
            };

            c.prototype.drawCrosshair = function (b, e) {
              var f = this.crosshair,
                  a = l(f && f.snap, !0),
                  p = this.chart,
                  q,
                  g = this.cross;
              H(this, "drawCrosshair", {
                e: b,
                point: e
              });
              b || (b = this.cross && this.cross.e);

              if (f && !1 !== (m(e) || !a)) {
                a ? m(e) && (q = l("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : q = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);

                if (m(q)) {
                  var c = {
                    value: e && (this.isXAxis ? e.x : l(e.stackY, e.y)),
                    translatedValue: q
                  };
                  p.polar && R(c, {
                    isCrosshair: !0,
                    chartX: b && b.chartX,
                    chartY: b && b.chartY,
                    point: e
                  });
                  c = this.getPlotLinePath(c) || null;
                }

                if (!m(c)) {
                  this.hideCrosshair();
                  return;
                }

                a = this.categories && !this.isRadial;
                g || (this.cross = g = p.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a ? "category " : "thin ") + (f.className || "")).attr({
                  zIndex: l(f.zIndex, 2)
                }).add(), p.styledMode || (g.attr({
                  stroke: f.color || (a ? E.parse(G.highlightColor20).setOpacity(.25).get() : G.neutralColor20),
                  "stroke-width": l(f.width, 1)
                }).css({
                  "pointer-events": "none"
                }), f.dashStyle && g.attr({
                  dashstyle: f.dashStyle
                })));
                g.show().attr({
                  d: c
                });
                a && !f.width && g.attr({
                  "stroke-width": this.transA
                });
                this.cross.e = b;
              } else this.hideCrosshair();

              H(this, "afterDrawCrosshair", {
                e: b,
                point: e
              });
            };

            c.prototype.hideCrosshair = function () {
              this.cross && this.cross.hide();
              H(this, "afterHideCrosshair");
            };

            c.prototype.hasVerticalPanning = function () {
              var b = this.chart.options.chart.panning;
              return !!(b && b.enabled && /y/.test(b.type));
            };

            c.prototype.validatePositiveValue = function (e) {
              return b(e) && 0 < e;
            };

            c.prototype.update = function (b, e) {
              var f = this.chart;
              b = F(this.userOptions, b);
              this.destroy(!0);
              this.init(f, b);
              f.isDirtyBox = !0;
              l(e, !0) && f.redraw();
            };

            c.prototype.remove = function (b) {
              for (var e = this.chart, f = this.coll, a = this.series, p = a.length; p--;) {
                a[p] && a[p].remove(!1);
              }

              L(e.axes, this);
              L(e[f], this);
              e[f].forEach(function (b, e) {
                b.options.index = b.userOptions.index = e;
              });
              this.destroy();
              e.isDirtyBox = !0;
              l(b, !0) && e.redraw();
            };

            c.prototype.setTitle = function (b, e) {
              this.update({
                title: b
              }, e);
            };

            c.prototype.setCategories = function (b, e) {
              this.update({
                categories: b
              }, e);
            };

            c.defaultOptions = d.defaultXAxisOptions;
            c.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return c;
          }();

          "";
          return c;
        });
        M(d, "Core/Axis/DateTimeAxis.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.addEvent,
              E = c.getMagnitude,
              G = c.normalizeTickInterval,
              C = c.timeUnits,
              D;

          (function (c) {
            function A() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }

            function r(a) {
              "datetime" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new h(this));
            }

            var k = [];

            c.compose = function (a) {
              -1 === k.indexOf(a) && (k.push(a), a.keepProps.push("dateTime"), a.prototype.getTimeTicks = A, d(a, "init", r));
              return a;
            };

            var h = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.normalizeTimeTickInterval = function (a, c) {
                var g = c || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                c = g[g.length - 1];
                var d = C[c[0]],
                    h = c[1],
                    m;

                for (m = 0; m < g.length && !(c = g[m], d = C[c[0]], h = c[1], g[m + 1] && a <= (d * h[h.length - 1] + C[g[m + 1][0]]) / 2); m++) {
                  ;
                }

                d === C.year && a < 5 * d && (h = [1, 2, 5]);
                a = G(a / d, h, "year" === c[0] ? Math.max(E(a / d), 1) : 1);
                return {
                  unitRange: d,
                  count: a,
                  unitName: c[0]
                };
              };

              a.prototype.getXDateFormat = function (a, c) {
                var g = this.axis;
                return g.closestPointRange ? g.chart.time.getDateFormat(g.closestPointRange, a, g.options.startOfWeek, c) || c.year : c.day;
              };

              return a;
            }();

            c.Additions = h;
          })(D || (D = {}));

          return D;
        });
        M(d, "Core/Axis/LogarithmicAxis.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.addEvent,
              E = c.getMagnitude,
              G = c.normalizeTickInterval,
              C = c.pick,
              D;

          (function (c) {
            function A(a) {
              var g = this.logarithmic;
              "logarithmic" !== a.userOptions.type ? this.logarithmic = void 0 : g || (this.logarithmic = new h(this));
            }

            function r() {
              var a = this.logarithmic;
              a && (this.lin2val = function (g) {
                return a.lin2log(g);
              }, this.val2lin = function (g) {
                return a.log2lin(g);
              });
            }

            var k = [];

            c.compose = function (a) {
              -1 === k.indexOf(a) && (k.push(a), a.keepProps.push("logarithmic"), d(a, "init", A), d(a, "afterInit", r));
              return a;
            };

            var h = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.getLogTickPositions = function (a, c, d, h) {
                var g = this.axis,
                    m = g.len,
                    n = g.options,
                    k = [];
                h || (this.minorAutoInterval = void 0);
                if (.5 <= a) a = Math.round(a), k = g.getLinearTickPositions(a, c, d);else if (.08 <= a) {
                  var x = Math.floor(c),
                      y,
                      H = n = void 0;

                  for (m = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; x < d + 1 && !H; x++) {
                    var w = m.length;

                    for (y = 0; y < w && !H; y++) {
                      var f = this.log2lin(this.lin2log(x) * m[y]);
                      f > c && (!h || n <= d) && "undefined" !== typeof n && k.push(n);
                      n > d && (H = !0);
                      n = f;
                    }
                  }
                } else c = this.lin2log(c), d = this.lin2log(d), a = h ? g.getMinorTickInterval() : n.tickInterval, a = C("auto" === a ? null : a, this.minorAutoInterval, n.tickPixelInterval / (h ? 5 : 1) * (d - c) / ((h ? m / g.tickPositions.length : m) || 1)), a = G(a, void 0, E(a)), k = g.getLinearTickPositions(a, c, d).map(this.log2lin), h || (this.minorAutoInterval = a / 5);
                h || (g.tickInterval = a);
                return k;
              };

              a.prototype.lin2log = function (a) {
                return Math.pow(10, a);
              };

              a.prototype.log2lin = function (a) {
                return Math.log(a) / Math.LN10;
              };

              return a;
            }();

            c.Additions = h;
          })(D || (D = {}));

          return D;
        });
        M(d, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.erase,
              E = c.extend,
              G = c.isNumber,
              C;

          (function (c) {
            var B = [],
                A;

            c.compose = function (c, d) {
              A || (A = c);
              -1 === B.indexOf(d) && (B.push(d), E(d.prototype, r.prototype));
              return d;
            };

            var r = function () {
              function c() {}

              c.prototype.getPlotBandPath = function (c, a, g) {
                void 0 === g && (g = this.options);
                var d = this.getPlotLinePath({
                  value: a,
                  force: !0,
                  acrossPanes: g.acrossPanes
                }),
                    h = [],
                    k = this.horiz;
                a = !G(this.min) || !G(this.max) || c < this.min && a < this.min || c > this.max && a > this.max;
                c = this.getPlotLinePath({
                  value: c,
                  force: !0,
                  acrossPanes: g.acrossPanes
                });
                g = 1;

                if (c && d) {
                  if (a) {
                    var r = c.toString() === d.toString();
                    g = 0;
                  }

                  for (a = 0; a < c.length; a += 2) {
                    var m = c[a],
                        N = c[a + 1],
                        L = d[a],
                        x = d[a + 1];
                    "M" !== m[0] && "L" !== m[0] || "M" !== N[0] && "L" !== N[0] || "M" !== L[0] && "L" !== L[0] || "M" !== x[0] && "L" !== x[0] || (k && L[1] === m[1] ? (L[1] += g, x[1] += g) : k || L[2] !== m[2] || (L[2] += g, x[2] += g), h.push(["M", m[1], m[2]], ["L", N[1], N[2]], ["L", x[1], x[2]], ["L", L[1], L[2]], ["Z"]));
                    h.isFlat = r;
                  }
                }

                return h;
              };

              c.prototype.addPlotBand = function (c) {
                return this.addPlotBandOrLine(c, "plotBands");
              };

              c.prototype.addPlotLine = function (c) {
                return this.addPlotBandOrLine(c, "plotLines");
              };

              c.prototype.addPlotBandOrLine = function (c, a) {
                var g = this,
                    d = this.userOptions,
                    h = new A(this, c);
                this.visible && (h = h.render());

                if (h) {
                  this._addedPlotLB || (this._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (a) {
                    g.addPlotBandOrLine(a);
                  }));

                  if (a) {
                    var k = d[a] || [];
                    k.push(c);
                    d[a] = k;
                  }

                  this.plotLinesAndBands.push(h);
                }

                return h;
              };

              c.prototype.removePlotBandOrLine = function (c) {
                var a = this.plotLinesAndBands,
                    g = this.options,
                    h = this.userOptions;

                if (a) {
                  for (var n = a.length; n--;) {
                    a[n].id === c && a[n].destroy();
                  }

                  [g.plotLines || [], h.plotLines || [], g.plotBands || [], h.plotBands || []].forEach(function (a) {
                    for (n = a.length; n--;) {
                      (a[n] || {}).id === c && d(a, a[n]);
                    }
                  });
                }
              };

              c.prototype.removePlotBand = function (c) {
                this.removePlotBandOrLine(c);
              };

              c.prototype.removePlotLine = function (c) {
                this.removePlotBandOrLine(c);
              };

              return c;
            }();
          })(C || (C = {}));

          return C;
        });
        M(d, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [d["Core/Color/Palette.js"], d["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = E.arrayMax,
              C = E.arrayMin,
              D = E.defined,
              K = E.destroyObjectProperties,
              A = E.erase,
              r = E.fireEvent,
              k = E.merge,
              h = E.objectEach,
              a = E.pick;

          E = function () {
            function g(a, c) {
              this.axis = a;
              c && (this.options = c, this.id = c.id);
            }

            g.compose = function (a) {
              return d.compose(g, a);
            };

            g.prototype.render = function () {
              r(this, "render");
              var g = this,
                  d = g.axis,
                  t = d.horiz,
                  O = d.logarithmic,
                  m = g.options,
                  N = m.color,
                  L = a(m.zIndex, 0),
                  x = m.events,
                  R = {},
                  H = d.chart.renderer,
                  w = m.label,
                  f = g.label,
                  b = m.to,
                  v = m.from,
                  F = m.value,
                  e = g.svgElem,
                  q = [],
                  l = D(v) && D(b);
              q = D(F);
              var I = !e,
                  p = {
                "class": "highcharts-plot-" + (l ? "band " : "line ") + (m.className || "")
              },
                  z = l ? "bands" : "lines";
              O && (v = O.log2lin(v), b = O.log2lin(b), F = O.log2lin(F));
              d.chart.styledMode || (q ? (p.stroke = N || c.neutralColor40, p["stroke-width"] = a(m.width, 1), m.dashStyle && (p.dashstyle = m.dashStyle)) : l && (p.fill = N || c.highlightColor10, m.borderWidth && (p.stroke = m.borderColor, p["stroke-width"] = m.borderWidth)));
              R.zIndex = L;
              z += "-" + L;
              (O = d.plotLinesAndBandsGroups[z]) || (d.plotLinesAndBandsGroups[z] = O = H.g("plot-" + z).attr(R).add());
              I && (g.svgElem = e = H.path().attr(p).add(O));
              if (q) q = d.getPlotLinePath({
                value: F,
                lineWidth: e.strokeWidth(),
                acrossPanes: m.acrossPanes
              });else if (l) q = d.getPlotBandPath(v, b, m);else return;
              !g.eventsAdded && x && (h(x, function (b, f) {
                e.on(f, function (b) {
                  x[f].apply(g, [b]);
                });
              }), g.eventsAdded = !0);
              (I || !e.d) && q && q.length ? e.attr({
                d: q
              }) : e && (q ? (e.show(!0), e.animate({
                d: q
              })) : e.d && (e.hide(), f && (g.label = f = f.destroy())));
              w && (D(w.text) || D(w.formatter)) && q && q.length && 0 < d.width && 0 < d.height && !q.isFlat ? (w = k({
                align: t && l && "center",
                x: t ? !l && 4 : 10,
                verticalAlign: !t && l && "middle",
                y: t ? l ? 16 : 10 : l ? 6 : -4,
                rotation: t && !l && 90
              }, w), this.renderLabel(w, q, l, L)) : f && f.hide();
              return g;
            };

            g.prototype.renderLabel = function (a, c, g, d) {
              var h = this.axis,
                  n = h.chart.renderer,
                  t = this.label;
              t || (this.label = t = n.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
                align: a.textAlign || a.align,
                rotation: a.rotation,
                "class": "highcharts-plot-" + (g ? "band" : "line") + "-label " + (a.className || ""),
                zIndex: d
              }).add(), h.chart.styledMode || t.css(k({
                textOverflow: "ellipsis"
              }, a.style)));
              d = c.xBounds || [c[0][1], c[1][1], g ? c[2][1] : c[0][1]];
              c = c.yBounds || [c[0][2], c[1][2], g ? c[2][2] : c[0][2]];
              g = C(d);
              n = C(c);
              t.align(a, !1, {
                x: g,
                y: n,
                width: B(d) - g,
                height: B(c) - n
              });
              t.alignValue && "left" !== t.alignValue || t.css({
                width: (90 === t.rotation ? h.height - (t.alignAttr.y - h.top) : h.width - (t.alignAttr.x - h.left)) + "px"
              });
              t.show(!0);
            };

            g.prototype.getLabelText = function (a) {
              return D(a.formatter) ? a.formatter.call(this) : a.text;
            };

            g.prototype.destroy = function () {
              A(this.axis.plotLinesAndBands, this);
              delete this.axis;
              K(this);
            };

            return g;
          }();

          "";
          "";
          return E;
        });
        M(d, "Core/Tooltip.js", [d["Core/FormatUtilities.js"], d["Core/Globals.js"], d["Core/Color/Palette.js"], d["Core/Renderer/RendererUtilities.js"], d["Core/Renderer/RendererRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D) {
          var B = c.format,
              A = d.doc,
              r = G.distribute,
              k = D.addEvent,
              h = D.clamp,
              a = D.css,
              g = D.defined,
              y = D.discardElement,
              n = D.extend,
              t = D.fireEvent,
              O = D.isArray,
              m = D.isNumber,
              N = D.isString,
              L = D.merge,
              x = D.pick,
              R = D.splat,
              H = D.syncTimeout;

          c = function () {
            function c(f, b) {
              this.container = void 0;
              this.crosshairs = [];
              this.distance = 0;
              this.isHidden = !0;
              this.isSticky = !1;
              this.now = {};
              this.options = {};
              this.outside = !1;
              this.chart = f;
              this.init(f, b);
            }

            c.prototype.applyFilter = function () {
              var f = this.chart;
              f.renderer.definition({
                tagName: "filter",
                attributes: {
                  id: "drop-shadow-" + f.index,
                  opacity: .5
                },
                children: [{
                  tagName: "feGaussianBlur",
                  attributes: {
                    "in": "SourceAlpha",
                    stdDeviation: 1
                  }
                }, {
                  tagName: "feOffset",
                  attributes: {
                    dx: 1,
                    dy: 1
                  }
                }, {
                  tagName: "feComponentTransfer",
                  children: [{
                    tagName: "feFuncA",
                    attributes: {
                      type: "linear",
                      slope: .3
                    }
                  }]
                }, {
                  tagName: "feMerge",
                  children: [{
                    tagName: "feMergeNode"
                  }, {
                    tagName: "feMergeNode",
                    attributes: {
                      "in": "SourceGraphic"
                    }
                  }]
                }]
              });
            };

            c.prototype.bodyFormatter = function (f) {
              return f.map(function (b) {
                var f = b.series.tooltipOptions;
                return (f[(b.point.formatPrefix || "point") + "Formatter"] || b.point.tooltipFormatter).call(b.point, f[(b.point.formatPrefix || "point") + "Format"] || "");
              });
            };

            c.prototype.cleanSplit = function (f) {
              this.chart.series.forEach(function (b) {
                var a = b && b.tt;
                a && (!a.isActive || f ? b.tt = a.destroy() : a.isActive = !1);
              });
            };

            c.prototype.defaultFormatter = function (f) {
              var b = this.points || R(this);
              var a = [f.tooltipFooterHeaderFormatter(b[0])];
              a = a.concat(f.bodyFormatter(b));
              a.push(f.tooltipFooterHeaderFormatter(b[0], !0));
              return a;
            };

            c.prototype.destroy = function () {
              this.label && (this.label = this.label.destroy());
              this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
              this.renderer && (this.renderer = this.renderer.destroy(), y(this.container));
              D.clearTimeout(this.hideTimer);
              D.clearTimeout(this.tooltipTimeout);
            };

            c.prototype.getAnchor = function (f, b) {
              var a = this.chart,
                  c = a.pointer,
                  e = a.inverted,
                  q = a.plotTop,
                  l = a.plotLeft,
                  g,
                  p,
                  d = 0,
                  h = 0;
              f = R(f);
              this.followPointer && b ? ("undefined" === typeof b.chartX && (b = c.normalize(b)), c = [b.chartX - l, b.chartY - q]) : f[0].tooltipPos ? c = f[0].tooltipPos : (f.forEach(function (b) {
                g = b.series.yAxis;
                p = b.series.xAxis;
                d += b.plotX || 0;
                h += b.plotLow ? (b.plotLow + (b.plotHigh || 0)) / 2 : b.plotY || 0;
                p && g && (e ? (d += q + a.plotHeight - p.len - p.pos, h += l + a.plotWidth - g.len - g.pos) : (d += p.pos - l, h += g.pos - q));
              }), d /= f.length, h /= f.length, c = [e ? a.plotWidth - h : d, e ? a.plotHeight - d : h], this.shared && 1 < f.length && b && (e ? c[0] = b.chartX - l : c[1] = b.chartY - q));
              return c.map(Math.round);
            };

            c.prototype.getLabel = function () {
              var f = this,
                  b = this.chart.styledMode,
                  c = this.options,
                  h = "tooltip" + (g(c.className) ? " " + c.className : ""),
                  e = c.style.pointerEvents || (!this.followPointer && c.stickOnContact ? "auto" : "none"),
                  q = function q() {
                f.inContact = !0;
              },
                  l = function l(b) {
                var e = f.chart.hoverSeries;
                f.inContact = f.shouldStickOnContact() && f.chart.pointer.inClass(b.relatedTarget, "highcharts-tooltip");
                if (!f.inContact && e && e.onMouseOut) e.onMouseOut();
              },
                  m,
                  p = this.chart.renderer;

              if (!this.label) {
                if (this.outside) {
                  var z = this.chart.options.chart.style,
                      w = C.getRendererType();
                  this.container = m = d.doc.createElement("div");
                  m.className = "highcharts-tooltip-container";
                  a(m, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: e,
                    zIndex: Math.max(this.options.style.zIndex || 0, (z && z.zIndex || 0) + 3)
                  });
                  k(m, "mouseenter", q);
                  k(m, "mouseleave", l);
                  d.doc.body.appendChild(m);
                  this.renderer = p = new w(m, 0, 0, z, void 0, void 0, p.styledMode);
                }

                this.split ? this.label = p.g(h) : (this.label = p.label("", 0, 0, c.shape, void 0, void 0, c.useHTML, void 0, h).attr({
                  padding: c.padding,
                  r: c.borderRadius
                }), b || this.label.attr({
                  fill: c.backgroundColor,
                  "stroke-width": c.borderWidth
                }).css(c.style).css({
                  pointerEvents: e
                }).shadow(c.shadow));
                b && c.shadow && (this.applyFilter(), this.label.attr({
                  filter: "url(#drop-shadow-" + this.chart.index + ")"
                }));

                if (f.outside && !f.split) {
                  var n = this.label,
                      H = n.xSetter,
                      u = n.ySetter;

                  n.xSetter = function (b) {
                    H.call(n, f.distance);
                    m.style.left = b + "px";
                  };

                  n.ySetter = function (b) {
                    u.call(n, f.distance);
                    m.style.top = b + "px";
                  };
                }

                this.label.on("mouseenter", q).on("mouseleave", l).attr({
                  zIndex: 8
                }).add();
              }

              return this.label;
            };

            c.prototype.getPosition = function (f, b, a) {
              var c = this.chart,
                  e = this.distance,
                  q = {},
                  l = c.inverted && a.h || 0,
                  g = this.outside,
                  p = g ? A.documentElement.clientWidth - 2 * e : c.chartWidth,
                  d = g ? Math.max(A.body.scrollHeight, A.documentElement.scrollHeight, A.body.offsetHeight, A.documentElement.offsetHeight, A.documentElement.clientHeight) : c.chartHeight,
                  v = c.pointer.getChartPosition(),
                  h = function h(l) {
                var q = "x" === l;
                return [l, q ? p : d, q ? f : b].concat(g ? [q ? f * v.scaleX : b * v.scaleY, q ? v.left - e + (a.plotX + c.plotLeft) * v.scaleX : v.top - e + (a.plotY + c.plotTop) * v.scaleY, 0, q ? p : d] : [q ? f : b, q ? a.plotX + c.plotLeft : a.plotY + c.plotTop, q ? c.plotLeft : c.plotTop, q ? c.plotLeft + c.plotWidth : c.plotTop + c.plotHeight]);
              },
                  m = h("y"),
                  w = h("x"),
                  k,
                  n = !this.followPointer && x(a.ttBelow, !c.inverted === !!a.negative),
                  H = function H(b, f, a, c, p, d, h) {
                var z = g ? "y" === b ? e * v.scaleY : e * v.scaleX : e,
                    m = (a - c) / 2,
                    F = c < p - e,
                    I = p + e + c < f,
                    w = p - z - a + m;
                p = p + z - m;
                if (n && I) q[b] = p;else if (!n && F) q[b] = w;else if (F) q[b] = Math.min(h - c, 0 > w - l ? w : w - l);else if (I) q[b] = Math.max(d, p + l + a > f ? p : p + l);else return !1;
              },
                  t = function t(b, f, a, l, c) {
                var p;
                c < e || c > f - e ? p = !1 : q[b] = c < a / 2 ? 1 : c > f - l / 2 ? f - l - 2 : c - a / 2;
                return p;
              },
                  Q = function Q(b) {
                var e = m;
                m = w;
                w = e;
                k = b;
              },
                  y = function y() {
                !1 !== H.apply(0, m) ? !1 !== t.apply(0, w) || k || (Q(!0), y()) : k ? q.x = q.y = 0 : (Q(!0), y());
              };

              (c.inverted || 1 < this.len) && Q();
              y();
              return q;
            };

            c.prototype.hide = function (f) {
              var b = this;
              D.clearTimeout(this.hideTimer);
              f = x(f, this.options.hideDelay);
              this.isHidden || (this.hideTimer = H(function () {
                b.getLabel().fadeOut(f ? void 0 : f);
                b.isHidden = !0;
              }, f));
            };

            c.prototype.init = function (f, b) {
              this.chart = f;
              this.options = b;
              this.crosshairs = [];
              this.now = {
                x: 0,
                y: 0
              };
              this.isHidden = !0;
              this.split = b.split && !f.inverted && !f.polar;
              this.shared = b.shared || this.split;
              this.outside = x(b.outside, !(!f.scrollablePixelsX && !f.scrollablePixelsY));
            };

            c.prototype.shouldStickOnContact = function () {
              return !(this.followPointer || !this.options.stickOnContact);
            };

            c.prototype.isStickyOnContact = function () {
              return !(!this.shouldStickOnContact() || !this.inContact);
            };

            c.prototype.move = function (f, b, a, c) {
              var e = this,
                  q = e.now,
                  l = !1 !== e.options.animation && !e.isHidden && (1 < Math.abs(f - q.x) || 1 < Math.abs(b - q.y)),
                  g = e.followPointer || 1 < e.len;
              n(q, {
                x: l ? (2 * q.x + f) / 3 : f,
                y: l ? (q.y + b) / 2 : b,
                anchorX: g ? void 0 : l ? (2 * q.anchorX + a) / 3 : a,
                anchorY: g ? void 0 : l ? (q.anchorY + c) / 2 : c
              });
              e.getLabel().attr(q);
              e.drawTracker();
              l && (D.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                e && e.move(f, b, a, c);
              }, 32));
            };

            c.prototype.refresh = function (f, b) {
              var a = this.chart,
                  c = this.options,
                  e = R(f),
                  q = e[0],
                  l = [],
                  g = c.formatter || this.defaultFormatter,
                  p = this.shared,
                  d = a.styledMode,
                  h = {};

              if (c.enabled) {
                D.clearTimeout(this.hideTimer);
                this.followPointer = !this.split && q.series.tooltipOptions.followPointer;
                var m = this.getAnchor(f, b),
                    w = m[0],
                    k = m[1];
                !p || !O(f) && f.series && f.series.noSharedTooltip ? h = q.getLabelConfig() : (a.pointer.applyInactiveState(e), e.forEach(function (b) {
                  b.setState("hover");
                  l.push(b.getLabelConfig());
                }), h = {
                  x: q.category,
                  y: q.y
                }, h.points = l);
                this.len = l.length;
                f = g.call(h, this);
                g = q.series;
                this.distance = x(g.tooltipOptions.distance, 16);
                if (!1 === f) this.hide();else {
                  if (this.split) this.renderSplit(f, e);else if (e = w, p = k, b && a.pointer.isDirectTouch && (e = b.chartX - a.plotLeft, p = b.chartY - a.plotTop), a.polar || !1 === g.options.clip || g.shouldShowTooltip(e, p)) b = this.getLabel(), c.style.width && !d || b.css({
                    width: this.chart.spacingBox.width + "px"
                  }), b.attr({
                    text: f && f.join ? f.join("") : f
                  }), b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + x(q.colorIndex, g.colorIndex)), d || b.attr({
                    stroke: c.borderColor || q.color || g.color || E.neutralColor60
                  }), this.updatePosition({
                    plotX: w,
                    plotY: k,
                    negative: q.negative,
                    ttBelow: q.ttBelow,
                    h: m[2] || 0
                  });else {
                    this.hide();
                    return;
                  }
                  this.isHidden && this.label && this.label.attr({
                    opacity: 1
                  }).show();
                  this.isHidden = !1;
                }
                t(this, "refresh");
              }
            };

            c.prototype.renderSplit = function (f, b) {
              function a(b, e, f, a, l) {
                void 0 === l && (l = !0);
                f ? (e = B ? 0 : K, b = h(b - a / 2, U.left, U.right - a - (c.outside ? D : 0))) : (e -= C, b = l ? b - a - O : b + O, b = h(b, l ? b : U.left, U.right));
                return {
                  x: b,
                  y: e
                };
              }

              var c = this,
                  e = c.chart,
                  q = c.chart,
                  l = q.chartWidth,
                  g = q.chartHeight,
                  p = q.plotHeight,
                  d = q.plotLeft,
                  m = q.plotTop,
                  w = q.pointer,
                  k = q.scrollablePixelsY;
              k = void 0 === k ? 0 : k;
              var u = q.scrollablePixelsX,
                  H = q.scrollingContainer;
              H = void 0 === H ? {
                scrollLeft: 0,
                scrollTop: 0
              } : H;
              var t = H.scrollLeft;
              H = H.scrollTop;
              var y = q.styledMode,
                  O = c.distance,
                  Q = c.options,
                  X = c.options.positioner,
                  U = c.outside && "number" !== typeof u ? A.documentElement.getBoundingClientRect() : {
                left: t,
                right: t + l,
                top: H,
                bottom: H + g
              },
                  L = c.getLabel(),
                  R = this.renderer || e.renderer,
                  B = !(!e.xAxis[0] || !e.xAxis[0].opposite);
              e = w.getChartPosition();
              var D = e.left;
              e = e.top;
              var C = m + H,
                  G = 0,
                  K = p - k;
              N(f) && (f = [!1, f]);
              f = f.slice(0, b.length + 1).reduce(function (e, f, l) {
                if (!1 !== f && "" !== f) {
                  l = b[l - 1] || {
                    isHeader: !0,
                    plotX: b[0].plotX,
                    plotY: p,
                    series: {}
                  };
                  var q = l.isHeader,
                      g = q ? c : l.series;
                  f = f.toString();
                  var v = g.tt,
                      z = l.isHeader;
                  var F = l.series;
                  var w = "highcharts-color-" + x(l.colorIndex, F.colorIndex, "none");
                  v || (v = {
                    padding: Q.padding,
                    r: Q.borderRadius
                  }, y || (v.fill = Q.backgroundColor, v["stroke-width"] = Q.borderWidth), v = R.label("", 0, 0, Q[z ? "headerShape" : "shape"], void 0, void 0, Q.useHTML).addClass((z ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + w).attr(v).add(L));
                  v.isActive = !0;
                  v.attr({
                    text: f
                  });
                  y || v.css(Q.style).shadow(Q.shadow).attr({
                    stroke: Q.borderColor || l.color || F.color || E.neutralColor80
                  });
                  g = g.tt = v;
                  z = g.getBBox();
                  f = z.width + g.strokeWidth();
                  q && (G = z.height, K += G, B && (C -= G));
                  F = l.plotX;
                  F = void 0 === F ? 0 : F;
                  w = l.plotY;
                  w = void 0 === w ? 0 : w;
                  v = l.series;

                  if (l.isHeader) {
                    F = d + F;
                    var I = m + p / 2;
                  } else {
                    var k = v.xAxis,
                        n = v.yAxis;
                    F = k.pos + h(F, -O, k.len + O);
                    v.shouldShowTooltip(0, n.pos - m + w, {
                      ignoreX: !0
                    }) && (I = n.pos + w);
                  }

                  F = h(F, U.left - O, U.right + O);
                  "number" === typeof I ? (z = z.height + 1, w = X ? X.call(c, f, z, l) : a(F, I, q, f), e.push({
                    align: X ? 0 : void 0,
                    anchorX: F,
                    anchorY: I,
                    boxWidth: f,
                    point: l,
                    rank: x(w.rank, q ? 1 : 0),
                    size: z,
                    target: w.y,
                    tt: g,
                    x: w.x
                  })) : g.isActive = !1;
                }

                return e;
              }, []);
              !X && f.some(function (b) {
                var e = (c.outside ? D : 0) + b.anchorX;
                return e < U.left && e + b.boxWidth < U.right ? !0 : e < D - U.left + b.boxWidth && U.right - e > e;
              }) && (f = f.map(function (b) {
                var e = a(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
                return n(b, {
                  target: e.y,
                  x: e.x
                });
              }));
              c.cleanSplit();
              r(f, K);
              var M = D,
                  aa = D;
              f.forEach(function (b) {
                var e = b.x,
                    f = b.boxWidth;
                b = b.isHeader;
                b || (c.outside && D + e < M && (M = D + e), !b && c.outside && M + f > aa && (aa = D + e));
              });
              f.forEach(function (b) {
                var e = b.x,
                    f = b.anchorX,
                    a = b.pos,
                    l = b.point.isHeader;
                a = {
                  visibility: "undefined" === typeof a ? "hidden" : "inherit",
                  x: e,
                  y: a + C,
                  anchorX: f,
                  anchorY: b.anchorY
                };

                if (c.outside && e < f) {
                  var p = D - M;
                  0 < p && (l || (a.x = e + p, a.anchorX = f + p), l && (a.x = (aa - M) / 2, a.anchorX = f + p));
                }

                b.tt.attr(a);
              });
              f = c.container;
              k = c.renderer;
              c.outside && f && k && (q = L.getBBox(), k.setSize(q.width + q.x, q.height + q.y, !1), f.style.left = M + "px", f.style.top = e + "px");
            };

            c.prototype.drawTracker = function () {
              if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
                var f = this.chart,
                    b = this.label,
                    a = this.shared ? f.hoverPoints : f.hoverPoint;

                if (b && a) {
                  var c = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                  a = this.getAnchor(a);
                  var e = b.getBBox();
                  a[0] += f.plotLeft - b.translateX;
                  a[1] += f.plotTop - b.translateY;
                  c.x = Math.min(0, a[0]);
                  c.y = Math.min(0, a[1]);
                  c.width = 0 > a[0] ? Math.max(Math.abs(a[0]), e.width - a[0]) : Math.max(Math.abs(a[0]), e.width);
                  c.height = 0 > a[1] ? Math.max(Math.abs(a[1]), e.height - Math.abs(a[1])) : Math.max(Math.abs(a[1]), e.height);
                  this.tracker ? this.tracker.attr(c) : (this.tracker = b.renderer.rect(c).addClass("highcharts-tracker").add(b), f.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                  }));
                }
              }
            };

            c.prototype.styledModeFormat = function (a) {
              return a.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };

            c.prototype.tooltipFooterHeaderFormatter = function (a, b) {
              var f = a.series,
                  c = f.tooltipOptions,
                  e = f.xAxis,
                  q = e && e.dateTime;
              e = {
                isFooter: b,
                labelConfig: a
              };
              var l = c.xDateFormat,
                  g = c[b ? "footerFormat" : "headerFormat"];
              t(this, "headerFormatter", e, function (b) {
                q && !l && m(a.key) && (l = q.getXDateFormat(a.key, c.dateTimeLabelFormats));
                q && l && (a.point && a.point.tooltipDateKeys || ["key"]).forEach(function (b) {
                  g = g.replace("{point." + b + "}", "{point." + b + ":" + l + "}");
                });
                f.chart.styledMode && (g = this.styledModeFormat(g));
                b.text = B(g, {
                  point: a,
                  series: f
                }, this.chart);
              });
              return e.text;
            };

            c.prototype.update = function (a) {
              this.destroy();
              L(!0, this.chart.options.tooltip.userOptions, a);
              this.init(this.chart, L(!0, this.options, a));
            };

            c.prototype.updatePosition = function (f) {
              var b = this.chart,
                  c = this.options,
                  g = b.pointer,
                  e = this.getLabel();
              g = g.getChartPosition();
              var q = (c.positioner || this.getPosition).call(this, e.width, e.height, f),
                  l = f.plotX + b.plotLeft;
              f = f.plotY + b.plotTop;

              if (this.outside) {
                c = c.borderWidth + 2 * this.distance;
                this.renderer.setSize(e.width + c, e.height + c, !1);
                if (1 !== g.scaleX || 1 !== g.scaleY) a(this.container, {
                  transform: "scale(" + g.scaleX + ", " + g.scaleY + ")"
                }), l *= g.scaleX, f *= g.scaleY;
                l += g.left - q.x;
                f += g.top - q.y;
              }

              this.move(Math.round(q.x), Math.round(q.y || 0), l, f);
            };

            return c;
          }();

          "";
          return c;
        });
        M(d, "Core/Series/Point.js", [d["Core/Renderer/HTML/AST.js"], d["Core/Animation/AnimationUtilities.js"], d["Core/DefaultOptions.js"], d["Core/FormatUtilities.js"], d["Core/Utilities.js"]], function (c, d, E, G, C) {
          var D = d.animObject,
              B = E.defaultOptions,
              A = G.format,
              r = C.addEvent,
              k = C.defined,
              h = C.erase,
              a = C.extend,
              g = C.fireEvent,
              y = C.getNestedProperty,
              n = C.isArray,
              t = C.isFunction,
              O = C.isNumber,
              m = C.isObject,
              N = C.merge,
              L = C.objectEach,
              x = C.pick,
              R = C.syncTimeout,
              H = C.removeEvent,
              w = C.uniqueKey;

          d = function () {
            function f() {
              this.colorIndex = this.category = void 0;
              this.formatPrefix = "point";
              this.id = void 0;
              this.isNull = !1;
              this.percentage = this.options = this.name = void 0;
              this.selected = !1;
              this.total = this.series = void 0;
              this.visible = !0;
              this.x = void 0;
            }

            f.prototype.animateBeforeDestroy = function () {
              var b = this,
                  f = {
                x: b.startXPos,
                opacity: 0
              },
                  c = b.getGraphicalProps();
              c.singular.forEach(function (e) {
                b[e] = b[e].animate("dataLabel" === e ? {
                  x: b[e].startXPos,
                  y: b[e].startYPos,
                  opacity: 0
                } : f);
              });
              c.plural.forEach(function (e) {
                b[e].forEach(function (e) {
                  e.element && e.animate(a({
                    x: b.startXPos
                  }, e.startYPos ? {
                    x: e.startXPos,
                    y: e.startYPos
                  } : {}));
                });
              });
            };

            f.prototype.applyOptions = function (b, c) {
              var g = this.series,
                  e = g.options.pointValKey || g.pointValKey;
              b = f.prototype.optionsToObject.call(this, b);
              a(this, b);
              this.options = this.options ? a(this.options, b) : b;
              b.group && delete this.group;
              b.dataLabels && delete this.dataLabels;
              e && (this.y = f.prototype.getNestedProperty.call(this, e));
              this.formatPrefix = (this.isNull = x(this.isValid && !this.isValid(), null === this.x || !O(this.y))) ? "null" : "point";
              this.selected && (this.state = "select");
              "name" in this && "undefined" === typeof c && g.xAxis && g.xAxis.hasNames && (this.x = g.xAxis.nameToX(this));
              "undefined" === typeof this.x && g ? this.x = "undefined" === typeof c ? g.autoIncrement() : c : O(b.x) && g.options.relativeXValue && (this.x = g.autoIncrement(b.x));
              return this;
            };

            f.prototype.destroy = function () {
              function b() {
                if (a.graphic || a.dataLabel || a.dataLabels) H(a), a.destroyElements();

                for (g in a) {
                  a[g] = null;
                }
              }

              var a = this,
                  f = a.series,
                  e = f.chart;
              f = f.options.dataSorting;
              var c = e.hoverPoints,
                  l = D(a.series.chart.renderer.globalAnimation),
                  g;
              a.legendItem && e.legend.destroyItem(a);
              c && (a.setState(), h(c, a), c.length || (e.hoverPoints = null));
              if (a === e.hoverPoint) a.onMouseOut();
              f && f.enabled ? (this.animateBeforeDestroy(), R(b, l.duration)) : b();
              e.pointCount--;
            };

            f.prototype.destroyElements = function (b) {
              var a = this;
              b = a.getGraphicalProps(b);
              b.singular.forEach(function (b) {
                a[b] = a[b].destroy();
              });
              b.plural.forEach(function (b) {
                a[b].forEach(function (b) {
                  b.element && b.destroy();
                });
                delete a[b];
              });
            };

            f.prototype.firePointEvent = function (b, a, f) {
              var e = this,
                  c = this.series.options;
              (c.point.events[b] || e.options && e.options.events && e.options.events[b]) && e.importEvents();
              "click" === b && c.allowPointSelect && (f = function f(b) {
                e.select && e.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
              });
              g(e, b, a, f);
            };

            f.prototype.getClassName = function () {
              return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };

            f.prototype.getGraphicalProps = function (b) {
              var a = this,
                  f = [],
                  e = {
                singular: [],
                plural: []
              },
                  c;
              b = b || {
                graphic: 1,
                dataLabel: 1
              };
              b.graphic && f.push("graphic", "upperGraphic", "shadowGroup");
              b.dataLabel && f.push("dataLabel", "dataLabelUpper", "connector");

              for (c = f.length; c--;) {
                var l = f[c];
                a[l] && e.singular.push(l);
              }

              ["dataLabel", "connector"].forEach(function (f) {
                var l = f + "s";
                b[f] && a[l] && e.plural.push(l);
              });
              return e;
            };

            f.prototype.getLabelConfig = function () {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
              };
            };

            f.prototype.getNestedProperty = function (b) {
              if (b) return 0 === b.indexOf("custom.") ? y(b, this.options) : this[b];
            };

            f.prototype.getZone = function () {
              var b = this.series,
                  a = b.zones;
              b = b.zoneAxis || "y";
              var f,
                  e = 0;

              for (f = a[e]; this[b] >= f.value;) {
                f = a[++e];
              }

              this.nonZonedColor || (this.nonZonedColor = this.color);
              this.color = f && f.color && !this.options.color ? f.color : this.nonZonedColor;
              return f;
            };

            f.prototype.hasNewShapeType = function () {
              return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };

            f.prototype.init = function (b, a, f) {
              this.series = b;
              this.applyOptions(a, f);
              this.id = k(this.id) ? this.id : w();
              this.resolveColor();
              b.chart.pointCount++;
              g(this, "afterInit");
              return this;
            };

            f.prototype.optionsToObject = function (b) {
              var a = this.series,
                  c = a.options.keys,
                  e = c || a.pointArrayMap || ["y"],
                  g = e.length,
                  l = {},
                  d = 0,
                  p = 0;
              if (O(b) || null === b) l[e[0]] = b;else if (n(b)) for (!c && b.length > g && (a = typeof b[0], "string" === a ? l.name = b[0] : "number" === a && (l.x = b[0]), d++); p < g;) {
                c && "undefined" === typeof b[d] || (0 < e[p].indexOf(".") ? f.prototype.setNestedProperty(l, b[d], e[p]) : l[e[p]] = b[d]), d++, p++;
              } else "object" === typeof b && (l = b, b.dataLabels && (a._hasPointLabels = !0), b.marker && (a._hasPointMarkers = !0));
              return l;
            };

            f.prototype.resolveColor = function () {
              var b = this.series,
                  a = b.chart.styledMode;
              var f = b.chart.options.chart.colorCount;
              delete this.nonZonedColor;

              if (b.options.colorByPoint) {
                if (!a) {
                  f = b.options.colors || b.chart.options.colors;
                  var e = f[b.colorCounter];
                  f = f.length;
                }

                a = b.colorCounter;
                b.colorCounter++;
                b.colorCounter === f && (b.colorCounter = 0);
              } else a || (e = b.color), a = b.colorIndex;

              this.colorIndex = x(this.options.colorIndex, a);
              this.color = x(this.options.color, e);
            };

            f.prototype.setNestedProperty = function (b, a, f) {
              f.split(".").reduce(function (b, f, l, c) {
                b[f] = c.length - 1 === l ? a : m(b[f], !0) ? b[f] : {};
                return b[f];
              }, b);
              return b;
            };

            f.prototype.tooltipFormatter = function (b) {
              var a = this.series,
                  f = a.tooltipOptions,
                  e = x(f.valueDecimals, ""),
                  c = f.valuePrefix || "",
                  l = f.valueSuffix || "";
              a.chart.styledMode && (b = a.chart.tooltip.styledModeFormat(b));
              (a.pointArrayMap || ["y"]).forEach(function (a) {
                a = "{point." + a;
                if (c || l) b = b.replace(RegExp(a + "}", "g"), c + a + "}" + l);
                b = b.replace(RegExp(a + "}", "g"), a + ":,." + e + "f}");
              });
              return A(b, {
                point: this,
                series: this.series
              }, a.chart);
            };

            f.prototype.update = function (b, a, f, e) {
              function c() {
                l.applyOptions(b);
                var e = p && l.hasDummyGraphic;
                e = null === l.y ? !e : e;
                p && e && (l.graphic = p.destroy(), delete l.hasDummyGraphic);
                m(b, !0) && (p && p.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (l.graphic = p.destroy()), b && b.dataLabels && l.dataLabel && (l.dataLabel = l.dataLabel.destroy()), l.connector && (l.connector = l.connector.destroy()));
                v = l.index;
                g.updateParallelArrays(l, v);
                h.data[v] = m(h.data[v], !0) || m(b, !0) ? l.options : x(b, h.data[v]);
                g.isDirty = g.isDirtyData = !0;
                !g.fixedBox && g.hasCartesianSeries && (d.isDirtyBox = !0);
                "point" === h.legendType && (d.isDirtyLegend = !0);
                a && d.redraw(f);
              }

              var l = this,
                  g = l.series,
                  p = l.graphic,
                  d = g.chart,
                  h = g.options,
                  v;
              a = x(a, !0);
              !1 === e ? c() : l.firePointEvent("update", {
                options: b
              }, c);
            };

            f.prototype.remove = function (b, a) {
              this.series.removePoint(this.series.data.indexOf(this), b, a);
            };

            f.prototype.select = function (b, a) {
              var f = this,
                  e = f.series,
                  c = e.chart;
              this.selectedStaging = b = x(b, !f.selected);
              f.firePointEvent(b ? "select" : "unselect", {
                accumulate: a
              }, function () {
                f.selected = f.options.selected = b;
                e.options.data[e.data.indexOf(f)] = f.options;
                f.setState(b && "select");
                a || c.getSelectedPoints().forEach(function (b) {
                  var e = b.series;
                  b.selected && b !== f && (b.selected = b.options.selected = !1, e.options.data[e.data.indexOf(b)] = b.options, b.setState(c.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
                });
              });
              delete this.selectedStaging;
            };

            f.prototype.onMouseOver = function (b) {
              var a = this.series.chart,
                  f = a.pointer;
              b = b ? f.normalize(b) : f.getChartCoordinatesFromPoint(this, a.inverted);
              f.runPointActions(b, this);
            };

            f.prototype.onMouseOut = function () {
              var b = this.series.chart;
              this.firePointEvent("mouseOut");
              this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {
                b.setState();
              });
              b.hoverPoints = b.hoverPoint = null;
            };

            f.prototype.importEvents = function () {
              if (!this.hasImportedEvents) {
                var b = this,
                    a = N(b.series.options.point, b.options).events;
                b.events = a;
                L(a, function (a, e) {
                  t(a) && r(b, e, a);
                });
                this.hasImportedEvents = !0;
              }
            };

            f.prototype.setState = function (b, f) {
              var d = this.series,
                  e = this.state,
                  q = d.options.states[b || "normal"] || {},
                  l = B.plotOptions[d.type].marker && d.options.marker,
                  h = l && !1 === l.enabled,
                  p = l && l.states && l.states[b || "normal"] || {},
                  m = !1 === p.enabled,
                  v = this.marker || {},
                  w = d.chart,
                  k = l && d.markerAttribs,
                  n = d.halo,
                  H,
                  t = d.stateMarkerGraphic;
              b = b || "";

              if (!(b === this.state && !f || this.selected && "select" !== b || !1 === q.enabled || b && (m || h && !1 === p.enabled) || b && v.states && v.states[b] && !1 === v.states[b].enabled)) {
                this.state = b;
                k && (H = d.markerAttribs(this, b));

                if (this.graphic && !this.hasDummyGraphic) {
                  e && this.graphic.removeClass("highcharts-point-" + e);
                  b && this.graphic.addClass("highcharts-point-" + b);

                  if (!w.styledMode) {
                    var y = d.pointAttribs(this, b);
                    var r = x(w.options.chart.animation, q.animation);
                    d.options.inactiveOtherPoints && O(y.opacity) && ((this.dataLabels || []).forEach(function (b) {
                      b && b.animate({
                        opacity: y.opacity
                      }, r);
                    }), this.connector && this.connector.animate({
                      opacity: y.opacity
                    }, r));
                    this.graphic.animate(y, r);
                  }

                  H && this.graphic.animate(H, x(w.options.chart.animation, p.animation, l.animation));
                  t && t.hide();
                } else {
                  if (b && p) {
                    e = v.symbol || d.symbol;
                    t && t.currentSymbol !== e && (t = t.destroy());
                    if (H) if (t) t[f ? "animate" : "attr"]({
                      x: H.x,
                      y: H.y
                    });else e && (d.stateMarkerGraphic = t = w.renderer.symbol(e, H.x, H.y, H.width, H.height).add(d.markerGroup), t.currentSymbol = e);
                    !w.styledMode && t && t.attr(d.pointAttribs(this, b));
                  }

                  t && (t[b && this.isInside ? "show" : "hide"](), t.element.point = this, t.addClass(this.getClassName(), !0));
                }

                q = q.halo;
                H = (t = this.graphic || t) && t.visibility || "inherit";
                q && q.size && t && "hidden" !== H && !this.isCluster ? (n || (d.halo = n = w.renderer.path().add(t.parentGroup)), n.show()[f ? "animate" : "attr"]({
                  d: this.haloPath(q.size)
                }), n.attr({
                  "class": "highcharts-halo highcharts-color-" + x(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
                  visibility: H,
                  zIndex: -1
                }), n.point = this, w.styledMode || n.attr(a({
                  fill: this.color || d.color,
                  "fill-opacity": q.opacity
                }, c.filterUserAttributes(q.attributes || {})))) : n && n.point && n.point.haloPath && n.animate({
                  d: n.point.haloPath(0)
                }, null, n.hide);
                g(this, "afterSetState", {
                  state: b
                });
              }
            };

            f.prototype.haloPath = function (b) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - b, this.plotY - b, 2 * b, 2 * b);
            };

            return f;
          }();

          "";
          return d;
        });
        M(d, "Core/Pointer.js", [d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Color/Palette.js"], d["Core/Tooltip.js"], d["Core/Utilities.js"]], function (c, d, E, G, C) {
          var D = c.parse,
              B = d.charts,
              A = d.noop,
              r = C.addEvent,
              k = C.attr,
              h = C.css,
              a = C.defined,
              g = C.extend,
              y = C.find,
              n = C.fireEvent,
              t = C.isNumber,
              O = C.isObject,
              m = C.objectEach,
              N = C.offset,
              L = C.pick,
              x = C.splat;

          c = function () {
            function c(a, c) {
              this.lastValidTouch = {};
              this.pinchDown = [];
              this.runChartClick = !1;
              this.eventsToUnbind = [];
              this.chart = a;
              this.hasDragged = !1;
              this.options = c;
              this.init(a, c);
            }

            c.prototype.applyInactiveState = function (a) {
              var c = [],
                  f;
              (a || []).forEach(function (b) {
                f = b.series;
                c.push(f);
                f.linkedParent && c.push(f.linkedParent);
                f.linkedSeries && (c = c.concat(f.linkedSeries));
                f.navigatorSeries && c.push(f.navigatorSeries);
              });
              this.chart.series.forEach(function (b) {
                -1 === c.indexOf(b) ? b.setState("inactive", !0) : b.options.inactiveOtherPoints && b.setAllPointsToState("inactive");
              });
            };

            c.prototype.destroy = function () {
              var a = this;
              this.eventsToUnbind.forEach(function (a) {
                return a();
              });
              this.eventsToUnbind = [];
              d.chartCount || (c.unbindDocumentMouseUp && (c.unbindDocumentMouseUp = c.unbindDocumentMouseUp()), c.unbindDocumentTouchEnd && (c.unbindDocumentTouchEnd = c.unbindDocumentTouchEnd()));
              clearInterval(a.tooltipTimeout);
              m(a, function (c, f) {
                a[f] = void 0;
              });
            };

            c.prototype.drag = function (a) {
              var c = this.chart,
                  f = c.options.chart,
                  b = this.zoomHor,
                  g = this.zoomVert,
                  d = c.plotLeft,
                  e = c.plotTop,
                  q = c.plotWidth,
                  l = c.plotHeight,
                  h = this.mouseDownX || 0,
                  p = this.mouseDownY || 0,
                  m = O(f.panning) ? f.panning && f.panning.enabled : f.panning,
                  k = f.panKey && a[f.panKey + "Key"],
                  n = a.chartX,
                  H = a.chartY,
                  u = this.selectionMarker;
              if (!u || !u.touch) if (n < d ? n = d : n > d + q && (n = d + q), H < e ? H = e : H > e + l && (H = e + l), this.hasDragged = Math.sqrt(Math.pow(h - n, 2) + Math.pow(p - H, 2)), 10 < this.hasDragged) {
                var t = c.isInsidePlot(h - d, p - e, {
                  visiblePlotOnly: !0
                });
                c.hasCartesianSeries && (this.zoomX || this.zoomY) && t && !k && !u && (this.selectionMarker = u = c.renderer.rect(d, e, b ? 1 : q, g ? 1 : l, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add(), c.styledMode || u.attr({
                  fill: f.selectionMarkerFill || D(E.highlightColor80).setOpacity(.25).get()
                }));
                u && b && (b = n - h, u.attr({
                  width: Math.abs(b),
                  x: (0 < b ? 0 : b) + h
                }));
                u && g && (b = H - p, u.attr({
                  height: Math.abs(b),
                  y: (0 < b ? 0 : b) + p
                }));
                t && !u && m && c.pan(a, f.panning);
              }
            };

            c.prototype.dragStart = function (a) {
              var c = this.chart;
              c.mouseIsDown = a.type;
              c.cancelClick = !1;
              c.mouseDownX = this.mouseDownX = a.chartX;
              c.mouseDownY = this.mouseDownY = a.chartY;
            };

            c.prototype.drop = function (c) {
              var d = this,
                  f = this.chart,
                  b = this.hasPinched;

              if (this.selectionMarker) {
                var m = {
                  originalEvent: c,
                  xAxis: [],
                  yAxis: []
                },
                    k = this.selectionMarker,
                    e = k.attr ? k.attr("x") : k.x,
                    q = k.attr ? k.attr("y") : k.y,
                    l = k.attr ? k.attr("width") : k.width,
                    I = k.attr ? k.attr("height") : k.height,
                    p;
                if (this.hasDragged || b) f.axes.forEach(function (f) {
                  if (f.zoomEnabled && a(f.min) && (b || d[{
                    xAxis: "zoomX",
                    yAxis: "zoomY"
                  }[f.coll]]) && t(e) && t(q)) {
                    var g = f.horiz,
                        h = "touchend" === c.type ? f.minPixelPadding : 0,
                        z = f.toValue((g ? e : q) + h);
                    g = f.toValue((g ? e + l : q + I) - h);
                    m[f.coll].push({
                      axis: f,
                      min: Math.min(z, g),
                      max: Math.max(z, g)
                    });
                    p = !0;
                  }
                }), p && n(f, "selection", m, function (e) {
                  f.zoom(g(e, b ? {
                    animation: !1
                  } : null));
                });
                t(f.index) && (this.selectionMarker = this.selectionMarker.destroy());
                b && this.scaleGroups();
              }

              f && t(f.index) && (h(f.container, {
                cursor: f._cursor
              }), f.cancelClick = 10 < this.hasDragged, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
            };

            c.prototype.findNearestKDPoint = function (a, c, f) {
              var b = this.chart,
                  g = b.hoverPoint;
              b = b.tooltip;
              if (g && b && b.isStickyOnContact()) return g;
              var d;
              a.forEach(function (b) {
                var e = !(b.noSharedTooltip && c) && 0 > b.options.findNearestPointBy.indexOf("y");
                b = b.searchPoint(f, e);

                if ((e = O(b, !0) && b.series) && !(e = !O(d, !0))) {
                  e = d.distX - b.distX;
                  var a = d.dist - b.dist,
                      g = (b.series.group && b.series.group.zIndex) - (d.series.group && d.series.group.zIndex);
                  e = 0 < (0 !== e && c ? e : 0 !== a ? a : 0 !== g ? g : d.series.index > b.series.index ? -1 : 1);
                }

                e && (d = b);
              });
              return d;
            };

            c.prototype.getChartCoordinatesFromPoint = function (a, c) {
              var f = a.series,
                  b = f.xAxis;
              f = f.yAxis;
              var g = a.shapeArgs;

              if (b && f) {
                var d = L(a.clientX, a.plotX),
                    e = a.plotY || 0;
                a.isNode && g && t(g.x) && t(g.y) && (d = g.x, e = g.y);
                return c ? {
                  chartX: f.len + f.pos - e,
                  chartY: b.len + b.pos - d
                } : {
                  chartX: d + b.pos,
                  chartY: e + f.pos
                };
              }

              if (g && g.x && g.y) return {
                chartX: g.x,
                chartY: g.y
              };
            };

            c.prototype.getChartPosition = function () {
              if (this.chartPosition) return this.chartPosition;
              var a = this.chart.container,
                  c = N(a);
              this.chartPosition = {
                left: c.left,
                top: c.top,
                scaleX: 1,
                scaleY: 1
              };
              var f = a.offsetWidth;
              a = a.offsetHeight;
              2 < f && 2 < a && (this.chartPosition.scaleX = c.width / f, this.chartPosition.scaleY = c.height / a);
              return this.chartPosition;
            };

            c.prototype.getCoordinates = function (a) {
              var c = {
                xAxis: [],
                yAxis: []
              };
              this.chart.axes.forEach(function (f) {
                c[f.isXAxis ? "xAxis" : "yAxis"].push({
                  axis: f,
                  value: f.toValue(a[f.horiz ? "chartX" : "chartY"])
                });
              });
              return c;
            };

            c.prototype.getHoverData = function (a, c, f, b, g, d) {
              var e = [];
              b = !(!b || !a);
              var q = {
                chartX: d ? d.chartX : void 0,
                chartY: d ? d.chartY : void 0,
                shared: g
              };
              n(this, "beforeGetHoverData", q);
              var l = c && !c.stickyTracking ? [c] : f.filter(function (b) {
                return q.filter ? q.filter(b) : b.visible && !(!g && b.directTouch) && L(b.options.enableMouseTracking, !0) && b.stickyTracking;
              });
              var h = b || !d ? a : this.findNearestKDPoint(l, g, d);
              c = h && h.series;
              h && (g && !c.noSharedTooltip ? (l = f.filter(function (b) {
                return q.filter ? q.filter(b) : b.visible && !(!g && b.directTouch) && L(b.options.enableMouseTracking, !0) && !b.noSharedTooltip;
              }), l.forEach(function (b) {
                var a = y(b.points, function (b) {
                  return b.x === h.x && !b.isNull;
                });
                O(a) && (b.chart.isBoosting && (a = b.getPoint(a)), e.push(a));
              })) : e.push(h));
              q = {
                hoverPoint: h
              };
              n(this, "afterGetHoverData", q);
              return {
                hoverPoint: q.hoverPoint,
                hoverSeries: c,
                hoverPoints: e
              };
            };

            c.prototype.getPointFromEvent = function (a) {
              a = a.target;

              for (var c; a && !c;) {
                c = a.point, a = a.parentNode;
              }

              return c;
            };

            c.prototype.onTrackerMouseOut = function (a) {
              a = a.relatedTarget || a.toElement;
              var c = this.chart.hoverSeries;
              this.isDirectTouch = !1;
              if (!(!c || !a || c.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + c.index) && this.inClass(a, "highcharts-tracker"))) c.onMouseOut();
            };

            c.prototype.inClass = function (a, c) {
              for (var f; a;) {
                if (f = k(a, "class")) {
                  if (-1 !== f.indexOf(c)) return !0;
                  if (-1 !== f.indexOf("highcharts-container")) return !1;
                }

                a = a.parentNode;
              }
            };

            c.prototype.init = function (a, c) {
              this.options = c;
              this.chart = a;
              this.runChartClick = !(!c.chart.events || !c.chart.events.click);
              this.pinchDown = [];
              this.lastValidTouch = {};
              G && (a.tooltip = new G(a, c.tooltip), this.followTouchMove = L(c.tooltip.followTouchMove, !0));
              this.setDOMEvents();
            };

            c.prototype.normalize = function (a, c) {
              var f = a.touches,
                  b = f ? f.length ? f.item(0) : L(f.changedTouches, a.changedTouches)[0] : a;
              c || (c = this.getChartPosition());
              f = b.pageX - c.left;
              b = b.pageY - c.top;
              f /= c.scaleX;
              b /= c.scaleY;
              return g(a, {
                chartX: Math.round(f),
                chartY: Math.round(b)
              });
            };

            c.prototype.onContainerClick = function (a) {
              var c = this.chart,
                  f = c.hoverPoint;
              a = this.normalize(a);
              var b = c.plotLeft,
                  d = c.plotTop;
              c.cancelClick || (f && this.inClass(a.target, "highcharts-tracker") ? (n(f.series, "click", g(a, {
                point: f
              })), c.hoverPoint && f.firePointEvent("click", a)) : (g(a, this.getCoordinates(a)), c.isInsidePlot(a.chartX - b, a.chartY - d, {
                visiblePlotOnly: !0
              }) && n(c, "click", a)));
            };

            c.prototype.onContainerMouseDown = function (a) {
              var c = 1 === ((a.buttons || a.button) & 1);
              a = this.normalize(a);
              if (d.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
              if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);
            };

            c.prototype.onContainerMouseLeave = function (a) {
              var g = B[L(c.hoverChartIndex, -1)],
                  f = this.chart.tooltip;
              f && f.shouldStickOnContact() && this.inClass(a.relatedTarget, "highcharts-tooltip-container") || (a = this.normalize(a), g && (a.relatedTarget || a.toElement) && (g.pointer.reset(), g.pointer.chartPosition = void 0), f && !f.isHidden && this.reset());
            };

            c.prototype.onContainerMouseEnter = function (a) {
              delete this.chartPosition;
            };

            c.prototype.onContainerMouseMove = function (a) {
              var c = this.chart;
              a = this.normalize(a);
              this.setHoverChartIndex();
              a.preventDefault || (a.returnValue = !1);
              ("mousedown" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);
              c.openMenu || !this.inClass(a.target, "highcharts-tracker") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
            };

            c.prototype.onDocumentTouchEnd = function (a) {
              var g = B[L(c.hoverChartIndex, -1)];
              g && g.pointer.drop(a);
            };

            c.prototype.onContainerTouchMove = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
            };

            c.prototype.onContainerTouchStart = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
            };

            c.prototype.onDocumentMouseMove = function (a) {
              var c = this.chart,
                  f = this.chartPosition;
              a = this.normalize(a, f);
              var b = c.tooltip;
              !f || b && b.isStickyOnContact() || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
            };

            c.prototype.onDocumentMouseUp = function (a) {
              var g = B[L(c.hoverChartIndex, -1)];
              g && g.pointer.drop(a);
            };

            c.prototype.pinch = function (a) {
              var c = this,
                  f = c.chart,
                  b = c.pinchDown,
                  d = a.touches || [],
                  h = d.length,
                  e = c.lastValidTouch,
                  q = c.hasZoom,
                  l = {},
                  m = 1 === h && (c.inClass(a.target, "highcharts-tracker") && f.runTrackerClick || c.runChartClick),
                  p = {},
                  z = c.selectionMarker;
              1 < h ? c.initiated = !0 : 1 === h && this.followTouchMove && (c.initiated = !1);
              q && c.initiated && !m && !1 !== a.cancelable && a.preventDefault();
              [].map.call(d, function (b) {
                return c.normalize(b);
              });
              "touchstart" === a.type ? ([].forEach.call(d, function (a, e) {
                b[e] = {
                  chartX: a.chartX,
                  chartY: a.chartY
                };
              }), e.x = [b[0].chartX, b[1] && b[1].chartX], e.y = [b[0].chartY, b[1] && b[1].chartY], f.axes.forEach(function (b) {
                if (b.zoomEnabled) {
                  var a = f.bounds[b.horiz ? "h" : "v"],
                      e = b.minPixelPadding,
                      c = b.toPixels(Math.min(L(b.options.min, b.dataMin), b.dataMin)),
                      l = b.toPixels(Math.max(L(b.options.max, b.dataMax), b.dataMax)),
                      g = Math.max(c, l);
                  a.min = Math.min(b.pos, Math.min(c, l) - e);
                  a.max = Math.max(b.pos + b.len, g + e);
                }
              }), c.res = !0) : c.followTouchMove && 1 === h ? this.runPointActions(c.normalize(a)) : b.length && (z || (c.selectionMarker = z = g({
                destroy: A,
                touch: !0
              }, f.plotBox)), c.pinchTranslate(b, d, l, z, p, e), c.hasPinched = q, c.scaleGroups(l, p), c.res && (c.res = !1, this.reset(!1, 0)));
            };

            c.prototype.pinchTranslate = function (a, c, f, b, g, d) {
              this.zoomHor && this.pinchTranslateDirection(!0, a, c, f, b, g, d);
              this.zoomVert && this.pinchTranslateDirection(!1, a, c, f, b, g, d);
            };

            c.prototype.pinchTranslateDirection = function (a, c, f, b, g, d, e, q) {
              var l = this.chart,
                  h = a ? "x" : "y",
                  p = a ? "X" : "Y",
                  m = "chart" + p,
                  v = a ? "width" : "height",
                  k = l["plot" + (a ? "Left" : "Top")],
                  n = l.inverted,
                  u = l.bounds[a ? "h" : "v"],
                  w = 1 === c.length,
                  F = c[0][m],
                  t = !w && c[1][m];

              c = function c() {
                "number" === typeof H && 20 < Math.abs(F - t) && (y = q || Math.abs(U - H) / Math.abs(F - t));
                Q = (k - U) / y + F;
                x = l["plot" + (a ? "Width" : "Height")] / y;
              };

              var x,
                  Q,
                  y = q || 1,
                  U = f[0][m],
                  H = !w && f[1][m];
              c();
              f = Q;

              if (f < u.min) {
                f = u.min;
                var r = !0;
              } else f + x > u.max && (f = u.max - x, r = !0);

              r ? (U -= .8 * (U - e[h][0]), "number" === typeof H && (H -= .8 * (H - e[h][1])), c()) : e[h] = [U, H];
              n || (d[h] = Q - k, d[v] = x);
              d = n ? 1 / y : y;
              g[v] = x;
              g[h] = f;
              b[n ? a ? "scaleY" : "scaleX" : "scale" + p] = y;
              b["translate" + p] = d * k + (U - d * F);
            };

            c.prototype.reset = function (a, c) {
              var f = this.chart,
                  b = f.hoverSeries,
                  g = f.hoverPoint,
                  d = f.hoverPoints,
                  e = f.tooltip,
                  q = e && e.shared ? d : g;
              a && q && x(q).forEach(function (b) {
                b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
              });
              if (a) e && q && x(q).length && (e.refresh(q), e.shared && d ? d.forEach(function (b) {
                b.setState(b.state, !0);
                b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
              }) : g && (g.setState(g.state, !0), f.axes.forEach(function (b) {
                b.crosshair && g.series[b.coll] === b && b.drawCrosshair(null, g);
              })));else {
                if (g) g.onMouseOut();
                d && d.forEach(function (b) {
                  b.setState();
                });
                if (b) b.onMouseOut();
                e && e.hide(c);
                this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                f.axes.forEach(function (b) {
                  b.hideCrosshair();
                });
                this.hoverX = f.hoverPoints = f.hoverPoint = null;
              }
            };

            c.prototype.runPointActions = function (a, g) {
              var f = this.chart,
                  b = f.tooltip && f.tooltip.options.enabled ? f.tooltip : void 0,
                  d = b ? b.shared : !1,
                  h = g || f.hoverPoint,
                  e = h && h.series || f.hoverSeries;
              g = this.getHoverData(h, e, f.series, (!a || "touchmove" !== a.type) && (!!g || e && e.directTouch && this.isDirectTouch), d, a);
              h = g.hoverPoint;
              e = g.hoverSeries;
              var q = g.hoverPoints;
              g = e && e.tooltipOptions.followPointer && !e.tooltipOptions.split;
              d = d && e && !e.noSharedTooltip;

              if (h && (h !== f.hoverPoint || b && b.isHidden)) {
                (f.hoverPoints || []).forEach(function (b) {
                  -1 === q.indexOf(b) && b.setState();
                });
                if (f.hoverSeries !== e) e.onMouseOver();
                this.applyInactiveState(q);
                (q || []).forEach(function (b) {
                  b.setState("hover");
                });
                f.hoverPoint && f.hoverPoint.firePointEvent("mouseOut");
                if (!h.series) return;
                f.hoverPoints = q;
                f.hoverPoint = h;
                h.firePointEvent("mouseOver");
                b && b.refresh(d ? q : h, a);
              } else g && b && !b.isHidden && (h = b.getAnchor([{}], a), f.isInsidePlot(h[0], h[1], {
                visiblePlotOnly: !0
              }) && b.updatePosition({
                plotX: h[0],
                plotY: h[1]
              }));

              this.unDocMouseMove || (this.unDocMouseMove = r(f.container.ownerDocument, "mousemove", function (b) {
                var a = B[c.hoverChartIndex];
                if (a) a.pointer.onDocumentMouseMove(b);
              }), this.eventsToUnbind.push(this.unDocMouseMove));
              f.axes.forEach(function (b) {
                var e = L((b.crosshair || {}).snap, !0),
                    c;
                e && ((c = f.hoverPoint) && c.series[b.coll] === b || (c = y(q, function (a) {
                  return a.series[b.coll] === b;
                })));
                c || !e ? b.drawCrosshair(a, c) : b.hideCrosshair();
              });
            };

            c.prototype.scaleGroups = function (a, c) {
              var f = this.chart;
              f.series.forEach(function (b) {
                var g = a || b.getPlotBox();
                b.xAxis && b.xAxis.zoomEnabled && b.group && (b.group.attr(g), b.markerGroup && (b.markerGroup.attr(g), b.markerGroup.clip(c ? f.clipRect : null)), b.dataLabelsGroup && b.dataLabelsGroup.attr(g));
              });
              f.clipRect.attr(c || f.clipBox);
            };

            c.prototype.setDOMEvents = function () {
              var a = this,
                  g = this.chart.container,
                  f = g.ownerDocument;
              g.onmousedown = this.onContainerMouseDown.bind(this);
              g.onmousemove = this.onContainerMouseMove.bind(this);
              g.onclick = this.onContainerClick.bind(this);
              this.eventsToUnbind.push(r(g, "mouseenter", this.onContainerMouseEnter.bind(this)));
              this.eventsToUnbind.push(r(g, "mouseleave", this.onContainerMouseLeave.bind(this)));
              c.unbindDocumentMouseUp || (c.unbindDocumentMouseUp = r(f, "mouseup", this.onDocumentMouseUp.bind(this)));

              for (var b = this.chart.renderTo.parentElement; b && "BODY" !== b.tagName;) {
                this.eventsToUnbind.push(r(b, "scroll", function () {
                  delete a.chartPosition;
                })), b = b.parentElement;
              }

              d.hasTouch && (this.eventsToUnbind.push(r(g, "touchstart", this.onContainerTouchStart.bind(this), {
                passive: !1
              })), this.eventsToUnbind.push(r(g, "touchmove", this.onContainerTouchMove.bind(this), {
                passive: !1
              })), c.unbindDocumentTouchEnd || (c.unbindDocumentTouchEnd = r(f, "touchend", this.onDocumentTouchEnd.bind(this), {
                passive: !1
              })));
            };

            c.prototype.setHoverChartIndex = function () {
              var a = this.chart,
                  g = d.charts[L(c.hoverChartIndex, -1)];
              if (g && g !== a) g.pointer.onContainerMouseLeave({
                relatedTarget: !0
              });
              g && g.mouseIsDown || (c.hoverChartIndex = a.index);
            };

            c.prototype.touch = function (a, c) {
              var f = this.chart,
                  b;
              this.setHoverChartIndex();
              if (1 === a.touches.length) {
                if (a = this.normalize(a), (b = f.isInsidePlot(a.chartX - f.plotLeft, a.chartY - f.plotTop, {
                  visiblePlotOnly: !0
                })) && !f.openMenu) {
                  c && this.runPointActions(a);

                  if ("touchmove" === a.type) {
                    c = this.pinchDown;
                    var g = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1;
                  }

                  L(g, !0) && this.pinch(a);
                } else c && this.reset();
              } else 2 === a.touches.length && this.pinch(a);
            };

            c.prototype.touchSelect = function (a) {
              return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
            };

            c.prototype.zoomOption = function (a) {
              var c = this.chart,
                  f = c.options.chart;
              c = c.inverted;
              var b = f.zoomType || "";
              /touch/.test(a.type) && (b = L(f.pinchType, b));
              this.zoomX = a = /x/.test(b);
              this.zoomY = f = /y/.test(b);
              this.zoomHor = a && !c || f && c;
              this.zoomVert = f && !c || a && c;
              this.hasZoom = a || f;
            };

            return c;
          }();

          "";
          return c;
        });
        M(d, "Core/MSPointer.js", [d["Core/Globals.js"], d["Core/Pointer.js"], d["Core/Utilities.js"]], function (c, d, E) {
          function B() {
            var a = [];

            a.item = function (a) {
              return this[a];
            };

            g(n, function (c) {
              a.push({
                pageX: c.pageX,
                pageY: c.pageY,
                target: c.target
              });
            });
            return a;
          }

          function C(a, c, g, h) {
            var m = K[d.hoverChartIndex || NaN];
            "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !m || (m = m.pointer, h(a), m[c]({
              type: g,
              target: a.currentTarget,
              preventDefault: r,
              touches: B()
            }));
          }

          var D = this && this.__extends || function () {
            var _a2 = function a(c, g) {
              _a2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var g in c) {
                  c.hasOwnProperty(g) && (a[g] = c[g]);
                }
              };

              return _a2(c, g);
            };

            return function (c, g) {
              function d() {
                this.constructor = c;
              }

              _a2(c, g);

              c.prototype = null === g ? Object.create(g) : (d.prototype = g.prototype, new d());
            };
          }(),
              K = c.charts,
              A = c.doc,
              r = c.noop,
              k = c.win,
              h = E.addEvent,
              a = E.css,
              g = E.objectEach,
              y = E.removeEvent,
              n = {},
              t = !!k.PointerEvent;

          return function (g) {
            function d() {
              return null !== g && g.apply(this, arguments) || this;
            }

            D(d, g);

            d.isRequired = function () {
              return !(c.hasTouch || !k.PointerEvent && !k.MSPointerEvent);
            };

            d.prototype.batchMSEvents = function (a) {
              a(this.chart.container, t ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              a(this.chart.container, t ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              a(A, t ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };

            d.prototype.destroy = function () {
              this.batchMSEvents(y);
              g.prototype.destroy.call(this);
            };

            d.prototype.init = function (c, d) {
              g.prototype.init.call(this, c, d);
              this.hasZoom && a(c.container, {
                "-ms-touch-action": "none",
                "touch-action": "none"
              });
            };

            d.prototype.onContainerPointerDown = function (a) {
              C(a, "onContainerTouchStart", "touchstart", function (a) {
                n[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY,
                  target: a.currentTarget
                };
              });
            };

            d.prototype.onContainerPointerMove = function (a) {
              C(a, "onContainerTouchMove", "touchmove", function (a) {
                n[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY
                };
                n[a.pointerId].target || (n[a.pointerId].target = a.currentTarget);
              });
            };

            d.prototype.onDocumentPointerUp = function (a) {
              C(a, "onDocumentTouchEnd", "touchend", function (a) {
                delete n[a.pointerId];
              });
            };

            d.prototype.setDOMEvents = function () {
              g.prototype.setDOMEvents.call(this);
              (this.hasZoom || this.followTouchMove) && this.batchMSEvents(h);
            };

            return d;
          }(d);
        });
        M(d, "Core/Legend/Legend.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/FormatUtilities.js"], d["Core/Globals.js"], d["Core/Series/Point.js"], d["Core/Renderer/RendererUtilities.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D) {
          var B = c.animObject,
              A = c.setAnimation,
              r = d.format;
          c = E.isFirefox;
          var k = E.marginNames;
          E = E.win;
          var h = C.distribute,
              a = D.addEvent,
              g = D.createElement,
              y = D.css,
              n = D.defined,
              t = D.discardElement,
              O = D.find,
              m = D.fireEvent,
              N = D.isNumber,
              L = D.merge,
              x = D.pick,
              R = D.relativeLength,
              H = D.stableSort,
              w = D.syncTimeout;
          C = D.wrap;

          D = function () {
            function f(b, a) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = !1;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = {};
              this.padding = 0;
              this.pages = [];
              this.proximate = !1;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = b;
              this.init(b, a);
            }

            f.prototype.init = function (b, f) {
              this.chart = b;
              this.setOptions(f);
              f.enabled && (this.render(), a(this.chart, "endResize", function () {
                this.legend.positionCheckboxes();
              }), this.proximate ? this.unchartrender = a(this.chart, "render", function () {
                this.legend.proximatePositions();
                this.legend.positionItems();
              }) : this.unchartrender && this.unchartrender());
            };

            f.prototype.setOptions = function (b) {
              var a = x(b.padding, 8);
              this.options = b;
              this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = L(this.itemStyle, b.itemHiddenStyle));
              this.itemMarginTop = b.itemMarginTop || 0;
              this.itemMarginBottom = b.itemMarginBottom || 0;
              this.padding = a;
              this.initialItemY = a - 5;
              this.symbolWidth = x(b.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === b.layout && !this.chart.inverted;
              this.baseline = void 0;
            };

            f.prototype.update = function (b, a) {
              var f = this.chart;
              this.setOptions(L(!0, this.options, b));
              this.destroy();
              f.isDirtyLegend = f.isDirtyBox = !0;
              x(a, !0) && f.redraw();
              m(this, "afterUpdate");
            };

            f.prototype.colorizeItem = function (b, a) {
              b.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

              if (!this.chart.styledMode) {
                var f = this.options,
                    e = b.legendItem,
                    c = b.legendLine,
                    g = b.legendSymbol,
                    d = this.itemHiddenStyle.color;
                f = a ? f.itemStyle.color : d;
                var p = a ? b.color || d : d,
                    h = b.options && b.options.marker,
                    k = {
                  fill: p
                };
                e && e.css({
                  fill: f,
                  color: f
                });
                c && c.attr({
                  stroke: p
                });
                g && (h && g.isMarker && (k = b.pointAttribs(), a || (k.stroke = k.fill = d)), g.attr(k));
              }

              m(this, "afterColorizeItem", {
                item: b,
                visible: a
              });
            };

            f.prototype.positionItems = function () {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            };

            f.prototype.positionItem = function (b) {
              var a = this,
                  f = this.options,
                  e = f.symbolPadding,
                  c = !f.rtl,
                  g = b._legendItemPos;
              f = g[0];
              g = g[1];
              var d = b.checkbox,
                  p = b.legendGroup;
              p && p.element && (e = {
                translateX: c ? f : this.legendWidth - f - 2 * e - 4,
                translateY: g
              }, c = function c() {
                m(a, "afterPositionItem", {
                  item: b
                });
              }, n(p.translateY) ? p.animate(e, void 0, c) : (p.attr(e), c()));
              d && (d.x = f, d.y = g);
            };

            f.prototype.destroyItem = function (b) {
              var a = b.checkbox;
              ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
                b[a] && (b[a] = b[a].destroy());
              });
              a && t(b.checkbox);
            };

            f.prototype.destroy = function () {
              function b(b) {
                this[b] && (this[b] = this[b].destroy());
              }

              this.getAllItems().forEach(function (a) {
                ["legendItem", "legendGroup"].forEach(b, a);
              });
              "clipRect up down pager nav box title group".split(" ").forEach(b, this);
              this.display = null;
            };

            f.prototype.positionCheckboxes = function () {
              var b = this.group && this.group.alignAttr,
                  a = this.clipHeight || this.legendHeight,
                  f = this.titleHeight;

              if (b) {
                var e = b.translateY;
                this.allItems.forEach(function (c) {
                  var g = c.checkbox;

                  if (g) {
                    var d = e + f + g.y + (this.scrollOffset || 0) + 3;
                    y(g, {
                      left: b.translateX + c.checkboxOffset + g.x - 20 + "px",
                      top: d + "px",
                      display: this.proximate || d > e - 6 && d < e + a - 6 ? "" : "none"
                    });
                  }
                }, this);
              }
            };

            f.prototype.renderTitle = function () {
              var b = this.options,
                  a = this.padding,
                  f = b.title,
                  e = 0;
              f.text && (this.title || (this.title = this.chart.renderer.label(f.text, a - 3, a - 4, null, null, null, b.useHTML, null, "legend-title").attr({
                zIndex: 1
              }), this.chart.styledMode || this.title.css(f.style), this.title.add(this.group)), f.width || this.title.css({
                width: this.maxLegendWidth + "px"
              }), b = this.title.getBBox(), e = b.height, this.offsetWidth = b.width, this.contentGroup.attr({
                translateY: e
              }));
              this.titleHeight = e;
            };

            f.prototype.setText = function (b) {
              var a = this.options;
              b.legendItem.attr({
                text: a.labelFormat ? r(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)
              });
            };

            f.prototype.renderItem = function (b) {
              var a = this.chart,
                  f = a.renderer,
                  e = this.options,
                  c = this.symbolWidth,
                  g = e.symbolPadding || 0,
                  d = this.itemStyle,
                  p = this.itemHiddenStyle,
                  h = "horizontal" === e.layout ? x(e.itemDistance, 20) : 0,
                  m = !e.rtl,
                  k = !b.series,
                  n = !k && b.series.drawLegendSymbol ? b.series : b,
                  u = n.options,
                  w = this.createCheckboxForItem && u && u.showCheckbox,
                  t = e.useHTML,
                  y = b.options.className,
                  r = b.legendItem;
              u = c + g + h + (w ? 20 : 0);
              r || (b.legendGroup = f.g("legend-item").addClass("highcharts-" + n.type + "-series highcharts-color-" + b.colorIndex + (y ? " " + y : "") + (k ? " highcharts-series-" + b.index : "")).attr({
                zIndex: 1
              }).add(this.scrollGroup), b.legendItem = r = f.text("", m ? c + g : -g, this.baseline || 0, t), a.styledMode || r.css(L(b.visible ? d : p)), r.attr({
                align: m ? "left" : "right",
                zIndex: 2
              }).add(b.legendGroup), this.baseline || (this.fontMetrics = f.fontMetrics(a.styledMode ? 12 : d.fontSize, r), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, r.attr("y", this.baseline), this.symbolHeight = e.symbolHeight || this.fontMetrics.f, e.squareSymbol && (this.symbolWidth = x(e.symbolWidth, Math.max(this.symbolHeight, 16)), u = this.symbolWidth + g + h + (w ? 20 : 0), m && r.attr("x", this.symbolWidth + g))), n.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, r, t));
              w && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
              this.colorizeItem(b, b.visible);
              !a.styledMode && d.width || r.css({
                width: (e.itemWidth || this.widthOption || a.spacingBox.width) - u + "px"
              });
              this.setText(b);
              a = r.getBBox();
              b.itemWidth = b.checkboxOffset = e.itemWidth || b.legendItemWidth || a.width + u;
              this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
              this.totalItemWidth += b.itemWidth;
              this.itemHeight = b.itemHeight = Math.round(b.legendItemHeight || a.height || this.symbolHeight);
            };

            f.prototype.layoutItem = function (b) {
              var a = this.options,
                  f = this.padding,
                  e = "horizontal" === a.layout,
                  c = b.itemHeight,
                  g = this.itemMarginBottom,
                  d = this.itemMarginTop,
                  p = e ? x(a.itemDistance, 20) : 0,
                  h = this.maxLegendWidth;
              a = a.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : b.itemWidth;
              e && this.itemX - f + a > h && (this.itemX = f, this.lastLineHeight && (this.itemY += d + this.lastLineHeight + g), this.lastLineHeight = 0);
              this.lastItemY = d + this.itemY + g;
              this.lastLineHeight = Math.max(c, this.lastLineHeight);
              b._legendItemPos = [this.itemX, this.itemY];
              e ? this.itemX += a : (this.itemY += d + c + g, this.lastLineHeight = c);
              this.offsetWidth = this.widthOption || Math.max((e ? this.itemX - f - (b.checkbox ? 0 : p) : a) + f, this.offsetWidth);
            };

            f.prototype.getAllItems = function () {
              var b = [];
              this.chart.series.forEach(function (a) {
                var f = a && a.options;
                a && x(f.showInLegend, n(f.linkedTo) ? !1 : void 0, !0) && (b = b.concat(a.legendItems || ("point" === f.legendType ? a.data : a)));
              });
              m(this, "afterGetAllItems", {
                allItems: b
              });
              return b;
            };

            f.prototype.getAlignment = function () {
              var b = this.options;
              return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
            };

            f.prototype.adjustMargins = function (b, a) {
              var f = this.chart,
                  e = this.options,
                  c = this.getAlignment();
              c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, d) {
                g.test(c) && !n(b[d]) && (f[k[d]] = Math.max(f[k[d]], f.legend[(d + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][d] * e[d % 2 ? "x" : "y"] + x(e.margin, 12) + a[d] + (f.titleOffset[d] || 0)));
              });
            };

            f.prototype.proximatePositions = function () {
              var b = this.chart,
                  a = [],
                  f = "left" === this.options.align;
              this.allItems.forEach(function (e) {
                var c;
                var g = f;

                if (e.yAxis) {
                  e.xAxis.options.reversed && (g = !g);
                  e.points && (c = O(g ? e.points : e.points.slice(0).reverse(), function (b) {
                    return N(b.plotY);
                  }));
                  g = this.itemMarginTop + e.legendItem.getBBox().height + this.itemMarginBottom;
                  var d = e.yAxis.top - b.plotTop;
                  e.visible ? (c = c ? c.plotY : e.yAxis.height, c += d - .3 * g) : c = d + e.yAxis.height;
                  a.push({
                    target: c,
                    size: g,
                    item: e
                  });
                }
              }, this);
              h(a, b.plotHeight).forEach(function (a) {
                a.item._legendItemPos && (a.item._legendItemPos[1] = b.plotTop - b.spacing[0] + a.pos);
              });
            };

            f.prototype.render = function () {
              var b = this.chart,
                  a = b.renderer,
                  f = this.options,
                  e = this.padding,
                  c = this.getAllItems(),
                  g = this.group,
                  d = this.box;
              this.itemX = e;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = R(f.width, b.spacingBox.width - e);
              var p = b.spacingBox.width - 2 * e - f.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (p /= 2);
              this.maxLegendWidth = this.widthOption || p;
              g || (this.group = g = a.g("legend").addClass(f.className || "").attr({
                zIndex: 7
              }).add(), this.contentGroup = a.g().attr({
                zIndex: 1
              }).add(g), this.scrollGroup = a.g().add(this.contentGroup));
              this.renderTitle();
              H(c, function (b, a) {
                return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
              });
              f.reversed && c.reverse();
              this.allItems = c;
              this.display = p = !!c.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              c.forEach(this.renderItem, this);
              c.forEach(this.layoutItem, this);
              c = (this.widthOption || this.offsetWidth) + e;
              var h = this.lastItemY + this.lastLineHeight + this.titleHeight;
              h = this.handleOverflow(h);
              h += e;
              d || (this.box = d = a.rect().addClass("highcharts-legend-box").attr({
                r: f.borderRadius
              }).add(g), d.isNew = !0);
              b.styledMode || d.attr({
                stroke: f.borderColor,
                "stroke-width": f.borderWidth || 0,
                fill: f.backgroundColor || "none"
              }).shadow(f.shadow);
              0 < c && 0 < h && (d[d.isNew ? "attr" : "animate"](d.crisp.call({}, {
                x: 0,
                y: 0,
                width: c,
                height: h
              }, d.strokeWidth())), d.isNew = !1);
              d[p ? "show" : "hide"]();
              b.styledMode && "none" === g.getStyle("display") && (c = h = 0);
              this.legendWidth = c;
              this.legendHeight = h;
              p && this.align();
              this.proximate || this.positionItems();
              m(this, "afterRender");
            };

            f.prototype.align = function (b) {
              void 0 === b && (b = this.chart.spacingBox);
              var a = this.chart,
                  f = this.options,
                  e = b.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? e += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (e -= a.titleOffset[2]);
              e !== b.y && (b = L(b, {
                y: e
              }));
              this.group.align(L(f, {
                width: this.legendWidth,
                height: this.legendHeight,
                verticalAlign: this.proximate ? "top" : f.verticalAlign
              }), !0, b);
            };

            f.prototype.handleOverflow = function (b) {
              var a = this,
                  f = this.chart,
                  e = f.renderer,
                  c = this.options,
                  g = c.y,
                  d = "top" === c.verticalAlign,
                  p = this.padding,
                  h = c.maxHeight,
                  m = c.navigation,
                  k = x(m.animation, !0),
                  n = m.arrowSize || 12,
                  u = this.pages,
                  w = this.allItems,
                  t = function t(b) {
                "number" === typeof b ? U.attr({
                  height: b
                }) : U && (a.clipRect = U.destroy(), a.contentGroup.clip());
                a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + p + "px,9999px," + (p + b) + "px,0)" : "auto");
              },
                  y = function y(b) {
                a[b] = e.circle(0, 0, 1.3 * n).translate(n / 2, n / 2).add(H);
                f.styledMode || a[b].attr("fill", "rgba(0,0,0,0.0001)");
                return a[b];
              },
                  r,
                  Q;

              g = f.spacingBox.height + (d ? -g : g) - p;
              var H = this.nav,
                  U = this.clipRect;
              "horizontal" !== c.layout || "middle" === c.verticalAlign || c.floating || (g /= 2);
              h && (g = Math.min(g, h));
              u.length = 0;
              b && 0 < g && b > g && !1 !== m.enabled ? (this.clipHeight = r = Math.max(g - 20 - this.titleHeight - p, 0), this.currentPage = x(this.currentPage, 1), this.fullHeight = b, w.forEach(function (b, a) {
                var e = b._legendItemPos[1],
                    f = Math.round(b.legendItem.getBBox().height),
                    c = u.length;
                if (!c || e - u[c - 1] > r && (Q || e) !== u[c - 1]) u.push(Q || e), c++;
                b.pageIx = c - 1;
                Q && (w[a - 1].pageIx = c - 1);
                a === w.length - 1 && e + f - u[c - 1] > r && e !== Q && (u.push(e), b.pageIx = c);
                e !== Q && (Q = e);
              }), U || (U = a.clipRect = e.clipRect(0, p, 9999, 0), a.contentGroup.clip(U)), t(r), H || (this.nav = H = e.g().attr({
                zIndex: 1
              }).add(this.group), this.up = e.symbol("triangle", 0, 0, n, n).add(H), y("upTracker").on("click", function () {
                a.scroll(-1, k);
              }), this.pager = e.text("", 15, 10).addClass("highcharts-legend-navigation"), f.styledMode || this.pager.css(m.style), this.pager.add(H), this.down = e.symbol("triangle-down", 0, 0, n, n).add(H), y("downTracker").on("click", function () {
                a.scroll(1, k);
              })), a.scroll(0), b = g) : H && (t(), this.nav = H.destroy(), this.scrollGroup.attr({
                translateY: 1
              }), this.clipHeight = 0);
              return b;
            };

            f.prototype.scroll = function (b, a) {
              var f = this,
                  e = this.chart,
                  c = this.pages,
                  g = c.length,
                  d = this.clipHeight,
                  p = this.options.navigation,
                  h = this.pager,
                  k = this.padding,
                  n = this.currentPage + b;
              n > g && (n = g);
              0 < n && ("undefined" !== typeof a && A(a, e), this.nav.attr({
                translateX: k,
                translateY: d + this.padding + 7 + this.titleHeight,
                visibility: "visible"
              }), [this.up, this.upTracker].forEach(function (b) {
                b.attr({
                  "class": 1 === n ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }), h.attr({
                text: n + "/" + g
              }), [this.down, this.downTracker].forEach(function (b) {
                b.attr({
                  x: 18 + this.pager.getBBox().width,
                  "class": n === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }, this), e.styledMode || (this.up.attr({
                fill: 1 === n ? p.inactiveColor : p.activeColor
              }), this.upTracker.css({
                cursor: 1 === n ? "default" : "pointer"
              }), this.down.attr({
                fill: n === g ? p.inactiveColor : p.activeColor
              }), this.downTracker.css({
                cursor: n === g ? "default" : "pointer"
              })), this.scrollOffset = -c[n - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: this.scrollOffset
              }), this.currentPage = n, this.positionCheckboxes(), b = B(x(a, e.renderer.globalAnimation, !0)), w(function () {
                m(f, "afterScroll", {
                  currentPage: n
                });
              }, b.duration));
            };

            f.prototype.setItemEvents = function (b, a, f) {
              var e = this,
                  c = e.chart.renderer.boxWrapper,
                  g = b instanceof G,
                  d = "highcharts-legend-" + (g ? "point" : "series") + "-active",
                  p = e.chart.styledMode,
                  h = function h(a) {
                e.allItems.forEach(function (e) {
                  b !== e && [e].concat(e.linkedSeries || []).forEach(function (b) {
                    b.setState(a, !g);
                  });
                });
              };

              (f ? [a, b.legendSymbol] : [b.legendGroup]).forEach(function (f) {
                if (f) f.on("mouseover", function () {
                  b.visible && h("inactive");
                  b.setState("hover");
                  b.visible && c.addClass(d);
                  p || a.css(e.options.itemHoverStyle);
                }).on("mouseout", function () {
                  e.chart.styledMode || a.css(L(b.visible ? e.itemStyle : e.itemHiddenStyle));
                  h("");
                  c.removeClass(d);
                  b.setState();
                }).on("click", function (a) {
                  var e = function e() {
                    b.setVisible && b.setVisible();
                    h(b.visible ? "inactive" : "");
                  };

                  c.removeClass(d);
                  a = {
                    browserEvent: a
                  };
                  b.firePointEvent ? b.firePointEvent("legendItemClick", a, e) : m(b, "legendItemClick", a, e);
                });
              });
            };

            f.prototype.createCheckboxForItem = function (b) {
              b.checkbox = g("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: b.selected,
                defaultChecked: b.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              a(b.checkbox, "click", function (a) {
                m(b.series || b, "checkboxClick", {
                  checked: a.target.checked,
                  item: b
                }, function () {
                  b.select();
                });
              });
            };

            return f;
          }();

          (/Trident\/7\.0/.test(E.navigator && E.navigator.userAgent) || c) && C(D.prototype, "positionItem", function (a, b) {
            var f = this,
                c = function c() {
              b._legendItemPos && a.call(f, b);
            };

            c();
            f.bubbleLegend || setTimeout(c);
          });
          "";
          return D;
        });
        M(d, "Core/Series/SeriesRegistry.js", [d["Core/Globals.js"], d["Core/DefaultOptions.js"], d["Core/Series/Point.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var B = d.defaultOptions,
              D = G.error,
              K = G.extendClass,
              A = G.merge,
              r;

          (function (d) {
            function h(a, c) {
              var g = B.plotOptions || {},
                  h = c.defaultOptions;
              c.prototype.pointClass || (c.prototype.pointClass = E);
              c.prototype.type = a;
              h && (g[a] = h);
              d.seriesTypes[a] = c;
            }

            d.seriesTypes = c.seriesTypes;

            d.getSeries = function (a, c) {
              void 0 === c && (c = {});
              var g = a.options.chart;
              g = c.type || g.type || g.defaultSeriesType || "";
              var h = d.seriesTypes[g];
              d || D(17, !0, a, {
                missingModuleFor: g
              });
              g = new h();
              "function" === typeof g.init && g.init(a, c);
              return g;
            };

            d.registerSeriesType = h;

            d.seriesType = function (a, c, k, n, t) {
              var g = B.plotOptions || {};
              c = c || "";
              g[a] = A(g[c], k);
              h(a, K(d.seriesTypes[c] || function () {}, n));
              d.seriesTypes[a].prototype.type = a;
              t && (d.seriesTypes[a].prototype.pointClass = K(E, t));
              return d.seriesTypes[a];
            };
          })(r || (r = {}));

          return r;
        });
        M(d, "Core/Chart/Chart.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Axis/Axis.js"], d["Core/FormatUtilities.js"], d["Core/Foundation.js"], d["Core/Globals.js"], d["Core/Legend/Legend.js"], d["Core/MSPointer.js"], d["Core/DefaultOptions.js"], d["Core/Color/Palette.js"], d["Core/Pointer.js"], d["Core/Renderer/RendererRegistry.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Renderer/SVG/SVGRenderer.js"], d["Core/Time.js"], d["Core/Utilities.js"], d["Core/Renderer/HTML/AST.js"]], function (c, d, E, G, C, D, K, A, r, k, h, a, g, y, n, t) {
          var O = c.animate,
              m = c.animObject,
              N = c.setAnimation,
              L = E.numberFormat,
              x = G.registerEventOptions,
              R = C.charts,
              H = C.doc,
              w = C.marginNames,
              f = C.svg,
              b = C.win,
              v = A.defaultOptions,
              F = A.defaultTime,
              e = a.seriesTypes,
              q = n.addEvent,
              l = n.attr,
              I = n.cleanRecursively,
              p = n.createElement,
              z = n.css,
              P = n.defined,
              T = n.discardElement,
              J = n.erase,
              u = n.error,
              B = n.extend,
              ba = n.find,
              S = n.fireEvent,
              ca = n.getStyle,
              Q = n.isArray,
              X = n.isNumber,
              U = n.isObject,
              da = n.isString,
              Y = n.merge,
              Z = n.objectEach,
              V = n.pick,
              ea = n.pInt,
              ha = n.relativeLength,
              fa = n.removeEvent,
              M = n.splat,
              aa = n.syncTimeout,
              ja = n.uniqueKey;

          c = function () {
            function a(b, a, e) {
              this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
              this.sharedClips = {};
              this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
              this.getArgs(b, a, e);
            }

            a.chart = function (b, e, f) {
              return new a(b, e, f);
            };

            a.prototype.getArgs = function (b, a, e) {
              da(b) || b.nodeName ? (this.renderTo = b, this.init(a, e)) : this.init(b, a);
            };

            a.prototype.init = function (b, a) {
              var e = b.plotOptions || {};
              S(this, "init", {
                args: arguments
              }, function () {
                var f = Y(v, b),
                    c = f.chart;
                Z(f.plotOptions, function (b, a) {
                  U(b) && (b.tooltip = e[a] && Y(e[a].tooltip) || void 0);
                });
                f.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
                this.userOptions = b;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                  h: {},
                  v: {}
                };
                this.labelCollectors = [];
                this.callback = a;
                this.isResizing = 0;
                this.options = f;
                this.axes = [];
                this.series = [];
                this.time = b.time && Object.keys(b.time).length ? new y(b.time) : C.time;
                this.numberFormatter = c.numberFormatter || L;
                this.styledMode = c.styledMode;
                this.hasCartesianSeries = c.showAxes;
                this.index = R.length;
                R.push(this);
                C.chartCount++;
                x(this, c);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                S(this, "afterInit");
                this.firstRender();
              });
            };

            a.prototype.initSeries = function (b) {
              var a = this.options.chart;
              a = b.type || a.type || a.defaultSeriesType;
              var f = e[a];
              f || u(17, !0, this, {
                missingModuleFor: a
              });
              a = new f();
              "function" === typeof a.init && a.init(this, b);
              return a;
            };

            a.prototype.setSeriesData = function () {
              this.getSeriesOrderByLinks().forEach(function (b) {
                b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
              });
            };

            a.prototype.getSeriesOrderByLinks = function () {
              return this.series.concat().sort(function (b, a) {
                return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
              });
            };

            a.prototype.orderSeries = function (b) {
              var a = this.series;
              b = b || 0;

              for (var e = a.length; b < e; ++b) {
                a[b] && (a[b].index = b, a[b].name = a[b].getName());
              }
            };

            a.prototype.isInsidePlot = function (b, a, e) {
              void 0 === e && (e = {});
              var f = this.inverted,
                  c = this.plotBox,
                  g = this.plotLeft,
                  d = this.plotTop,
                  l = this.scrollablePlotBox,
                  p = 0;
              var q = 0;
              e.visiblePlotOnly && this.scrollingContainer && (q = this.scrollingContainer, p = q.scrollLeft, q = q.scrollTop);
              var h = e.series;
              c = e.visiblePlotOnly && l || c;
              l = e.inverted ? a : b;
              a = e.inverted ? b : a;
              b = {
                x: l,
                y: a,
                isInsidePlot: !0
              };

              if (!e.ignoreX) {
                var m = h && (f ? h.yAxis : h.xAxis) || {
                  pos: g,
                  len: Infinity
                };
                l = e.paneCoordinates ? m.pos + l : g + l;
                l >= Math.max(p + g, m.pos) && l <= Math.min(p + g + c.width, m.pos + m.len) || (b.isInsidePlot = !1);
              }

              !e.ignoreY && b.isInsidePlot && (f = h && (f ? h.xAxis : h.yAxis) || {
                pos: d,
                len: Infinity
              }, e = e.paneCoordinates ? f.pos + a : d + a, e >= Math.max(q + d, f.pos) && e <= Math.min(q + d + c.height, f.pos + f.len) || (b.isInsidePlot = !1));
              S(this, "afterIsInsidePlot", b);
              return b.isInsidePlot;
            };

            a.prototype.redraw = function (b) {
              S(this, "beforeRedraw");
              var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                  e = this.series,
                  f = this.pointer,
                  c = this.legend,
                  g = this.userOptions.legend,
                  d = this.renderer,
                  l = d.isHidden(),
                  p = [],
                  q = this.isDirtyBox,
                  h = this.isDirtyLegend;
              this.setResponsive && this.setResponsive(!1);
              N(this.hasRendered ? b : !1, this);
              l && this.temporaryDisplay();
              this.layOutTitles();

              for (b = e.length; b--;) {
                var m = e[b];

                if (m.options.stacking || m.options.centerInCategory) {
                  var z = !0;

                  if (m.isDirty) {
                    var n = !0;
                    break;
                  }
                }
              }

              if (n) for (b = e.length; b--;) {
                m = e[b], m.options.stacking && (m.isDirty = !0);
              }
              e.forEach(function (b) {
                b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), h = !0) : g && (g.labelFormatter || g.labelFormat) && (h = !0));
                b.isDirtyData && S(b, "updatedData");
              });
              h && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);
              z && this.getStacks();
              a.forEach(function (b) {
                b.updateNames();
                b.setScale();
              });
              this.getMargins();
              a.forEach(function (b) {
                b.isDirty && (q = !0);
              });
              a.forEach(function (b) {
                var a = b.min + "," + b.max;
                b.extKey !== a && (b.extKey = a, p.push(function () {
                  S(b, "afterSetExtremes", B(b.eventArgs, b.getExtremes()));
                  delete b.eventArgs;
                }));
                (q || z) && b.redraw();
              });
              q && this.drawChartBox();
              S(this, "predraw");
              e.forEach(function (b) {
                (q || b.isDirty) && b.visible && b.redraw();
                b.isDirtyData = !1;
              });
              f && f.reset(!0);
              d.draw();
              S(this, "redraw");
              S(this, "render");
              l && this.temporaryDisplay(!0);
              p.forEach(function (b) {
                b.call();
              });
            };

            a.prototype.get = function (b) {
              function a(a) {
                return a.id === b || a.options && a.options.id === b;
              }

              for (var e = this.series, f = ba(this.axes, a) || ba(this.series, a), c = 0; !f && c < e.length; c++) {
                f = ba(e[c].points || [], a);
              }

              return f;
            };

            a.prototype.getAxes = function () {
              var b = this,
                  a = this.options,
                  e = a.xAxis = M(a.xAxis || {});
              a = a.yAxis = M(a.yAxis || {});
              S(this, "getAxes");
              e.forEach(function (b, a) {
                b.index = a;
                b.isX = !0;
              });
              a.forEach(function (b, a) {
                b.index = a;
              });
              e.concat(a).forEach(function (a) {
                new d(b, a);
              });
              S(this, "afterGetAxes");
            };

            a.prototype.getSelectedPoints = function () {
              return this.series.reduce(function (b, a) {
                a.getPointsCollection().forEach(function (a) {
                  V(a.selectedStaging, a.selected) && b.push(a);
                });
                return b;
              }, []);
            };

            a.prototype.getSelectedSeries = function () {
              return this.series.filter(function (b) {
                return b.selected;
              });
            };

            a.prototype.setTitle = function (b, a, e) {
              this.applyDescription("title", b);
              this.applyDescription("subtitle", a);
              this.applyDescription("caption", void 0);
              this.layOutTitles(e);
            };

            a.prototype.applyDescription = function (b, a) {
              var e = this,
                  f = "title" === b ? {
                color: r.neutralColor80,
                fontSize: this.options.isStock ? "16px" : "18px"
              } : {
                color: r.neutralColor60
              };
              f = this.options[b] = Y(!this.styledMode && {
                style: f
              }, this.options[b], a);
              var c = this[b];
              c && a && (this[b] = c = c.destroy());
              f && !c && (c = this.renderer.text(f.text, 0, 0, f.useHTML).attr({
                align: f.align,
                "class": "highcharts-" + b,
                zIndex: f.zIndex || 4
              }).add(), c.update = function (a) {
                e[{
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }[b]](a);
              }, this.styledMode || c.css(f.style), this[b] = c);
            };

            a.prototype.layOutTitles = function (b) {
              var a = [0, 0, 0],
                  e = this.renderer,
                  f = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (b) {
                var c = this[b],
                    g = this.options[b],
                    d = g.verticalAlign || "top";
                b = "title" === b ? "top" === d ? -3 : 0 : "top" === d ? a[0] + 2 : 0;
                var l;

                if (c) {
                  this.styledMode || (l = g.style && g.style.fontSize);
                  l = e.fontMetrics(l, c).b;
                  c.css({
                    width: (g.width || f.width + (g.widthAdjust || 0)) + "px"
                  });
                  var p = Math.round(c.getBBox(g.useHTML).height);
                  c.align(B({
                    y: "bottom" === d ? l : b + l,
                    height: p
                  }, g), !1, "spacingBox");
                  g.floating || ("top" === d ? a[0] = Math.ceil(a[0] + p) : "bottom" === d && (a[2] = Math.ceil(a[2] + p)));
                }
              }, this);
              a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
              a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
              var c = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
              this.titleOffset = a;
              S(this, "afterLayOutTitles");
              !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && V(b, !0) && this.isDirtyBox && this.redraw());
            };

            a.prototype.getChartSize = function () {
              var b = this.options.chart,
                  a = b.width;
              b = b.height;
              var e = this.renderTo;
              P(a) || (this.containerWidth = ca(e, "width"));
              P(b) || (this.containerHeight = ca(e, "height"));
              this.chartWidth = Math.max(0, a || this.containerWidth || 600);
              this.chartHeight = Math.max(0, ha(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };

            a.prototype.temporaryDisplay = function (b) {
              var a = this.renderTo;
              if (b) for (; a && a.style;) {
                a.hcOrigStyle && (z(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (H.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;
              } else for (; a && a.style;) {
                H.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, H.body.appendChild(a));
                if ("none" === ca(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
                  display: a.style.display,
                  height: a.style.height,
                  overflow: a.style.overflow
                }, b = {
                  display: "block",
                  overflow: "hidden"
                }, a !== this.renderTo && (b.height = 0), z(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
                a = a.parentNode;
                if (a === H.body) break;
              }
            };

            a.prototype.setClassName = function (b) {
              this.container.className = "highcharts-container " + (b || "");
            };

            a.prototype.getContainer = function () {
              var b = this.options,
                  a = b.chart,
                  e = ja(),
                  c,
                  d = this.renderTo;
              d || (this.renderTo = d = a.renderTo);
              da(d) && (this.renderTo = d = H.getElementById(d));
              d || u(13, !0, this);
              var q = ea(l(d, "data-highcharts-chart"));
              X(q) && R[q] && R[q].hasRendered && R[q].destroy();
              l(d, "data-highcharts-chart", this.index);
              d.innerHTML = "";
              a.skipClone || d.offsetWidth || this.temporaryDisplay();
              this.getChartSize();
              q = this.chartWidth;
              var m = this.chartHeight;
              z(d, {
                overflow: "hidden"
              });
              this.styledMode || (c = B({
                position: "relative",
                overflow: "hidden",
                width: q + "px",
                height: m + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                userSelect: "none",
                "touch-action": "manipulation",
                outline: "none"
              }, a.style || {}));
              this.container = e = p("div", {
                id: e
              }, c, d);
              this._cursor = e.style.cursor;
              this.renderer = new (a.renderer || !f ? h.getRendererType(a.renderer) : g)(e, q, m, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
              N(void 0, this);
              this.setClassName(a.className);
              if (this.styledMode) for (var n in b.defs) {
                this.renderer.definition(b.defs[n]);
              } else this.renderer.setStyle(a.style);
              this.renderer.chartIndex = this.index;
              S(this, "afterGetContainer");
            };

            a.prototype.getMargins = function (b) {
              var a = this.spacing,
                  e = this.margin,
                  f = this.titleOffset;
              this.resetMargins();
              f[0] && !P(e[0]) && (this.plotTop = Math.max(this.plotTop, f[0] + a[0]));
              f[2] && !P(e[2]) && (this.marginBottom = Math.max(this.marginBottom, f[2] + a[2]));
              this.legend && this.legend.display && this.legend.adjustMargins(e, a);
              S(this, "getMargins");
              b || this.getAxisMargins();
            };

            a.prototype.getAxisMargins = function () {
              var b = this,
                  a = b.axisOffset = [0, 0, 0, 0],
                  e = b.colorAxis,
                  f = b.margin,
                  c = function c(b) {
                b.forEach(function (b) {
                  b.visible && b.getOffset();
                });
              };

              b.hasCartesianSeries ? c(b.axes) : e && e.length && c(e);
              w.forEach(function (e, c) {
                P(f[c]) || (b[e] += a[c]);
              });
              b.setChartSize();
            };

            a.prototype.reflow = function (a) {
              var e = this,
                  f = e.options.chart,
                  c = e.renderTo,
                  g = P(f.width) && P(f.height),
                  d = f.width || ca(c, "width");
              f = f.height || ca(c, "height");
              c = a ? a.target : b;
              delete e.pointer.chartPosition;

              if (!g && !e.isPrinting && d && f && (c === b || c === H)) {
                if (d !== e.containerWidth || f !== e.containerHeight) n.clearTimeout(e.reflowTimeout), e.reflowTimeout = aa(function () {
                  e.container && e.setSize(void 0, void 0, !1);
                }, a ? 100 : 0);
                e.containerWidth = d;
                e.containerHeight = f;
              }
            };

            a.prototype.setReflow = function (a) {
              var e = this;
              !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = q(b, "resize", function (b) {
                e.options && e.reflow(b);
              }), q(this, "destroy", this.unbindReflow));
            };

            a.prototype.setSize = function (b, a, e) {
              var f = this,
                  c = f.renderer;
              f.isResizing += 1;
              N(e, f);
              e = c.globalAnimation;
              f.oldChartHeight = f.chartHeight;
              f.oldChartWidth = f.chartWidth;
              "undefined" !== typeof b && (f.options.chart.width = b);
              "undefined" !== typeof a && (f.options.chart.height = a);
              f.getChartSize();
              f.styledMode || (e ? O : z)(f.container, {
                width: f.chartWidth + "px",
                height: f.chartHeight + "px"
              }, e);
              f.setChartSize(!0);
              c.setSize(f.chartWidth, f.chartHeight, e);
              f.axes.forEach(function (b) {
                b.isDirty = !0;
                b.setScale();
              });
              f.isDirtyLegend = !0;
              f.isDirtyBox = !0;
              f.layOutTitles();
              f.getMargins();
              f.redraw(e);
              f.oldChartHeight = null;
              S(f, "resize");
              aa(function () {
                f && S(f, "endResize", null, function () {
                  --f.isResizing;
                });
              }, m(e).duration);
            };

            a.prototype.setChartSize = function (b) {
              var a = this.inverted,
                  e = this.renderer,
                  f = this.chartWidth,
                  c = this.chartHeight,
                  g = this.options.chart,
                  d = this.spacing,
                  l = this.clipOffset,
                  p,
                  q,
                  h,
                  m;
              this.plotLeft = p = Math.round(this.plotLeft);
              this.plotTop = q = Math.round(this.plotTop);
              this.plotWidth = h = Math.max(0, Math.round(f - p - this.marginRight));
              this.plotHeight = m = Math.max(0, Math.round(c - q - this.marginBottom));
              this.plotSizeX = a ? m : h;
              this.plotSizeY = a ? h : m;
              this.plotBorderWidth = g.plotBorderWidth || 0;
              this.spacingBox = e.spacingBox = {
                x: d[3],
                y: d[0],
                width: f - d[3] - d[1],
                height: c - d[0] - d[2]
              };
              this.plotBox = e.plotBox = {
                x: p,
                y: q,
                width: h,
                height: m
              };
              a = 2 * Math.floor(this.plotBorderWidth / 2);
              f = Math.ceil(Math.max(a, l[3]) / 2);
              c = Math.ceil(Math.max(a, l[0]) / 2);
              this.clipBox = {
                x: f,
                y: c,
                width: Math.floor(this.plotSizeX - Math.max(a, l[1]) / 2 - f),
                height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, l[2]) / 2 - c))
              };
              b || (this.axes.forEach(function (b) {
                b.setAxisSize();
                b.setAxisTranslation();
              }), e.alignElements());
              S(this, "afterSetChartSize", {
                skipAxes: b
              });
            };

            a.prototype.resetMargins = function () {
              S(this, "resetMargins");
              var b = this,
                  a = b.options.chart;
              ["margin", "spacing"].forEach(function (e) {
                var f = a[e],
                    c = U(f) ? f : [f, f, f, f];
                ["Top", "Right", "Bottom", "Left"].forEach(function (f, g) {
                  b[e][g] = V(a[e + f], c[g]);
                });
              });
              w.forEach(function (a, e) {
                b[a] = V(b.margin[e], b.spacing[e]);
              });
              b.axisOffset = [0, 0, 0, 0];
              b.clipOffset = [0, 0, 0, 0];
            };

            a.prototype.drawChartBox = function () {
              var b = this.options.chart,
                  a = this.renderer,
                  e = this.chartWidth,
                  f = this.chartHeight,
                  c = this.styledMode,
                  g = this.plotBGImage,
                  d = b.backgroundColor,
                  l = b.plotBackgroundColor,
                  p = b.plotBackgroundImage,
                  q = this.plotLeft,
                  h = this.plotTop,
                  m = this.plotWidth,
                  z = this.plotHeight,
                  n = this.plotBox,
                  k = this.clipRect,
                  u = this.clipBox,
                  v = this.chartBackground,
                  I = this.plotBackground,
                  Q = this.plotBorder,
                  w,
                  t = "animate";
              v || (this.chartBackground = v = a.rect().addClass("highcharts-background").add(), t = "attr");
              if (c) var x = w = v.strokeWidth();else {
                x = b.borderWidth || 0;
                w = x + (b.shadow ? 8 : 0);
                d = {
                  fill: d || "none"
                };
                if (x || v["stroke-width"]) d.stroke = b.borderColor, d["stroke-width"] = x;
                v.attr(d).shadow(b.shadow);
              }
              v[t]({
                x: w / 2,
                y: w / 2,
                width: e - w - x % 2,
                height: f - w - x % 2,
                r: b.borderRadius
              });
              t = "animate";
              I || (t = "attr", this.plotBackground = I = a.rect().addClass("highcharts-plot-background").add());
              I[t](n);
              c || (I.attr({
                fill: l || "none"
              }).shadow(b.plotShadow), p && (g ? (p !== g.attr("href") && g.attr("href", p), g.animate(n)) : this.plotBGImage = a.image(p, q, h, m, z).add()));
              k ? k.animate({
                width: u.width,
                height: u.height
              }) : this.clipRect = a.clipRect(u);
              t = "animate";
              Q || (t = "attr", this.plotBorder = Q = a.rect().addClass("highcharts-plot-border").attr({
                zIndex: 1
              }).add());
              c || Q.attr({
                stroke: b.plotBorderColor,
                "stroke-width": b.plotBorderWidth || 0,
                fill: "none"
              });
              Q[t](Q.crisp({
                x: q,
                y: h,
                width: m,
                height: z
              }, -Q.strokeWidth()));
              this.isDirtyBox = !1;
              S(this, "afterDrawChartBox");
            };

            a.prototype.propFromSeries = function () {
              var b = this,
                  a = b.options.chart,
                  f = b.options.series,
                  c,
                  g,
                  d;
              ["inverted", "angular", "polar"].forEach(function (l) {
                g = e[a.type || a.defaultSeriesType];
                d = a[l] || g && g.prototype[l];

                for (c = f && f.length; !d && c--;) {
                  (g = e[f[c].type]) && g.prototype[l] && (d = !0);
                }

                b[l] = d;
              });
            };

            a.prototype.linkSeries = function () {
              var b = this,
                  a = b.series;
              a.forEach(function (b) {
                b.linkedSeries.length = 0;
              });
              a.forEach(function (a) {
                var e = a.options.linkedTo;
                da(e) && (e = ":previous" === e ? b.series[a.index - 1] : b.get(e)) && e.linkedParent !== a && (e.linkedSeries.push(a), a.linkedParent = e, e.enabledDataSorting && a.setDataSortingOptions(), a.visible = V(a.options.visible, e.options.visible, a.visible));
              });
              S(this, "afterLinkSeries");
            };

            a.prototype.renderSeries = function () {
              this.series.forEach(function (b) {
                b.translate();
                b.render();
              });
            };

            a.prototype.renderLabels = function () {
              var b = this,
                  a = b.options.labels;
              a.items && a.items.forEach(function (e) {
                var f = B(a.style, e.style),
                    c = ea(f.left) + b.plotLeft,
                    g = ea(f.top) + b.plotTop + 12;
                delete f.left;
                delete f.top;
                b.renderer.text(e.html, c, g).attr({
                  zIndex: 2
                }).css(f).add();
              });
            };

            a.prototype.render = function () {
              var b = this.axes,
                  a = this.colorAxis,
                  e = this.renderer,
                  f = this.options,
                  c = function c(b) {
                b.forEach(function (b) {
                  b.visible && b.render();
                });
              },
                  g = 0;

              this.setTitle();
              this.legend = new D(this, f.legend);
              this.getStacks && this.getStacks();
              this.getMargins(!0);
              this.setChartSize();
              f = this.plotWidth;
              b.some(function (b) {
                if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return g = 21, !0;
              });
              var d = this.plotHeight = Math.max(this.plotHeight - g, 0);
              b.forEach(function (b) {
                b.setScale();
              });
              this.getAxisMargins();
              var l = 1.1 < f / this.plotWidth,
                  p = 1.05 < d / this.plotHeight;
              if (l || p) b.forEach(function (b) {
                (b.horiz && l || !b.horiz && p) && b.setTickInterval(!0);
              }), this.getMargins();
              this.drawChartBox();
              this.hasCartesianSeries ? c(b) : a && a.length && c(a);
              this.seriesGroup || (this.seriesGroup = e.g("series-group").attr({
                zIndex: 3
              }).add());
              this.renderSeries();
              this.renderLabels();
              this.addCredits();
              this.setResponsive && this.setResponsive();
              this.hasRendered = !0;
            };

            a.prototype.addCredits = function (a) {
              var e = this,
                  f = Y(!0, this.options.credits, a);
              f.enabled && !this.credits && (this.credits = this.renderer.text(f.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                f.href && (b.location.href = f.href);
              }).attr({
                align: f.position.align,
                zIndex: 8
              }), e.styledMode || this.credits.css(f.style), this.credits.add().align(f.position), this.credits.update = function (b) {
                e.credits = e.credits.destroy();
                e.addCredits(b);
              });
            };

            a.prototype.destroy = function () {
              var b = this,
                  a = b.axes,
                  e = b.series,
                  f = b.container,
                  c = f && f.parentNode,
                  g;
              S(b, "destroy");
              b.renderer.forExport ? J(R, b) : R[b.index] = void 0;
              C.chartCount--;
              b.renderTo.removeAttribute("data-highcharts-chart");
              fa(b);

              for (g = a.length; g--;) {
                a[g] = a[g].destroy();
              }

              this.scroller && this.scroller.destroy && this.scroller.destroy();

              for (g = e.length; g--;) {
                e[g] = e[g].destroy();
              }

              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
                var e = b[a];
                e && e.destroy && (b[a] = e.destroy());
              });
              f && (f.innerHTML = "", fa(f), c && T(f));
              Z(b, function (a, e) {
                delete b[e];
              });
            };

            a.prototype.firstRender = function () {
              var b = this,
                  a = b.options;

              if (!b.isReadyToRender || b.isReadyToRender()) {
                b.getContainer();
                b.resetMargins();
                b.setChartSize();
                b.propFromSeries();
                b.getAxes();
                (Q(a.series) ? a.series : []).forEach(function (a) {
                  b.initSeries(a);
                });
                b.linkSeries();
                b.setSeriesData();
                S(b, "beforeRender");
                k && (K.isRequired() ? b.pointer = new K(b, a) : b.pointer = new k(b, a));
                b.render();
                b.pointer.getChartPosition();
                if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
                b.temporaryDisplay(!0);
              }
            };

            a.prototype.onload = function () {
              this.callbacks.concat([this.callback]).forEach(function (b) {
                b && "undefined" !== typeof this.index && b.apply(this, [this]);
              }, this);
              S(this, "load");
              S(this, "render");
              P(this.index) && this.setReflow(this.options.chart.reflow);
              this.hasLoaded = !0;
            };

            a.prototype.addSeries = function (b, a, e) {
              var f = this,
                  c;
              b && (a = V(a, !0), S(f, "addSeries", {
                options: b
              }, function () {
                c = f.initSeries(b);
                f.isDirtyLegend = !0;
                f.linkSeries();
                c.enabledDataSorting && c.setData(b.data, !1);
                S(f, "afterAddSeries", {
                  series: c
                });
                a && f.redraw(e);
              }));
              return c;
            };

            a.prototype.addAxis = function (b, a, e, f) {
              return this.createAxis(a ? "xAxis" : "yAxis", {
                axis: b,
                redraw: e,
                animation: f
              });
            };

            a.prototype.addColorAxis = function (b, a, e) {
              return this.createAxis("colorAxis", {
                axis: b,
                redraw: a,
                animation: e
              });
            };

            a.prototype.createAxis = function (b, a) {
              b = new d(this, Y(a.axis, {
                index: this[b].length,
                isX: "xAxis" === b
              }));
              V(a.redraw, !0) && this.redraw(a.animation);
              return b;
            };

            a.prototype.showLoading = function (b) {
              var a = this,
                  e = a.options,
                  f = e.loading,
                  c = function c() {
                g && z(g, {
                  left: a.plotLeft + "px",
                  top: a.plotTop + "px",
                  width: a.plotWidth + "px",
                  height: a.plotHeight + "px"
                });
              },
                  g = a.loadingDiv,
                  d = a.loadingSpan;

              g || (a.loadingDiv = g = p("div", {
                className: "highcharts-loading highcharts-loading-hidden"
              }, null, a.container));
              d || (a.loadingSpan = d = p("span", {
                className: "highcharts-loading-inner"
              }, null, g), q(a, "redraw", c));
              g.className = "highcharts-loading";
              t.setElementHTML(d, V(b, e.lang.loading, ""));
              a.styledMode || (z(g, B(f.style, {
                zIndex: 10
              })), z(d, f.labelStyle), a.loadingShown || (z(g, {
                opacity: 0,
                display: ""
              }), O(g, {
                opacity: f.style.opacity || .5
              }, {
                duration: f.showDuration || 0
              })));
              a.loadingShown = !0;
              c();
            };

            a.prototype.hideLoading = function () {
              var b = this.options,
                  a = this.loadingDiv;
              a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || O(a, {
                opacity: 0
              }, {
                duration: b.loading.hideDuration || 100,
                complete: function complete() {
                  z(a, {
                    display: "none"
                  });
                }
              }));
              this.loadingShown = !1;
            };

            a.prototype.update = function (b, a, e, f) {
              var c = this,
                  g = {
                credits: "addCredits",
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              },
                  d = b.isResponsiveOptions,
                  l = [],
                  p,
                  q;
              S(c, "update", {
                options: b
              });
              d || c.setResponsive(!1, !0);
              b = I(b, c.options);
              c.userOptions = Y(c.userOptions, b);
              var h = b.chart;

              if (h) {
                Y(!0, c.options.chart, h);
                "className" in h && c.setClassName(h.className);
                "reflow" in h && c.setReflow(h.reflow);

                if ("inverted" in h || "polar" in h || "type" in h) {
                  c.propFromSeries();
                  var m = !0;
                }

                "alignTicks" in h && (m = !0);
                "events" in h && x(this, h);
                Z(h, function (b, a) {
                  -1 !== c.propsRequireUpdateSeries.indexOf("chart." + a) && (p = !0);
                  -1 !== c.propsRequireDirtyBox.indexOf(a) && (c.isDirtyBox = !0);
                  -1 !== c.propsRequireReflow.indexOf(a) && (d ? c.isDirtyBox = !0 : q = !0);
                });
                !c.styledMode && h.style && c.renderer.setStyle(c.options.chart.style || {});
              }

              !c.styledMode && b.colors && (this.options.colors = b.colors);
              b.time && (this.time === F && (this.time = new y(b.time)), Y(!0, c.options.time, b.time));
              Z(b, function (a, e) {
                if (c[e] && "function" === typeof c[e].update) c[e].update(a, !1);else if ("function" === typeof c[g[e]]) c[g[e]](a);else "colors" !== e && -1 === c.collectionsWithUpdate.indexOf(e) && Y(!0, c.options[e], b[e]);
                "chart" !== e && -1 !== c.propsRequireUpdateSeries.indexOf(e) && (p = !0);
              });
              this.collectionsWithUpdate.forEach(function (a) {
                if (b[a]) {
                  var f = [];
                  c[a].forEach(function (b, a) {
                    b.options.isInternal || f.push(V(b.options.index, a));
                  });
                  M(b[a]).forEach(function (b, g) {
                    var d = P(b.id),
                        l;
                    d && (l = c.get(b.id));
                    !l && c[a] && (l = c[a][f ? f[g] : g]) && d && P(l.options.id) && (l = void 0);
                    l && l.coll === a && (l.update(b, !1), e && (l.touched = !0));
                    !l && e && c.collectionsWithInit[a] && (c.collectionsWithInit[a][0].apply(c, [b].concat(c.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
                  });
                  e && c[a].forEach(function (b) {
                    b.touched || b.options.isInternal ? delete b.touched : l.push(b);
                  });
                }
              });
              l.forEach(function (b) {
                b.chart && b.remove && b.remove(!1);
              });
              m && c.axes.forEach(function (b) {
                b.update({}, !1);
              });
              p && c.getSeriesOrderByLinks().forEach(function (b) {
                b.chart && b.update({}, !1);
              }, this);
              m = h && h.width;
              h = h && (da(h.height) ? ha(h.height, m || c.chartWidth) : h.height);
              q || X(m) && m !== c.chartWidth || X(h) && h !== c.chartHeight ? c.setSize(m, h, f) : V(a, !0) && c.redraw(f);
              S(c, "afterUpdate", {
                options: b,
                redraw: a,
                animation: f
              });
            };

            a.prototype.setSubtitle = function (b, a) {
              this.applyDescription("subtitle", b);
              this.layOutTitles(a);
            };

            a.prototype.setCaption = function (b, a) {
              this.applyDescription("caption", b);
              this.layOutTitles(a);
            };

            a.prototype.showResetZoom = function () {
              function b() {
                a.zoomOut();
              }

              var a = this,
                  e = v.lang,
                  f = a.options.chart.resetZoomButton,
                  c = f.theme,
                  g = c.states,
                  d = "chart" === f.relativeTo || "spacingBox" === f.relativeTo ? null : "scrollablePlotBox";
              S(this, "beforeShowResetZoom", null, function () {
                a.resetZoomButton = a.renderer.button(e.resetZoom, null, null, b, c, g && g.hover).attr({
                  align: f.position.align,
                  title: e.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(f.position, !1, d);
              });
              S(this, "afterShowResetZoom");
            };

            a.prototype.zoomOut = function () {
              S(this, "selection", {
                resetSelection: !0
              }, this.zoom);
            };

            a.prototype.zoom = function (b) {
              var a = this,
                  e = a.pointer,
                  f = a.inverted ? e.mouseDownX : e.mouseDownY,
                  c = !1,
                  g;
              !b || b.resetSelection ? (a.axes.forEach(function (b) {
                g = b.zoom();
              }), e.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
                var d = b.axis,
                    l = a.inverted ? d.left : d.top,
                    p = a.inverted ? l + d.width : l + d.height,
                    q = d.isXAxis,
                    h = !1;
                if (!q && f >= l && f <= p || q || !P(f)) h = !0;
                e[q ? "zoomX" : "zoomY"] && h && (g = d.zoom(b.min, b.max), d.displayBtn && (c = !0));
              });
              var d = a.resetZoomButton;
              c && !d ? a.showResetZoom() : !c && U(d) && (a.resetZoomButton = d.destroy());
              g && a.redraw(V(a.options.chart.animation, b && b.animation, 100 > a.pointCount));
            };

            a.prototype.pan = function (b, a) {
              var e = this,
                  f = e.hoverPoints;
              a = "object" === typeof a ? a : {
                enabled: a,
                type: "x"
              };
              var c = e.options.chart,
                  g = e.options.mapNavigation && e.options.mapNavigation.enabled;
              c && c.panning && (c.panning = a);
              var d = a.type,
                  l;
              S(this, "pan", {
                originalEvent: b
              }, function () {
                f && f.forEach(function (b) {
                  b.setState();
                });
                var a = e.xAxis;
                "xy" === d ? a = a.concat(e.yAxis) : "y" === d && (a = e.yAxis);
                var c = {};
                a.forEach(function (a) {
                  if (a.options.panningEnabled && !a.options.isInternal) {
                    var f = a.horiz,
                        p = b[f ? "chartX" : "chartY"];
                    f = f ? "mouseDownX" : "mouseDownY";
                    var q = e[f],
                        h = a.minPointOffset || 0,
                        m = a.reversed && !e.inverted || !a.reversed && e.inverted ? -1 : 1,
                        z = a.getExtremes(),
                        n = a.toValue(q - p, !0) + h * m,
                        k = a.toValue(q + a.len - p, !0) - (h * m || a.isXAxis && a.pointRangePadding || 0),
                        u = k < n;
                    m = a.hasVerticalPanning();
                    q = u ? k : n;
                    n = u ? n : k;
                    var v = a.panningState;
                    !m || a.isXAxis || v && !v.isDirty || a.series.forEach(function (b) {
                      var a = b.getProcessedData(!0);
                      a = b.getExtremes(a.yData, !0);
                      v || (v = {
                        startMin: Number.MAX_VALUE,
                        startMax: -Number.MAX_VALUE
                      });
                      X(a.dataMin) && X(a.dataMax) && (v.startMin = Math.min(V(b.options.threshold, Infinity), a.dataMin, v.startMin), v.startMax = Math.max(V(b.options.threshold, -Infinity), a.dataMax, v.startMax));
                    });
                    m = Math.min(V(v && v.startMin, z.dataMin), h ? z.min : a.toValue(a.toPixels(z.min) - a.minPixelPadding));
                    k = Math.max(V(v && v.startMax, z.dataMax), h ? z.max : a.toValue(a.toPixels(z.max) + a.minPixelPadding));
                    a.panningState = v;
                    a.isOrdinal || (h = m - q, 0 < h && (n += h, q = m), h = n - k, 0 < h && (n = k, q -= h), a.series.length && q !== z.min && n !== z.max && q >= m && n <= k && (a.setExtremes(q, n, !1, !1, {
                      trigger: "pan"
                    }), e.resetZoomButton || g || q === m || n === k || !d.match("y") || (e.showResetZoom(), a.displayBtn = !1), l = !0), c[f] = p);
                  }
                });
                Z(c, function (b, a) {
                  e[a] = b;
                });
                l && e.redraw(!1);
                z(e.container, {
                  cursor: "move"
                });
              });
            };

            return a;
          }();

          B(c.prototype, {
            callbacks: [],
            collectionsWithInit: {
              xAxis: [c.prototype.addAxis, [!0]],
              yAxis: [c.prototype.addAxis, [!1]],
              series: [c.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
          });
          "";
          return c;
        });
        M(d, "Core/Legend/LegendSymbol.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.merge,
              E = c.pick,
              G;

          (function (c) {
            c.drawLineMarker = function (c) {
              var B = this.options,
                  A = c.symbolWidth,
                  r = c.symbolHeight,
                  k = r / 2,
                  h = this.chart.renderer,
                  a = this.legendGroup;
              c = c.baseline - Math.round(.3 * c.fontMetrics.b);
              var g = {},
                  y = B.marker;
              this.chart.styledMode || (g = {
                "stroke-width": B.lineWidth || 0
              }, B.dashStyle && (g.dashstyle = B.dashStyle));
              this.legendLine = h.path([["M", 0, c], ["L", A, c]]).addClass("highcharts-graph").attr(g).add(a);
              y && !1 !== y.enabled && A && (B = Math.min(E(y.radius, k), k), 0 === this.symbol.indexOf("url") && (y = d(y, {
                width: r,
                height: r
              }), B = 0), this.legendSymbol = A = h.symbol(this.symbol, A / 2 - B, c - B, 2 * B, 2 * B, y).addClass("highcharts-point").add(a), A.isMarker = !0);
            };

            c.drawRectangle = function (c, d) {
              var A = c.symbolHeight,
                  r = c.options.squareSymbol;
              d.legendSymbol = this.chart.renderer.rect(r ? (c.symbolWidth - A) / 2 : 0, c.baseline - A + 1, r ? A : c.symbolWidth, A, E(c.options.symbolRadius, A / 2)).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(d.legendGroup);
            };
          })(G || (G = {}));

          return G;
        });
        M(d, "Core/Series/SeriesDefaults.js", [d["Core/Color/Palette.js"]], function (c) {
          return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
              duration: 1E3
            },
            events: {},
            marker: {
              enabledThreshold: 2,
              lineColor: c.backgroundColor,
              lineWidth: 0,
              radius: 4,
              states: {
                normal: {
                  animation: !0
                },
                hover: {
                  animation: {
                    duration: 50
                  },
                  enabled: !0,
                  radiusPlus: 2,
                  lineWidthPlus: 1
                },
                select: {
                  fillColor: c.neutralColor20,
                  lineColor: c.neutralColor100,
                  lineWidth: 2
                }
              }
            },
            point: {
              events: {}
            },
            dataLabels: {
              animation: {},
              align: "center",
              defer: !0,
              formatter: function formatter() {
                var c = this.series.chart.numberFormatter;
                return "number" !== typeof this.y ? "" : c(this.y, -1);
              },
              padding: 5,
              style: {
                fontSize: "11px",
                fontWeight: "bold",
                color: "contrast",
                textOutline: "1px contrast"
              },
              verticalAlign: "bottom",
              x: 0,
              y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                lineWidthPlus: 1,
                marker: {},
                halo: {
                  size: 10,
                  opacity: .25
                }
              },
              select: {
                animation: {
                  duration: 0
                }
              },
              inactive: {
                animation: {
                  duration: 50
                },
                opacity: .2
              }
            },
            stickyTracking: !0,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
          };
        });
        M(d, "Core/Series/Series.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/DefaultOptions.js"], d["Core/Foundation.js"], d["Core/Globals.js"], d["Core/Legend/LegendSymbol.js"], d["Core/Color/Palette.js"], d["Core/Series/Point.js"], d["Core/Series/SeriesDefaults.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Renderer/SVG/SVGElement.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A, r, k, h) {
          var a = c.animObject,
              g = c.setAnimation,
              y = d.defaultOptions,
              n = E.registerEventOptions,
              t = G.hasTouch,
              O = G.svg,
              m = G.win,
              N = r.seriesTypes,
              L = h.addEvent,
              x = h.arrayMax,
              B = h.arrayMin,
              H = h.clamp,
              w = h.cleanRecursively,
              f = h.correctFloat,
              b = h.defined,
              v = h.erase,
              F = h.error,
              e = h.extend,
              q = h.find,
              l = h.fireEvent,
              I = h.getNestedProperty,
              p = h.isArray,
              z = h.isNumber,
              P = h.isString,
              T = h.merge,
              J = h.objectEach,
              u = h.pick,
              ia = h.removeEvent,
              ba = h.splat,
              S = h.syncTimeout;

          c = function () {
            function c() {
              this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }

            c.prototype.init = function (b, a) {
              l(this, "init", {
                options: a
              });
              var c = this,
                  f = b.series;
              this.eventsToUnbind = [];
              c.chart = b;
              c.options = c.setOptions(a);
              a = c.options;
              c.linkedSeries = [];
              c.bindAxes();
              e(c, {
                name: a.name,
                state: "",
                visible: !1 !== a.visible,
                selected: !0 === a.selected
              });
              n(this, a);
              var g = a.events;
              if (g && g.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;
              c.getColor();
              c.getSymbol();
              c.parallelArrays.forEach(function (b) {
                c[b + "Data"] || (c[b + "Data"] = []);
              });
              c.isCartesian && (b.hasCartesianSeries = !0);
              var d;
              f.length && (d = f[f.length - 1]);
              c._i = u(d && d._i, -1) + 1;
              c.opacity = c.options.opacity;
              b.orderSeries(this.insert(f));
              a.dataSorting && a.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(a.data, !1);
              l(this, "afterInit");
            };

            c.prototype.is = function (b) {
              return N[b] && this instanceof N[b];
            };

            c.prototype.insert = function (b) {
              var a = this.options.index,
                  e;

              if (z(a)) {
                for (e = b.length; e--;) {
                  if (a >= u(b[e].options.index, b[e]._i)) {
                    b.splice(e + 1, 0, this);
                    break;
                  }
                }

                -1 === e && b.unshift(this);
                e += 1;
              } else b.push(this);

              return u(e, b.length - 1);
            };

            c.prototype.bindAxes = function () {
              var b = this,
                  a = b.options,
                  e = b.chart,
                  c;
              l(this, "bindAxes", null, function () {
                (b.axisTypes || []).forEach(function (f) {
                  var g = 0;
                  e[f].forEach(function (e) {
                    c = e.options;
                    if (a[f] === g && !c.isInternal || "undefined" !== typeof a[f] && a[f] === c.id || "undefined" === typeof a[f] && 0 === c.index) b.insert(e.series), b[f] = e, e.isDirty = !0;
                    c.isInternal || g++;
                  });
                  b[f] || b.optionalAxis === f || F(18, !0, e);
                });
              });
              l(this, "afterBindAxes");
            };

            c.prototype.updateParallelArrays = function (b, a) {
              var e = b.series,
                  c = arguments,
                  f = z(a) ? function (c) {
                var f = "y" === c && e.toYData ? e.toYData(b) : b[c];
                e[c + "Data"][a] = f;
              } : function (b) {
                Array.prototype[a].apply(e[b + "Data"], Array.prototype.slice.call(c, 2));
              };
              e.parallelArrays.forEach(f);
            };

            c.prototype.hasData = function () {
              return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };

            c.prototype.autoIncrement = function (b) {
              var a = this.options,
                  e = a.pointIntervalUnit,
                  c = a.relativeXValue,
                  f = this.chart.time,
                  g = this.xIncrement,
                  d;
              g = u(g, a.pointStart, 0);
              this.pointInterval = d = u(this.pointInterval, a.pointInterval, 1);
              c && z(b) && (d *= b);
              e && (a = new f.Date(g), "day" === e ? f.set("Date", a, f.get("Date", a) + d) : "month" === e ? f.set("Month", a, f.get("Month", a) + d) : "year" === e && f.set("FullYear", a, f.get("FullYear", a) + d), d = a.getTime() - g);
              if (c && z(b)) return g + d;
              this.xIncrement = g + d;
              return g;
            };

            c.prototype.setDataSortingOptions = function () {
              var a = this.options;
              e(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1
              });
              b(a.pointRange) || (a.pointRange = 1);
            };

            c.prototype.setOptions = function (a) {
              var e = this.chart,
                  c = e.options,
                  f = c.plotOptions,
                  g = e.userOptions || {};
              a = T(a);
              e = e.styledMode;
              var d = {
                plotOptions: f,
                userOptions: a
              };
              l(this, "setOptions", d);
              var p = d.plotOptions[this.type],
                  q = g.plotOptions || {};
              this.userOptions = d.userOptions;
              g = T(p, f.series, g.plotOptions && g.plotOptions[this.type], a);
              this.tooltipOptions = T(y.tooltip, y.plotOptions.series && y.plotOptions.series.tooltip, y.plotOptions[this.type].tooltip, c.tooltip.userOptions, f.series && f.series.tooltip, f[this.type].tooltip, a.tooltip);
              this.stickyTracking = u(a.stickyTracking, q[this.type] && q[this.type].stickyTracking, q.series && q.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : g.stickyTracking);
              null === p.marker && delete g.marker;
              this.zoneAxis = g.zoneAxis;
              f = this.zones = (g.zones || []).slice();
              !g.negativeColor && !g.negativeFillColor || g.zones || (c = {
                value: g[this.zoneAxis + "Threshold"] || g.threshold || 0,
                className: "highcharts-negative"
              }, e || (c.color = g.negativeColor, c.fillColor = g.negativeFillColor), f.push(c));
              f.length && b(f[f.length - 1].value) && f.push(e ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
              l(this, "afterSetOptions", {
                options: g
              });
              return g;
            };

            c.prototype.getName = function () {
              return u(this.options.name, "Series " + (this.index + 1));
            };

            c.prototype.getCyclic = function (a, e, c) {
              var f = this.chart,
                  g = this.userOptions,
                  d = a + "Index",
                  l = a + "Counter",
                  p = c ? c.length : u(f.options.chart[a + "Count"], f[a + "Count"]);

              if (!e) {
                var q = u(g[d], g["_" + d]);
                b(q) || (f.series.length || (f[l] = 0), g["_" + d] = q = f[l] % p, f[l] += 1);
                c && (e = c[q]);
              }

              "undefined" !== typeof q && (this[d] = q);
              this[a] = e;
            };

            c.prototype.getColor = function () {
              this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = D.neutralColor20 : this.getCyclic("color", this.options.color || y.plotOptions[this.type].color, this.chart.options.colors);
            };

            c.prototype.getPointsCollection = function () {
              return (this.hasGroupedData ? this.points : this.data) || [];
            };

            c.prototype.getSymbol = function () {
              this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };

            c.prototype.findPointIndex = function (b, a) {
              var e = b.id,
                  c = b.x,
                  f = this.points,
                  g = this.options.dataSorting,
                  d,
                  l;
              if (e) g = this.chart.get(e), g instanceof K && (d = g);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (d = function d(a) {
                return !a.touched && a.index === b.index;
              }, g && g.matchByName ? d = function d(a) {
                return !a.touched && a.name === b.name;
              } : this.options.relativeXValue && (d = function d(a) {
                return !a.touched && a.options.x === b.x;
              }), d = q(f, d), !d) return;

              if (d) {
                var p = d && d.index;
                "undefined" !== typeof p && (l = !0);
              }

              "undefined" === typeof p && z(c) && (p = this.xData.indexOf(c, a));
              -1 !== p && "undefined" !== typeof p && this.cropped && (p = p >= this.cropStart ? p - this.cropStart : p);
              !l && z(p) && f[p] && f[p].touched && (p = void 0);
              return p;
            };

            c.prototype.updateData = function (a, e) {
              var c = this.options,
                  f = c.dataSorting,
                  g = this.points,
                  d = [],
                  l = this.requireSorting,
                  p = a.length === g.length,
                  q,
                  h,
                  m,
                  n = !0;
              this.xIncrement = null;
              a.forEach(function (a, e) {
                var h = b(a) && this.pointClass.prototype.optionsToObject.call({
                  series: this
                }, a) || {},
                    n = h.x;

                if (h.id || z(n)) {
                  if (h = this.findPointIndex(h, m), -1 === h || "undefined" === typeof h ? d.push(a) : g[h] && a !== c.data[h] ? (g[h].update(a, !1, null, !1), g[h].touched = !0, l && (m = h + 1)) : g[h] && (g[h].touched = !0), !p || e !== h || f && f.enabled || this.hasDerivedData) q = !0;
                } else d.push(a);
              }, this);
              if (q) for (a = g.length; a--;) {
                (h = g[a]) && !h.touched && h.remove && h.remove(!1, e);
              } else !p || f && f.enabled ? n = !1 : (a.forEach(function (b, a) {
                b !== g[a].y && g[a].update && g[a].update(b, !1, null, !1);
              }), d.length = 0);
              g.forEach(function (b) {
                b && (b.touched = !1);
              });
              if (!n) return !1;
              d.forEach(function (b) {
                this.addPoint(b, !1, null, null, !1);
              }, this);
              null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement());
              return !0;
            };

            c.prototype.setData = function (b, a, e, c) {
              var f = this,
                  g = f.points,
                  d = g && g.length || 0,
                  l = f.options,
                  q = f.chart,
                  h = l.dataSorting,
                  m = f.xAxis,
                  n = l.turboThreshold,
                  k = this.xData,
                  v = this.yData,
                  I = f.pointArrayMap;
              I = I && I.length;
              var w = l.keys,
                  t,
                  x = 0,
                  y = 1,
                  Q = null;
              b = b || [];
              var r = b.length;
              a = u(a, !0);
              h && h.enabled && (b = this.sortData(b));
              !1 !== c && r && d && !f.cropped && !f.hasGroupedData && f.visible && !f.isSeriesBoosting && (t = this.updateData(b, e));

              if (!t) {
                f.xIncrement = null;
                f.colorCounter = 0;
                this.parallelArrays.forEach(function (b) {
                  f[b + "Data"].length = 0;
                });
                if (n && r > n) {
                  if (Q = f.getFirstValidPoint(b), z(Q)) for (e = 0; e < r; e++) {
                    k[e] = this.autoIncrement(), v[e] = b[e];
                  } else if (p(Q)) {
                    if (I) for (e = 0; e < r; e++) {
                      c = b[e], k[e] = c[0], v[e] = c.slice(1, I + 1);
                    } else for (w && (x = w.indexOf("x"), y = w.indexOf("y"), x = 0 <= x ? x : 0, y = 0 <= y ? y : 1), e = 0; e < r; e++) {
                      c = b[e], k[e] = c[x], v[e] = c[y];
                    }
                  } else F(12, !1, q);
                } else for (e = 0; e < r; e++) {
                  "undefined" !== typeof b[e] && (c = {
                    series: f
                  }, f.pointClass.prototype.applyOptions.apply(c, [b[e]]), f.updateParallelArrays(c, e));
                }
                v && P(v[0]) && F(14, !0, q);
                f.data = [];
                f.options.data = f.userOptions.data = b;

                for (e = d; e--;) {
                  g[e] && g[e].destroy && g[e].destroy();
                }

                m && (m.minRange = m.userMinRange);
                f.isDirty = q.isDirtyBox = !0;
                f.isDirtyData = !!g;
                e = !1;
              }

              "point" === l.legendType && (this.processData(), this.generatePoints());
              a && q.redraw(e);
            };

            c.prototype.sortData = function (a) {
              var e = this,
                  c = e.options.dataSorting.sortKey || "y",
                  f = function f(a, e) {
                return b(e) && a.pointClass.prototype.optionsToObject.call({
                  series: a
                }, e) || {};
              };

              a.forEach(function (b, c) {
                a[c] = f(e, b);
                a[c].index = c;
              }, this);
              a.concat().sort(function (b, a) {
                b = I(c, b);
                a = I(c, a);
                return a < b ? -1 : a > b ? 1 : 0;
              }).forEach(function (b, a) {
                b.x = a;
              }, this);
              e.linkedSeries && e.linkedSeries.forEach(function (b) {
                var e = b.options,
                    c = e.data;
                e.dataSorting && e.dataSorting.enabled || !c || (c.forEach(function (e, g) {
                  c[g] = f(b, e);
                  a[g] && (c[g].x = a[g].x, c[g].index = g);
                }), b.setData(c, !1));
              });
              return a;
            };

            c.prototype.getProcessedData = function (b) {
              var a = this.xAxis,
                  e = this.options,
                  c = e.cropThreshold,
                  f = b || this.getExtremesFromAll || e.getExtremesFromAll,
                  g = this.isCartesian;
              b = a && a.val2lin;
              e = !(!a || !a.logarithmic);
              var d = 0,
                  l = this.xData,
                  p = this.yData,
                  q = this.requireSorting;
              var h = !1;
              var m = l.length;

              if (a) {
                h = a.getExtremes();
                var z = h.min;
                var n = h.max;
                h = a.categories && !a.names.length;
              }

              if (g && this.sorted && !f && (!c || m > c || this.forceCrop)) if (l[m - 1] < z || l[0] > n) l = [], p = [];else if (this.yData && (l[0] < z || l[m - 1] > n)) {
                var k = this.cropData(this.xData, this.yData, z, n);
                l = k.xData;
                p = k.yData;
                d = k.start;
                k = !0;
              }

              for (c = l.length || 1; --c;) {
                if (a = e ? b(l[c]) - b(l[c - 1]) : l[c] - l[c - 1], 0 < a && ("undefined" === typeof v || a < v)) var v = a;else 0 > a && q && !h && (F(15, !1, this.chart), q = !1);
              }

              return {
                xData: l,
                yData: p,
                cropped: k,
                cropStart: d,
                closestPointRange: v
              };
            };

            c.prototype.processData = function (b) {
              var a = this.xAxis;
              if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;
              b = this.getProcessedData();
              this.cropped = b.cropped;
              this.cropStart = b.cropStart;
              this.processedXData = b.xData;
              this.processedYData = b.yData;
              this.closestPointRange = this.basePointRange = b.closestPointRange;
            };

            c.prototype.cropData = function (b, a, e, c, f) {
              var g = b.length,
                  d,
                  l = 0,
                  p = g;
              f = u(f, this.cropShoulder);

              for (d = 0; d < g; d++) {
                if (b[d] >= e) {
                  l = Math.max(0, d - f);
                  break;
                }
              }

              for (e = d; e < g; e++) {
                if (b[e] > c) {
                  p = e + f;
                  break;
                }
              }

              return {
                xData: b.slice(l, p),
                yData: a.slice(l, p),
                start: l,
                end: p
              };
            };

            c.prototype.generatePoints = function () {
              var b = this.options,
                  a = b.data,
                  c = this.processedXData,
                  f = this.processedYData,
                  g = this.pointClass,
                  d = c.length,
                  p = this.cropStart || 0,
                  q = this.hasGroupedData,
                  h = b.keys,
                  m = [];
              b = b.dataGrouping && b.dataGrouping.groupAll ? p : 0;
              var z,
                  n,
                  k = this.data;

              if (!k && !q) {
                var v = [];
                v.length = a.length;
                k = this.data = v;
              }

              h && q && (this.options.keys = !1);

              for (n = 0; n < d; n++) {
                v = p + n;

                if (q) {
                  var u = new g().init(this, [c[n]].concat(ba(f[n])));
                  u.dataGroup = this.groupMap[b + n];
                  u.dataGroup.options && (u.options = u.dataGroup.options, e(u, u.dataGroup.options), delete u.dataLabels);
                } else (u = k[v]) || "undefined" === typeof a[v] || (k[v] = u = new g().init(this, a[v], c[n]));

                u && (u.index = q ? b + n : v, m[n] = u);
              }

              this.options.keys = h;
              if (k && (d !== (z = k.length) || q)) for (n = 0; n < z; n++) {
                n !== p || q || (n += d), k[n] && (k[n].destroyElements(), k[n].plotX = void 0);
              }
              this.data = k;
              this.points = m;
              l(this, "afterGeneratePoints");
            };

            c.prototype.getXExtremes = function (b) {
              return {
                min: B(b),
                max: x(b)
              };
            };

            c.prototype.getExtremes = function (b, a) {
              var e = this.xAxis,
                  c = this.yAxis,
                  f = this.processedXData || this.xData,
                  g = [],
                  d = this.requireSorting ? this.cropShoulder : 0;
              c = c ? c.positiveValuesOnly : !1;
              var q,
                  h = 0,
                  m = 0,
                  n = 0;
              b = b || this.stackedYData || this.processedYData || [];
              var k = b.length;

              if (e) {
                var v = e.getExtremes();
                h = v.min;
                m = v.max;
              }

              for (q = 0; q < k; q++) {
                var u = f[q];
                v = b[q];
                var I = (z(v) || p(v)) && (v.length || 0 < v || !c);
                u = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !e || (f[q + d] || u) >= h && (f[q - d] || u) <= m;
                if (I && u) if (I = v.length) for (; I--;) {
                  z(v[I]) && (g[n++] = v[I]);
                } else g[n++] = v;
              }

              b = {
                dataMin: B(g),
                dataMax: x(g)
              };
              l(this, "afterGetExtremes", {
                dataExtremes: b
              });
              return b;
            };

            c.prototype.applyExtremes = function () {
              var b = this.getExtremes();
              this.dataMin = b.dataMin;
              this.dataMax = b.dataMax;
              return b;
            };

            c.prototype.getFirstValidPoint = function (b) {
              for (var a = b.length, e = 0, c = null; null === c && e < a;) {
                c = b[e], e++;
              }

              return c;
            };

            c.prototype.translate = function () {
              this.processedXData || this.processData();
              this.generatePoints();
              var a = this.options,
                  e = a.stacking,
                  c = this.xAxis,
                  g = c.categories,
                  d = this.enabledDataSorting,
                  q = this.yAxis,
                  h = this.points,
                  m = h.length,
                  n = !!this.modifyValue,
                  k = this.pointPlacementToXValue(),
                  v = !!k,
                  I = a.threshold,
                  w = a.startFromThreshold ? I : 0,
                  t = this.zoneAxis || "y",
                  x,
                  y,
                  P = Number.MAX_VALUE;

              for (x = 0; x < m; x++) {
                var F = h[x],
                    r = F.x,
                    J = void 0,
                    O = void 0,
                    L = F.y,
                    N = F.low,
                    T = e && q.stacking && q.stacking.stacks[(this.negStacks && L < (w ? 0 : I) ? "-" : "") + this.stackKey];
                if (q.positiveValuesOnly && !q.validatePositiveValue(L) || c.positiveValuesOnly && !c.validatePositiveValue(r)) F.isNull = !0;
                F.plotX = y = f(H(c.translate(r, 0, 0, 0, 1, k, "flags" === this.type), -1E5, 1E5));

                if (e && this.visible && T && T[r]) {
                  var A = this.getStackIndicator(A, r, this.index);
                  F.isNull || (J = T[r], O = J.points[A.key]);
                }

                p(O) && (N = O[0], L = O[1], N === w && A.key === T[r].base && (N = u(z(I) && I, q.min)), q.positiveValuesOnly && 0 >= N && (N = null), F.total = F.stackTotal = J.total, F.percentage = J.total && F.y / J.total * 100, F.stackY = L, this.irregularWidths || J.setOffset(this.pointXOffset || 0, this.barW || 0));
                F.yBottom = b(N) ? H(q.translate(N, 0, 1, 0, 1), -1E5, 1E5) : null;
                n && (L = this.modifyValue(L, F));
                F.plotY = void 0;
                z(L) && (J = q.translate(L, !1, !0, !1, !0), "undefined" !== typeof J && (F.plotY = H(J, -1E5, 1E5)));
                F.isInside = this.isPointInside(F);
                F.clientX = v ? f(c.translate(r, 0, 0, 0, 1, k)) : y;
                F.negative = F[t] < (a[t + "Threshold"] || I || 0);
                F.category = g && "undefined" !== typeof g[F.x] ? g[F.x] : F.x;

                if (!F.isNull && !1 !== F.visible) {
                  "undefined" !== typeof B && (P = Math.min(P, Math.abs(y - B)));
                  var B = y;
                }

                F.zone = this.zones.length && F.getZone();
                !F.graphic && this.group && d && (F.isNew = !0);
              }

              this.closestPointRangePx = P;
              l(this, "afterTranslate");
            };

            c.prototype.getValidPoints = function (b, a, e) {
              var c = this.chart;
              return (b || this.points || []).filter(function (b) {
                return a && !c.isInsidePlot(b.plotX, b.plotY, {
                  inverted: c.inverted
                }) ? !1 : !1 !== b.visible && (e || !b.isNull);
              });
            };

            c.prototype.getClipBox = function (b, a) {
              var e = this.options,
                  c = this.chart,
                  f = c.inverted,
                  g = this.xAxis,
                  d = g && this.yAxis,
                  l = c.options.chart.scrollablePlotArea || {};
              b && !1 === e.clip && d ? b = f ? {
                y: -c.chartWidth + d.len + d.pos,
                height: c.chartWidth,
                width: c.chartHeight,
                x: -c.chartHeight + g.len + g.pos
              } : {
                y: -d.pos,
                height: c.chartHeight,
                width: c.chartWidth,
                x: -g.pos
              } : (b = this.clipBox || c.clipBox, a && (b.width = c.plotSizeX, b.x = (c.scrollablePixelsX || 0) * (l.scrollPositionX || 0)));
              return a ? {
                width: b.width,
                x: b.x
              } : b;
            };

            c.prototype.getSharedClipKey = function (b) {
              if (this.sharedClipKey) return this.sharedClipKey;
              var a = [b && b.duration, b && b.easing, b && b.defer, this.getClipBox(b).height, this.options.xAxis, this.options.yAxis].join();
              if (!1 !== this.options.clip || b) this.sharedClipKey = a;
              return a;
            };

            c.prototype.setClip = function (b) {
              var a = this.chart,
                  e = this.options,
                  c = a.renderer,
                  f = a.inverted,
                  g = this.clipBox,
                  d = this.getClipBox(b),
                  l = this.getSharedClipKey(b),
                  p = a.sharedClips[l],
                  q = a.sharedClips[l + "m"];
              b && (d.width = 0, f && (d.x = a.plotHeight + (!1 !== e.clip ? 0 : a.plotTop)));
              p ? a.hasLoaded || p.attr(d) : (b && (a.sharedClips[l + "m"] = q = c.clipRect(f ? (a.plotSizeX || 0) + 99 : -99, f ? -a.plotLeft : -a.plotTop, 99, f ? a.chartWidth : a.chartHeight)), a.sharedClips[l] = p = c.clipRect(d), p.count = {
                length: 0
              });
              b && !p.count[this.index] && (p.count[this.index] = !0, p.count.length += 1);
              if (!1 !== e.clip || b) this.group.clip(b || g ? p : a.clipRect), this.markerGroup.clip(q);
              b || (p.count[this.index] && (delete p.count[this.index], --p.count.length), 0 === p.count.length && (g || (a.sharedClips[l] = p.destroy()), q && (a.sharedClips[l + "m"] = q.destroy())));
            };

            c.prototype.animate = function (b) {
              var e = this.chart,
                  c = a(this.options.animation),
                  f = this.sharedClipKey;
              if (b) this.setClip(c);else if (f) {
                b = e.sharedClips[f];
                f = e.sharedClips[f + "m"];
                var g = this.getClipBox(c, !0);
                b && b.animate(g, c);
                f && f.animate({
                  width: g.width + 99,
                  x: g.x - (e.inverted ? 0 : 99)
                }, c);
              }
            };

            c.prototype.afterAnimate = function () {
              this.setClip();
              l(this, "afterAnimate");
              this.finishedAnimating = !0;
            };

            c.prototype.drawPoints = function () {
              var b = this.points,
                  a = this.chart,
                  e = this.options.marker,
                  c = this[this.specialGroup] || this.markerGroup,
                  f = this.xAxis,
                  g = u(e.enabled, !f || f.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius),
                  d,
                  l;
              if (!1 !== e.enabled || this._hasPointMarkers) for (d = 0; d < b.length; d++) {
                var p = b[d];
                var q = (l = p.graphic) ? "animate" : "attr";
                var h = p.marker || {};
                var m = !!p.marker;

                if ((g && "undefined" === typeof h.enabled || h.enabled) && !p.isNull && !1 !== p.visible) {
                  var n = u(h.symbol, this.symbol, "rect");
                  var z = this.markerAttribs(p, p.selected && "select");
                  this.enabledDataSorting && (p.startXPos = f.reversed ? -(z.width || 0) : f.width);
                  var k = !1 !== p.isInside;
                  l ? l[k ? "show" : "hide"](k).animate(z) : k && (0 < (z.width || 0) || p.hasImage) && (p.graphic = l = a.renderer.symbol(n, z.x, z.y, z.width, z.height, m ? h : e).add(c), this.enabledDataSorting && a.hasRendered && (l.attr({
                    x: p.startXPos
                  }), q = "animate"));
                  l && "animate" === q && l[k ? "show" : "hide"](k).animate(z);
                  if (l && !a.styledMode) l[q](this.pointAttribs(p, p.selected && "select"));
                  l && l.addClass(p.getClassName(), !0);
                } else l && (p.graphic = l.destroy());
              }
            };

            c.prototype.markerAttribs = function (b, a) {
              var e = this.options,
                  c = e.marker,
                  f = b.marker || {},
                  g = f.symbol || c.symbol,
                  d = u(f.radius, c.radius);
              a && (c = c.states[a], a = f.states && f.states[a], d = u(a && a.radius, c && c.radius, d + (c && c.radiusPlus || 0)));
              b.hasImage = g && 0 === g.indexOf("url");
              b.hasImage && (d = 0);
              b = {
                x: e.crisp ? Math.floor(b.plotX - d) : b.plotX - d,
                y: b.plotY - d
              };
              d && (b.width = b.height = 2 * d);
              return b;
            };

            c.prototype.pointAttribs = function (b, a) {
              var e = this.options.marker,
                  c = b && b.options,
                  f = c && c.marker || {},
                  g = c && c.color,
                  d = b && b.color,
                  l = b && b.zone && b.zone.color,
                  p = this.color;
              b = u(f.lineWidth, e.lineWidth);
              c = 1;
              p = g || l || d || p;
              g = f.fillColor || e.fillColor || p;
              d = f.lineColor || e.lineColor || p;
              a = a || "normal";
              e = e.states[a];
              a = f.states && f.states[a] || {};
              b = u(a.lineWidth, e.lineWidth, b + u(a.lineWidthPlus, e.lineWidthPlus, 0));
              g = a.fillColor || e.fillColor || g;
              d = a.lineColor || e.lineColor || d;
              c = u(a.opacity, e.opacity, c);
              return {
                stroke: d,
                "stroke-width": b,
                fill: g,
                opacity: c
              };
            };

            c.prototype.destroy = function (b) {
              var a = this,
                  e = a.chart,
                  c = /AppleWebKit\/533/.test(m.navigator.userAgent),
                  f = a.data || [],
                  g,
                  d,
                  p,
                  q;
              l(a, "destroy");
              this.removeEvents(b);
              (a.axisTypes || []).forEach(function (b) {
                (q = a[b]) && q.series && (v(q.series, a), q.isDirty = q.forceRedraw = !0);
              });
              a.legendItem && a.chart.legend.destroyItem(a);

              for (d = f.length; d--;) {
                (p = f[d]) && p.destroy && p.destroy();
              }

              a.clips && a.clips.forEach(function (b) {
                return b.destroy();
              });
              h.clearTimeout(a.animationTimeout);
              J(a, function (b, a) {
                b instanceof k && !b.survive && (g = c && "group" === a ? "hide" : "destroy", b[g]());
              });
              e.hoverSeries === a && (e.hoverSeries = void 0);
              v(e.series, a);
              e.orderSeries();
              J(a, function (e, c) {
                b && "hcEvents" === c || delete a[c];
              });
            };

            c.prototype.applyZones = function () {
              var b = this,
                  a = this.chart,
                  e = a.renderer,
                  c = this.zones,
                  f = this.clips || [],
                  g = this.graph,
                  d = this.area,
                  l = Math.max(a.chartWidth, a.chartHeight),
                  p = this[(this.zoneAxis || "y") + "Axis"],
                  q = a.inverted,
                  h,
                  m,
                  z,
                  n,
                  k,
                  v,
                  I,
                  w,
                  t = !1;

              if (c.length && (g || d) && p && "undefined" !== typeof p.min) {
                var x = p.reversed;
                var y = p.horiz;
                g && !this.showLine && g.hide();
                d && d.hide();
                var F = p.getExtremes();
                c.forEach(function (c, P) {
                  h = x ? y ? a.plotWidth : 0 : y ? 0 : p.toPixels(F.min) || 0;
                  h = H(u(m, h), 0, l);
                  m = H(Math.round(p.toPixels(u(c.value, F.max), !0) || 0), 0, l);
                  t && (h = m = p.toPixels(F.max));
                  n = Math.abs(h - m);
                  k = Math.min(h, m);
                  v = Math.max(h, m);
                  p.isXAxis ? (z = {
                    x: q ? v : k,
                    y: 0,
                    width: n,
                    height: l
                  }, y || (z.x = a.plotHeight - z.x)) : (z = {
                    x: 0,
                    y: q ? v : k,
                    width: l,
                    height: n
                  }, y && (z.y = a.plotWidth - z.y));
                  q && e.isVML && (z = p.isXAxis ? {
                    x: 0,
                    y: x ? k : v,
                    height: z.width,
                    width: a.chartWidth
                  } : {
                    x: z.y - a.plotLeft - a.spacingBox.x,
                    y: 0,
                    width: z.height,
                    height: a.chartHeight
                  });
                  f[P] ? f[P].animate(z) : f[P] = e.clipRect(z);
                  I = b["zone-area-" + P];
                  w = b["zone-graph-" + P];
                  g && w && w.clip(f[P]);
                  d && I && I.clip(f[P]);
                  t = c.value > F.max;
                  b.resetZones && 0 === m && (m = void 0);
                });
                this.clips = f;
              } else b.visible && (g && g.show(!0), d && d.show(!0));
            };

            c.prototype.invertGroups = function (b) {
              function a() {
                ["group", "markerGroup"].forEach(function (a) {
                  e[a] && (c.renderer.isVML && e[a].attr({
                    width: e.yAxis.len,
                    height: e.xAxis.len
                  }), e[a].width = e.yAxis.len, e[a].height = e.xAxis.len, e[a].invert(e.isRadialSeries ? !1 : b));
                });
              }

              var e = this,
                  c = e.chart;
              e.xAxis && (e.eventsToUnbind.push(L(c, "resize", a)), a(), e.invertGroups = a);
            };

            c.prototype.plotGroup = function (a, e, c, f, g) {
              var d = this[a],
                  l = !d;
              c = {
                visibility: c,
                zIndex: f || .1
              };
              "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c.opacity = this.opacity);
              l && (this[a] = d = this.chart.renderer.g().add(g));
              d.addClass("highcharts-" + e + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (b(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (d.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
              d.attr(c)[l ? "attr" : "animate"](this.getPlotBox());
              return d;
            };

            c.prototype.getPlotBox = function () {
              var b = this.chart,
                  a = this.xAxis,
                  e = this.yAxis;
              b.inverted && (a = e, e = this.xAxis);
              return {
                translateX: a ? a.left : b.plotLeft,
                translateY: e ? e.top : b.plotTop,
                scaleX: 1,
                scaleY: 1
              };
            };

            c.prototype.removeEvents = function (b) {
              b || ia(this);
              this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
                b();
              }), this.eventsToUnbind.length = 0);
            };

            c.prototype.render = function () {
              var b = this,
                  e = b.chart,
                  c = b.options,
                  f = a(c.animation),
                  g = b.visible ? "inherit" : "hidden",
                  d = c.zIndex,
                  p = b.hasRendered,
                  q = e.seriesGroup,
                  h = e.inverted,
                  m = !b.finishedAnimating && e.renderer.isSVG && f.duration;
              l(this, "render");
              var z = b.plotGroup("group", "series", g, d, q);
              b.markerGroup = b.plotGroup("markerGroup", "markers", g, d, q);
              m && b.animate && b.animate(!0);
              z.inverted = u(b.invertible, b.isCartesian) ? h : !1;
              b.drawGraph && (b.drawGraph(), b.applyZones());
              b.visible && b.drawPoints();
              b.drawDataLabels && b.drawDataLabels();
              b.redrawPoints && b.redrawPoints();
              b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();
              b.invertGroups(h);
              !1 === c.clip || b.sharedClipKey || p || z.clip(e.clipRect);
              m && b.animate && b.animate();
              p || (m && f.defer && (m += f.defer), b.animationTimeout = S(function () {
                b.afterAnimate();
              }, m || 0));
              b.isDirty = !1;
              b.hasRendered = !0;
              l(b, "afterRender");
            };

            c.prototype.redraw = function () {
              var b = this.chart,
                  a = this.isDirty || this.isDirtyData,
                  e = this.group,
                  c = this.xAxis,
                  f = this.yAxis;
              e && (b.inverted && e.attr({
                width: b.plotWidth,
                height: b.plotHeight
              }), e.animate({
                translateX: u(c && c.left, b.plotLeft),
                translateY: u(f && f.top, b.plotTop)
              }));
              this.translate();
              this.render();
              a && delete this.kdTree;
            };

            c.prototype.searchPoint = function (b, a) {
              var e = this.xAxis,
                  c = this.yAxis,
                  f = this.chart.inverted;
              return this.searchKDTree({
                clientX: f ? e.len - b.chartY + e.pos : b.chartX - e.pos,
                plotY: f ? c.len - b.chartX + c.pos : b.chartY - c.pos
              }, a, b);
            };

            c.prototype.buildKDTree = function (b) {
              function a(b, c, f) {
                var g = b && b.length;

                if (g) {
                  var d = e.kdAxisArray[c % f];
                  b.sort(function (b, a) {
                    return b[d] - a[d];
                  });
                  g = Math.floor(g / 2);
                  return {
                    point: b[g],
                    left: a(b.slice(0, g), c + 1, f),
                    right: a(b.slice(g + 1), c + 1, f)
                  };
                }
              }

              this.buildingKdTree = !0;
              var e = this,
                  c = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete e.kdTree;
              S(function () {
                e.kdTree = a(e.getValidPoints(null, !e.directTouch), c, c);
                e.buildingKdTree = !1;
              }, e.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
            };

            c.prototype.searchKDTree = function (a, e, c) {
              function f(a, e, c, q) {
                var h = e.point,
                    m = g.kdAxisArray[c % q],
                    z = h,
                    n = b(a[d]) && b(h[d]) ? Math.pow(a[d] - h[d], 2) : null;
                var k = b(a[l]) && b(h[l]) ? Math.pow(a[l] - h[l], 2) : null;
                k = (n || 0) + (k || 0);
                h.dist = b(k) ? Math.sqrt(k) : Number.MAX_VALUE;
                h.distX = b(n) ? Math.sqrt(n) : Number.MAX_VALUE;
                m = a[m] - h[m];
                k = 0 > m ? "left" : "right";
                n = 0 > m ? "right" : "left";
                e[k] && (k = f(a, e[k], c + 1, q), z = k[p] < z[p] ? k : h);
                e[n] && Math.sqrt(m * m) < z[p] && (a = f(a, e[n], c + 1, q), z = a[p] < z[p] ? a : z);
                return z;
              }

              var g = this,
                  d = this.kdAxisArray[0],
                  l = this.kdAxisArray[1],
                  p = e ? "distX" : "dist";
              e = -1 < g.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              this.kdTree || this.buildingKdTree || this.buildKDTree(c);
              if (this.kdTree) return f(a, this.kdTree, e, e);
            };

            c.prototype.pointPlacementToXValue = function () {
              var b = this.options,
                  a = b.pointRange,
                  e = this.xAxis;
              b = b.pointPlacement;
              "between" === b && (b = e.reversed ? -.5 : .5);
              return z(b) ? b * (a || e.pointRange) : 0;
            };

            c.prototype.isPointInside = function (b) {
              return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= this.yAxis.len && 0 <= b.plotX && b.plotX <= this.xAxis.len;
            };

            c.prototype.drawTracker = function () {
              var b = this,
                  a = b.options,
                  e = a.trackByArea,
                  c = [].concat(e ? b.areaPath : b.graphPath),
                  f = b.chart,
                  g = f.pointer,
                  d = f.renderer,
                  p = f.options.tooltip.snap,
                  q = b.tracker,
                  h = function h(a) {
                if (f.hoverSeries !== b) b.onMouseOver();
              },
                  m = "rgba(192,192,192," + (O ? .0001 : .002) + ")";

              q ? q.attr({
                d: c
              }) : b.graph && (b.tracker = d.path(c).attr({
                visibility: b.visible ? "visible" : "hidden",
                zIndex: 2
              }).addClass(e ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), f.styledMode || b.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: m,
                fill: e ? m : "none",
                "stroke-width": b.graph.strokeWidth() + (e ? 0 : 2 * p)
              }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
                if (b && (b.addClass("highcharts-tracker").on("mouseover", h).on("mouseout", function (b) {
                  g.onTrackerMouseOut(b);
                }), a.cursor && !f.styledMode && b.css({
                  cursor: a.cursor
                }), t)) b.on("touchstart", h);
              }));
              l(this, "afterDrawTracker");
            };

            c.prototype.addPoint = function (b, a, e, c, f) {
              var g = this.options,
                  d = this.data,
                  p = this.chart,
                  q = this.xAxis;
              q = q && q.hasNames && q.names;
              var h = g.data,
                  m = this.xData,
                  z;
              a = u(a, !0);
              var n = {
                series: this
              };
              this.pointClass.prototype.applyOptions.apply(n, [b]);
              var k = n.x;
              var v = m.length;
              if (this.requireSorting && k < m[v - 1]) for (z = !0; v && m[v - 1] > k;) {
                v--;
              }
              this.updateParallelArrays(n, "splice", v, 0, 0);
              this.updateParallelArrays(n, v);
              q && n.name && (q[k] = n.name);
              h.splice(v, 0, b);
              z && (this.data.splice(v, 0, null), this.processData());
              "point" === g.legendType && this.generatePoints();
              e && (d[0] && d[0].remove ? d[0].remove(!1) : (d.shift(), this.updateParallelArrays(n, "shift"), h.shift()));
              !1 !== f && l(this, "addPoint", {
                point: n
              });
              this.isDirtyData = this.isDirty = !0;
              a && p.redraw(c);
            };

            c.prototype.removePoint = function (b, a, e) {
              var c = this,
                  f = c.data,
                  d = f[b],
                  p = c.points,
                  l = c.chart,
                  q = function q() {
                p && p.length === f.length && p.splice(b, 1);
                f.splice(b, 1);
                c.options.data.splice(b, 1);
                c.updateParallelArrays(d || {
                  series: c
                }, "splice", b, 1);
                d && d.destroy();
                c.isDirty = !0;
                c.isDirtyData = !0;
                a && l.redraw();
              };

              g(e, l);
              a = u(a, !0);
              d ? d.firePointEvent("remove", null, q) : q();
            };

            c.prototype.remove = function (b, a, e, c) {
              function f() {
                g.destroy(c);
                d.isDirtyLegend = d.isDirtyBox = !0;
                d.linkSeries();
                u(b, !0) && d.redraw(a);
              }

              var g = this,
                  d = g.chart;
              !1 !== e ? l(g, "remove", null, f) : f();
            };

            c.prototype.update = function (b, a) {
              b = w(b, this.userOptions);
              l(this, "update", {
                options: b
              });
              var c = this,
                  f = c.chart,
                  g = c.userOptions,
                  d = c.initialType || c.type,
                  p = f.options.plotOptions,
                  q = N[d].prototype,
                  h = c.finishedAnimating && {
                animation: !1
              },
                  m = {},
                  z,
                  n = ["eventOptions", "navigatorSeries", "baseSeries"],
                  k = b.type || g.type || f.options.chart.type,
                  v = !(this.hasDerivedData || k && k !== this.type || "undefined" !== typeof b.pointStart || "undefined" !== typeof b.pointInterval || "undefined" !== typeof b.relativeXValue || c.hasOptionChanged("dataGrouping") || c.hasOptionChanged("pointStart") || c.hasOptionChanged("pointInterval") || c.hasOptionChanged("pointIntervalUnit") || c.hasOptionChanged("keys"));
              k = k || d;
              v && (n.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== b.visible && n.push("area", "graph"), c.parallelArrays.forEach(function (b) {
                n.push(b + "Data");
              }), b.data && (b.dataSorting && e(c.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));
              b = T(g, h, {
                index: "undefined" === typeof g.index ? c.index : g.index,
                pointStart: u(p && p.series && p.series.pointStart, g.pointStart, c.xData[0])
              }, !v && {
                data: c.options.data
              }, b);
              v && b.data && (b.data = c.options.data);
              n = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(n);
              n.forEach(function (b) {
                n[b] = c[b];
                delete c[b];
              });
              p = !1;

              if (N[k]) {
                if (p = k !== c.type, c.remove(!1, !1, !1, !0), p) if (Object.setPrototypeOf) Object.setPrototypeOf(c, N[k].prototype);else {
                  h = Object.hasOwnProperty.call(c, "hcEvents") && c.hcEvents;

                  for (z in q) {
                    c[z] = void 0;
                  }

                  e(c, N[k].prototype);
                  h ? c.hcEvents = h : delete c.hcEvents;
                }
              } else F(17, !0, f, {
                missingModuleFor: k
              });

              n.forEach(function (b) {
                c[b] = n[b];
              });
              c.init(f, b);

              if (v && this.points) {
                var I = c.options;
                !1 === I.visible ? (m.graphic = 1, m.dataLabel = 1) : c._hasPointLabels || (b = I.marker, q = I.dataLabels, !b || !1 !== b.enabled && (g.marker && g.marker.symbol) === b.symbol || (m.graphic = 1), q && !1 === q.enabled && (m.dataLabel = 1));
                this.points.forEach(function (b) {
                  b && b.series && (b.resolveColor(), Object.keys(m).length && b.destroyElements(m), !1 === I.showInLegend && b.legendItem && f.legend.destroyItem(b));
                }, this);
              }

              c.initialType = d;
              f.linkSeries();
              p && c.linkedSeries.length && (c.isDirtyData = !0);
              l(this, "afterUpdate");
              u(a, !0) && f.redraw(v ? void 0 : !1);
            };

            c.prototype.setName = function (b) {
              this.name = this.options.name = this.userOptions.name = b;
              this.chart.isDirtyLegend = !0;
            };

            c.prototype.hasOptionChanged = function (b) {
              var a = this.options[b],
                  e = this.chart.options.plotOptions,
                  c = this.userOptions[b];
              return c ? a !== c : a !== u(e && e[this.type] && e[this.type][b], e && e.series && e.series[b], a);
            };

            c.prototype.onMouseOver = function () {
              var b = this.chart,
                  a = b.hoverSeries;
              b.pointer.setHoverChartIndex();
              if (a && a !== this) a.onMouseOut();
              this.options.events.mouseOver && l(this, "mouseOver");
              this.setState("hover");
              b.hoverSeries = this;
            };

            c.prototype.onMouseOut = function () {
              var b = this.options,
                  a = this.chart,
                  e = a.tooltip,
                  c = a.hoverPoint;
              a.hoverSeries = null;
              if (c) c.onMouseOut();
              this && b.events.mouseOut && l(this, "mouseOut");
              !e || this.stickyTracking || e.shared && !this.noSharedTooltip || e.hide();
              a.series.forEach(function (b) {
                b.setState("", !0);
              });
            };

            c.prototype.setState = function (b, a) {
              var e = this,
                  c = e.options,
                  f = e.graph,
                  g = c.inactiveOtherPoints,
                  d = c.states,
                  p = u(d[b || "normal"] && d[b || "normal"].animation, e.chart.options.chart.animation),
                  l = c.lineWidth,
                  q = 0,
                  h = c.opacity;
              b = b || "";

              if (e.state !== b && ([e.group, e.markerGroup, e.dataLabelsGroup].forEach(function (a) {
                a && (e.state && a.removeClass("highcharts-series-" + e.state), b && a.addClass("highcharts-series-" + b));
              }), e.state = b, !e.chart.styledMode)) {
                if (d[b] && !1 === d[b].enabled) return;
                b && (l = d[b].lineWidth || l + (d[b].lineWidthPlus || 0), h = u(d[b].opacity, h));
                if (f && !f.dashstyle) for (c = {
                  "stroke-width": l
                }, f.animate(c, p); e["zone-graph-" + q];) {
                  e["zone-graph-" + q].animate(c, p), q += 1;
                }
                g || [e.group, e.markerGroup, e.dataLabelsGroup, e.labelBySeries].forEach(function (b) {
                  b && b.animate({
                    opacity: h
                  }, p);
                });
              }

              a && g && e.points && e.setAllPointsToState(b || void 0);
            };

            c.prototype.setAllPointsToState = function (b) {
              this.points.forEach(function (a) {
                a.setState && a.setState(b);
              });
            };

            c.prototype.setVisible = function (b, a) {
              var e = this,
                  c = e.chart,
                  f = e.legendItem,
                  g = c.options.chart.ignoreHiddenSeries,
                  d = e.visible,
                  p = (e.visible = b = e.options.visible = e.userOptions.visible = "undefined" === typeof b ? !d : b) ? "show" : "hide";
              ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
                if (e[b]) e[b][p]();
              });
              if (c.hoverSeries === e || (c.hoverPoint && c.hoverPoint.series) === e) e.onMouseOut();
              f && c.legend.colorizeItem(e, b);
              e.isDirty = !0;
              e.options.stacking && c.series.forEach(function (b) {
                b.options.stacking && b.visible && (b.isDirty = !0);
              });
              e.linkedSeries.forEach(function (a) {
                a.setVisible(b, !1);
              });
              g && (c.isDirtyBox = !0);
              l(e, p);
              !1 !== a && c.redraw();
            };

            c.prototype.show = function () {
              this.setVisible(!0);
            };

            c.prototype.hide = function () {
              this.setVisible(!1);
            };

            c.prototype.select = function (b) {
              this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
              this.checkbox && (this.checkbox.checked = b);
              l(this, b ? "select" : "unselect");
            };

            c.prototype.shouldShowTooltip = function (b, a, e) {
              void 0 === e && (e = {});
              e.series = this;
              e.visiblePlotOnly = !0;
              return this.chart.isInsidePlot(b, a, e);
            };

            c.defaultOptions = A;
            return c;
          }();

          e(c.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: C.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: K,
            requireSorting: !0,
            sorted: !0
          });
          r.series = c;
          "";
          "";
          return c;
        });
        M(d, "Extensions/ScrollablePlotArea.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Axis/Axis.js"], d["Core/Chart/Chart.js"], d["Core/Series/Series.js"], d["Core/Renderer/RendererRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D) {
          var B = c.stop,
              A = D.addEvent,
              r = D.createElement,
              k = D.merge,
              h = D.pick;
          A(E, "afterSetChartSize", function (a) {
            var c = this.options.chart.scrollablePlotArea,
                h = c && c.minWidth;
            c = c && c.minHeight;

            if (!this.renderer.forExport) {
              if (h) {
                if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = k(this.plotBox);
                  this.plotBox.width = this.plotWidth += h;
                  this.inverted ? this.clipBox.height += h : this.clipBox.width += h;
                  var n = {
                    1: {
                      name: "right",
                      value: h
                    }
                  };
                }
              } else c && (this.scrollablePixelsY = h = Math.max(0, c - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = k(this.plotBox), this.plotBox.height = this.plotHeight += h, this.inverted ? this.clipBox.width += h : this.clipBox.height += h, n = {
                2: {
                  name: "bottom",
                  value: h
                }
              });

              n && !a.skipAxes && this.axes.forEach(function (a) {
                n[a.side] ? a.getPlotLinePath = function () {
                  var c = n[a.side].name,
                      g = this[c];
                  this[c] = g - n[a.side].value;
                  var h = d.prototype.getPlotLinePath.apply(this, arguments);
                  this[c] = g;
                  return h;
                } : (a.setAxisSize(), a.setAxisTranslation());
              });
            }
          });
          A(E, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });

          E.prototype.setUpScrolling = function () {
            var a = this,
                c = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            this.scrollablePixelsX && (c.overflowX = "auto");
            this.scrollablePixelsY && (c.overflowY = "auto");
            this.scrollingParent = r("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = r("div", {
              className: "highcharts-scrolling"
            }, c, this.scrollingParent);
            A(this.scrollingContainer, "scroll", function () {
              a.pointer && delete a.pointer.chartPosition;
            });
            this.innerContainer = r("div", {
              className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };

          E.prototype.moveFixedElements = function () {
            var a = this.container,
                c = this.fixedRenderer,
                d = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
                h;
            this.scrollablePixelsX && !this.inverted ? h = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? h = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? h = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (h = ".highcharts-yaxis");
            h && d.push(h + ":not(.highcharts-radial-axis)", h + "-labels:not(.highcharts-radial-axis-labels)");
            d.forEach(function (g) {
              [].forEach.call(a.querySelectorAll(g), function (a) {
                (a.namespaceURI === c.SVG_NS ? c.box : c.box.parentNode).appendChild(a);
                a.style.pointerEvents = "auto";
              });
            });
          };

          E.prototype.applyFixed = function () {
            var a = !this.fixedDiv,
                c = this.options.chart,
                d = c.scrollablePlotArea,
                n = C.getRendererType();
            a ? (this.fixedDiv = r("div", {
              className: "highcharts-fixed"
            }, {
              position: "absolute",
              overflow: "hidden",
              pointerEvents: "none",
              zIndex: (c.style && c.style.zIndex || 0) + 2,
              top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = c = new n(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({
              fill: this.options.chart.backgroundColor || "#fff",
              "fill-opacity": h(d.opacity, .85),
              zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), A(this, "afterShowResetZoom", this.moveFixedElements), A(this, "afterDrilldown", this.moveFixedElements), A(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
            c = this.chartWidth + (this.scrollablePixelsX || 0);
            n = this.chartHeight + (this.scrollablePixelsY || 0);
            B(this.container);
            this.container.style.width = c + "px";
            this.container.style.height = n + "px";
            this.renderer.boxWrapper.attr({
              width: c,
              height: n,
              viewBox: [0, 0, c, n].join(" ")
            });
            this.chartBackground.attr({
              width: c,
              height: n
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            a && (d.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * d.scrollPositionX), d.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * d.scrollPositionY));
            n = this.axisOffset;
            a = this.plotTop - n[0] - 1;
            d = this.plotLeft - n[3] - 1;
            c = this.plotTop + this.plotHeight + n[2] + 1;
            n = this.plotLeft + this.plotWidth + n[1] + 1;
            var k = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                O = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, c], ["L", 0, c], ["Z"], ["M", k, a], ["L", this.chartWidth, a], ["L", this.chartWidth, c], ["L", k, c], ["Z"]] : this.scrollablePixelsY ? [["M", d, 0], ["L", d, this.plotTop - 1], ["L", n, this.plotTop - 1], ["L", n, 0], ["Z"], ["M", d, O], ["L", d, this.chartHeight], ["L", n, this.chartHeight], ["L", n, O], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
              d: a
            });
          };

          A(d, "afterInit", function () {
            this.chart.scrollableDirty = !0;
          });
          A(G, "show", function () {
            this.chart.scrollableDirty = !0;
          });
          "";
        });
        M(d, "Core/Axis/StackingAxis.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Axis/Axis.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = c.getDeferredAnimation,
              C = E.addEvent,
              D = E.destroyObjectProperties,
              K = E.fireEvent,
              A = E.isNumber,
              r = E.objectEach,
              k;

          (function (c) {
            function a() {
              var a = this.stacking;

              if (a) {
                var c = a.stacks;
                r(c, function (a, g) {
                  D(a);
                  c[g] = null;
                });
                a && a.stackTotalGroup && a.stackTotalGroup.destroy();
              }
            }

            function g() {
              this.stacking || (this.stacking = new h(this));
            }

            var d = [];

            c.compose = function (c) {
              -1 === d.indexOf(c) && (d.push(c), C(c, "init", g), C(c, "destroy", a));
              return c;
            };

            var h = function () {
              function a(a) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = a;
              }

              a.prototype.buildStacks = function () {
                var a = this.axis,
                    c = a.series,
                    g = a.options.reversedStacks,
                    d = c.length,
                    h;

                if (!a.isXAxis) {
                  this.usePercentage = !1;

                  for (h = d; h--;) {
                    var n = c[g ? h : d - h - 1];
                    n.setStackedPoints();
                    n.setGroupedPoints();
                  }

                  for (h = 0; h < d; h++) {
                    c[h].modifyStacks();
                  }

                  K(a, "afterBuildStacks");
                }
              };

              a.prototype.cleanStacks = function () {
                if (!this.axis.isXAxis) {
                  if (this.oldStacks) var a = this.stacks = this.oldStacks;
                  r(a, function (a) {
                    r(a, function (a) {
                      a.cumulative = a.total;
                    });
                  });
                }
              };

              a.prototype.resetStacks = function () {
                var a = this,
                    c = a.stacks;
                a.axis.isXAxis || r(c, function (c) {
                  r(c, function (g, d) {
                    A(g.touched) && g.touched < a.stacksTouched ? (g.destroy(), delete c[d]) : (g.total = null, g.cumulative = null);
                  });
                });
              };

              a.prototype.renderStackTotals = function () {
                var a = this.axis,
                    c = a.chart,
                    g = c.renderer,
                    d = this.stacks;
                a = B(c, a.options.stackLabels && a.options.stackLabels.animation || !1);
                var h = this.stackTotalGroup = this.stackTotalGroup || g.g("stack-labels").attr({
                  visibility: "visible",
                  zIndex: 6,
                  opacity: 0
                }).add();
                h.translate(c.plotLeft, c.plotTop);
                r(d, function (a) {
                  r(a, function (a) {
                    a.render(h);
                  });
                });
                h.animate({
                  opacity: 1
                }, a);
              };

              return a;
            }();

            c.Additions = h;
          })(k || (k = {}));

          return k;
        });
        M(d, "Extensions/Stacking.js", [d["Core/Axis/Axis.js"], d["Core/Chart/Chart.js"], d["Core/FormatUtilities.js"], d["Core/Globals.js"], d["Core/Series/Series.js"], d["Core/Axis/StackingAxis.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K) {
          var A = E.format,
              r = K.correctFloat,
              k = K.defined,
              h = K.destroyObjectProperties,
              a = K.isArray,
              g = K.isNumber,
              y = K.objectEach,
              n = K.pick,
              t = function () {
            function a(a, c, g, d, h) {
              var m = a.chart.inverted;
              this.axis = a;
              this.isNegative = g;
              this.options = c = c || {};
              this.x = d;
              this.total = null;
              this.points = {};
              this.hasValidPoints = !1;
              this.stack = h;
              this.rightCliff = this.leftCliff = 0;
              this.alignOptions = {
                align: c.align || (m ? g ? "left" : "right" : "center"),
                verticalAlign: c.verticalAlign || (m ? "middle" : g ? "bottom" : "top"),
                y: c.y,
                x: c.x
              };
              this.textAlign = c.textAlign || (m ? g ? "right" : "left" : "center");
            }

            a.prototype.destroy = function () {
              h(this, this.axis);
            };

            a.prototype.render = function (a) {
              var c = this.axis.chart,
                  g = this.options,
                  d = g.format;
              d = d ? A(d, this, c) : g.formatter.call(this);
              this.label ? this.label.attr({
                text: d,
                visibility: "hidden"
              }) : (this.label = c.renderer.label(d, null, null, g.shape, null, null, g.useHTML, !1, "stack-labels"), d = {
                r: g.borderRadius || 0,
                text: d,
                rotation: g.rotation,
                padding: n(g.padding, 5),
                visibility: "hidden"
              }, c.styledMode || (d.fill = g.backgroundColor, d.stroke = g.borderColor, d["stroke-width"] = g.borderWidth, this.label.css(g.style)), this.label.attr(d), this.label.added || this.label.add(a));
              this.label.labelrank = c.plotSizeY;
            };

            a.prototype.setOffset = function (a, c, d, h, t) {
              var m = this.axis,
                  w = m.chart;
              h = m.translate(m.stacking.usePercentage ? 100 : h ? h : this.total, 0, 0, 0, 1);
              d = m.translate(d ? d : 0);
              d = k(h) && Math.abs(h - d);
              a = n(t, w.xAxis[0].translate(this.x)) + a;
              m = k(h) && this.getStackBox(w, this, a, h, c, d, m);
              c = this.label;
              d = this.isNegative;
              a = "justify" === n(this.options.overflow, "justify");
              var f = this.textAlign;
              c && m && (t = c.getBBox(), h = c.padding, f = "left" === f ? w.inverted ? -h : h : "right" === f ? t.width : w.inverted && "center" === f ? t.width / 2 : w.inverted ? d ? t.width + h : -h : t.width / 2, d = w.inverted ? t.height / 2 : d ? -h : t.height, this.alignOptions.x = n(this.options.x, 0), this.alignOptions.y = n(this.options.y, 0), m.x -= f, m.y -= d, c.align(this.alignOptions, null, m), w.isInsidePlot(c.alignAttr.x + f - this.alignOptions.x, c.alignAttr.y + d - this.alignOptions.y) ? c.show() : (c.alignAttr.y = -9999, a = !1), a && C.prototype.justifyDataLabel.call(this.axis, c, this.alignOptions, c.alignAttr, t, m), c.attr({
                x: c.alignAttr.x,
                y: c.alignAttr.y
              }), n(!a && this.options.crop, !0) && ((w = g(c.x) && g(c.y) && w.isInsidePlot(c.x - h + c.width, c.y) && w.isInsidePlot(c.x + h, c.y)) || c.hide()));
            };

            a.prototype.getStackBox = function (a, c, g, d, h, n, k) {
              var f = c.axis.reversed,
                  b = a.inverted,
                  m = k.height + k.pos - (b ? a.plotLeft : a.plotTop);
              c = c.isNegative && !f || !c.isNegative && f;
              return {
                x: b ? c ? d - k.right : d - n + k.pos - a.plotLeft : g + a.xAxis[0].transB - a.plotLeft,
                y: b ? k.height - g - h : c ? m - d - n : m - d,
                width: b ? n : h,
                height: b ? h : n
              };
            };

            return a;
          }();

          d.prototype.getStacks = function () {
            var a = this,
                c = a.inverted;
            a.yAxis.forEach(function (a) {
              a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
            });
            a.series.forEach(function (g) {
              var d = g.xAxis && g.xAxis.options || {};
              !g.options.stacking || !0 !== g.visible && !1 !== a.options.chart.ignoreHiddenSeries || (g.stackKey = [g.type, n(g.options.stack, ""), c ? d.top : d.left, c ? d.height : d.width].join());
            });
          };

          D.compose(c);

          C.prototype.setGroupedPoints = function () {
            var a = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? C.prototype.setStackedPoints.call(this, "group") : a && y(a.stacks, function (c, g) {
              "group" === g.slice(-5) && (y(c, function (a) {
                return a.destroy();
              }), delete a.stacks[g]);
            });
          };

          C.prototype.setStackedPoints = function (c) {
            var g = c || this.options.stacking;

            if (g && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
              var d = this.processedXData,
                  h = this.processedYData,
                  x = [],
                  y = h.length,
                  H = this.options,
                  w = H.threshold,
                  f = n(H.startFromThreshold && w, 0);
              H = H.stack;
              c = c ? this.type + "," + g : this.stackKey;
              var b = "-" + c,
                  v = this.negStacks,
                  F = this.yAxis,
                  e = F.stacking.stacks,
                  q = F.stacking.oldStacks,
                  l,
                  I;
              F.stacking.stacksTouched += 1;

              for (I = 0; I < y; I++) {
                var p = d[I];
                var z = h[I];
                var P = this.getStackIndicator(P, p, this.index);
                var T = P.key;
                var J = (l = v && z < (f ? 0 : w)) ? b : c;
                e[J] || (e[J] = {});
                e[J][p] || (q[J] && q[J][p] ? (e[J][p] = q[J][p], e[J][p].total = null) : e[J][p] = new t(F, F.options.stackLabels, l, p, H));
                J = e[J][p];
                null !== z ? (J.points[T] = J.points[this.index] = [n(J.cumulative, f)], k(J.cumulative) || (J.base = T), J.touched = F.stacking.stacksTouched, 0 < P.index && !1 === this.singleStacks && (J.points[T][0] = J.points[this.index + "," + p + ",0"][0])) : J.points[T] = J.points[this.index] = null;
                "percent" === g ? (l = l ? c : b, v && e[l] && e[l][p] ? (l = e[l][p], J.total = l.total = Math.max(l.total, J.total) + Math.abs(z) || 0) : J.total = r(J.total + (Math.abs(z) || 0))) : "group" === g ? (a(z) && (z = z[0]), null !== z && (J.total = (J.total || 0) + 1)) : J.total = r(J.total + (z || 0));
                J.cumulative = "group" === g ? (J.total || 1) - 1 : n(J.cumulative, f) + (z || 0);
                null !== z && (J.points[T].push(J.cumulative), x[I] = J.cumulative, J.hasValidPoints = !0);
              }

              "percent" === g && (F.stacking.usePercentage = !0);
              "group" !== g && (this.stackedYData = x);
              F.stacking.oldStacks = {};
            }
          };

          C.prototype.modifyStacks = function () {
            var a = this,
                c = a.stackKey,
                g = a.yAxis.stacking.stacks,
                d = a.processedXData,
                h,
                n = a.options.stacking;
            a[n + "Stacker"] && [c, "-" + c].forEach(function (c) {
              for (var m = d.length, f, b; m--;) {
                if (f = d[m], h = a.getStackIndicator(h, f, a.index, c), b = (f = g[c] && g[c][f]) && f.points[h.key]) a[n + "Stacker"](b, f, m);
              }
            });
          };

          C.prototype.percentStacker = function (a, c, g) {
            c = c.total ? 100 / c.total : 0;
            a[0] = r(a[0] * c);
            a[1] = r(a[1] * c);
            this.stackedYData[g] = a[1];
          };

          C.prototype.getStackIndicator = function (a, c, g, d) {
            !k(a) || a.x !== c || d && a.key !== d ? a = {
              x: c,
              index: 0,
              key: d
            } : a.index++;
            a.key = [g, c, a.index].join();
            return a;
          };

          G.StackItem = t;
          "";
          return G.StackItem;
        });
        M(d, "Series/Line/LineSeries.js", [d["Core/Color/Palette.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var B = this && this.__extends || function () {
            var _c2 = function c(d, k) {
              _c2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, a) {
                c.__proto__ = a;
              } || function (c, a) {
                for (var g in a) {
                  a.hasOwnProperty(g) && (c[g] = a[g]);
                }
              };

              return _c2(d, k);
            };

            return function (d, k) {
              function h() {
                this.constructor = d;
              }

              _c2(d, k);

              d.prototype = null === k ? Object.create(k) : (h.prototype = k.prototype, new h());
            };
          }(),
              D = G.defined,
              K = G.merge;

          G = function (A) {
            function r() {
              var c = null !== A && A.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            B(r, A);

            r.prototype.drawGraph = function () {
              var d = this,
                  h = this.options,
                  a = (this.gappedPath || this.getGraphPath).call(this),
                  g = this.chart.styledMode,
                  y = [["graph", "highcharts-graph"]];
              g || y[0].push(h.lineColor || this.color || c.neutralColor20, h.dashStyle);
              y = d.getZonesGraphs(y);
              y.forEach(function (c, k) {
                var n = c[0],
                    m = d[n],
                    t = m ? "animate" : "attr";
                m ? (m.endX = d.preventGraphAnimation ? null : a.xMap, m.animate({
                  d: a
                })) : a.length && (d[n] = m = d.chart.renderer.path(a).addClass(c[1]).attr({
                  zIndex: 1
                }).add(d.group));
                m && !g && (n = {
                  stroke: c[2],
                  "stroke-width": h.lineWidth,
                  fill: d.fillGraph && d.color || "none"
                }, c[3] ? n.dashstyle = c[3] : "square" !== h.linecap && (n["stroke-linecap"] = n["stroke-linejoin"] = "round"), m[t](n).shadow(2 > k && h.shadow));
                m && (m.startX = a.xMap, m.isArea = a.isArea);
              });
            };

            r.prototype.getGraphPath = function (c, d, a) {
              var g = this,
                  h = g.options,
                  n = [],
                  k = [],
                  r,
                  m = h.step;
              c = c || g.points;
              var A = c.reversed;
              A && c.reverse();
              (m = {
                right: 1,
                center: 2
              }[m] || m && 3) && A && (m = 4 - m);
              c = this.getValidPoints(c, !1, !(h.connectNulls && !d && !a));
              c.forEach(function (t, x) {
                var y = t.plotX,
                    H = t.plotY,
                    w = c[x - 1];
                (t.leftCliff || w && w.rightCliff) && !a && (r = !0);
                t.isNull && !D(d) && 0 < x ? r = !h.connectNulls : t.isNull && !d ? r = !0 : (0 === x || r ? x = [["M", t.plotX, t.plotY]] : g.getPointSpline ? x = [g.getPointSpline(c, t, x)] : m ? (x = 1 === m ? [["L", w.plotX, H]] : 2 === m ? [["L", (w.plotX + y) / 2, w.plotY], ["L", (w.plotX + y) / 2, H]] : [["L", y, w.plotY]], x.push(["L", y, H])) : x = [["L", y, H]], k.push(t.x), m && (k.push(t.x), 2 === m && k.push(t.x)), n.push.apply(n, x), r = !1);
              });
              n.xMap = k;
              return g.graphPath = n;
            };

            r.prototype.getZonesGraphs = function (c) {
              this.zones.forEach(function (d, a) {
                a = ["zone-graph-" + a, "highcharts-graph highcharts-zone-graph-" + a + " " + (d.className || "")];
                this.chart.styledMode || a.push(d.color || this.color, d.dashStyle || this.options.dashStyle);
                c.push(a);
              }, this);
              return c;
            };

            r.defaultOptions = K(d.defaultOptions, {});
            return r;
          }(d);

          E.registerSeriesType("line", G);
          "";
          return G;
        });
        M(d, "Series/Area/AreaSeries.js", [d["Core/Color/Color.js"], d["Core/Legend/LegendSymbol.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var B = this && this.__extends || function () {
            var _c3 = function c(a, g) {
              _c3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var g in c) {
                  c.hasOwnProperty(g) && (a[g] = c[g]);
                }
              };

              return _c3(a, g);
            };

            return function (a, g) {
              function d() {
                this.constructor = a;
              }

              _c3(a, g);

              a.prototype = null === g ? Object.create(g) : (d.prototype = g.prototype, new d());
            };
          }(),
              D = c.parse,
              K = E.seriesTypes.line;

          c = G.extend;
          var A = G.merge,
              r = G.objectEach,
              k = G.pick;

          G = function (c) {
            function a() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            B(a, c);

            a.prototype.drawGraph = function () {
              this.areaPath = [];
              c.prototype.drawGraph.apply(this);
              var a = this,
                  d = this.areaPath,
                  h = this.options,
                  t = [["area", "highcharts-area", this.color, h.fillColor]];
              this.zones.forEach(function (c, g) {
                t.push(["zone-area-" + g, "highcharts-area highcharts-zone-area-" + g + " " + c.className, c.color || a.color, c.fillColor || h.fillColor]);
              });
              t.forEach(function (c) {
                var g = c[0],
                    n = a[g],
                    t = n ? "animate" : "attr",
                    x = {};
                n ? (n.endX = a.preventGraphAnimation ? null : d.xMap, n.animate({
                  d: d
                })) : (x.zIndex = 0, n = a[g] = a.chart.renderer.path(d).addClass(c[1]).add(a.group), n.isArea = !0);
                a.chart.styledMode || (x.fill = k(c[3], D(c[2]).setOpacity(k(h.fillOpacity, .75)).get()));
                n[t](x);
                n.startX = d.xMap;
                n.shiftUnit = h.step ? 2 : 1;
              });
            };

            a.prototype.getGraphPath = function (a) {
              var c = K.prototype.getGraphPath,
                  g = this.options,
                  d = g.stacking,
                  h = this.yAxis,
                  m,
                  r = [],
                  A = [],
                  x = this.index,
                  B = h.stacking.stacks[this.stackKey],
                  H = g.threshold,
                  w = Math.round(h.getThreshold(g.threshold));
              g = k(g.connectNulls, "percent" === d);

              var f = function f(b, c, _f2) {
                var e = a[b];
                b = d && B[e.x].points[x];
                var g = e[_f2 + "Null"] || 0;
                _f2 = e[_f2 + "Cliff"] || 0;
                e = !0;

                if (_f2 || g) {
                  var l = (g ? b[0] : b[1]) + _f2;
                  var q = b[0] + _f2;
                  e = !!g;
                } else !d && a[c] && a[c].isNull && (l = q = H);

                "undefined" !== typeof l && (A.push({
                  plotX: v,
                  plotY: null === l ? w : h.getThreshold(l),
                  isNull: e,
                  isCliff: !0
                }), r.push({
                  plotX: v,
                  plotY: null === q ? w : h.getThreshold(q),
                  doCurve: !1
                }));
              };

              a = a || this.points;
              d && (a = this.getStackPoints(a));

              for (m = 0; m < a.length; m++) {
                d || (a[m].leftCliff = a[m].rightCliff = a[m].leftNull = a[m].rightNull = void 0);
                var b = a[m].isNull;
                var v = k(a[m].rectPlotX, a[m].plotX);
                var F = d ? k(a[m].yBottom, w) : w;
                if (!b || g) g || f(m, m - 1, "left"), b && !d && g || (A.push(a[m]), r.push({
                  x: m,
                  plotX: v,
                  plotY: F
                })), g || f(m, m + 1, "right");
              }

              m = c.call(this, A, !0, !0);
              r.reversed = !0;
              b = c.call(this, r, !0, !0);
              (F = b[0]) && "M" === F[0] && (b[0] = ["L", F[1], F[2]]);
              b = m.concat(b);
              b.length && b.push(["Z"]);
              c = c.call(this, A, !1, g);
              b.xMap = m.xMap;
              this.areaPath = b;
              return c;
            };

            a.prototype.getStackPoints = function (a) {
              var c = this,
                  g = [],
                  d = [],
                  h = this.xAxis,
                  m = this.yAxis,
                  A = m.stacking.stacks[this.stackKey],
                  B = {},
                  x = m.series,
                  D = x.length,
                  H = m.options.reversedStacks ? 1 : -1,
                  w = x.indexOf(c);
              a = a || this.points;

              if (this.options.stacking) {
                for (var f = 0; f < a.length; f++) {
                  a[f].leftNull = a[f].rightNull = void 0, B[a[f].x] = a[f];
                }

                r(A, function (b, a) {
                  null !== b.total && d.push(a);
                });
                d.sort(function (b, a) {
                  return b - a;
                });
                var b = x.map(function (b) {
                  return b.visible;
                });
                d.forEach(function (a, f) {
                  var e = 0,
                      q,
                      l;
                  if (B[a] && !B[a].isNull) g.push(B[a]), [-1, 1].forEach(function (e) {
                    var g = 1 === e ? "rightNull" : "leftNull",
                        p = 0,
                        h = A[d[f + e]];
                    if (h) for (var m = w; 0 <= m && m < D;) {
                      var n = x[m].index;
                      q = h.points[n];
                      q || (n === c.index ? B[a][g] = !0 : b[m] && (l = A[a].points[n]) && (p -= l[1] - l[0]));
                      m += H;
                    }
                    B[a][1 === e ? "rightCliff" : "leftCliff"] = p;
                  });else {
                    for (var n = w; 0 <= n && n < D;) {
                      if (q = A[a].points[x[n].index]) {
                        e = q[1];
                        break;
                      }

                      n += H;
                    }

                    e = k(e, 0);
                    e = m.translate(e, 0, 1, 0, 1);
                    g.push({
                      isNull: !0,
                      plotX: h.translate(a, 0, 0, 0, 1),
                      x: a,
                      plotY: e,
                      yBottom: e
                    });
                  }
                });
              }

              return g;
            };

            a.defaultOptions = A(K.defaultOptions, {
              threshold: 0
            });
            return a;
          }(K);

          c(G.prototype, {
            singleStacks: !1,
            drawLegendSymbol: d.drawRectangle
          });
          E.registerSeriesType("area", G);
          "";
          return G;
        });
        M(d, "Series/Spline/SplineSeries.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d) {
          var B = this && this.__extends || function () {
            var _c4 = function c(d, r) {
              _c4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, d) {
                c.__proto__ = d;
              } || function (c, d) {
                for (var a in d) {
                  d.hasOwnProperty(a) && (c[a] = d[a]);
                }
              };

              return _c4(d, r);
            };

            return function (d, r) {
              function k() {
                this.constructor = d;
              }

              _c4(d, r);

              d.prototype = null === r ? Object.create(r) : (k.prototype = r.prototype, new k());
            };
          }(),
              G = c.seriesTypes.line,
              C = d.merge,
              D = d.pick;

          d = function (c) {
            function d() {
              var d = null !== c && c.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            B(d, c);

            d.prototype.getPointSpline = function (c, d, h) {
              var a = d.plotX || 0,
                  g = d.plotY || 0,
                  k = c[h - 1];
              h = c[h + 1];

              if (k && !k.isNull && !1 !== k.doCurve && !d.isCliff && h && !h.isNull && !1 !== h.doCurve && !d.isCliff) {
                c = k.plotY || 0;
                var n = h.plotX || 0;
                h = h.plotY || 0;
                var t = 0;
                var r = (1.5 * a + (k.plotX || 0)) / 2.5;
                var m = (1.5 * g + c) / 2.5;
                n = (1.5 * a + n) / 2.5;
                var A = (1.5 * g + h) / 2.5;
                n !== r && (t = (A - m) * (n - a) / (n - r) + g - A);
                m += t;
                A += t;
                m > c && m > g ? (m = Math.max(c, g), A = 2 * g - m) : m < c && m < g && (m = Math.min(c, g), A = 2 * g - m);
                A > h && A > g ? (A = Math.max(h, g), m = 2 * g - A) : A < h && A < g && (A = Math.min(h, g), m = 2 * g - A);
                d.rightContX = n;
                d.rightContY = A;
              }

              d = ["C", D(k.rightContX, k.plotX, 0), D(k.rightContY, k.plotY, 0), D(r, a, 0), D(m, g, 0), a, g];
              k.rightContX = k.rightContY = void 0;
              return d;
            };

            d.defaultOptions = C(G.defaultOptions);
            return d;
          }(G);

          c.registerSeriesType("spline", d);
          "";
          return d;
        });
        M(d, "Series/AreaSpline/AreaSplineSeries.js", [d["Series/Area/AreaSeries.js"], d["Series/Spline/SplineSeries.js"], d["Core/Legend/LegendSymbol.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G, C) {
          var B = this && this.__extends || function () {
            var _c5 = function c(d, a) {
              _c5 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _c5(d, a);
            };

            return function (d, a) {
              function g() {
                this.constructor = d;
              }

              _c5(d, a);

              d.prototype = null === a ? Object.create(a) : (g.prototype = a.prototype, new g());
            };
          }(),
              K = c.prototype,
              A = C.extend,
              r = C.merge;

          C = function (k) {
            function h() {
              var a = null !== k && k.apply(this, arguments) || this;
              a.data = void 0;
              a.points = void 0;
              a.options = void 0;
              return a;
            }

            B(h, k);
            h.defaultOptions = r(d.defaultOptions, c.defaultOptions);
            return h;
          }(d);

          A(C.prototype, {
            getGraphPath: K.getGraphPath,
            getStackPoints: K.getStackPoints,
            drawGraph: K.drawGraph,
            drawLegendSymbol: E.drawRectangle
          });
          G.registerSeriesType("areaspline", C);
          "";
          return C;
        });
        M(d, "Series/Column/ColumnSeries.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Legend/LegendSymbol.js"], d["Core/Color/Palette.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A) {
          var r = this && this.__extends || function () {
            var _a3 = function a(c, f) {
              _a3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var c in a) {
                  a.hasOwnProperty(c) && (b[c] = a[c]);
                }
              };

              return _a3(c, f);
            };

            return function (c, f) {
              function b() {
                this.constructor = c;
              }

              _a3(c, f);

              c.prototype = null === f ? Object.create(f) : (b.prototype = f.prototype, new b());
            };
          }(),
              k = c.animObject,
              h = d.parse,
              a = E.hasTouch;

          c = E.noop;
          var g = A.clamp,
              y = A.css,
              n = A.defined,
              t = A.extend,
              B = A.fireEvent,
              m = A.isArray,
              N = A.isNumber,
              L = A.merge,
              x = A.pick,
              R = A.objectEach;

          A = function (c) {
            function d() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.borderWidth = void 0;
              a.data = void 0;
              a.group = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(d, c);

            d.prototype.animate = function (a) {
              var b = this,
                  c = this.yAxis,
                  f = b.options,
                  e = this.chart.inverted,
                  d = {},
                  l = e ? "translateX" : "translateY";
              if (a) d.scaleY = .001, a = g(c.toPixels(f.threshold), c.pos, c.pos + c.len), e ? d.translateX = a - c.len : d.translateY = a, b.clipBox && b.setClip(), b.group.attr(d);else {
                var h = Number(b.group.attr(l));
                b.group.animate({
                  scaleY: 1
                }, t(k(b.options.animation), {
                  step: function step(a, e) {
                    b.group && (d[l] = h + e.pos * (c.pos - h), b.group.attr(d));
                  }
                }));
              }
            };

            d.prototype.init = function (a, b) {
              c.prototype.init.apply(this, arguments);
              var f = this;
              a = f.chart;
              a.hasRendered && a.series.forEach(function (b) {
                b.type === f.type && (b.isDirty = !0);
              });
            };

            d.prototype.getColumnMetrics = function () {
              var a = this,
                  b = a.options,
                  c = a.xAxis,
                  d = a.yAxis,
                  e = c.options.reversedStacks;
              e = c.reversed && !e || !c.reversed && e;
              var g = {},
                  l,
                  h = 0;
              !1 === b.grouping ? h = 1 : a.chart.series.forEach(function (b) {
                var c = b.yAxis,
                    e = b.options;

                if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && d.len === c.len && d.pos === c.pos) {
                  if (e.stacking && "group" !== e.stacking) {
                    l = b.stackKey;
                    "undefined" === typeof g[l] && (g[l] = h++);
                    var f = g[l];
                  } else !1 !== e.grouping && (f = h++);

                  b.columnIndex = f;
                }
              });
              var p = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
                  m = p * b.groupPadding,
                  n = (p - 2 * m) / (h || 1);
              b = Math.min(b.maxPointWidth || c.len, x(b.pointWidth, n * (1 - 2 * b.pointPadding)));
              a.columnMetrics = {
                width: b,
                offset: (n - b) / 2 + (m + ((a.columnIndex || 0) + (e ? 1 : 0)) * n - p / 2) * (e ? -1 : 1),
                paddedWidth: n,
                columnCount: h
              };
              return a.columnMetrics;
            };

            d.prototype.crispCol = function (a, b, c, d) {
              var e = this.chart,
                  f = this.borderWidth,
                  g = -(f % 2 ? .5 : 0);
              f = f % 2 ? .5 : 1;
              e.inverted && e.renderer.isVML && (f += 1);
              this.options.crisp && (c = Math.round(a + c) + g, a = Math.round(a) + g, c -= a);
              d = Math.round(b + d) + f;
              g = .5 >= Math.abs(b) && .5 < d;
              b = Math.round(b) + f;
              d -= b;
              g && d && (--b, d += 1);
              return {
                x: a,
                y: b,
                width: c,
                height: d
              };
            };

            d.prototype.adjustForMissingColumns = function (a, b, c, d) {
              var e = this,
                  f = this.options.stacking;

              if (!c.isNull && 1 < d.columnCount) {
                var g = 0,
                    h = 0;
                R(this.yAxis.stacking && this.yAxis.stacking.stacks, function (b) {
                  if ("number" === typeof c.x && (b = b[c.x.toString()])) {
                    var a = b.points[e.index],
                        d = b.total;
                    f ? (a && (g = h), b.hasValidPoints && h++) : m(a) && (g = a[1], h = d || 0);
                  }
                });
                a = (c.plotX || 0) + ((h - 1) * d.paddedWidth + b) / 2 - b - g * d.paddedWidth;
              }

              return a;
            };

            d.prototype.translate = function () {
              var a = this,
                  b = a.chart,
                  c = a.options,
                  d = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
              d = a.borderWidth = x(c.borderWidth, d ? 0 : 1);
              var e = a.xAxis,
                  h = a.yAxis,
                  l = c.threshold,
                  m = a.translatedThreshold = h.getThreshold(l),
                  p = x(c.minPointLength, 5),
                  z = a.getColumnMetrics(),
                  k = z.width,
                  w = a.pointXOffset = z.offset,
                  t = a.dataMin,
                  u = a.dataMax,
                  r = a.barW = Math.max(k, 1 + 2 * d);
              b.inverted && (m -= .5);
              c.pointPadding && (r = Math.ceil(r));
              D.prototype.translate.apply(a);
              a.points.forEach(function (f) {
                var d = x(f.yBottom, m),
                    q = 999 + Math.abs(d),
                    v = f.plotX || 0;
                q = g(f.plotY, -q, h.len + q);
                var I = Math.min(q, d),
                    P = Math.max(q, d) - I,
                    F = k,
                    y = v + w,
                    J = r;
                p && Math.abs(P) < p && (P = p, v = !h.reversed && !f.negative || h.reversed && f.negative, N(l) && N(u) && f.y === l && u <= l && (h.min || 0) < l && (t !== u || (h.max || 0) <= l) && (v = !v), I = Math.abs(I - m) > p ? d - p : m - (v ? p : 0));
                n(f.options.pointWidth) && (F = J = Math.ceil(f.options.pointWidth), y -= Math.round((F - k) / 2));
                c.centerInCategory && (y = a.adjustForMissingColumns(y, F, f, z));
                f.barX = y;
                f.pointWidth = F;
                f.tooltipPos = b.inverted ? [g(h.len + h.pos - b.plotLeft - q, h.pos - b.plotLeft, h.len + h.pos - b.plotLeft), e.len + e.pos - b.plotTop - y - J / 2, P] : [e.left - b.plotLeft + y + J / 2, g(q + h.pos - b.plotTop, h.pos - b.plotTop, h.len + h.pos - b.plotTop), P];
                f.shapeType = a.pointClass.prototype.shapeType || "rect";
                f.shapeArgs = a.crispCol.apply(a, f.isNull ? [y, m, J, 0] : [y, I, J, P]);
              });
            };

            d.prototype.drawGraph = function () {
              this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };

            d.prototype.pointAttribs = function (a, b) {
              var c = this.options,
                  f = this.pointAttrToOptions || {},
                  e = f.stroke || "borderColor",
                  d = f["stroke-width"] || "borderWidth",
                  g = a && a.color || this.color,
                  m = a && a[e] || c[e] || g;
              f = a && a.options.dashStyle || c.dashStyle;
              var p = a && a[d] || c[d] || this[d] || 0,
                  n = x(a && a.opacity, c.opacity, 1);

              if (a && this.zones.length) {
                var k = a.getZone();
                g = a.options.color || k && (k.color || a.nonZonedColor) || this.color;
                k && (m = k.borderColor || m, f = k.dashStyle || f, p = k.borderWidth || p);
              }

              b && a && (a = L(c.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, g = a.color || "undefined" !== typeof b && h(g).brighten(a.brightness).get() || g, m = a[e] || m, p = a[d] || p, f = a.dashStyle || f, n = x(a.opacity, n));
              e = {
                fill: g,
                stroke: m,
                "stroke-width": p,
                opacity: n
              };
              f && (e.dashstyle = f);
              return e;
            };

            d.prototype.drawPoints = function () {
              var a = this,
                  b = this.chart,
                  c = a.options,
                  d = b.renderer,
                  e = c.animationLimit || 250,
                  g;
              a.points.forEach(function (f) {
                var l = f.graphic,
                    p = !!l,
                    h = l && b.pointCount < e ? "animate" : "attr";

                if (N(f.plotY) && null !== f.y) {
                  g = f.shapeArgs;
                  l && f.hasNewShapeType() && (l = l.destroy());
                  a.enabledDataSorting && (f.startXPos = a.xAxis.reversed ? -(g ? g.width || 0 : 0) : a.xAxis.width);
                  l || (f.graphic = l = d[f.shapeType](g).add(f.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < e && (l.attr({
                    x: f.startXPos
                  }), p = !0, h = "animate");
                  if (l && p) l[h](L(g));
                  if (c.borderRadius) l[h]({
                    r: c.borderRadius
                  });
                  b.styledMode || l[h](a.pointAttribs(f, f.selected && "select")).shadow(!1 !== f.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);
                  l && (l.addClass(f.getClassName(), !0), l.attr({
                    visibility: f.visible ? "inherit" : "hidden"
                  }));
                } else l && (f.graphic = l.destroy());
              });
            };

            d.prototype.drawTracker = function () {
              var c = this,
                  b = c.chart,
                  d = b.pointer,
                  g = function g(b) {
                var a = d.getPointFromEvent(b);
                "undefined" !== typeof a && (d.isDirectTouch = !0, a.onMouseOver(b));
              },
                  e;

              c.points.forEach(function (b) {
                e = m(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
                b.graphic && (b.graphic.element.point = b);
                e.forEach(function (a) {
                  a.div ? a.div.point = b : a.element.point = b;
                });
              });
              c._hasTracking || (c.trackerGroups.forEach(function (e) {
                if (c[e]) {
                  c[e].addClass("highcharts-tracker").on("mouseover", g).on("mouseout", function (b) {
                    d.onTrackerMouseOut(b);
                  });
                  if (a) c[e].on("touchstart", g);
                  !b.styledMode && c.options.cursor && c[e].css(y).css({
                    cursor: c.options.cursor
                  });
                }
              }), c._hasTracking = !0);
              B(this, "afterDrawTracker");
            };

            d.prototype.remove = function () {
              var a = this,
                  b = a.chart;
              b.hasRendered && b.series.forEach(function (b) {
                b.type === a.type && (b.isDirty = !0);
              });
              D.prototype.remove.apply(a, arguments);
            };

            d.defaultOptions = L(D.defaultOptions, {
              borderRadius: 0,
              centerInCategory: !1,
              groupPadding: .2,
              marker: null,
              pointPadding: .1,
              minPointLength: 0,
              cropThreshold: 50,
              pointRange: null,
              states: {
                hover: {
                  halo: !1,
                  brightness: .1
                },
                select: {
                  color: C.neutralColor20,
                  borderColor: C.neutralColor100
                }
              },
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
              },
              startFromThreshold: !0,
              stickyTracking: !1,
              tooltip: {
                distance: 6
              },
              threshold: 0,
              borderColor: C.backgroundColor
            });
            return d;
          }(D);

          t(A.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: G.drawRectangle,
            getSymbol: c,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          K.registerSeriesType("column", A);
          "";
          "";
          return A;
        });
        M(d, "Core/Series/DataLabel.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/FormatUtilities.js"], d["Core/Color/Palette.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var B = c.getDeferredAnimation,
              D = d.format,
              K = G.defined,
              A = G.extend,
              r = G.fireEvent,
              k = G.isArray,
              h = G.merge,
              a = G.objectEach,
              g = G.pick,
              y = G.splat,
              n;

          (function (c) {
            function d(a, c, b, d, h) {
              var e = this,
                  f = this.chart,
                  l = this.isCartesian && f.inverted,
                  m = this.enabledDataSorting,
                  p = g(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
                  n = g(a.plotY, -9999),
                  k = c.getBBox(),
                  v = b.rotation,
                  t = b.align,
                  u = f.isInsidePlot(p, Math.round(n), {
                inverted: l,
                paneCoordinates: !0,
                series: e
              }),
                  w = function w(b) {
                m && e.xAxis && !x && e.setDataLabelStartPos(a, c, h, u, b);
              },
                  x = "justify" === g(b.overflow, m ? "none" : "justify"),
                  y = this.visible && !1 !== a.visible && (a.series.forceDL || m && !x || u || g(b.inside, !!this.options.stacking) && d && f.isInsidePlot(p, l ? d.x + 1 : d.y + d.height - 1, {
                inverted: l,
                paneCoordinates: !0,
                series: e
              }));

              if (y) {
                var F = f.renderer.fontMetrics(f.styledMode ? void 0 : b.style.fontSize, c).b;
                d = A({
                  x: l ? this.yAxis.len - n : p,
                  y: Math.round(l ? this.xAxis.len - p : n),
                  width: 0,
                  height: 0
                }, d);
                A(b, {
                  width: k.width,
                  height: k.height
                });
                v ? (x = !1, p = f.renderer.rotCorr(F, v), p = {
                  x: d.x + (b.x || 0) + d.width / 2 + p.x,
                  y: d.y + (b.y || 0) + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                  }[b.verticalAlign] * d.height
                }, w(p), c[h ? "attr" : "animate"](p).attr({
                  align: t
                }), w = (v + 720) % 360, w = 180 < w && 360 > w, "left" === t ? p.y -= w ? k.height : 0 : "center" === t ? (p.x -= k.width / 2, p.y -= k.height / 2) : "right" === t && (p.x -= k.width, p.y -= w ? 0 : k.height), c.placed = !0, c.alignAttr = p) : (w(d), c.align(b, void 0, d), p = c.alignAttr);
                x && 0 <= d.height ? this.justifyDataLabel(c, b, p, k, d, h) : g(b.crop, !0) && (y = f.isInsidePlot(p.x, p.y, {
                  paneCoordinates: !0,
                  series: e
                }) && f.isInsidePlot(p.x + k.width, p.y + k.height, {
                  paneCoordinates: !0,
                  series: e
                }));
                if (b.shape && !v) c[h ? "attr" : "animate"]({
                  anchorX: l ? f.plotWidth - a.plotY : a.plotX,
                  anchorY: l ? f.plotHeight - a.plotX : a.plotY
                });
              }

              h && m && (c.placed = !1);
              y || m && !x || (c.hide(!0), c.placed = !1);
            }

            function m(a, c) {
              var b = c.filter;
              return b ? (c = b.operator, a = a[b.property], b = b.value, ">" === c && a > b || "<" === c && a < b || ">=" === c && a >= b || "<=" === c && a <= b || "==" === c && a == b || "===" === c && a === b ? !0 : !1) : !0;
            }

            function n() {
              var c = this,
                  f = c.chart,
                  b = c.options,
                  d = c.points,
                  h = c.hasRendered || 0,
                  e = f.renderer,
                  q = b.dataLabels,
                  l,
                  n = q.animation;
              n = q.defer ? B(f, n, c) : {
                defer: 0,
                duration: 0
              };
              q = x(x(f.options.plotOptions && f.options.plotOptions.series && f.options.plotOptions.series.dataLabels, f.options.plotOptions && f.options.plotOptions[c.type] && f.options.plotOptions[c.type].dataLabels), q);
              r(this, "drawDataLabels");

              if (k(q) || q.enabled || c._hasPointLabels) {
                var p = c.plotGroup("dataLabelsGroup", "data-labels", h ? "inherit" : "hidden", q.zIndex || 6);
                p.attr({
                  opacity: +h
                });
                !h && (h = c.dataLabelsGroup) && (c.visible && p.show(!0), h[b.animation ? "animate" : "attr"]({
                  opacity: 1
                }, n));
                d.forEach(function (d) {
                  l = y(x(q, d.dlOptions || d.options && d.options.dataLabels));
                  l.forEach(function (l, h) {
                    var q = l.enabled && (!d.isNull || d.dataLabelOnNull) && m(d, l),
                        n = d.connectors ? d.connectors[h] : d.connector,
                        k = d.dataLabels ? d.dataLabels[h] : d.dataLabel,
                        z = g(l.distance, d.labelDistance),
                        v = !k;

                    if (q) {
                      var I = d.getLabelConfig();
                      var t = g(l[d.formatPrefix + "Format"], l.format);
                      I = K(t) ? D(t, I, f) : (l[d.formatPrefix + "Formatter"] || l.formatter).call(I, l);
                      t = l.style;
                      var w = l.rotation;
                      f.styledMode || (t.color = g(l.color, t.color, c.color, E.neutralColor100), "contrast" === t.color ? (d.contrastColor = e.getContrast(d.color || c.color), t.color = !K(z) && l.inside || 0 > z || b.stacking ? d.contrastColor : E.neutralColor100) : delete d.contrastColor, b.cursor && (t.cursor = b.cursor));
                      var x = {
                        r: l.borderRadius || 0,
                        rotation: w,
                        padding: l.padding,
                        zIndex: 1
                      };
                      f.styledMode || (x.fill = l.backgroundColor, x.stroke = l.borderColor, x["stroke-width"] = l.borderWidth);
                      a(x, function (b, a) {
                        "undefined" === typeof b && delete x[a];
                      });
                    }

                    !k || q && K(I) ? q && K(I) && (k ? x.text = I : (d.dataLabels = d.dataLabels || [], k = d.dataLabels[h] = w ? e.text(I, 0, -9999, l.useHTML).addClass("highcharts-data-label") : e.label(I, 0, -9999, l.shape, null, null, l.useHTML, null, "data-label"), h || (d.dataLabel = k), k.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (l.className || "") + (l.useHTML ? " highcharts-tracker" : ""))), k.options = l, k.attr(x), f.styledMode || k.css(t).shadow(l.shadow), k.added || k.add(p), l.textPath && !l.useHTML && (k.setTextPath(d.getDataLabelPath && d.getDataLabelPath(k) || d.graphic, l.textPath), d.dataLabelPath && !l.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), c.alignDataLabel(d, k, l, null, v)) : (d.dataLabel = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[h]), h || delete d.dataLabel, n && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[h])));
                  });
                });
              }

              r(this, "afterDrawDataLabels");
            }

            function t(a, c, b, d, g, e) {
              var f = this.chart,
                  l = c.align,
                  h = c.verticalAlign,
                  p = a.box ? 0 : a.padding || 0,
                  m = c.x;
              m = void 0 === m ? 0 : m;
              var n = c.y;
              n = void 0 === n ? 0 : n;
              var k = (b.x || 0) + p;

              if (0 > k) {
                "right" === l && 0 <= m ? (c.align = "left", c.inside = !0) : m -= k;
                var v = !0;
              }

              k = (b.x || 0) + d.width - p;
              k > f.plotWidth && ("left" === l && 0 >= m ? (c.align = "right", c.inside = !0) : m += f.plotWidth - k, v = !0);
              k = b.y + p;
              0 > k && ("bottom" === h && 0 <= n ? (c.verticalAlign = "top", c.inside = !0) : n -= k, v = !0);
              k = (b.y || 0) + d.height - p;
              k > f.plotHeight && ("top" === h && 0 >= n ? (c.verticalAlign = "bottom", c.inside = !0) : n += f.plotHeight - k, v = !0);
              v && (c.x = m, c.y = n, a.placed = !e, a.align(c, void 0, g));
              return v;
            }

            function x(a, c) {
              var b = [],
                  f;
              if (k(a) && !k(c)) b = a.map(function (b) {
                return h(b, c);
              });else if (k(c) && !k(a)) b = c.map(function (b) {
                return h(a, b);
              });else if (k(a) || k(c)) for (f = Math.max(a.length, c.length); f--;) {
                b[f] = h(a[f], c[f]);
              } else b = h(a, c);
              return b;
            }

            function C(a, c, b, d, g) {
              var e = this.chart,
                  f = e.inverted,
                  l = this.xAxis,
                  h = l.reversed,
                  p = f ? c.height / 2 : c.width / 2;
              a = (a = a.pointWidth) ? a / 2 : 0;
              c.startXPos = f ? g.x : h ? -p - a : l.width - p + a;
              c.startYPos = f ? h ? this.yAxis.height - p + a : -p - a : g.y;
              d ? "hidden" === c.visibility && (c.show(), c.attr({
                opacity: 0
              }).animate({
                opacity: 1
              })) : c.attr({
                opacity: 1
              }).animate({
                opacity: 0
              }, void 0, c.hide);
              e.hasRendered && (b && c.attr({
                x: c.startXPos,
                y: c.startYPos
              }), c.placed = !0);
            }

            var H = [];

            c.compose = function (a) {
              if (-1 === H.indexOf(a)) {
                var c = a.prototype;
                H.push(a);
                c.alignDataLabel = d;
                c.drawDataLabels = n;
                c.justifyDataLabel = t;
                c.setDataLabelStartPos = C;
              }
            };
          })(n || (n = {}));

          "";
          return n;
        });
        M(d, "Series/Column/ColumnDataLabel.js", [d["Core/Series/DataLabel.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = d.series,
              C = E.merge,
              D = E.pick,
              K;

          (function (d) {
            function r(c, a, d, k, n) {
              var g = this.chart.inverted,
                  h = c.series,
                  m = c.dlBox || c.shapeArgs,
                  r = D(c.below, c.plotY > D(this.translatedThreshold, h.yAxis.len)),
                  y = D(d.inside, !!this.options.stacking);
              m && (k = C(m), 0 > k.y && (k.height += k.y, k.y = 0), m = k.y + k.height - h.yAxis.len, 0 < m && m < k.height && (k.height -= m), g && (k = {
                x: h.yAxis.len - k.y - k.height,
                y: h.xAxis.len - k.x - k.width,
                width: k.height,
                height: k.width
              }), y || (g ? (k.x += r ? 0 : k.width, k.width = 0) : (k.y += r ? k.height : 0, k.height = 0)));
              d.align = D(d.align, !g || y ? "center" : r ? "right" : "left");
              d.verticalAlign = D(d.verticalAlign, g || y ? "middle" : r ? "top" : "bottom");
              B.prototype.alignDataLabel.call(this, c, a, d, k, n);
              d.inside && c.contrastColor && a.css({
                color: c.contrastColor
              });
            }

            var k = [];

            d.compose = function (d) {
              c.compose(B);
              -1 === k.indexOf(d) && (k.push(d), d.prototype.alignDataLabel = r);
            };
          })(K || (K = {}));

          return K;
        });
        M(d, "Series/Bar/BarSeries.js", [d["Series/Column/ColumnSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = this && this.__extends || function () {
            var _c6 = function c(d, r) {
              _c6 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, d) {
                c.__proto__ = d;
              } || function (c, d) {
                for (var a in d) {
                  d.hasOwnProperty(a) && (c[a] = d[a]);
                }
              };

              return _c6(d, r);
            };

            return function (d, r) {
              function k() {
                this.constructor = d;
              }

              _c6(d, r);

              d.prototype = null === r ? Object.create(r) : (k.prototype = r.prototype, new k());
            };
          }(),
              C = E.extend,
              D = E.merge;

          E = function (d) {
            function A() {
              var c = null !== d && d.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            B(A, d);
            A.defaultOptions = D(c.defaultOptions, {});
            return A;
          }(c);

          C(E.prototype, {
            inverted: !0
          });
          d.registerSeriesType("bar", E);
          "";
          return E;
        });
        M(d, "Series/Scatter/ScatterSeries.js", [d["Series/Column/ColumnSeries.js"], d["Series/Line/LineSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var B = this && this.__extends || function () {
            var _c7 = function c(d, h) {
              _c7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _c7(d, h);
            };

            return function (d, h) {
              function a() {
                this.constructor = d;
              }

              _c7(d, h);

              d.prototype = null === h ? Object.create(h) : (a.prototype = h.prototype, new a());
            };
          }(),
              D = G.addEvent,
              K = G.extend,
              A = G.merge;

          G = function (c) {
            function k() {
              var d = null !== c && c.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            B(k, c);

            k.prototype.applyJitter = function () {
              var c = this,
                  a = this.options.jitter,
                  d = this.points.length;
              a && this.points.forEach(function (g, h) {
                ["x", "y"].forEach(function (k, n) {
                  var m = "plot" + k.toUpperCase();

                  if (a[k] && !g.isNull) {
                    var t = c[k + "Axis"];
                    var r = a[k] * t.transA;

                    if (t && !t.isLog) {
                      var x = Math.max(0, g[m] - r);
                      t = Math.min(t.len, g[m] + r);
                      n = 1E4 * Math.sin(h + n * d);
                      g[m] = x + (t - x) * (n - Math.floor(n));
                      "x" === k && (g.clientX = g.plotX);
                    }
                  }
                });
              });
            };

            k.prototype.drawGraph = function () {
              this.options.lineWidth ? c.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };

            k.defaultOptions = A(d.defaultOptions, {
              lineWidth: 0,
              findNearestPointBy: "xy",
              jitter: {
                x: 0,
                y: 0
              },
              marker: {
                enabled: !0
              },
              tooltip: {
                headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
              }
            });
            return k;
          }(d);

          K(G.prototype, {
            drawTracker: c.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
          });
          D(G, "afterTranslate", function () {
            this.applyJitter();
          });
          E.registerSeriesType("scatter", G);
          "";
          return G;
        });
        M(d, "Mixins/CenteredSeries.js", [d["Core/Globals.js"], d["Core/Series/Series.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = E.isNumber,
              C = E.pick,
              D = E.relativeLength,
              K = c.deg2rad;
          return c.CenteredSeriesMixin = {
            getCenter: function getCenter() {
              var c = this.options,
                  r = this.chart,
                  k = 2 * (c.slicedOffset || 0),
                  h = r.plotWidth - 2 * k,
                  a = r.plotHeight - 2 * k,
                  g = c.center,
                  y = Math.min(h, a),
                  n = c.size,
                  t = c.innerSize || 0;
              "string" === typeof n && (n = parseFloat(n));
              "string" === typeof t && (t = parseFloat(t));
              c = [C(g[0], "50%"), C(g[1], "50%"), C(n && 0 > n ? void 0 : c.size, "100%"), C(t && 0 > t ? void 0 : c.innerSize || 0, "0%")];
              !r.angular || this instanceof d || (c[3] = 0);

              for (g = 0; 4 > g; ++g) {
                n = c[g], r = 2 > g || 2 === g && /%$/.test(n), c[g] = D(n, [h, a, y, c[2]][g]) + (r ? k : 0);
              }

              c[3] > c[2] && (c[3] = c[2]);
              return c;
            },
            getStartAndEndRadians: function getStartAndEndRadians(c, d) {
              c = B(c) ? c : 0;
              d = B(d) && d > c && 360 > d - c ? d : c + 360;
              return {
                start: K * (c + -90),
                end: K * (d + -90)
              };
            }
          };
        });
        M(d, "Series/Pie/PiePoint.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Series/Point.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = this && this.__extends || function () {
            var _c8 = function c(a, d) {
              _c8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _c8(a, d);
            };

            return function (a, d) {
              function g() {
                this.constructor = a;
              }

              _c8(a, d);

              a.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }(),
              C = c.setAnimation,
              D = E.addEvent,
              K = E.defined;

          c = E.extend;
          var A = E.isNumber,
              r = E.pick,
              k = E.relativeLength;

          d = function (c) {
            function a() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.labelDistance = void 0;
              a.options = void 0;
              a.series = void 0;
              return a;
            }

            B(a, c);

            a.prototype.getConnectorPath = function () {
              var a = this.labelPosition,
                  c = this.series.options.dataLabels,
                  d = this.connectorShapes,
                  h = c.connectorShape;
              d[h] && (h = d[h]);
              return h.call(this, {
                x: a["final"].x,
                y: a["final"].y,
                alignment: a.alignment
              }, a.connectorPosition, c);
            };

            a.prototype.getTranslate = function () {
              return this.sliced ? this.slicedTranslation : {
                translateX: 0,
                translateY: 0
              };
            };

            a.prototype.haloPath = function (a) {
              var c = this.shapeArgs;
              return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
                innerR: c.r - 1,
                start: c.start,
                end: c.end
              });
            };

            a.prototype.init = function () {
              var a = this;
              c.prototype.init.apply(this, arguments);
              this.name = r(this.name, "Slice");

              var d = function d(c) {
                a.slice("select" === c.type);
              };

              D(this, "select", d);
              D(this, "unselect", d);
              return this;
            };

            a.prototype.isValid = function () {
              return A(this.y) && 0 <= this.y;
            };

            a.prototype.setVisible = function (a, c) {
              var d = this,
                  g = this.series,
                  h = g.chart,
                  m = g.options.ignoreHiddenPoint;
              c = r(c, m);
              a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, g.options.data[g.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (c) {
                if (d[c]) d[c][a ? "show" : "hide"](a);
              }), this.legendItem && h.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), m && (g.isDirty = !0), c && h.redraw());
            };

            a.prototype.slice = function (a, c, d) {
              var g = this.series;
              C(d, g.chart);
              r(c, !0);
              this.sliced = this.options.sliced = K(a) ? a : !this.sliced;
              g.options.data[g.data.indexOf(this)] = this.options;
              this.graphic && this.graphic.animate(this.getTranslate());
              this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };

            return a;
          }(d);

          c(d.prototype, {
            connectorShapes: {
              fixedOffset: function fixedOffset(c, a, d) {
                var g = a.breakAt;
                a = a.touchingSliceAt;
                return [["M", c.x, c.y], d.softConnector ? ["C", c.x + ("left" === c.alignment ? -5 : 5), c.y, 2 * g.x - a.x, 2 * g.y - a.y, g.x, g.y] : ["L", g.x, g.y], ["L", a.x, a.y]];
              },
              straight: function straight(c, a) {
                a = a.touchingSliceAt;
                return [["M", c.x, c.y], ["L", a.x, a.y]];
              },
              crookedLine: function crookedLine(c, a, d) {
                a = a.touchingSliceAt;
                var g = this.series,
                    h = g.center[0],
                    t = g.chart.plotWidth,
                    r = g.chart.plotLeft;
                g = c.alignment;
                var m = this.shapeArgs.r;
                d = k(d.crookDistance, 1);
                t = "left" === g ? h + m + (t + r - h - m) * (1 - d) : r + (h - m) * d;
                d = ["L", t, c.y];
                h = !0;
                if ("left" === g ? t > c.x || t < a.x : t < c.x || t > a.x) h = !1;
                c = [["M", c.x, c.y]];
                h && c.push(d);
                c.push(["L", a.x, a.y]);
                return c;
              }
            }
          });
          return d;
        });
        M(d, "Series/Pie/PieSeries.js", [d["Mixins/CenteredSeries.js"], d["Series/Column/ColumnSeries.js"], d["Core/Globals.js"], d["Core/Legend/LegendSymbol.js"], d["Core/Color/Palette.js"], d["Series/Pie/PiePoint.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Renderer/SVG/Symbols.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A, r, k) {
          var h = this && this.__extends || function () {
            var _a4 = function a(c, d) {
              _a4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _a4(c, d);
            };

            return function (c, d) {
              function g() {
                this.constructor = c;
              }

              _a4(c, d);

              c.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }(),
              a = c.getStartAndEndRadians;

          E = E.noop;
          var g = k.clamp,
              y = k.extend,
              n = k.fireEvent,
              t = k.merge,
              B = k.pick,
              m = k.relativeLength;

          k = function (c) {
            function d() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.center = void 0;
              a.data = void 0;
              a.maxLabelDistance = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            h(d, c);

            d.prototype.animate = function (a) {
              var c = this,
                  d = c.points,
                  g = c.startAngleRad;
              a || d.forEach(function (a) {
                var b = a.graphic,
                    f = a.shapeArgs;
                b && f && (b.attr({
                  r: B(a.startR, c.center && c.center[3] / 2),
                  start: g,
                  end: g
                }), b.animate({
                  r: f.r,
                  start: f.start,
                  end: f.end
                }, c.options.animation));
              });
            };

            d.prototype.drawEmpty = function () {
              var a = this.startAngleRad,
                  c = this.endAngleRad,
                  d = this.options;

              if (0 === this.total && this.center) {
                var g = this.center[0];
                var f = this.center[1];
                this.graph || (this.graph = this.chart.renderer.arc(g, f, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
                this.graph.attr({
                  d: r.arc(g, f, this.center[2] / 2, 0, {
                    start: a,
                    end: c,
                    innerR: this.center[3] / 2
                  })
                });
                this.chart.styledMode || this.graph.attr({
                  "stroke-width": d.borderWidth,
                  fill: d.fillColor || "none",
                  stroke: d.color || C.neutralColor20
                });
              } else this.graph && (this.graph = this.graph.destroy());
            };

            d.prototype.drawPoints = function () {
              var a = this.chart.renderer;
              this.points.forEach(function (c) {
                c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
                c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
              });
            };

            d.prototype.generatePoints = function () {
              c.prototype.generatePoints.call(this);
              this.updateTotals();
            };

            d.prototype.getX = function (a, c, d) {
              var h = this.center,
                  f = this.radii ? this.radii[d.index] || 0 : h[2] / 2;
              a = Math.asin(g((a - h[1]) / (f + d.labelDistance), -1, 1));
              return h[0] + (c ? -1 : 1) * Math.cos(a) * (f + d.labelDistance) + (0 < d.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
            };

            d.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            d.prototype.redrawPoints = function () {
              var a = this,
                  c = a.chart,
                  d = c.renderer,
                  g = a.options.shadow,
                  f,
                  b,
                  h,
                  m;
              this.drawEmpty();
              !g || a.shadowGroup || c.styledMode || (a.shadowGroup = d.g("shadow").attr({
                zIndex: -1
              }).add(a.group));
              a.points.forEach(function (e) {
                var q = {};
                b = e.graphic;

                if (!e.isNull && b) {
                  var l = void 0;
                  m = e.shapeArgs;
                  f = e.getTranslate();
                  c.styledMode || (l = e.shadowGroup, g && !l && (l = e.shadowGroup = d.g("shadow").add(a.shadowGroup)), l && l.attr(f), h = a.pointAttribs(e, e.selected && "select"));
                  e.delayedRendering ? (b.setRadialReference(a.center).attr(m).attr(f), c.styledMode || b.attr(h).attr({
                    "stroke-linejoin": "round"
                  }).shadow(g, l), e.delayedRendering = !1) : (b.setRadialReference(a.center), c.styledMode || t(!0, q, h), t(!0, q, m, f), b.animate(q));
                  b.attr({
                    visibility: e.visible ? "inherit" : "hidden"
                  });
                  b.addClass(e.getClassName(), !0);
                } else b && (e.graphic = b.destroy());
              });
            };

            d.prototype.sortByAngle = function (a, c) {
              a.sort(function (a, d) {
                return "undefined" !== typeof a.angle && (d.angle - a.angle) * c;
              });
            };

            d.prototype.translate = function (c) {
              this.generatePoints();
              var d = this.options,
                  g = d.slicedOffset,
                  h = g + (d.borderWidth || 0),
                  f = a(d.startAngle, d.endAngle),
                  b = this.startAngleRad = f.start;
              f = (this.endAngleRad = f.end) - b;
              var k = this.points,
                  t = d.dataLabels.distance;
              d = d.ignoreHiddenPoint;
              var e = k.length,
                  q,
                  l = 0;
              c || (this.center = c = this.getCenter());

              for (q = 0; q < e; q++) {
                var I = k[q];
                var p = b + l * f;
                !I.isValid() || d && !I.visible || (l += I.percentage / 100);
                var z = b + l * f;
                var x = {
                  x: c[0],
                  y: c[1],
                  r: c[2] / 2,
                  innerR: c[3] / 2,
                  start: Math.round(1E3 * p) / 1E3,
                  end: Math.round(1E3 * z) / 1E3
                };
                I.shapeType = "arc";
                I.shapeArgs = x;
                I.labelDistance = B(I.options.dataLabels && I.options.dataLabels.distance, t);
                I.labelDistance = m(I.labelDistance, x.r);
                this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, I.labelDistance);
                z = (z + p) / 2;
                z > 1.5 * Math.PI ? z -= 2 * Math.PI : z < -Math.PI / 2 && (z += 2 * Math.PI);
                I.slicedTranslation = {
                  translateX: Math.round(Math.cos(z) * g),
                  translateY: Math.round(Math.sin(z) * g)
                };
                x = Math.cos(z) * c[2] / 2;
                var r = Math.sin(z) * c[2] / 2;
                I.tooltipPos = [c[0] + .7 * x, c[1] + .7 * r];
                I.half = z < -Math.PI / 2 || z > Math.PI / 2 ? 1 : 0;
                I.angle = z;
                p = Math.min(h, I.labelDistance / 5);
                I.labelPosition = {
                  natural: {
                    x: c[0] + x + Math.cos(z) * I.labelDistance,
                    y: c[1] + r + Math.sin(z) * I.labelDistance
                  },
                  "final": {},
                  alignment: 0 > I.labelDistance ? "center" : I.half ? "right" : "left",
                  connectorPosition: {
                    breakAt: {
                      x: c[0] + x + Math.cos(z) * p,
                      y: c[1] + r + Math.sin(z) * p
                    },
                    touchingSliceAt: {
                      x: c[0] + x,
                      y: c[1] + r
                    }
                  }
                };
              }

              n(this, "afterTranslate");
            };

            d.prototype.updateTotals = function () {
              var a = this.points,
                  c = a.length,
                  d = this.options.ignoreHiddenPoint,
                  g,
                  f = 0;

              for (g = 0; g < c; g++) {
                var b = a[g];
                !b.isValid() || d && !b.visible || (f += b.y);
              }

              this.total = f;

              for (g = 0; g < c; g++) {
                b = a[g], b.percentage = 0 < f && (b.visible || !d) ? b.y / f * 100 : 0, b.total = f;
              }
            };

            d.defaultOptions = t(K.defaultOptions, {
              center: [null, null],
              clip: !1,
              colorByPoint: !0,
              dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0
              },
              fillColor: void 0,
              ignoreHiddenPoint: !0,
              inactiveOtherPoints: !0,
              legendType: "point",
              marker: null,
              size: null,
              showInLegend: !1,
              slicedOffset: 10,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0
              },
              borderColor: C.backgroundColor,
              borderWidth: 1,
              lineWidth: void 0,
              states: {
                hover: {
                  brightness: .1
                }
              }
            });
            return d;
          }(K);

          y(k.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: G.drawRectangle,
            drawTracker: d.prototype.drawTracker,
            getCenter: c.getCenter,
            getSymbol: E,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: d.prototype.pointAttribs,
            pointClass: D,
            requireSorting: !1,
            searchPoint: E,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          A.registerSeriesType("pie", k);
          "";
          return k;
        });
        M(d, "Series/Pie/PieDataLabel.js", [d["Core/Series/DataLabel.js"], d["Core/Globals.js"], d["Core/Color/Palette.js"], d["Core/Renderer/RendererUtilities.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D) {
          var B = d.noop,
              A = G.distribute,
              r = C.series,
              k = D.arrayMax,
              h = D.clamp,
              a = D.defined,
              g = D.merge,
              y = D.pick,
              n = D.relativeLength,
              t;

          (function (d) {
            function m() {
              var c = this,
                  d = c.data,
                  f = c.chart,
                  b = c.options.dataLabels || {},
                  h = b.connectorPadding,
                  m = f.plotWidth,
                  e = f.plotHeight,
                  q = f.plotLeft,
                  l = Math.round(f.chartWidth / 3),
                  n = c.center,
                  p = n[2] / 2,
                  z = n[1],
                  t = [[], []],
                  x = [0, 0, 0, 0],
                  J = c.dataLabelPositioners,
                  u,
                  B,
                  D,
                  C,
                  G,
                  L,
                  O,
                  K,
                  N,
                  R,
                  M,
                  V;
              c.visible && (b.enabled || c._hasPointLabels) && (d.forEach(function (b) {
                b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({
                  width: "auto"
                }).css({
                  width: "auto",
                  textOverflow: "clip"
                }), b.dataLabel.shortened = !1);
              }), r.prototype.drawDataLabels.apply(c), d.forEach(function (c) {
                c.dataLabel && (c.visible ? (t[c.half].push(c), c.dataLabel._pos = null, !a(b.style.width) && !a(c.options.dataLabels && c.options.dataLabels.style && c.options.dataLabels.style.width) && c.dataLabel.getBBox().width > l && (c.dataLabel.css({
                  width: Math.round(.7 * l) + "px"
                }), c.dataLabel.shortened = !0)) : (c.dataLabel = c.dataLabel.destroy(), c.dataLabels && 1 === c.dataLabels.length && delete c.dataLabels));
              }), t.forEach(function (d, g) {
                var l = d.length,
                    k = [],
                    v;

                if (l) {
                  c.sortByAngle(d, g - .5);

                  if (0 < c.maxLabelDistance) {
                    var I = Math.max(0, z - p - c.maxLabelDistance);
                    var t = Math.min(z + p + c.maxLabelDistance, f.plotHeight);
                    d.forEach(function (b) {
                      0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, z - p - b.labelDistance), b.bottom = Math.min(z + p + b.labelDistance, f.plotHeight), v = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                        target: b.labelPosition.natural.y - b.top + v / 2,
                        size: v,
                        rank: b.y
                      }, k.push(b.distributeBox));
                    });
                    I = t + v - I;
                    A(k, I, I / 5);
                  }

                  for (M = 0; M < l; M++) {
                    u = d[M];
                    L = u.labelPosition;
                    C = u.dataLabel;
                    R = !1 === u.visible ? "hidden" : "inherit";
                    N = I = L.natural.y;
                    k && a(u.distributeBox) && ("undefined" === typeof u.distributeBox.pos ? R = "hidden" : (O = u.distributeBox.size, N = J.radialDistributionY(u)));
                    delete u.positionIndex;
                    if (b.justify) K = J.justify(u, p, n);else switch (b.alignTo) {
                      case "connectors":
                        K = J.alignToConnectors(d, g, m, q);
                        break;

                      case "plotEdges":
                        K = J.alignToPlotEdges(C, g, m, q);
                        break;

                      default:
                        K = J.radialDistributionX(c, u, N, I);
                    }
                    C._attr = {
                      visibility: R,
                      align: L.alignment
                    };
                    V = u.options.dataLabels || {};
                    C._pos = {
                      x: K + y(V.x, b.x) + ({
                        left: h,
                        right: -h
                      }[L.alignment] || 0),
                      y: N + y(V.y, b.y) - 10
                    };
                    L["final"].x = K;
                    L["final"].y = N;
                    y(b.crop, !0) && (G = C.getBBox().width, I = null, K - G < h && 1 === g ? (I = Math.round(G - K + h), x[3] = Math.max(I, x[3])) : K + G > m - h && 0 === g && (I = Math.round(K + G - m + h), x[1] = Math.max(I, x[1])), 0 > N - O / 2 ? x[0] = Math.max(Math.round(-N + O / 2), x[0]) : N + O / 2 > e && (x[2] = Math.max(Math.round(N + O / 2 - e), x[2])), C.sideOverflow = I);
                  }
                }
              }), 0 === k(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach(function (a) {
                V = g(b, a.options.dataLabels);

                if (B = y(V.connectorWidth, 1)) {
                  var e;
                  D = a.connector;

                  if ((C = a.dataLabel) && C._pos && a.visible && 0 < a.labelDistance) {
                    R = C._attr.visibility;
                    if (e = !D) a.connector = D = f.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(c.dataLabelsGroup), f.styledMode || D.attr({
                      "stroke-width": B,
                      stroke: V.connectorColor || a.color || E.neutralColor60
                    });
                    D[e ? "attr" : "animate"]({
                      d: a.getConnectorPath()
                    });
                    D.attr("visibility", R);
                  } else D && (a.connector = D.destroy());
                }
              }));
            }

            function t() {
              this.points.forEach(function (a) {
                var c = a.dataLabel,
                    d;
                c && a.visible && ((d = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
                  width: c._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](d), c.moved = !0) : c && c.attr({
                  y: -9999
                }));
                delete a.distributeBox;
              }, this);
            }

            function D(a) {
              var c = this.center,
                  d = this.options,
                  b = d.center,
                  g = d.minSize || 80,
                  m = null !== d.size;

              if (!m) {
                if (null !== b[0]) var e = Math.max(c[2] - Math.max(a[1], a[3]), g);else e = Math.max(c[2] - a[1] - a[3], g), c[0] += (a[3] - a[1]) / 2;
                null !== b[1] ? e = h(e, g, c[2] - Math.max(a[0], a[2])) : (e = h(e, g, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
                e < c[2] ? (c[2] = e, c[3] = Math.min(n(d.innerSize || 0, e), e), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : m = !0;
              }

              return m;
            }

            var x = [],
                C = {
              radialDistributionY: function radialDistributionY(a) {
                return a.top + a.distributeBox.pos;
              },
              radialDistributionX: function radialDistributionX(a, c, d, b) {
                return a.getX(d < c.top + 2 || d > c.bottom - 2 ? b : d, c.half, c);
              },
              justify: function justify(a, c, d) {
                return d[0] + (a.half ? -1 : 1) * (c + a.labelDistance);
              },
              alignToPlotEdges: function alignToPlotEdges(a, c, d, b) {
                a = a.getBBox().width;
                return c ? a + b : d - a - b;
              },
              alignToConnectors: function alignToConnectors(a, c, d, b) {
                var f = 0,
                    g;
                a.forEach(function (b) {
                  g = b.dataLabel.getBBox().width;
                  g > f && (f = g);
                });
                return c ? f + b : d - f - b;
              }
            };

            d.compose = function (a) {
              c.compose(r);
              -1 === x.indexOf(a) && (x.push(a), a = a.prototype, a.dataLabelPositioners = C, a.alignDataLabel = B, a.drawDataLabels = m, a.placeDataLabels = t, a.verifyDataLabelOverflow = D);
            };
          })(t || (t = {}));

          return t;
        });
        M(d, "Extensions/OverlappingDataLabels.js", [d["Core/Chart/Chart.js"], d["Core/Utilities.js"]], function (c, d) {
          function B(c, d) {
            var a = !1;

            if (c) {
              var g = c.newOpacity;
              c.oldOpacity !== g && (c.alignAttr && c.placed ? (c[g ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), a = !0, c.alignAttr.opacity = g, c[c.isOld ? "animate" : "attr"](c.alignAttr, null, function () {
                d.styledMode || c.css({
                  pointerEvents: g ? "auto" : "none"
                });
              }), C(d, "afterHideOverlappingLabel")) : c.attr({
                opacity: g
              }));
              c.isOld = !0;
            }

            return a;
          }

          var G = d.addEvent,
              C = d.fireEvent,
              D = d.isArray,
              K = d.isNumber,
              A = d.objectEach,
              r = d.pick;
          G(c, "render", function () {
            var c = this,
                d = [];
            (this.labelCollectors || []).forEach(function (a) {
              d = d.concat(a());
            });
            (this.yAxis || []).forEach(function (a) {
              a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && A(a.stacking.stacks, function (a) {
                A(a, function (a) {
                  a.label && "hidden" !== a.label.visibility && d.push(a.label);
                });
              });
            });
            (this.series || []).forEach(function (a) {
              var g = a.options.dataLabels;
              a.visible && (!1 !== g.enabled || a._hasPointLabels) && (g = function g(a) {
                return a.forEach(function (a) {
                  a.visible && (D(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : []).forEach(function (g) {
                    var h = g.options;
                    g.labelrank = r(h.labelrank, a.labelrank, a.shapeArgs && a.shapeArgs.height);
                    h.allowOverlap ? (g.oldOpacity = g.opacity, g.newOpacity = 1, B(g, c)) : d.push(g);
                  });
                });
              }, g(a.nodes || []), g(a.points));
            });
            this.hideOverlappingLabels(d);
          });

          c.prototype.hideOverlappingLabels = function (c) {
            var d = this,
                a = c.length,
                g = d.renderer,
                k,
                n,
                t,
                r = !1;

            var m = function m(a) {
              var c,
                  d = a.box ? 0 : a.padding || 0,
                  h = c = 0,
                  f;

              if (a && (!a.alignAttr || a.placed)) {
                var b = a.alignAttr || {
                  x: a.attr("x"),
                  y: a.attr("y")
                };
                var m = a.parentGroup;
                a.width || (c = a.getBBox(), a.width = c.width, a.height = c.height, c = g.fontMetrics(null, a.element).h);
                var k = a.width - 2 * d;
                (f = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[a.alignValue]) ? h = +f * k : K(a.x) && Math.round(a.x) !== a.translateX && (h = a.x - a.translateX);
                return {
                  x: b.x + (m.translateX || 0) + d - (h || 0),
                  y: b.y + (m.translateY || 0) + d - c,
                  width: a.width - 2 * d,
                  height: a.height - 2 * d
                };
              }
            };

            for (n = 0; n < a; n++) {
              if (k = c[n]) k.oldOpacity = k.opacity, k.newOpacity = 1, k.absoluteBox = m(k);
            }

            c.sort(function (a, c) {
              return (c.labelrank || 0) - (a.labelrank || 0);
            });

            for (n = 0; n < a; n++) {
              var A = (m = c[n]) && m.absoluteBox;

              for (k = n + 1; k < a; ++k) {
                var D = (t = c[k]) && t.absoluteBox;
                !A || !D || m === t || 0 === m.newOpacity || 0 === t.newOpacity || D.x >= A.x + A.width || D.x + D.width <= A.x || D.y >= A.y + A.height || D.y + D.height <= A.y || ((m.labelrank < t.labelrank ? m : t).newOpacity = 0);
              }
            }

            c.forEach(function (a) {
              B(a, d) && (r = !0);
            });
            r && C(d, "afterHideAllOverlappingLabels");
          };
        });
        M(d, "Core/Responsive.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.extend,
              E = c.find,
              G = c.isArray,
              C = c.isObject,
              D = c.merge,
              K = c.objectEach,
              A = c.pick,
              r = c.splat,
              k = c.uniqueKey,
              h;

          (function (a) {
            var c = [];

            a.compose = function (a) {
              -1 === c.indexOf(a) && (c.push(a), d(a.prototype, h.prototype));
              return a;
            };

            var h = function () {
              function a() {}

              a.prototype.currentOptions = function (a) {
                function c(a, g, h, m) {
                  var k;
                  K(a, function (a, b) {
                    if (!m && -1 < d.collectionsWithUpdate.indexOf(b) && g[b]) for (a = r(a), h[b] = [], k = 0; k < Math.max(a.length, g[b].length); k++) {
                      g[b][k] && (void 0 === a[k] ? h[b][k] = g[b][k] : (h[b][k] = {}, c(a[k], g[b][k], h[b][k], m + 1)));
                    } else C(a) ? (h[b] = G(a) ? [] : {}, c(a, g[b] || {}, h[b], m + 1)) : h[b] = "undefined" === typeof g[b] ? null : g[b];
                  });
                }

                var d = this,
                    g = {};
                c(a, this.options, g, 0);
                return g;
              };

              a.prototype.matchResponsiveRule = function (a, c) {
                var d = a.condition;
                (d.callback || function () {
                  return this.chartWidth <= A(d.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(d.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(d.minWidth, 0) && this.chartHeight >= A(d.minHeight, 0);
                }).call(this) && c.push(a._id);
              };

              a.prototype.setResponsive = function (a, c) {
                var d = this,
                    g = this.options.responsive,
                    h = this.currentResponsive,
                    n = [];
                !c && g && g.rules && g.rules.forEach(function (a) {
                  "undefined" === typeof a._id && (a._id = k());
                  d.matchResponsiveRule(a, n);
                }, this);
                c = D.apply(void 0, n.map(function (a) {
                  return E((g || {}).rules || [], function (c) {
                    return c._id === a;
                  });
                }).map(function (a) {
                  return a && a.chartOptions;
                }));
                c.isResponsiveOptions = !0;
                n = n.toString() || void 0;
                n !== (h && h.ruleIds) && (h && this.update(h.undoOptions, a, !0), n ? (h = this.currentOptions(c), h.isResponsiveOptions = !0, this.currentResponsive = {
                  ruleIds: n,
                  mergedOptions: c,
                  undoOptions: h
                }, this.update(c, a, !0)) : this.currentResponsive = void 0);
              };

              return a;
            }();
          })(h || (h = {}));

          "";
          "";
          return h;
        });
        M(d, "masters/highcharts.src.js", [d["Core/Globals.js"], d["Core/Utilities.js"], d["Core/DefaultOptions.js"], d["Core/Animation/Fx.js"], d["Core/Animation/AnimationUtilities.js"], d["Core/Renderer/HTML/AST.js"], d["Core/FormatUtilities.js"], d["Core/Renderer/RendererUtilities.js"], d["Core/Renderer/SVG/SVGElement.js"], d["Core/Renderer/SVG/SVGRenderer.js"], d["Core/Renderer/HTML/HTMLElement.js"], d["Core/Renderer/HTML/HTMLRenderer.js"], d["Core/Axis/Axis.js"], d["Core/Axis/DateTimeAxis.js"], d["Core/Axis/LogarithmicAxis.js"], d["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], d["Core/Axis/Tick.js"], d["Core/Tooltip.js"], d["Core/Series/Point.js"], d["Core/Pointer.js"], d["Core/MSPointer.js"], d["Core/Legend/Legend.js"], d["Core/Chart/Chart.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Series/Column/ColumnSeries.js"], d["Series/Column/ColumnDataLabel.js"], d["Series/Pie/PieSeries.js"], d["Series/Pie/PieDataLabel.js"], d["Core/Series/DataLabel.js"], d["Core/Responsive.js"], d["Core/Color/Color.js"], d["Core/Time.js"]], function (c, d, E, G, C, D, K, A, r, k, h, a, g, y, n, t, O, m, N, L, x, R, H, w, f, b, v, F, e, q, l, I, p) {
          c.animate = C.animate;
          c.animObject = C.animObject;
          c.getDeferredAnimation = C.getDeferredAnimation;
          c.setAnimation = C.setAnimation;
          c.stop = C.stop;
          c.timers = G.timers;
          c.AST = D;
          c.Axis = g;
          c.Chart = H;
          c.chart = H.chart;
          c.Fx = G;
          c.Legend = R;
          c.PlotLineOrBand = t;
          c.Point = N;
          c.Pointer = x.isRequired() ? x : L;
          c.Series = w;
          c.SVGElement = r;
          c.SVGRenderer = k;
          c.Tick = O;
          c.Time = p;
          c.Tooltip = m;
          c.Color = I;
          c.color = I.parse;
          a.compose(k);
          h.compose(r);
          c.defaultOptions = E.defaultOptions;
          c.getOptions = E.getOptions;
          c.time = E.defaultTime;
          c.setOptions = E.setOptions;
          c.dateFormat = K.dateFormat;
          c.format = K.format;
          c.numberFormat = K.numberFormat;
          c.addEvent = d.addEvent;
          c.arrayMax = d.arrayMax;
          c.arrayMin = d.arrayMin;
          c.attr = d.attr;
          c.clearTimeout = d.clearTimeout;
          c.correctFloat = d.correctFloat;
          c.createElement = d.createElement;
          c.css = d.css;
          c.defined = d.defined;
          c.destroyObjectProperties = d.destroyObjectProperties;
          c.discardElement = d.discardElement;
          c.distribute = A.distribute;
          c.erase = d.erase;
          c.error = d.error;
          c.extend = d.extend;
          c.extendClass = d.extendClass;
          c.find = d.find;
          c.fireEvent = d.fireEvent;
          c.getMagnitude = d.getMagnitude;
          c.getStyle = d.getStyle;
          c.inArray = d.inArray;
          c.isArray = d.isArray;
          c.isClass = d.isClass;
          c.isDOMElement = d.isDOMElement;
          c.isFunction = d.isFunction;
          c.isNumber = d.isNumber;
          c.isObject = d.isObject;
          c.isString = d.isString;
          c.keys = d.keys;
          c.merge = d.merge;
          c.normalizeTickInterval = d.normalizeTickInterval;
          c.objectEach = d.objectEach;
          c.offset = d.offset;
          c.pad = d.pad;
          c.pick = d.pick;
          c.pInt = d.pInt;
          c.relativeLength = d.relativeLength;
          c.removeEvent = d.removeEvent;
          c.seriesType = f.seriesType;
          c.splat = d.splat;
          c.stableSort = d.stableSort;
          c.syncTimeout = d.syncTimeout;
          c.timeUnits = d.timeUnits;
          c.uniqueKey = d.uniqueKey;
          c.useSerialIds = d.useSerialIds;
          c.wrap = d.wrap;
          v.compose(b);
          q.compose(w);
          y.compose(g);
          n.compose(g);
          e.compose(F);
          t.compose(g);
          l.compose(H);
          return c;
        });
        M(d, "Core/Axis/OrdinalAxis.js", [d["Core/Axis/Axis.js"], d["Core/Globals.js"], d["Core/Series/Series.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var C = G.addEvent,
              D = G.correctFloat,
              B = G.css,
              A = G.defined,
              r = G.error,
              k = G.pick,
              h = G.timeUnits,
              a = [],
              g;

          (function (c) {
            function g(b, a, c, d, f, g, p) {
              void 0 === f && (f = []);
              void 0 === g && (g = 0);
              var e = {},
                  l = this.options.tickPixelInterval,
                  q = this.chart.time,
                  m = [],
                  k,
                  n,
                  I = 0,
                  v = [],
                  t = -Number.MAX_VALUE;
              if (!this.options.ordinal && !this.options.breaks || !f || 3 > f.length || "undefined" === typeof a) return q.getTimeTicks.apply(q, arguments);
              var F = f.length;

              for (k = 0; k < F; k++) {
                var x = k && f[k - 1] > c;
                f[k] < a && (I = k);

                if (k === F - 1 || f[k + 1] - f[k] > 5 * g || x) {
                  if (f[k] > t) {
                    for (n = q.getTimeTicks(b, f[I], f[k], d); n.length && n[0] <= t;) {
                      n.shift();
                    }

                    n.length && (t = n[n.length - 1]);
                    m.push(v.length);
                    v = v.concat(n);
                  }

                  I = k + 1;
                }

                if (x) break;
              }

              if (n) {
                n = n.info;

                if (p && n.unitRange <= h.hour) {
                  k = v.length - 1;

                  for (I = 1; I < k; I++) {
                    if (q.dateFormat("%d", v[I]) !== q.dateFormat("%d", v[I - 1])) {
                      e[v[I]] = "day";
                      var w = !0;
                    }
                  }

                  w && (e[v[0]] = "day");
                  n.higherRanks = e;
                }

                n.segmentStarts = m;
                v.info = n;
              } else r(12, !1, this.chart);

              if (p && A(l)) {
                n = v.length;
                q = [];
                I = [];
                k = void 0;

                for (w = n; w--;) {
                  m = this.translate(v[w]), k && (I[w] = k - m), q[w] = k = m;
                }

                I.sort();
                I = I[Math.floor(I.length / 2)];
                I < .6 * l && (I = null);
                w = v[n - 1] > c ? n - 1 : n;

                for (k = void 0; w--;) {
                  m = q[w], n = Math.abs(k - m), k && n < .8 * l && (null === I || n < .8 * I) ? (e[v[w]] && !e[v[w + 1]] ? (n = w + 1, k = m) : n = w, v.splice(n, 1)) : k = m;
                }
              }

              return v;
            }

            function t(b) {
              var a = this.ordinal.positions;
              if (!a) return b;
              var c = a.length - 1;
              if (0 > b) b = a[0];else if (b > c) b = a[c];else {
                c = Math.floor(b);
                var d = b - c;
              }
              return "undefined" !== typeof d && "undefined" !== typeof a[c] ? a[c] + (d ? d * (a[c + 1] - a[c]) : 0) : b;
            }

            function y(b) {
              var a = this.ordinal,
                  c = a.positions;
              if (!c) return b;
              var d = (b - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding;
              0 < d && d < this.left + this.len || (a.extendedOrdinalPositions || (a.extendedOrdinalPositions = a.getExtendedPositions()), c = a.extendedOrdinalPositions);

              if (c && c.length) {
                b = a.getIndexOfPoint(d, c);
                a = D(b % 1);
                if (0 <= b && b < c.length) return c[Math.floor(b)] + a * (c[Math.ceil(b)] - c[Math.floor(b)]);
                a = c.length;
                d = c[0];
                c = c[a - 1];
                var f = (c - d) / (a - 1);
                return 0 > b ? d + f * b : c + f * (b - a);
              }

              return b;
            }

            function m(b, a) {
              var e = c.Additions.findIndexOf(b, a, !0);
              return b[e] === a ? e : e + (a - b[e]) / (b[e + 1] - b[e]);
            }

            function G() {
              this.ordinal || (this.ordinal = new c.Additions(this));
            }

            function L() {
              this.isXAxis && A(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && "navigator" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && A(this.userMin) && (this.min += this.options.overscroll));
            }

            function x() {
              this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
            }

            function K() {
              this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
            }

            function H(b) {
              var a = this.xAxis[0],
                  c = a.options.overscroll,
                  d = b.originalEvent.chartX,
                  f = this.options.chart.panning,
                  g = !1;

              if (f && "y" !== f.type && a.options.ordinal && a.series.length) {
                var p = this.mouseDownX,
                    h = a.getExtremes(),
                    m = h.dataMax,
                    k = h.min,
                    n = h.max,
                    u = this.hoverPoints,
                    v = a.closestPointRange || a.ordinal && a.ordinal.overscrollPointsRange;
                p = (p - d) / (a.translationSlope * (a.ordinal.slope || v));
                v = {
                  ordinal: {
                    positions: a.ordinal.getExtendedPositions()
                  }
                };
                var t = a.index2val,
                    r = a.val2lin,
                    x = void 0,
                    w = x = void 0,
                    y = void 0;
                v.ordinal.positions ? 1 < Math.abs(p) && (u && u.forEach(function (a) {
                  a.setState();
                }), 0 > p ? (w = v, y = a.ordinal.positions ? a : v) : (w = a.ordinal.positions ? a : v, y = v), x = y.ordinal.positions, m > x[x.length - 1] && x.push(m), this.fixedRange = n - k, x = a.navigatorAxis.toFixedRange(null, null, t.apply(w, [r.apply(w, [k, !0]) + p]), t.apply(y, [r.apply(y, [n, !0]) + p])), x.min >= Math.min(h.dataMin, k) && x.max <= Math.max(m, n) + c && a.setExtremes(x.min, x.max, !0, !1, {
                  trigger: "pan"
                }), this.mouseDownX = d, B(this.container, {
                  cursor: "move"
                })) : g = !0;
              } else g = !0;

              g || f && /y/.test(f.type) ? c && (a.max = a.dataMax + c) : b.preventDefault();
            }

            function w() {
              var a = this.xAxis;
              a && a.options.ordinal && (delete a.ordinal.index, delete a.ordinal.extendedOrdinalPositions);
            }

            function f(a, b) {
              var c = this.ordinal,
                  d = c.positions,
                  f = c.slope,
                  g = c.extendedOrdinalPositions;
              if (!d) return a;
              var p = d.length;
              if (d[0] <= a && d[p - 1] >= a) a = m(d, a);else {
                g || (g = c.getExtendedPositions && c.getExtendedPositions(), c.extendedOrdinalPositions = g);
                if (!g || !g.length) return a;
                p = g.length;
                f || (f = (g[p - 1] - g[0]) / p);
                d = m(g, d[0]);
                a >= g[0] && a <= g[p - 1] ? a = m(g, a) - d : a < g[0] ? (a = g[0] - a, a = -d - a / f) : (a -= g[p - 1], a = a / f + p - d);
              }
              return b ? a : f * (a || 0) + c.offset;
            }

            c.compose = function (b, c, e) {
              if (-1 === a.indexOf(b)) {
                a.push(b);
                var d = b.prototype;
                d.getTimeTicks = g;
                d.index2val = t;
                d.lin2val = y;
                d.val2lin = f;
                d.ordinal2lin = d.val2lin;
                C(b, "afterInit", G);
                C(b, "foundExtremes", L);
                C(b, "afterSetScale", x);
                C(b, "initialAxisTranslation", K);
              }

              -1 === a.indexOf(e) && (a.push(e), C(e, "pan", H));
              -1 === a.indexOf(c) && (a.push(c), C(c, "updatedData", w));
              return b;
            };

            var b = function () {
              function a(a) {
                this.index = {};
                this.axis = a;
              }

              a.prototype.beforeSetTickPositions = function () {
                var a = this.axis,
                    b = a.ordinal,
                    c = a.getExtremes(),
                    d = c.min,
                    f = c.max,
                    g = a.isXAxis && !!a.options.breaks;
                c = a.options.ordinal;
                var h = a.chart.options.chart.ignoreHiddenSeries,
                    m,
                    n,
                    t,
                    u = [],
                    v = Number.MAX_VALUE,
                    r = !1;

                if (c || g) {
                  a.series.forEach(function (a, b) {
                    m = [];

                    if (!(h && !1 === a.visible || !1 === a.takeOrdinalPosition && !g) && (u = u.concat(a.processedXData), x = u.length, u.sort(function (a, b) {
                      return a - b;
                    }), v = Math.min(v, k(a.closestPointRange, v)), x)) {
                      for (b = 0; b < x - 1;) {
                        u[b] !== u[b + 1] && m.push(u[b + 1]), b++;
                      }

                      m[0] !== u[0] && m.unshift(u[0]);
                      u = m;
                    }

                    a.isSeriesBoosting && (t = !0);
                  });
                  t && (u.length = 0);
                  var x = u.length;

                  if (2 < x) {
                    var w = u[1] - u[0];

                    for (n = x - 1; n-- && !r;) {
                      u[n + 1] - u[n] !== w && (r = !0);
                    }

                    !a.options.keepOrdinalPadding && (u[0] - d > w || f - u[u.length - 1] > w) && (r = !0);
                  } else a.options.overscroll && (2 === x ? v = u[1] - u[0] : 1 === x ? (v = a.options.overscroll, u = [u[0], u[0] + v]) : v = b.overscrollPointsRange);

                  r || a.forceOrdinal ? (a.options.overscroll && (b.overscrollPointsRange = v, u = u.concat(b.getOverscrollPositions())), b.positions = u, w = a.ordinal2lin(Math.max(d, u[0]), !0), n = Math.max(a.ordinal2lin(Math.min(f, u[u.length - 1]), !0), 1), b.slope = f = (f - d) / (n - w), b.offset = d - w * f) : (b.overscrollPointsRange = k(a.closestPointRange, b.overscrollPointsRange), b.positions = a.ordinal.slope = b.offset = void 0);
                }

                a.isOrdinal = c && r;
                b.groupIntervalFactor = null;
              };

              a.findIndexOf = function (a, b, c) {
                for (var e = 0, d = a.length - 1, f; e < d;) {
                  f = Math.ceil((e + d) / 2), a[f] <= b ? e = f : d = f - 1;
                }

                return a[e] === b ? e : c ? e : -1;
              };

              a.prototype.getExtendedPositions = function () {
                var a = this,
                    b = a.axis,
                    c = b.constructor.prototype,
                    f = b.chart,
                    g = b.series[0].currentDataGrouping,
                    p = g ? g.count + g.unitName : "raw",
                    h = b.options.overscroll,
                    m = b.getExtremes(),
                    k = void 0,
                    n = a.index;
                n || (n = a.index = {});

                if (!n[p]) {
                  var u = {
                    series: [],
                    chart: f,
                    forceOrdinal: !1,
                    getExtremes: function getExtremes() {
                      return {
                        min: m.dataMin,
                        max: m.dataMax + h
                      };
                    },
                    getGroupPixelWidth: c.getGroupPixelWidth,
                    getTimeTicks: c.getTimeTicks,
                    options: {
                      ordinal: !0
                    },
                    ordinal: {
                      getGroupIntervalFactor: this.getGroupIntervalFactor
                    },
                    ordinal2lin: c.ordinal2lin,
                    getIndexOfPoint: c.getIndexOfPoint,
                    val2lin: c.val2lin
                  };
                  u.ordinal.axis = u;
                  b.series.forEach(function (b) {
                    k = {
                      xAxis: u,
                      xData: b.xData.slice(),
                      chart: f,
                      destroyGroupedData: d.noop,
                      getProcessedData: E.prototype.getProcessedData,
                      applyGrouping: E.prototype.applyGrouping
                    };
                    k.xData = k.xData.concat(a.getOverscrollPositions());
                    k.options = {
                      dataGrouping: g ? {
                        firstAnchor: "firstPoint",
                        anchor: "middle",
                        lastAnchor: "lastPoint",
                        enabled: !0,
                        forced: !0,
                        approximation: "open",
                        units: [[g.unitName, [g.count]]]
                      } : {
                        enabled: !1
                      }
                    };
                    u.series.push(k);
                    b.processData.apply(k);
                  });
                  b.applyGrouping.call(u);
                  k.closestPointRange !== k.basePointRange && k.currentDataGrouping && (u.forceOrdinal = !0);
                  b.ordinal.beforeSetTickPositions.apply({
                    axis: u
                  });
                  n[p] = u.ordinal.positions;
                }

                return n[p];
              };

              a.prototype.getGroupIntervalFactor = function (a, b, c) {
                c = c.processedXData;
                var e = c.length,
                    d = [];
                var f = this.groupIntervalFactor;

                if (!f) {
                  for (f = 0; f < e - 1; f++) {
                    d[f] = c[f + 1] - c[f];
                  }

                  d.sort(function (a, b) {
                    return a - b;
                  });
                  d = d[Math.floor(e / 2)];
                  a = Math.max(a, c[0]);
                  b = Math.min(b, c[e - 1]);
                  this.groupIntervalFactor = f = e * d / (b - a);
                }

                return f;
              };

              a.prototype.getIndexOfPoint = function (b, c) {
                var e = this.axis,
                    d = this.positions ? this.positions[0] : 0,
                    f = e.series[0].points && e.series[0].points[0] && e.series[0].points[0].plotX || e.minPixelPadding;
                1 < e.series.length && e.series.forEach(function (a) {
                  A(a.points[0]) && A(a.points[0].plotX) && a.points[0].plotX < f && (f = a.points[0].plotX);
                });
                b = (b - f) / (e.translationSlope * (this.slope || e.closestPointRange || this.overscrollPointsRange));
                return a.findIndexOf(c, d) + b;
              };

              a.prototype.getOverscrollPositions = function () {
                var a = this.axis,
                    b = a.options.overscroll,
                    c = this.overscrollPointsRange,
                    d = [],
                    f = a.dataMax;
                if (A(c)) for (; f <= a.dataMax + b;) {
                  f += c, d.push(f);
                }
                return d;
              };

              a.prototype.postProcessTickInterval = function (a) {
                var b = this.axis,
                    c = this.slope;
                return c ? b.options.breaks ? b.closestPointRange || a : a / (c / b.closestPointRange) : a;
              };

              return a;
            }();

            c.Additions = b;
          })(g || (g = {}));

          return g;
        });
        M(d, "Core/Axis/BrokenAxis.js", [d["Extensions/Stacking.js"], d["Core/Utilities.js"]], function (c, d) {
          var E = d.addEvent,
              G = d.find,
              C = d.fireEvent,
              D = d.isArray,
              B = d.isNumber,
              A = d.pick,
              r;

          (function (d) {
            function h() {
              "undefined" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);
            }

            function a() {
              this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);
            }

            function g() {
              var a = this.brokenAxis;

              if (a && a.hasBreaks) {
                for (var c = this.tickPositions, d = this.tickPositions.info, g = [], f = 0; f < c.length; f++) {
                  a.isInAnyBreak(c[f]) || g.push(c[f]);
                }

                this.tickPositions = g;
                this.tickPositions.info = d;
              }
            }

            function k() {
              this.brokenAxis || (this.brokenAxis = new L(this));
            }

            function n() {
              var a = this.options.connectNulls,
                  c = this.points,
                  d = this.xAxis,
                  g = this.yAxis;
              if (this.isDirty) for (var f = c.length; f--;) {
                var b = c[f],
                    h = !(null === b.y && !1 === a) && (d && d.brokenAxis && d.brokenAxis.isInAnyBreak(b.x, !0) || g && g.brokenAxis && g.brokenAxis.isInAnyBreak(b.y, !0));
                b.visible = h ? !1 : !1 !== b.options.visible;
              }
            }

            function t() {
              this.drawBreaks(this.xAxis, ["x"]);
              this.drawBreaks(this.yAxis, A(this.pointArrayMap, ["y"]));
            }

            function r(a, c) {
              var d = this,
                  g = d.points,
                  f,
                  b,
                  h,
                  m;

              if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {
                var e = a.brokenAxis;
                c.forEach(function (c) {
                  f = e && e.breakArray || [];
                  b = a.isXAxis ? a.min : A(d.options.threshold, a.min);
                  g.forEach(function (e) {
                    m = A(e["stack" + c.toUpperCase()], e[c]);
                    f.forEach(function (c) {
                      if (B(b) && B(m)) {
                        h = !1;
                        if (b < c.from && m > c.to || b > c.from && m < c.from) h = "pointBreak";else if (b < c.from && m > c.from && m < c.to || b > c.from && m > c.to && m < c.from) h = "pointInBreak";
                        h && C(a, h, {
                          point: e,
                          brk: c
                        });
                      }
                    });
                  });
                });
              }
            }

            function m() {
              var a = this.currentDataGrouping,
                  d = a && a.gapSize;
              a = this.points.slice();
              var g = this.yAxis,
                  h = this.options.gapSize,
                  f = a.length - 1,
                  b;
              if (h && 0 < f) for ("value" !== this.options.gapUnit && (h *= this.basePointRange), d && d > h && d >= this.basePointRange && (h = d), b = void 0; f--;) {
                b && !1 !== b.visible || (b = a[f + 1]), d = a[f], !1 !== b.visible && !1 !== d.visible && (b.x - d.x > h && (b = (d.x + b.x) / 2, a.splice(f + 1, 0, {
                  isNull: !0,
                  x: b
                }), g.stacking && this.options.stacking && (b = g.stacking.stacks[this.stackKey][b] = new c(g, g.options.stackLabels, !1, b, this.stack), b.total = 0)), b = d);
              }
              return this.getGraphPath(a);
            }

            var K = [];

            d.compose = function (c, d) {
              -1 === K.indexOf(c) && (K.push(c), c.keepProps.push("brokenAxis"), E(c, "init", k), E(c, "afterInit", h), E(c, "afterSetTickPositions", g), E(c, "afterSetOptions", a));

              if (-1 === K.indexOf(d)) {
                K.push(d);
                var x = d.prototype;
                x.drawBreaks = r;
                x.gappedPath = m;
                E(d, "afterGeneratePoints", n);
                E(d, "afterRender", t);
              }

              return c;
            };

            var L = function () {
              function a(a) {
                this.hasBreaks = !1;
                this.axis = a;
              }

              a.isInBreak = function (a, c) {
                var d = a.repeat || Infinity,
                    f = a.from,
                    b = a.to - a.from;
                c = c >= f ? (c - f) % d : d - (f - c) % d;
                return a.inclusive ? c <= b : c < b && 0 !== c;
              };

              a.lin2Val = function (c) {
                var d = this.brokenAxis;
                d = d && d.breakArray;
                if (!d || !B(c)) return c;
                var g;

                for (g = 0; g < d.length; g++) {
                  var f = d[g];
                  if (f.from >= c) break;else f.to < c ? c += f.len : a.isInBreak(f, c) && (c += f.len);
                }

                return c;
              };

              a.val2Lin = function (c) {
                var d = this.brokenAxis;
                d = d && d.breakArray;
                if (!d || !B(c)) return c;
                var g = c,
                    f;

                for (f = 0; f < d.length; f++) {
                  var b = d[f];
                  if (b.to <= c) g -= b.len;else if (b.from >= c) break;else if (a.isInBreak(b, c)) {
                    g -= c - b.from;
                    break;
                  }
                }

                return g;
              };

              a.prototype.findBreakAt = function (a, c) {
                return G(c, function (c) {
                  return c.from < a && a < c.to;
                });
              };

              a.prototype.isInAnyBreak = function (c, d) {
                var g = this.axis,
                    f = g.options.breaks || [],
                    b = f.length,
                    h;

                if (b && B(c)) {
                  for (; b--;) {
                    if (a.isInBreak(f[b], c)) {
                      var m = !0;
                      h || (h = A(f[b].showPoints, !g.isXAxis));
                    }
                  }

                  var e = m && d ? m && !h : m;
                }

                return e;
              };

              a.prototype.setBreaks = function (c, d) {
                var g = this,
                    f = g.axis,
                    b = D(c) && !!c.length;
                f.isDirty = g.hasBreaks !== b;
                g.hasBreaks = b;
                f.options.breaks = f.userOptions.breaks = c;
                f.forceRedraw = !0;
                f.series.forEach(function (a) {
                  a.isDirty = !0;
                });
                b || f.val2lin !== a.val2Lin || (delete f.val2lin, delete f.lin2val);
                b && (f.userOptions.ordinal = !1, f.lin2val = a.lin2Val, f.val2lin = a.val2Lin, f.setExtremes = function (a, b, c, d, h) {
                  if (g.hasBreaks) {
                    for (var e = this.options.breaks || [], p; p = g.findBreakAt(a, e);) {
                      a = p.to;
                    }

                    for (; p = g.findBreakAt(b, e);) {
                      b = p.from;
                    }

                    b < a && (b = a);
                  }

                  f.constructor.prototype.setExtremes.call(this, a, b, c, d, h);
                }, f.setAxisTranslation = function () {
                  f.constructor.prototype.setAxisTranslation.call(this);
                  g.unitLength = void 0;

                  if (g.hasBreaks) {
                    var b = f.options.breaks || [],
                        c = [],
                        d = [],
                        h = A(f.pointRangePadding, 0),
                        l = 0,
                        m,
                        p = f.userMin || f.min,
                        k = f.userMax || f.max,
                        n;
                    b.forEach(function (b) {
                      m = b.repeat || Infinity;
                      B(p) && B(k) && (a.isInBreak(b, p) && (p += b.to % m - p % m), a.isInBreak(b, k) && (k -= k % m - b.from % m));
                    });
                    b.forEach(function (a) {
                      r = a.from;
                      m = a.repeat || Infinity;

                      if (B(p) && B(k)) {
                        for (; r - m > p;) {
                          r -= m;
                        }

                        for (; r < p;) {
                          r += m;
                        }

                        for (n = r; n < k; n += m) {
                          c.push({
                            value: n,
                            move: "in"
                          }), c.push({
                            value: n + a.to - a.from,
                            move: "out",
                            size: a.breakSize
                          });
                        }
                      }
                    });
                    c.sort(function (a, b) {
                      return a.value === b.value ? ("in" === a.move ? 0 : 1) - ("in" === b.move ? 0 : 1) : a.value - b.value;
                    });
                    var t = 0;
                    var r = p;
                    c.forEach(function (a) {
                      t += "in" === a.move ? 1 : -1;
                      1 === t && "in" === a.move && (r = a.value);
                      0 === t && B(r) && (d.push({
                        from: r,
                        to: a.value,
                        len: a.value - r - (a.size || 0)
                      }), l += a.value - r - (a.size || 0));
                    });
                    g.breakArray = d;
                    B(p) && B(k) && B(f.min) && (g.unitLength = k - p - l + h, C(f, "afterBreaks"), f.staticScale ? f.transA = f.staticScale : g.unitLength && (f.transA *= (k - f.min + h) / g.unitLength), h && (f.minPixelPadding = f.transA * (f.minPointOffset || 0)), f.min = p, f.max = k);
                  }
                });
                A(d, !0) && f.chart.redraw();
              };

              return a;
            }();

            d.Additions = L;
          })(r || (r = {}));

          return r;
        });
        M(d, "masters/modules/broken-axis.src.js", [d["Core/Globals.js"], d["Core/Axis/BrokenAxis.js"]], function (c, d) {
          d.compose(c.Axis, c.Series);
        });
        M(d, "Extensions/DataGrouping.js", [d["Core/Axis/Axis.js"], d["Core/Axis/DateTimeAxis.js"], d["Core/FormatUtilities.js"], d["Core/Globals.js"], d["Core/Series/Point.js"], d["Core/Series/Series.js"], d["Core/Tooltip.js"], d["Core/DefaultOptions.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A, r) {
          var k = E.format,
              h = D.prototype;
          E = r.addEvent;
          var a = r.arrayMax,
              g = r.arrayMin,
              y = r.correctFloat,
              n = r.defined,
              t = r.error,
              B = r.extend,
              m = r.isNumber,
              N = r.merge,
              L = r.pick;
          "";
          var x = G.approximations = {
            sum: function sum(a) {
              var b = a.length;
              if (!b && a.hasNulls) var c = null;else if (b) for (c = 0; b--;) {
                c += a[b];
              }
              return c;
            },
            average: function average(a) {
              var b = a.length;
              a = x.sum(a);
              m(a) && b && (a = y(a / b));
              return a;
            },
            averages: function averages() {
              var a = [];
              [].forEach.call(arguments, function (b) {
                a.push(x.average(b));
              });
              return "undefined" === typeof a[0] ? void 0 : a;
            },
            open: function open(a) {
              return a.length ? a[0] : a.hasNulls ? null : void 0;
            },
            high: function high(b) {
              return b.length ? a(b) : b.hasNulls ? null : void 0;
            },
            low: function low(a) {
              return a.length ? g(a) : a.hasNulls ? null : void 0;
            },
            close: function close(a) {
              return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;
            },
            ohlc: function ohlc(a, b, c, d) {
              a = x.open(a);
              b = x.high(b);
              c = x.low(c);
              d = x.close(d);
              if (m(a) || m(b) || m(c) || m(d)) return [a, b, c, d];
            },
            range: function range(a, b) {
              a = x.low(a);
              b = x.high(b);
              if (m(a) || m(b)) return [a, b];
              if (null === a && null === b) return null;
            }
          };

          r = function r(a, b, c, d) {
            var e = this,
                f = e.data,
                g = e.options && e.options.data,
                h = [],
                q = [],
                k = [],
                t = a.length,
                u = !!b,
                r = [],
                v = e.pointArrayMap,
                w = v && v.length,
                y = ["x"].concat(v || ["y"]),
                A = this.options.dataGrouping && this.options.dataGrouping.groupAll,
                D = 0,
                C = 0,
                F;
            d = "function" === typeof d ? d : x[d] ? x[d] : x[e.getDGApproximation && e.getDGApproximation() || "average"];
            w ? v.forEach(function () {
              r.push([]);
            }) : r.push([]);
            var E = w || 1;

            for (F = 0; F <= t && !(a[F] >= c[0]); F++) {
              ;
            }

            for (F; F <= t; F++) {
              for (; "undefined" !== typeof c[D + 1] && a[F] >= c[D + 1] || F === t;) {
                var B = c[D];
                e.dataGroupInfo = {
                  start: A ? C : e.cropStart + C,
                  length: r[0].length
                };
                var H = d.apply(e, r);
                e.pointClass && !n(e.dataGroupInfo.options) && (e.dataGroupInfo.options = N(e.pointClass.prototype.optionsToObject.call({
                  series: e
                }, e.options.data[e.cropStart + C])), y.forEach(function (a) {
                  delete e.dataGroupInfo.options[a];
                }));
                "undefined" !== typeof H && (h.push(B), q.push(H), k.push(e.dataGroupInfo));
                C = F;

                for (B = 0; B < E; B++) {
                  r[B].length = 0, r[B].hasNulls = !1;
                }

                D += 1;
                if (F === t) break;
              }

              if (F === t) break;

              if (v) {
                B = e.options.dataGrouping && e.options.dataGrouping.groupAll ? F : e.cropStart + F;
                H = f && f[B] || e.pointClass.prototype.applyOptions.apply({
                  series: e
                }, [g[B]]);
                var G = void 0;

                for (B = 0; B < w; B++) {
                  G = H[v[B]], m(G) ? r[B].push(G) : null === G && (r[B].hasNulls = !0);
                }
              } else B = u ? b[F] : null, m(B) ? r[0].push(B) : null === B && (r[0].hasNulls = !0);
            }

            return {
              groupedXData: h,
              groupedYData: q,
              groupMap: k
            };
          };

          var R = {
            approximations: x,
            groupData: r
          },
              H = h.generatePoints,
              w = {
            groupPixelWidth: 2,
            dateTimeLabelFormats: {
              millisecond: ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"],
              second: ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"],
              minute: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
              hour: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
              day: ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
              week: ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
              month: ["%B %Y", "%B", "-%B %Y"],
              year: ["%Y", "%Y", "-%Y"]
            }
          },
              f = {
            line: {},
            spline: {},
            area: {},
            areaspline: {},
            arearange: {},
            column: {
              groupPixelWidth: 10
            },
            columnrange: {
              groupPixelWidth: 10
            },
            candlestick: {
              groupPixelWidth: 10
            },
            ohlc: {
              groupPixelWidth: 5
            },
            heikinashi: {
              groupPixelWidth: 10
            }
          },
              b = G.defaultDataGroupingUnits = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]];

          h.getDGApproximation = function () {
            return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("column") ? "sum" : "average";
          };

          h.groupData = r;

          h.applyGrouping = function () {
            var a = this.chart,
                c = this.options.dataGrouping,
                e = !1 !== this.allowDG && c && L(c.enabled, a.options.isStock),
                f = this.visible || !a.options.chart.ignoreHiddenSeries,
                g,
                k = this.currentDataGrouping,
                p = !1;
            e && !this.requireSorting && (this.requireSorting = p = !0);
            var z = !this.isCartesian || this.isDirty || this.xAxis.isDirty || this.yAxis.isDirty ? void 0 : !1;
            p && (this.requireSorting = !1);

            if (!z && e) {
              this.destroyGroupedData();
              z = c.groupAll ? this.xData : this.processedXData;
              var r = c.groupAll ? this.yData : this.processedYData;
              p = a.plotSizeX;
              e = this.xAxis;
              var x = e.options.ordinal,
                  w = this.groupPixelWidth;

              if (w && z && z.length) {
                this.isDirty = g = !0;
                this.points = null;
                var u = e.getExtremes();
                var y = u.min;
                u = u.max;
                x = x && e.ordinal && e.ordinal.getGroupIntervalFactor(y, u, this) || 1;
                p = e.getTimeTicks(d.Additions.prototype.normalizeTimeTickInterval(w * (u - y) / p * x, c.units || b), Math.min(y, z[0]), Math.max(u, z[z.length - 1]), e.options.startOfWeek, z, this.closestPointRange);
                w = h.groupData.apply(this, [z, r, p, c.approximation]);
                z = w.groupedXData;
                r = w.groupedYData;
                x = 0;
                c && c.smoothed && z.length && (c.firstAnchor = "firstPoint", c.anchor = "middle", c.lastAnchor = "lastPoint", t(32, !1, a, {
                  "dataGrouping.smoothed": "use dataGrouping.anchor"
                }));
                a = z;
                var A = this.options.dataGrouping;
                y = this.currentDataGrouping && this.currentDataGrouping.gapSize;

                if (A && this.xData && y && this.groupMap) {
                  var D = a.length - 1;
                  var C = A.anchor;
                  var B = L(A.firstAnchor, C);
                  A = L(A.lastAnchor, C);

                  if (C && "start" !== C) {
                    var E = y * {
                      middle: .5,
                      end: 1
                    }[C];

                    for (C = a.length - 1; C-- && 0 < C;) {
                      a[C] += E;
                    }
                  }

                  if (B && "start" !== B && this.xData[0] >= a[0]) {
                    C = this.groupMap[0].start;
                    E = this.groupMap[0].length;
                    var H = void 0;
                    m(C) && m(E) && (H = C + (E - 1));
                    a[0] = {
                      middle: a[0] + .5 * y,
                      end: a[0] + y,
                      firstPoint: this.xData[0],
                      lastPoint: H && this.xData[H]
                    }[B];
                  }

                  A && "start" !== A && y && a[D] >= u - y && (u = this.groupMap[this.groupMap.length - 1].start, a[D] = {
                    middle: a[D] + .5 * y,
                    end: a[D] + y,
                    firstPoint: u && this.xData[u],
                    lastPoint: this.xData[this.xData.length - 1]
                  }[A]);
                }

                for (u = 1; u < p.length; u++) {
                  p.info.segmentStarts && -1 !== p.info.segmentStarts.indexOf(u) || (x = Math.max(p[u] - p[u - 1], x));
                }

                u = p.info;
                u.gapSize = x;
                this.closestPointRange = p.info.totalRange;
                this.groupMap = w.groupMap;

                if (f) {
                  f = z;

                  if (n(f[0]) && m(e.min) && m(e.dataMin) && f[0] < e.min) {
                    if (!n(e.options.min) && e.min <= e.dataMin || e.min === e.dataMin) e.min = Math.min(f[0], e.min);
                    e.dataMin = Math.min(f[0], e.dataMin);
                  }

                  if (n(f[f.length - 1]) && m(e.max) && m(e.dataMax) && f[f.length - 1] > e.max) {
                    if (!n(e.options.max) && m(e.dataMax) && e.max >= e.dataMax || e.max === e.dataMax) e.max = Math.max(f[f.length - 1], e.max);
                    e.dataMax = Math.max(f[f.length - 1], e.dataMax);
                  }
                }

                c.groupAll && (this.allGroupedData = r, c = this.cropData(z, r, e.min, e.max, 1), z = c.xData, r = c.yData, this.cropStart = c.start);
                this.processedXData = z;
                this.processedYData = r;
              } else this.groupMap = null;

              this.hasGroupedData = g;
              this.currentDataGrouping = u;
              this.preventGraphAnimation = (k && k.totalRange) !== (u && u.totalRange);
            }
          };

          h.destroyGroupedData = function () {
            this.groupedData && (this.groupedData.forEach(function (a, b) {
              a && (this.groupedData[b] = a.destroy ? a.destroy() : null);
            }, this), this.groupedData.length = 0);
          };

          h.generatePoints = function () {
            H.apply(this);
            this.destroyGroupedData();
            this.groupedData = this.hasGroupedData ? this.points : null;
          };

          c.prototype.applyGrouping = function () {
            var a = this;
            a.series.forEach(function (b) {
              b.groupPixelWidth = void 0;
              b.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth();
              b.groupPixelWidth && (b.hasProcessed = !0);
              b.applyGrouping();
            });
          };

          c.prototype.getGroupPixelWidth = function () {
            var a = this.series,
                b = a.length,
                c,
                d = 0,
                f = !1,
                g;

            for (c = b; c--;) {
              (g = a[c].options.dataGrouping) && (d = Math.max(d, L(g.groupPixelWidth, w.groupPixelWidth)));
            }

            for (c = b; c--;) {
              if (g = a[c].options.dataGrouping) if (b = (a[c].processedXData || a[c].data).length, a[c].groupPixelWidth || b > this.chart.plotSizeX / d || b && g.forced) f = !0;
            }

            return f ? d : 0;
          };

          c.prototype.setDataGrouping = function (a, b) {
            var d;
            b = L(b, !0);
            a || (a = {
              forced: !1,
              units: null
            });
            if (this instanceof c) for (d = this.series.length; d--;) {
              this.series[d].update({
                dataGrouping: a
              }, !1);
            } else this.chart.options.series.forEach(function (b) {
              b.dataGrouping = a;
            }, !1);
            this.ordinal && (this.ordinal.slope = void 0);
            b && this.chart.redraw();
          };

          E(c, "postProcessData", c.prototype.applyGrouping);
          E(C, "update", function () {
            if (this.dataGroup) return t(24, !1, this.series.chart), !1;
          });
          E(K, "headerFormatter", function (a) {
            var b = this.chart,
                c = b.time,
                d = a.labelConfig,
                f = d.series,
                g = f.tooltipOptions,
                p = f.options.dataGrouping,
                h = g.xDateFormat,
                n = f.xAxis,
                t = g[a.isFooter ? "footerFormat" : "headerFormat"];

            if (n && "datetime" === n.options.type && p && m(d.key)) {
              var r = f.currentDataGrouping;
              p = p.dateTimeLabelFormats || w.dateTimeLabelFormats;
              if (r) {
                if (g = p[r.unitName], 1 === r.count) h = g[0];else {
                  h = g[1];
                  var u = g[2];
                }
              } else !h && p && n.dateTime && (h = n.dateTime.getXDateFormat(d.x, g.dateTimeLabelFormats));
              h = c.dateFormat(h, d.key);
              u && (h += c.dateFormat(u, d.key + r.totalRange - 1));
              f.chart.styledMode && (t = this.styledModeFormat(t));
              a.text = k(t, {
                point: B(d.point, {
                  key: h
                }),
                series: f
              }, b);
              a.preventDefault();
            }
          });
          E(D, "destroy", h.destroyGroupedData);
          E(D, "afterSetOptions", function (a) {
            a = a.options;
            var b = this.type,
                c = this.chart.options.plotOptions,
                d = A.defaultOptions.plotOptions[b].dataGrouping,
                g = this.useCommonDataGrouping && w;

            if (f[b] || g) {
              d || (d = N(w, f[b]));
              var h = this.chart.rangeSelector;
              a.dataGrouping = N(g, d, c.series && c.series.dataGrouping, c[b].dataGrouping, this.userOptions.dataGrouping, !a.isInternal && h && m(h.selected) && h.buttonOptions[h.selected].dataGrouping);
            }
          });
          E(c, "afterSetScale", function () {
            this.series.forEach(function (a) {
              a.hasProcessed = !1;
            });
          });
          G.dataGrouping = R;
          "";
          return R;
        });
        M(d, "Series/OHLC/OHLCPoint.js", [d["Core/Series/SeriesRegistry.js"]], function (c) {
          var d = this && this.__extends || function () {
            var _c9 = function c(d, C) {
              _c9 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, d) {
                c.__proto__ = d;
              } || function (c, d) {
                for (var A in d) {
                  d.hasOwnProperty(A) && (c[A] = d[A]);
                }
              };

              return _c9(d, C);
            };

            return function (d, C) {
              function D() {
                this.constructor = d;
              }

              _c9(d, C);

              d.prototype = null === C ? Object.create(C) : (D.prototype = C.prototype, new D());
            };
          }();

          return function (c) {
            function B() {
              var d = null !== c && c.apply(this, arguments) || this;
              d.close = void 0;
              d.high = void 0;
              d.low = void 0;
              d.open = void 0;
              d.options = void 0;
              d.plotClose = void 0;
              d.plotOpen = void 0;
              d.series = void 0;
              return d;
            }

            d(B, c);

            B.prototype.getClassName = function () {
              return c.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
            };

            B.prototype.resolveUpColor = function () {
              this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
            };

            B.prototype.resolveColor = function () {
              c.prototype.resolveColor.call(this);
              this.resolveUpColor();
            };

            B.prototype.getZone = function () {
              var d = c.prototype.getZone.call(this);
              this.resolveUpColor();
              return d;
            };

            B.prototype.applyOptions = function () {
              c.prototype.applyOptions.apply(this, arguments);
              this.resolveColor && this.resolveColor();
              return this;
            };

            return B;
          }(c.seriesTypes.column.prototype.pointClass);
        });
        M(d, "Series/OHLC/OHLCSeries.js", [d["Series/OHLC/OHLCPoint.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = this && this.__extends || function () {
            var _c10 = function c(d, k) {
              _c10 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, a) {
                c.__proto__ = a;
              } || function (c, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (c[d] = a[d]);
                }
              };

              return _c10(d, k);
            };

            return function (d, k) {
              function h() {
                this.constructor = d;
              }

              _c10(d, k);

              d.prototype = null === k ? Object.create(k) : (h.prototype = k.prototype, new h());
            };
          }(),
              C = d.seriesTypes.column,
              D = E.extend,
              K = E.merge;

          E = function (c) {
            function d() {
              var d = null !== c && c.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              d.yData = void 0;
              return d;
            }

            B(d, c);

            d.prototype.drawPoints = function () {
              var c = this,
                  d = c.chart,
                  a = function a(_a5, c, d) {
                var g = _a5[0];
                _a5 = _a5[1];
                "number" === typeof g[2] && (g[2] = Math.max(d + c, g[2]));
                "number" === typeof _a5[2] && (_a5[2] = Math.min(d - c, _a5[2]));
              };

              c.points.forEach(function (g) {
                var h = g.graphic,
                    k = !h;

                if ("undefined" !== typeof g.plotY) {
                  h || (g.graphic = h = d.renderer.path().add(c.group));
                  d.styledMode || h.attr(c.pointAttribs(g, g.selected && "select"));
                  var t = h.strokeWidth();
                  var r = t % 2 / 2;
                  var m = Math.round(g.plotX) - r;
                  var A = Math.round(g.shapeArgs.width / 2);
                  var D = [["M", m, Math.round(g.yBottom)], ["L", m, Math.round(g.plotHigh)]];

                  if (null !== g.open) {
                    var x = Math.round(g.plotOpen) + r;
                    D.push(["M", m, x], ["L", m - A, x]);
                    a(D, t / 2, x);
                  }

                  null !== g.close && (x = Math.round(g.plotClose) + r, D.push(["M", m, x], ["L", m + A, x]), a(D, t / 2, x));
                  h[k ? "attr" : "animate"]({
                    d: D
                  }).addClass(g.getClassName(), !0);
                }
              });
            };

            d.prototype.init = function () {
              c.prototype.init.apply(this, arguments);
              this.options.stacking = void 0;
            };

            d.prototype.pointAttribs = function (d, h) {
              h = c.prototype.pointAttribs.call(this, d, h);
              var a = this.options;
              delete h.fill;
              !d.options.color && a.upColor && d.open < d.close && (h.stroke = a.upColor);
              return h;
            };

            d.prototype.toYData = function (c) {
              return [c.open, c.high, c.low, c.close];
            };

            d.prototype.translate = function () {
              var d = this,
                  h = d.yAxis,
                  a = !!d.modifyValue,
                  g = ["plotOpen", "plotHigh", "plotLow", "plotClose", "yBottom"];
              c.prototype.translate.apply(d);
              d.points.forEach(function (c) {
                [c.open, c.high, c.low, c.close, c.low].forEach(function (k, t) {
                  null !== k && (a && (k = d.modifyValue(k)), c[g[t]] = h.toPixels(k, !0));
                });
                c.tooltipPos[1] = c.plotHigh + h.pos - d.chart.plotTop;
              });
            };

            d.defaultOptions = K(C.defaultOptions, {
              lineWidth: 1,
              tooltip: {
                pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>"
              },
              threshold: null,
              states: {
                hover: {
                  lineWidth: 3
                }
              },
              stickyTracking: !0
            });
            return d;
          }(C);

          D(E.prototype, {
            animate: null,
            directTouch: !1,
            pointArrayMap: ["open", "high", "low", "close"],
            pointAttrToOptions: {
              stroke: "color",
              "stroke-width": "lineWidth"
            },
            pointValKey: "close"
          });
          E.prototype.pointClass = c;
          d.registerSeriesType("ohlc", E);
          "";
          return E;
        });
        M(d, "Series/Candlestick/CandlestickSeries.js", [d["Core/DefaultOptions.js"], d["Core/Color/Palette.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G) {
          var C = this && this.__extends || function () {
            var _c11 = function c(d, a) {
              _c11 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _c11(d, a);
            };

            return function (d, a) {
              function g() {
                this.constructor = d;
              }

              _c11(d, a);

              d.prototype = null === a ? Object.create(a) : (g.prototype = a.prototype, new g());
            };
          }(),
              D = c.defaultOptions;

          c = E.seriesTypes;
          var B = c.column,
              A = c.ohlc,
              r = G.merge;

          G = function (c) {
            function h() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            C(h, c);

            h.prototype.pointAttribs = function (a, c) {
              var d = B.prototype.pointAttribs.call(this, a, c),
                  g = this.options,
                  h = a.open < a.close,
                  k = g.lineColor || this.color,
                  m = a.color || this.color;
              d["stroke-width"] = g.lineWidth;
              d.fill = a.options.color || (h ? g.upColor || m : m);
              d.stroke = a.options.lineColor || (h ? g.upLineColor || k : k);
              c && (a = g.states[c], d.fill = a.color || d.fill, d.stroke = a.lineColor || d.stroke, d["stroke-width"] = a.lineWidth || d["stroke-width"]);
              return d;
            };

            h.prototype.drawPoints = function () {
              var a = this,
                  c = a.chart,
                  d = a.yAxis.reversed;
              a.points.forEach(function (g) {
                var h = g.graphic,
                    k = !h;

                if ("undefined" !== typeof g.plotY) {
                  h || (g.graphic = h = c.renderer.path().add(a.group));
                  a.chart.styledMode || h.attr(a.pointAttribs(g, g.selected && "select")).shadow(a.options.shadow);
                  var m = h.strokeWidth() % 2 / 2;
                  var n = Math.round(g.plotX) - m;
                  var r = g.plotOpen;
                  var x = g.plotClose;
                  var y = Math.min(r, x);
                  r = Math.max(r, x);
                  var A = Math.round(g.shapeArgs.width / 2);
                  x = d ? r !== g.yBottom : Math.round(y) !== Math.round(g.plotHigh);
                  var w = d ? Math.round(y) !== Math.round(g.plotHigh) : r !== g.yBottom;
                  y = Math.round(y) + m;
                  r = Math.round(r) + m;
                  m = [];
                  m.push(["M", n - A, r], ["L", n - A, y], ["L", n + A, y], ["L", n + A, r], ["Z"], ["M", n, y], ["L", n, x ? Math.round(d ? g.yBottom : g.plotHigh) : y], ["M", n, r], ["L", n, w ? Math.round(d ? g.plotHigh : g.yBottom) : r]);
                  h[k ? "attr" : "animate"]({
                    d: m
                  }).addClass(g.getClassName(), !0);
                }
              });
            };

            h.defaultOptions = r(A.defaultOptions, D.plotOptions, {
              states: {
                hover: {
                  lineWidth: 2
                }
              },
              tooltip: D.plotOptions.ohlc.tooltip,
              threshold: null,
              lineColor: d.neutralColor100,
              lineWidth: 1,
              upColor: d.backgroundColor,
              stickyTracking: !0
            });
            return h;
          }(A);

          E.registerSeriesType("candlestick", G);
          "";
          return G;
        });
        M(d, "Series/Flags/FlagsPoint.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d) {
          var B = this && this.__extends || function () {
            var _c12 = function c(d, B) {
              _c12 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, d) {
                c.__proto__ = d;
              } || function (c, d) {
                for (var k in d) {
                  d.hasOwnProperty(k) && (c[k] = d[k]);
                }
              };

              return _c12(d, B);
            };

            return function (d, B) {
              function A() {
                this.constructor = d;
              }

              _c12(d, B);

              d.prototype = null === B ? Object.create(B) : (A.prototype = B.prototype, new A());
            };
          }(),
              G = d.isNumber;

          return function (c) {
            function d() {
              var d = null !== c && c.apply(this, arguments) || this;
              d.options = void 0;
              d.series = void 0;
              return d;
            }

            B(d, c);

            d.prototype.isValid = function () {
              return G(this.y) || "undefined" === typeof this.y;
            };

            d.prototype.hasNewShapeType = function () {
              var c = this.options.shape || this.series.options.shape;
              return this.graphic && c && c !== this.graphic.symbolKey;
            };

            return d;
          }(c.seriesTypes.column.prototype.pointClass);
        });
        M(d, "Mixins/OnSeries.js", [d["Series/Column/ColumnSeries.js"], d["Core/Series/Series.js"], d["Core/Utilities.js"]], function (c, d, E) {
          var B = c.prototype,
              C = d.prototype,
              D = E.defined,
              K = E.stableSort;
          return {
            getPlotBox: function getPlotBox() {
              return C.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);
            },
            translate: function translate() {
              B.translate.apply(this);
              var c = this,
                  d = c.options,
                  k = c.chart,
                  h = c.points,
                  a = h.length - 1,
                  g,
                  y = d.onSeries;
              y = y && k.get(y);
              d = d.onKey || "y";
              var n = y && y.options.step,
                  t = y && y.points,
                  C = t && t.length,
                  m = k.inverted,
                  E = c.xAxis,
                  G = c.yAxis,
                  x = 0,
                  M;

              if (y && y.visible && C) {
                x = (y.pointXOffset || 0) + (y.barW || 0) / 2;
                k = y.currentDataGrouping;
                var H = t[C - 1].x + (k ? k.totalRange : 0);
                K(h, function (a, c) {
                  return a.x - c.x;
                });

                for (d = "plot" + d[0].toUpperCase() + d.substr(1); C-- && h[a];) {
                  var w = t[C];
                  k = h[a];
                  k.y = w.y;

                  if (w.x <= k.x && "undefined" !== typeof w[d]) {
                    if (k.x <= H && (k.plotY = w[d], w.x < k.x && !n && (M = t[C + 1]) && "undefined" !== typeof M[d])) {
                      var f = (k.x - w.x) / (M.x - w.x);
                      k.plotY += f * (M[d] - w[d]);
                      k.y += f * (M.y - w.y);
                    }

                    a--;
                    C++;
                    if (0 > a) break;
                  }
                }
              }

              h.forEach(function (a, d) {
                a.plotX += x;
                if ("undefined" === typeof a.plotY || m) 0 <= a.plotX && a.plotX <= E.len ? m ? (a.plotY = E.translate(a.x, 0, 1, 0, 1), a.plotX = D(a.y) ? G.translate(a.y, 0, 0, 0, 1) : 0) : a.plotY = (E.opposite ? 0 : c.yAxis.len) + E.offset : a.shapeArgs = {};

                if ((g = h[d - 1]) && g.plotX === a.plotX) {
                  "undefined" === typeof g.stackIndex && (g.stackIndex = 0);
                  var b = g.stackIndex + 1;
                }

                a.stackIndex = b;
              });
              this.onSeries = y;
            }
          };
        });
        M(d, "Series/Flags/FlagsSymbols.js", [d["Core/Renderer/RendererRegistry.js"], d["Core/Renderer/SVG/SVGRenderer.js"]], function (c, d) {
          function B(c) {
            G[c + "pin"] = function (d, B, A, r, k) {
              var h = k && k.anchorX;
              k = k && k.anchorY;
              "circle" === c && r > A && (d -= Math.round((r - A) / 2), A = r);
              var a = G[c](d, B, A, r);

              if (h && k) {
                var g = h;
                "circle" === c ? g = d + A / 2 : (d = a[0], A = a[1], "M" === d[0] && "L" === A[0] && (g = (d[1] + A[1]) / 2));
                a.push(["M", g, B > k ? B : B + r], ["L", h, k]);
                a = a.concat(G.circle(h - 1, k - 1, 2, 2));
              }

              return a;
            };
          }

          var G = d.prototype.symbols;

          G.flag = function (c, d, B, A, r) {
            var k = r && r.anchorX || c;
            r = r && r.anchorY || d;
            var h = G.circle(k - 1, r - 1, 2, 2);
            h.push(["M", k, r], ["L", c, d + A], ["L", c, d], ["L", c + B, d], ["L", c + B, d + A], ["L", c, d + A], ["Z"]);
            return h;
          };

          B("circle");
          B("square");
          c = c.getRendererType();
          c !== d && (c.prototype.symbols.circlepin = G.circlepin, c.prototype.symbols.flag = G.flag, c.prototype.symbols.squarepin = G.squarepin);
          return G;
        });
        M(d, "Series/Flags/FlagsSeries.js", [d["Series/Flags/FlagsPoint.js"], d["Core/Globals.js"], d["Mixins/OnSeries.js"], d["Core/Color/Palette.js"], d["Core/Renderer/RendererUtilities.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Renderer/SVG/SVGElement.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A) {
          var r = this && this.__extends || function () {
            var _a6 = function a(c, d) {
              _a6 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var d in c) {
                  c.hasOwnProperty(d) && (a[d] = c[d]);
                }
              };

              return _a6(c, d);
            };

            return function (c, d) {
              function g() {
                this.constructor = c;
              }

              _a6(c, d);

              c.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }();

          d = d.noop;
          var k = C.distribute,
              h = D.series,
              a = D.seriesTypes.column,
              g = A.addEvent,
              y = A.defined;
          C = A.extend;
          var n = A.merge,
              t = A.objectEach,
              B = A.wrap;

          A = function (c) {
            function d() {
              var a = null !== c && c.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(d, c);

            d.prototype.animate = function (a) {
              a && this.setClip();
            };

            d.prototype.drawPoints = function () {
              var a = this.points,
                  c = this.chart,
                  d = c.renderer,
                  g = c.inverted,
                  h = this.options,
                  f = h.y,
                  b,
                  m = this.yAxis,
                  r = {},
                  e = [];

              for (b = a.length; b--;) {
                var q = a[b];
                var l = (g ? q.plotY : q.plotX) > this.xAxis.len;
                var I = q.plotX;
                var p = q.stackIndex;
                var z = q.options.shape || h.shape;
                var P = q.plotY;
                "undefined" !== typeof P && (P = q.plotY + f - ("undefined" !== typeof p && p * h.stackDistance));
                q.anchorX = p ? void 0 : q.plotX;
                var A = p ? void 0 : q.plotY;
                var J = "flag" !== z;
                p = q.graphic;
                "undefined" !== typeof P && 0 <= I && !l ? (p && q.hasNewShapeType() && (p = p.destroy()), p || (p = q.graphic = d.label("", null, null, z, null, null, h.useHTML).addClass("highcharts-point").add(this.markerGroup), q.graphic.div && (q.graphic.div.point = q), p.isNew = !0), p.attr({
                  align: J ? "center" : "left",
                  width: h.width,
                  height: h.height,
                  "text-align": h.textAlign
                }), c.styledMode || p.attr(this.pointAttribs(q)).css(n(h.style, q.style)).shadow(h.shadow), 0 < I && (I -= p.strokeWidth() % 2), z = {
                  y: P,
                  anchorY: A
                }, h.allowOverlapX && (z.x = I, z.anchorX = q.anchorX), p.attr({
                  text: q.options.title || h.title || "A"
                })[p.isNew ? "attr" : "animate"](z), h.allowOverlapX || (r[q.plotX] ? r[q.plotX].size = Math.max(r[q.plotX].size, p.width) : r[q.plotX] = {
                  align: J ? .5 : 0,
                  size: p.width,
                  target: I,
                  anchorX: I
                }), q.tooltipPos = [I, P + m.pos - c.plotTop]) : p && (q.graphic = p.destroy());
              }

              h.allowOverlapX || (t(r, function (a) {
                a.plotX = a.anchorX;
                e.push(a);
              }), k(e, g ? m.len : this.xAxis.len, 100), a.forEach(function (a) {
                var b = a.graphic && r[a.plotX];
                b && (a.graphic[a.graphic.isNew ? "attr" : "animate"]({
                  x: b.pos + b.align * b.size,
                  anchorX: a.anchorX
                }), y(b.pos) ? a.graphic.isNew = !1 : (a.graphic.attr({
                  x: -9999,
                  anchorX: -9999
                }), a.graphic.isNew = !0));
              }));
              h.useHTML && B(this.markerGroup, "on", function (a) {
                return K.prototype.on.apply(a.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
              });
            };

            d.prototype.drawTracker = function () {
              var a = this.points;
              c.prototype.drawTracker.call(this);
              a.forEach(function (c) {
                var d = c.graphic;
                d && (c.unbindMouseOver && c.unbindMouseOver(), c.unbindMouseOver = g(d.element, "mouseover", function () {
                  0 < c.stackIndex && !c.raised && (c._y = d.y, d.attr({
                    y: c._y - 8
                  }), c.raised = !0);
                  a.forEach(function (a) {
                    a !== c && a.raised && a.graphic && (a.graphic.attr({
                      y: a._y
                    }), a.raised = !1);
                  });
                }));
              });
            };

            d.prototype.pointAttribs = function (a, c) {
              var d = this.options,
                  g = a && a.color || this.color,
                  h = d.lineColor,
                  f = a && a.lineWidth;
              a = a && a.fillColor || d.fillColor;
              c && (a = d.states[c].fillColor, h = d.states[c].lineColor, f = d.states[c].lineWidth);
              return {
                fill: a || g,
                stroke: h || g,
                "stroke-width": f || d.lineWidth || 0
              };
            };

            d.prototype.setClip = function () {
              h.prototype.setClip.apply(this, arguments);
              !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
            };

            d.defaultOptions = n(a.defaultOptions, {
              pointRange: 0,
              allowOverlapX: !1,
              shape: "flag",
              stackDistance: 12,
              textAlign: "center",
              tooltip: {
                pointFormat: "{point.text}"
              },
              threshold: null,
              y: -30,
              fillColor: G.backgroundColor,
              lineWidth: 1,
              states: {
                hover: {
                  lineColor: G.neutralColor100,
                  fillColor: G.highlightColor20
                }
              },
              style: {
                fontSize: "11px",
                fontWeight: "bold"
              }
            });
            return d;
          }(a);

          C(A.prototype, {
            allowDG: !1,
            buildKDTree: d,
            forceCrop: !0,
            getPlotBox: E.getPlotBox,
            init: h.prototype.init,
            invertGroups: d,
            invertible: !1,
            noSharedTooltip: !0,
            pointClass: c,
            sorted: !1,
            takeOrdinalPosition: !1,
            trackerGroups: ["markerGroup"],
            translate: E.translate
          });
          D.registerSeriesType("flags", A);
          "";
          "";
          return A;
        });
        M(d, "Core/Axis/ScrollbarAxis.js", [d["Core/Utilities.js"]], function (c) {
          var d = c.addEvent,
              E = c.defined,
              G = c.pick;
          return function () {
            function c() {}

            c.compose = function (B, C) {
              if (-1 === c.composed.indexOf(B)) c.composed.push(B);else return B;

              var A = function A(c) {
                var d = G(c.options && c.options.min, c.min),
                    h = G(c.options && c.options.max, c.max);
                return {
                  axisMin: d,
                  axisMax: h,
                  scrollMin: E(c.dataMin) ? Math.min(d, c.min, c.dataMin, G(c.threshold, Infinity)) : d,
                  scrollMax: E(c.dataMax) ? Math.max(h, c.max, c.dataMax, G(c.threshold, -Infinity)) : h
                };
              };

              d(B, "afterInit", function () {
                var c = this;
                c.options && c.options.scrollbar && c.options.scrollbar.enabled && (c.options.scrollbar.vertical = !c.horiz, c.options.startOnTick = c.options.endOnTick = !1, c.scrollbar = new C(c.chart.renderer, c.options.scrollbar, c.chart), d(c.scrollbar, "changed", function (d) {
                  var h = A(c),
                      a = h.axisMax,
                      g = h.scrollMin,
                      k = h.scrollMax - g;
                  E(h.axisMin) && E(a) && (c.horiz && !c.reversed || !c.horiz && c.reversed ? (h = g + k * this.to, g += k * this.from) : (h = g + k * (1 - this.from), g += k * (1 - this.to)), this.shouldUpdateExtremes(d.DOMType) ? c.setExtremes(g, h, !0, "mousemove" !== d.DOMType && "touchmove" !== d.DOMType, d) : this.setRange(this.from, this.to));
                }));
              });
              d(B, "afterRender", function () {
                var c = A(this),
                    d = c.scrollMin,
                    h = c.scrollMax;
                c = this.scrollbar;
                var a = this.axisTitleMargin + (this.titleOffset || 0),
                    g = this.chart.scrollbarsOffsets,
                    y = this.options.margin || 0;
                c && (this.horiz ? (this.opposite || (g[1] += a), c.position(this.left, this.top + this.height + 2 + g[1] - (this.opposite ? y : 0), this.width, this.height), this.opposite || (g[1] += y), a = 1) : (this.opposite && (g[0] += a), c.position(this.left + this.width + 2 + g[0] - (this.opposite ? 0 : y), this.top, this.width, this.height), this.opposite && (g[0] += y), a = 0), g[a] += c.size + c.options.margin, isNaN(d) || isNaN(h) || !E(this.min) || !E(this.max) || this.min === this.max ? c.setRange(0, 1) : (g = (this.min - d) / (h - d), d = (this.max - d) / (h - d), this.horiz && !this.reversed || !this.horiz && this.reversed ? c.setRange(g, d) : c.setRange(1 - d, 1 - g)));
              });
              d(B, "afterGetOffset", function () {
                var c = this.horiz ? 2 : 1,
                    d = this.scrollbar;
                d && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[c] += d.size + d.options.margin);
              });
              return B;
            };

            c.composed = [];
            return c;
          }();
        });
        M(d, "Core/ScrollbarDefaults.js", [d["Core/Globals.js"], d["Core/Color/Palette.js"]], function (c, d) {
          return {
            height: c.isTouchDevice ? 20 : 14,
            barBorderRadius: 0,
            buttonBorderRadius: 0,
            liveRedraw: void 0,
            margin: 10,
            minWidth: 6,
            step: .2,
            zIndex: 3,
            barBackgroundColor: d.neutralColor20,
            barBorderWidth: 1,
            barBorderColor: d.neutralColor20,
            buttonArrowColor: d.neutralColor80,
            buttonBackgroundColor: d.neutralColor10,
            buttonBorderColor: d.neutralColor20,
            buttonBorderWidth: 1,
            rifleColor: d.neutralColor80,
            trackBackgroundColor: d.neutralColor5,
            trackBorderColor: d.neutralColor5,
            trackBorderWidth: 1
          };
        });
        M(d, "Core/Scrollbar.js", [d["Core/DefaultOptions.js"], d["Core/Globals.js"], d["Core/Axis/ScrollbarAxis.js"], d["Core/ScrollbarDefaults.js"], d["Core/Utilities.js"]], function (c, d, E, G, C) {
          var B = c.defaultOptions,
              K = C.addEvent,
              A = C.correctFloat,
              r = C.defined,
              k = C.destroyObjectProperties,
              h = C.fireEvent,
              a = C.merge,
              g = C.pick,
              y = C.removeEvent;

          c = function () {
            function c(a, c, d) {
              this._events = [];
              this.chart = void 0;
              this.from = this.chartY = this.chartX = 0;
              this.scrollbar = this.renderer = this.options = this.group = void 0;
              this.scrollbarButtons = [];
              this.scrollbarGroup = void 0;
              this.scrollbarLeft = 0;
              this.scrollbarRifles = void 0;
              this.scrollbarStrokeWidth = 1;
              this.to = this.size = this.scrollbarTop = 0;
              this.track = void 0;
              this.trackBorderWidth = 1;
              this.userOptions = void 0;
              this.y = this.x = 0;
              this.init(a, c, d);
            }

            c.compose = function (a) {
              E.compose(a, c);
            };

            c.swapXY = function (a, c) {
              c && a.forEach(function (a) {
                for (var c = a.length, d, g = 0; g < c; g += 2) {
                  d = a[g + 1], "number" === typeof d && (a[g + 1] = a[g + 2], a[g + 2] = d);
                }
              });
              return a;
            };

            c.prototype.addEvents = function () {
              var a = this.options.inverted ? [1, 0] : [0, 1],
                  c = this.scrollbarButtons,
                  g = this.scrollbarGroup.element,
                  h = this.track.element,
                  k = this.mouseDownHandler.bind(this),
                  n = this.mouseMoveHandler.bind(this),
                  r = this.mouseUpHandler.bind(this);
              a = [[c[a[0]].element, "click", this.buttonToMinClick.bind(this)], [c[a[1]].element, "click", this.buttonToMaxClick.bind(this)], [h, "click", this.trackClick.bind(this)], [g, "mousedown", k], [g.ownerDocument, "mousemove", n], [g.ownerDocument, "mouseup", r]];
              d.hasTouch && a.push([g, "touchstart", k], [g.ownerDocument, "touchmove", n], [g.ownerDocument, "touchend", r]);
              a.forEach(function (a) {
                K.apply(null, a);
              });
              this._events = a;
            };

            c.prototype.buttonToMaxClick = function (a) {
              var c = (this.to - this.from) * g(this.options.step, .2);
              this.updatePosition(this.from + c, this.to + c);
              h(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: a
              });
            };

            c.prototype.buttonToMinClick = function (a) {
              var c = A(this.to - this.from) * g(this.options.step, .2);
              this.updatePosition(A(this.from - c), A(this.to - c));
              h(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: a
              });
            };

            c.prototype.cursorToScrollbarPosition = function (a) {
              var c = this.options;
              c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;
              return {
                chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - c),
                chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - c)
              };
            };

            c.prototype.destroy = function () {
              var a = this,
                  c = a.chart.scroller;
              a.removeEvents();
              ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (c) {
                a[c] && a[c].destroy && (a[c] = a[c].destroy());
              });
              c && a === c.scrollbar && (c.scrollbar = null, k(c.scrollbarButtons));
            };

            c.prototype.drawScrollbarButton = function (a) {
              var d = this.renderer,
                  g = this.scrollbarButtons,
                  h = this.options,
                  k = this.size,
                  n = d.g().add(this.group);
              g.push(n);
              n = d.rect().addClass("highcharts-scrollbar-button").add(n);
              this.chart.styledMode || n.attr({
                stroke: h.buttonBorderColor,
                "stroke-width": h.buttonBorderWidth,
                fill: h.buttonBackgroundColor
              });
              n.attr(n.crisp({
                x: -.5,
                y: -.5,
                width: k + 1,
                height: k + 1,
                r: h.buttonBorderRadius
              }, n.strokeWidth()));
              n = d.path(c.swapXY([["M", k / 2 + (a ? -1 : 1), k / 2 - 3], ["L", k / 2 + (a ? -1 : 1), k / 2 + 3], ["L", k / 2 + (a ? 2 : -2), k / 2]], h.vertical)).addClass("highcharts-scrollbar-arrow").add(g[a]);
              this.chart.styledMode || n.attr({
                fill: h.buttonArrowColor
              });
            };

            c.prototype.init = function (c, d, h) {
              this.scrollbarButtons = [];
              this.renderer = c;
              this.userOptions = d;
              this.options = a(G, B.scrollbar, d);
              this.chart = h;
              this.size = g(this.options.size, this.options.height);
              d.enabled && (this.render(), this.addEvents());
            };

            c.prototype.mouseDownHandler = function (a) {
              a = this.chart.pointer.normalize(a);
              a = this.cursorToScrollbarPosition(a);
              this.chartX = a.chartX;
              this.chartY = a.chartY;
              this.initPositions = [this.from, this.to];
              this.grabbedCenter = !0;
            };

            c.prototype.mouseMoveHandler = function (a) {
              var c = this.chart.pointer.normalize(a),
                  d = this.options.vertical ? "chartY" : "chartX",
                  g = this.initPositions || [];
              !this.grabbedCenter || a.touches && 0 === a.touches[0][d] || (c = this.cursorToScrollbarPosition(c)[d], d = this[d], d = c - d, this.hasDragged = !0, this.updatePosition(g[0] + d, g[1] + d), this.hasDragged && h(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: a.type,
                DOMEvent: a
              }));
            };

            c.prototype.mouseUpHandler = function (a) {
              this.hasDragged && h(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: a.type,
                DOMEvent: a
              });
              this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
            };

            c.prototype.position = function (a, c, d, g) {
              var h = this.options.vertical,
                  m = this.rendered ? "animate" : "attr",
                  k = 0;
              this.x = a;
              this.y = c + this.trackBorderWidth;
              this.width = d;
              this.xOffset = this.height = g;
              this.yOffset = k;
              h ? (this.width = this.yOffset = d = k = this.size, this.xOffset = c = 0, this.barWidth = g - 2 * d, this.x = a += this.options.margin) : (this.height = this.xOffset = g = c = this.size, this.barWidth = d - 2 * g, this.y += this.options.margin);
              this.group[m]({
                translateX: a,
                translateY: this.y
              });
              this.track[m]({
                width: d,
                height: g
              });
              this.scrollbarButtons[1][m]({
                translateX: h ? 0 : d - c,
                translateY: h ? g - k : 0
              });
            };

            c.prototype.removeEvents = function () {
              this._events.forEach(function (a) {
                y.apply(null, a);
              });

              this._events.length = 0;
            };

            c.prototype.render = function () {
              var a = this.renderer,
                  d = this.options,
                  g = this.size,
                  h = this.chart.styledMode,
                  k = a.g("scrollbar").attr({
                zIndex: d.zIndex,
                translateY: -99999
              }).add();
              this.group = k;
              this.track = a.rect().addClass("highcharts-scrollbar-track").attr({
                x: 0,
                r: d.trackBorderRadius || 0,
                height: g,
                width: g
              }).add(k);
              h || this.track.attr({
                fill: d.trackBackgroundColor,
                stroke: d.trackBorderColor,
                "stroke-width": d.trackBorderWidth
              });
              this.trackBorderWidth = this.track.strokeWidth();
              this.track.attr({
                y: -this.trackBorderWidth % 2 / 2
              });
              this.scrollbarGroup = a.g().add(k);
              this.scrollbar = a.rect().addClass("highcharts-scrollbar-thumb").attr({
                height: g,
                width: g,
                r: d.barBorderRadius || 0
              }).add(this.scrollbarGroup);
              this.scrollbarRifles = a.path(c.swapXY([["M", -3, g / 4], ["L", -3, 2 * g / 3], ["M", 0, g / 4], ["L", 0, 2 * g / 3], ["M", 3, g / 4], ["L", 3, 2 * g / 3]], d.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
              h || (this.scrollbar.attr({
                fill: d.barBackgroundColor,
                stroke: d.barBorderColor,
                "stroke-width": d.barBorderWidth
              }), this.scrollbarRifles.attr({
                stroke: d.rifleColor,
                "stroke-width": 1
              }));
              this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
              this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
              this.drawScrollbarButton(0);
              this.drawScrollbarButton(1);
            };

            c.prototype.setRange = function (a, c) {
              var d = this.options,
                  g = d.vertical,
                  h = d.minWidth,
                  k = this.barWidth,
                  n = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";

              if (r(k)) {
                var t = k * Math.min(c, 1);
                a = Math.max(a, 0);
                var w = Math.ceil(k * a);
                this.calculatedWidth = t = A(t - w);
                t < h && (w = (k - h + t) * a, t = h);
                h = Math.floor(w + this.xOffset + this.yOffset);
                k = t / 2 - .5;
                this.from = a;
                this.to = c;
                g ? (this.scrollbarGroup[n]({
                  translateY: h
                }), this.scrollbar[n]({
                  height: t
                }), this.scrollbarRifles[n]({
                  translateY: k
                }), this.scrollbarTop = h, this.scrollbarLeft = 0) : (this.scrollbarGroup[n]({
                  translateX: h
                }), this.scrollbar[n]({
                  width: t
                }), this.scrollbarRifles[n]({
                  translateX: k
                }), this.scrollbarLeft = h, this.scrollbarTop = 0);
                12 >= t ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);
                !1 === d.showFull && (0 >= a && 1 <= c ? this.group.hide() : this.group.show());
                this.rendered = !0;
              }
            };

            c.prototype.shouldUpdateExtremes = function (a) {
              return g(this.options.liveRedraw, d.svg && !d.isTouchDevice && !this.chart.isBoosting) || "mouseup" === a || "touchend" === a || !r(a);
            };

            c.prototype.trackClick = function (a) {
              var c = this.chart.pointer.normalize(a),
                  d = this.to - this.from,
                  g = this.y + this.scrollbarTop,
                  k = this.x + this.scrollbarLeft;
              this.options.vertical && c.chartY > g || !this.options.vertical && c.chartX > k ? this.updatePosition(this.from + d, this.to + d) : this.updatePosition(this.from - d, this.to - d);
              h(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: a
              });
            };

            c.prototype.update = function (c) {
              this.destroy();
              this.init(this.chart.renderer, a(!0, this.options, c), this.chart);
            };

            c.prototype.updatePosition = function (a, c) {
              1 < c && (a = A(1 - A(c - a)), c = 1);
              0 > a && (c = A(c - a), a = 0);
              this.from = a;
              this.to = c;
            };

            c.defaultOptions = G;
            return c;
          }();

          B.scrollbar = a(!0, c.defaultOptions, B.scrollbar);
          return c;
        });
        M(d, "Core/Axis/NavigatorAxis.js", [d["Core/Globals.js"], d["Core/Utilities.js"]], function (c, d) {
          var B = c.isTouchDevice,
              G = d.addEvent,
              C = d.correctFloat,
              D = d.defined,
              K = d.isNumber,
              A = d.pick,
              r = function () {
            function c(c) {
              this.axis = c;
            }

            c.prototype.destroy = function () {
              this.axis = void 0;
            };

            c.prototype.toFixedRange = function (c, a, d, k) {
              var g = this.axis,
                  h = g.chart;
              h = h && h.fixedRange;
              var r = (g.pointRange || 0) / 2;
              c = A(d, g.translate(c, !0, !g.horiz));
              a = A(k, g.translate(a, !0, !g.horiz));
              g = h && (a - c) / h;
              D(d) || (c = C(c + r));
              D(k) || (a = C(a - r));
              .7 < g && 1.3 > g && (k ? c = a - h : a = c + h);
              K(c) && K(a) || (c = a = void 0);
              return {
                min: c,
                max: a
              };
            };

            return c;
          }();

          return function () {
            function c() {}

            c.compose = function (c) {
              c.keepProps.push("navigatorAxis");
              G(c, "init", function () {
                this.navigatorAxis || (this.navigatorAxis = new r(this));
              });
              G(c, "zoom", function (a) {
                var c = this.chart.options,
                    d = c.navigator,
                    h = this.navigatorAxis,
                    k = c.chart.pinchType,
                    r = c.rangeSelector;
                c = c.chart.zoomType;
                this.isXAxis && (d && d.enabled || r && r.enabled) && ("y" === c ? a.zoomed = !1 : (!B && "xy" === c || B && "xy" === k) && this.options.range && (d = h.previousZoom, D(a.newMin) ? h.previousZoom = [this.min, this.max] : d && (a.newMin = d[0], a.newMax = d[1], h.previousZoom = void 0)));
                "undefined" !== typeof a.zoomed && a.preventDefault();
              });
            };

            c.AdditionsClass = r;
            return c;
          }();
        });
        M(d, "Core/Navigator.js", [d["Core/Axis/Axis.js"], d["Core/Chart/Chart.js"], d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Axis/NavigatorAxis.js"], d["Core/DefaultOptions.js"], d["Core/Color/Palette.js"], d["Core/Renderer/RendererRegistry.js"], d["Core/Scrollbar.js"], d["Core/Series/Series.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A, r, k, h, a) {
          E = E.parse;

          var g = G.hasTouch,
              y = G.isTouchDevice,
              n = D.defaultOptions,
              t = a.addEvent,
              B = a.clamp,
              m = a.correctFloat,
              N = a.defined,
              L = a.destroyObjectProperties,
              x = a.erase,
              M = a.extend,
              H = a.find,
              w = a.isArray,
              f = a.isNumber,
              b = a.merge,
              v = a.pick,
              F = a.removeEvent,
              e = a.splat,
              q = function q(a) {
            for (var b = [], c = 1; c < arguments.length; c++) {
              b[c - 1] = arguments[c];
            }

            b = [].filter.call(b, f);
            if (b.length) return Math[a].apply(0, b);
          };

          D = "undefined" === typeof h.seriesTypes.areaspline ? "line" : "areaspline";
          M(n, {
            navigator: {
              height: 40,
              margin: 25,
              maskInside: !0,
              handles: {
                width: 7,
                height: 15,
                symbols: ["navigator-handle", "navigator-handle"],
                enabled: !0,
                lineWidth: 1,
                backgroundColor: K.neutralColor5,
                borderColor: K.neutralColor40
              },
              maskFill: E(K.highlightColor60).setOpacity(.3).get(),
              outlineColor: K.neutralColor20,
              outlineWidth: 1,
              series: {
                type: D,
                fillOpacity: .05,
                lineWidth: 1,
                compare: null,
                dataGrouping: {
                  approximation: "average",
                  enabled: !0,
                  groupPixelWidth: 2,
                  firstAnchor: "firstPoint",
                  anchor: "middle",
                  lastAnchor: "lastPoint",
                  units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
                },
                dataLabels: {
                  enabled: !1,
                  zIndex: 2
                },
                id: "highcharts-navigator-series",
                className: "highcharts-navigator-series",
                lineColor: null,
                marker: {
                  enabled: !1
                },
                threshold: null
              },
              xAxis: {
                overscroll: 0,
                className: "highcharts-navigator-xaxis",
                tickLength: 0,
                lineWidth: 0,
                gridLineColor: K.neutralColor10,
                gridLineWidth: 1,
                tickPixelInterval: 200,
                labels: {
                  align: "left",
                  style: {
                    color: K.neutralColor40
                  },
                  x: 3,
                  y: -4
                },
                crosshair: !1
              },
              yAxis: {
                className: "highcharts-navigator-yaxis",
                gridLineWidth: 0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: .1,
                maxPadding: .1,
                labels: {
                  enabled: !1
                },
                crosshair: !1,
                title: {
                  text: null
                },
                tickLength: 0,
                tickWidth: 0
              }
            }
          });

          A.getRendererType().prototype.symbols["navigator-handle"] = function (a, b, c, d, e) {
            a = (e && e.width || 0) / 2;
            b = Math.round(a / 3) + .5;
            e = e && e.height || 0;
            return [["M", -a - 1, .5], ["L", a, .5], ["L", a, e + .5], ["L", -a - 1, e + .5], ["L", -a - 1, .5], ["M", -b, 4], ["L", -b, e - 3], ["M", b - 1, 4], ["L", b - 1, e - 3]];
          };

          var l = function () {
            function a(a) {
              this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;
              this.init(a);
            }

            a.prototype.drawHandle = function (a, b, c, d) {
              var e = this.navigatorOptions.handles.height;
              this.handles[b][d](c ? {
                translateX: Math.round(this.left + this.height / 2),
                translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)
              } : {
                translateX: Math.round(this.left + parseInt(a, 10)),
                translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)
              });
            };

            a.prototype.drawOutline = function (a, b, c, d) {
              var e = this.navigatorOptions.maskInside,
                  f = this.outline.strokeWidth(),
                  g = f / 2,
                  h = f % 2 / 2;
              f = this.outlineHeight;
              var p = this.scrollbarHeight || 0,
                  l = this.size,
                  q = this.left - p,
                  k = this.top;
              c ? (q -= g, c = k + b + h, b = k + a + h, h = [["M", q + f, k - p - h], ["L", q + f, c], ["L", q, c], ["L", q, b], ["L", q + f, b], ["L", q + f, k + l + p]], e && h.push(["M", q + f, c - g], ["L", q + f, b + g])) : (a += q + p - h, b += q + p - h, k += g, h = [["M", q, k], ["L", a, k], ["L", a, k + f], ["L", b, k + f], ["L", b, k], ["L", q + l + 2 * p, k]], e && h.push(["M", a - g, k], ["L", b + g, k]));
              this.outline[d]({
                d: h
              });
            };

            a.prototype.drawMasks = function (a, b, c, d) {
              var e = this.left,
                  f = this.top,
                  g = this.height;

              if (c) {
                var h = [e, e, e];
                var p = [f, f + a, f + b];
                var l = [g, g, g];
                var q = [a, b - a, this.size - b];
              } else h = [e, e + a, e + b], p = [f, f, f], l = [a, b - a, this.size - b], q = [g, g, g];

              this.shades.forEach(function (a, b) {
                a[d]({
                  x: h[b],
                  y: p[b],
                  width: l[b],
                  height: q[b]
                });
              });
            };

            a.prototype.renderElements = function () {
              var a = this,
                  b = a.navigatorOptions,
                  c = b.maskInside,
                  d = a.chart,
                  e = d.renderer,
                  f,
                  g = {
                cursor: d.inverted ? "ns-resize" : "ew-resize"
              };
              a.navigatorGroup = f = e.g("navigator").attr({
                zIndex: 8,
                visibility: "hidden"
              }).add();
              [!c, c, !c].forEach(function (c, h) {
                a.shades[h] = e.rect().addClass("highcharts-navigator-mask" + (1 === h ? "-inside" : "-outside")).add(f);
                d.styledMode || a.shades[h].attr({
                  fill: c ? b.maskFill : "rgba(0,0,0,0)"
                }).css(1 === h && g);
              });
              a.outline = e.path().addClass("highcharts-navigator-outline").add(f);
              d.styledMode || a.outline.attr({
                "stroke-width": b.outlineWidth,
                stroke: b.outlineColor
              });
              b.handles.enabled && [0, 1].forEach(function (c) {
                b.handles.inverted = d.inverted;
                a.handles[c] = e.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);
                a.handles[c].attr({
                  zIndex: 7 - c
                }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][c]).add(f);

                if (!d.styledMode) {
                  var h = b.handles;
                  a.handles[c].attr({
                    fill: h.backgroundColor,
                    stroke: h.borderColor,
                    "stroke-width": h.lineWidth
                  }).css(g);
                }
              });
            };

            a.prototype.update = function (a) {
              (this.series || []).forEach(function (a) {
                a.baseSeries && delete a.baseSeries.navigatorSeries;
              });
              this.destroy();
              b(!0, this.chart.options.navigator, this.options, a);
              this.init(this.chart);
            };

            a.prototype.render = function (a, b, c, d) {
              var e = this.chart,
                  g = this.scrollbarHeight,
                  h,
                  p = this.xAxis,
                  l = p.pointRange || 0;
              var q = p.navigatorAxis.fake ? e.xAxis[0] : p;
              var k = this.navigatorEnabled,
                  n,
                  z = this.rendered;
              var r = e.inverted;
              var t = e.xAxis[0].minRange,
                  I = e.xAxis[0].options.maxRange;

              if (!this.hasDragged || N(c)) {
                a = m(a - l / 2);
                b = m(b + l / 2);
                if (!f(a) || !f(b)) if (z) c = 0, d = v(p.width, q.width);else return;
                this.left = v(p.left, e.plotLeft + g + (r ? e.plotWidth : 0));
                this.size = n = h = v(p.len, (r ? e.plotHeight : e.plotWidth) - 2 * g);
                e = r ? g : h + 2 * g;
                c = v(c, p.toPixels(a, !0));
                d = v(d, p.toPixels(b, !0));
                f(c) && Infinity !== Math.abs(c) || (c = 0, d = e);
                a = p.toValue(c, !0);
                b = p.toValue(d, !0);
                var w = Math.abs(m(b - a));
                w < t ? this.grabbedLeft ? c = p.toPixels(b - t - l, !0) : this.grabbedRight && (d = p.toPixels(a + t + l, !0)) : N(I) && m(w - l) > I && (this.grabbedLeft ? c = p.toPixels(b - I - l, !0) : this.grabbedRight && (d = p.toPixels(a + I + l, !0)));
                this.zoomedMax = B(Math.max(c, d), 0, n);
                this.zoomedMin = B(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, d), 0, n);
                this.range = this.zoomedMax - this.zoomedMin;
                n = Math.round(this.zoomedMax);
                c = Math.round(this.zoomedMin);
                k && (this.navigatorGroup.attr({
                  visibility: "visible"
                }), z = z && !this.hasDragged ? "animate" : "attr", this.drawMasks(c, n, r, z), this.drawOutline(c, n, r, z), this.navigatorOptions.handles.enabled && (this.drawHandle(c, 0, r, z), this.drawHandle(n, 1, r, z)));
                this.scrollbar && (r ? (r = this.top - g, q = this.left - g + (k || !q.opposite ? 0 : (q.titleOffset || 0) + q.axisTitleMargin), g = h + 2 * g) : (r = this.top + (k ? this.height : -g), q = this.left - g), this.scrollbar.position(q, r, e, g), this.scrollbar.setRange(this.zoomedMin / (h || 1), this.zoomedMax / (h || 1)));
                this.rendered = !0;
              }
            };

            a.prototype.addMouseEvents = function () {
              var a = this,
                  b = a.chart,
                  c = b.container,
                  d = [],
                  e,
                  f;

              a.mouseMoveHandler = e = function e(b) {
                a.onMouseMove(b);
              };

              a.mouseUpHandler = f = function f(b) {
                a.onMouseUp(b);
              };

              d = a.getPartsEvents("mousedown");
              d.push(t(b.renderTo, "mousemove", e), t(c.ownerDocument, "mouseup", f));
              g && (d.push(t(b.renderTo, "touchmove", e), t(c.ownerDocument, "touchend", f)), d.concat(a.getPartsEvents("touchstart")));
              a.eventsToUnbind = d;
              a.series && a.series[0] && d.push(t(a.series[0].xAxis, "foundExtremes", function () {
                b.navigator.modifyNavigatorAxisExtremes();
              }));
            };

            a.prototype.getPartsEvents = function (a) {
              var b = this,
                  c = [];
              ["shades", "handles"].forEach(function (d) {
                b[d].forEach(function (e, f) {
                  c.push(t(e.element, a, function (a) {
                    b[d + "Mousedown"](a, f);
                  }));
                });
              });
              return c;
            };

            a.prototype.shadesMousedown = function (a, b) {
              a = this.chart.pointer.normalize(a);
              var c = this.chart,
                  d = this.xAxis,
                  e = this.zoomedMin,
                  f = this.left,
                  g = this.size,
                  h = this.range,
                  l = a.chartX;
              c.inverted && (l = a.chartY, f = this.top);
              if (1 === b) this.grabbedCenter = l, this.fixedWidth = h, this.dragOffset = l - e;else {
                a = l - f - h / 2;
                if (0 === b) a = Math.max(0, a);else if (2 === b && a + h >= g) if (a = g - h, this.reversedExtremes) {
                  a -= h;
                  var p = this.getUnionExtremes().dataMin;
                } else var q = this.getUnionExtremes().dataMax;
                a !== e && (this.fixedWidth = h, b = d.navigatorAxis.toFixedRange(a, a + h, p, q), N(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {
                  trigger: "navigator"
                }));
              }
            };

            a.prototype.handlesMousedown = function (a, b) {
              this.chart.pointer.normalize(a);
              a = this.chart;
              var c = a.xAxis[0],
                  d = this.reversedExtremes;
              0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);
              a.fixedRange = null;
            };

            a.prototype.onMouseMove = function (a) {
              var b = this,
                  c = b.chart,
                  d = b.left,
                  e = b.navigatorSize,
                  f = b.range,
                  g = b.dragOffset,
                  h = c.inverted;
              a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, h && (d = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - d, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - d)) : b.grabbedCenter && (b.hasDragged = !0, c < g ? c = g : c > e + g - f && (c = e + g - f), b.render(0, 0, c - g, c - g + f)), b.hasDragged && b.scrollbar && v(b.scrollbar.options.liveRedraw, G.svg && !y && !this.chart.isBoosting) && (a.DOMType = a.type, setTimeout(function () {
                b.onMouseUp(a);
              }, 0)));
            };

            a.prototype.onMouseUp = function (a) {
              var b = this.chart,
                  c = this.xAxis,
                  d = this.scrollbar,
                  e = a.DOMEvent || a,
                  g = b.inverted,
                  h = this.rendered && !this.hasDragged ? "animate" : "attr";

              if (this.hasDragged && (!d || !d.hasDragged) || "scrollbar" === a.trigger) {
                d = this.getUnionExtremes();
                if (this.zoomedMin === this.otherHandlePos) var l = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var p = this.fixedExtreme;
                this.zoomedMax === this.size && (p = this.reversedExtremes ? d.dataMin : d.dataMax);
                0 === this.zoomedMin && (l = this.reversedExtremes ? d.dataMax : d.dataMin);
                c = c.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, l, p);
                N(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {
                  trigger: "navigator",
                  triggerOp: "navigator-drag",
                  DOMEvent: e
                });
              }

              "mousemove" !== a.DOMType && "touchmove" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
              this.navigatorEnabled && f(this.zoomedMin) && f(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, g, h), this.outline && this.drawOutline(b, a, g, h), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, g, h), this.drawHandle(a, 1, g, h)));
            };

            a.prototype.removeEvents = function () {
              this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {
                a();
              }), this.eventsToUnbind = void 0);
              this.removeBaseSeriesEvents();
            };

            a.prototype.removeBaseSeriesEvents = function () {
              var a = this.baseSeries || [];
              this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {
                F(a, "updatedData", this.updatedDataHandler);
              }, this), a[0].xAxis && F(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
            };

            a.prototype.init = function (a) {
              var d = a.options,
                  e = d.navigator,
                  f = e.enabled,
                  g = d.scrollbar,
                  h = g.enabled;
              d = f ? e.height : 0;
              var l = h ? g.height : 0;
              this.handles = [];
              this.shades = [];
              this.chart = a;
              this.setBaseSeries();
              this.height = d;
              this.scrollbarHeight = l;
              this.scrollbarEnabled = h;
              this.navigatorEnabled = f;
              this.navigatorOptions = e;
              this.scrollbarOptions = g;
              this.outlineHeight = d + l;
              this.opposite = v(e.opposite, !(f || !a.inverted));
              var p = this;
              f = p.baseSeries;
              g = a.xAxis.length;
              h = a.yAxis.length;
              var k = f && f[0] && f[0].xAxis || a.xAxis[0] || {
                options: {}
              };
              a.isDirtyBox = !0;
              p.navigatorEnabled ? (p.xAxis = new c(a, b({
                breaks: k.options.breaks,
                ordinal: k.options.ordinal
              }, e.xAxis, {
                id: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                isX: !0,
                type: "datetime",
                index: g,
                isInternal: !0,
                offset: 0,
                keepOrdinalPadding: !0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: 0,
                maxPadding: 0,
                zoomEnabled: !1
              }, a.inverted ? {
                offsets: [l, 0, -l, 0],
                width: d
              } : {
                offsets: [0, -l, 0, l],
                height: d
              })), p.yAxis = new c(a, b(e.yAxis, {
                id: "navigator-y-axis",
                alignTicks: !1,
                offset: 0,
                index: h,
                isInternal: !0,
                reversed: v(e.yAxis && e.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),
                zoomEnabled: !1
              }, a.inverted ? {
                width: d
              } : {
                height: d
              })), f || e.series.data ? p.updateNavigatorSeries(!1) : 0 === a.series.length && (p.unbindRedraw = t(a, "beforeRedraw", function () {
                0 < a.series.length && !p.series && (p.setBaseSeries(), p.unbindRedraw());
              })), p.reversedExtremes = a.inverted && !p.xAxis.reversed || !a.inverted && p.xAxis.reversed, p.renderElements(), p.addMouseEvents()) : (p.xAxis = {
                chart: a,
                navigatorAxis: {
                  fake: !0
                },
                translate: function translate(b, c) {
                  var d = a.xAxis[0],
                      e = d.getExtremes(),
                      f = d.len - 2 * l,
                      g = q("min", d.options.min, e.dataMin);
                  d = q("max", d.options.max, e.dataMax) - g;
                  return c ? b * d / f + g : f * (b - g) / d;
                },
                toPixels: function toPixels(a) {
                  return this.translate(a);
                },
                toValue: function toValue(a) {
                  return this.translate(a, !0);
                }
              }, p.xAxis.navigatorAxis.axis = p.xAxis, p.xAxis.navigatorAxis.toFixedRange = C.AdditionsClass.prototype.toFixedRange.bind(p.xAxis.navigatorAxis));
              a.options.scrollbar.enabled && (a.scrollbar = p.scrollbar = new r(a.renderer, b(a.options.scrollbar, {
                margin: p.navigatorEnabled ? 0 : 10,
                vertical: a.inverted
              }), a), t(p.scrollbar, "changed", function (a) {
                var b = p.size,
                    c = b * this.to;
                b *= this.from;
                p.hasDragged = p.scrollbar.hasDragged;
                p.render(0, 0, b, c);
                this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {
                  p.onMouseUp(a);
                });
              }));
              p.addBaseSeriesEvents();
              p.addChartEvents();
            };

            a.prototype.getUnionExtremes = function (a) {
              var b = this.chart.xAxis[0],
                  c = this.xAxis,
                  d = c.options,
                  e = b.options,
                  f;
              a && null === b.dataMin || (f = {
                dataMin: v(d && d.min, q("min", e.min, b.dataMin, c.dataMin, c.min)),
                dataMax: v(d && d.max, q("max", e.max, b.dataMax, c.dataMax, c.max))
              });
              return f;
            };

            a.prototype.setBaseSeries = function (a, b) {
              var c = this.chart,
                  d = this.baseSeries = [];
              a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? H(c.series, function (a) {
                return !a.options.isInternal;
              }).index : 0);
              (c.series || []).forEach(function (b, c) {
                b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);
              });
              this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);
            };

            a.prototype.updateNavigatorSeries = function (a, c) {
              var d = this,
                  f = d.chart,
                  g = d.baseSeries,
                  h,
                  l,
                  p = d.navigatorOptions.series,
                  q,
                  k = {
                enableMouseTracking: !1,
                index: null,
                linkedTo: null,
                group: "nav",
                padXAxis: !1,
                xAxis: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                showInLegend: !1,
                stacking: void 0,
                isInternal: !0,
                states: {
                  inactive: {
                    opacity: 1
                  }
                }
              },
                  m = d.series = (d.series || []).filter(function (a) {
                var b = a.baseSeries;
                return 0 > g.indexOf(b) ? (b && (F(b, "updatedData", d.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;
              });
              g && g.length && g.forEach(function (a) {
                var z = a.navigatorSeries,
                    u = M({
                  color: a.color,
                  visible: a.visible
                }, w(p) ? n.navigator.series : p);
                z && !1 === d.navigatorOptions.adaptToUpdatedData || (k.name = "Navigator " + g.length, h = a.options || {}, q = h.navigatorOptions || {}, u.dataLabels = e(u.dataLabels), l = b(h, k, u, q), l.pointRange = v(u.pointRange, q.pointRange, n.plotOptions[l.type || "line"].pointRange), u = q.data || u.data, d.hasNavigatorData = d.hasNavigatorData || !!u, l.data = u || h.data && h.data.slice(0), z && z.options ? z.update(l, c) : (a.navigatorSeries = f.initSeries(l), a.navigatorSeries.baseSeries = a, m.push(a.navigatorSeries)));
              });
              if (p.data && (!g || !g.length) || w(p)) d.hasNavigatorData = !1, p = e(p), p.forEach(function (a, c) {
                k.name = "Navigator " + (m.length + 1);
                l = b(n.navigator.series, {
                  color: f.series[c] && !f.series[c].options.isInternal && f.series[c].color || f.options.colors[c] || f.options.colors[0]
                }, k, a);
                l.data = a.data;
                l.data && (d.hasNavigatorData = !0, m.push(f.initSeries(l)));
              });
              a && this.addBaseSeriesEvents();
            };

            a.prototype.addBaseSeriesEvents = function () {
              var a = this,
                  b = a.baseSeries || [];
              b[0] && b[0].xAxis && b[0].eventsToUnbind.push(t(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
              b.forEach(function (b) {
                b.eventsToUnbind.push(t(b, "show", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);
                }));
                b.eventsToUnbind.push(t(b, "hide", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);
                }));
                !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(t(b, "updatedData", this.updatedDataHandler));
                b.eventsToUnbind.push(t(b, "remove", function () {
                  this.navigatorSeries && (x(a.series, this.navigatorSeries), N(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);
                }));
              }, this);
            };

            a.prototype.getBaseSeriesMin = function (a) {
              return this.baseSeries.reduce(function (a, b) {
                return Math.min(a, b.xData ? b.xData[0] : a);
              }, a);
            };

            a.prototype.modifyNavigatorAxisExtremes = function () {
              var a = this.xAxis,
                  b;
              "undefined" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));
            };

            a.prototype.modifyBaseAxisExtremes = function () {
              var a = this.chart.navigator,
                  b = this.getExtremes(),
                  c = b.dataMin,
                  d = b.dataMax;
              b = b.max - b.min;
              var e = a.stickToMin,
                  g = a.stickToMax,
                  h = v(this.options.overscroll, 0),
                  l = a.series && a.series[0],
                  q = !!this.setExtremes;

              if (!this.eventArgs || "rangeSelectorButton" !== this.eventArgs.trigger) {
                if (e) {
                  var k = c;
                  var m = k + b;
                }

                g && (m = d + h, e || (k = Math.max(c, m - b, a.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE))));
                q && (e || g) && f(k) && (this.min = this.userMin = k, this.max = this.userMax = m);
              }

              a.stickToMin = a.stickToMax = null;
            };

            a.prototype.updatedDataHandler = function () {
              var a = this.chart.navigator,
                  b = this.navigatorSeries;
              a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);
              a.stickToMin = a.shouldStickToMin(this, a);
              b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));
            };

            a.prototype.shouldStickToMin = function (a, b) {
              b = b.getBaseSeriesMin(a.xData[0]);
              var c = a.xAxis;
              a = c.max;
              var d = c.min;
              c = c.options.range;
              return f(a) && f(d) ? c && 0 < a - b ? a - b < c && !this.chart.fixedRange : d <= b : !1;
            };

            a.prototype.addChartEvents = function () {
              this.eventsToUnbind || (this.eventsToUnbind = []);
              this.eventsToUnbind.push(t(this.chart, "redraw", function () {
                var a = this.navigator,
                    b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);
                b && a.render(b.min, b.max);
              }), t(this.chart, "getMargins", function () {
                var a = this.navigator,
                    b = a.opposite ? "plotTop" : "marginBottom";
                this.inverted && (b = a.opposite ? "marginRight" : "plotLeft");
                this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;
              }));
            };

            a.prototype.destroy = function () {
              this.removeEvents();
              this.xAxis && (x(this.chart.xAxis, this.xAxis), x(this.chart.axes, this.xAxis));
              this.yAxis && (x(this.chart.yAxis, this.yAxis), x(this.chart.axes, this.yAxis));
              (this.series || []).forEach(function (a) {
                a.destroy && a.destroy();
              });
              "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach(function (a) {
                this[a] && this[a].destroy && this[a].destroy();
                this[a] = null;
              }, this);
              [this.handles].forEach(function (a) {
                L(a);
              }, this);
            };

            return a;
          }();

          G.Navigator || (G.Navigator = l, C.compose(c), t(d, "beforeShowResetZoom", function () {
            var a = this.options,
                b = a.navigator,
                c = a.rangeSelector;
            if ((b && b.enabled || c && c.enabled) && (!y && "x" === a.chart.zoomType || y && "x" === a.chart.pinchType)) return !1;
          }), t(d, "beforeRender", function () {
            var a = this.options;
            if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new l(this);
          }), t(d, "afterSetChartSize", function () {
            var a = this.legend,
                b = this.navigator;

            if (b) {
              var c = a && a.options;
              var d = b.xAxis;
              var e = b.yAxis;
              var f = b.scrollbarHeight;
              this.inverted ? (b.left = b.opposite ? this.chartWidth - f - b.height : this.spacing[3] + f, b.top = this.plotTop + f) : (b.left = v(d.left, this.plotLeft + f), b.top = b.navigatorOptions.top || this.chartHeight - b.height - f - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && "bottom" === c.verticalAlign && "proximate" !== c.layout && c.enabled && !c.floating ? a.legendHeight + v(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));
              d && e && (this.inverted ? d.options.left = e.options.left = b.left : d.options.top = e.options.top = b.top, d.setAxisSize(), e.setAxisSize());
            }
          }), t(d, "update", function (a) {
            var c = a.options.navigator || {},
                d = a.options.scrollbar || {};
            this.navigator || this.scroller || !c.enabled && !d.enabled || (b(!0, this.options.navigator, c), b(!0, this.options.scrollbar, d), delete a.options.navigator, delete a.options.scrollbar);
          }), t(d, "afterUpdate", function (a) {
            this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new l(this), v(a.redraw, !0) && this.redraw(a.animation));
          }), t(d, "afterAddSeries", function () {
            this.navigator && this.navigator.setBaseSeries(null, !1);
          }), t(k, "afterUpdate", function () {
            this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);
          }), d.prototype.callbacks.push(function (a) {
            var b = a.navigator;
            b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));
          }));
          G.Navigator = l;
          return G.Navigator;
        });
        M(d, "Extensions/RangeSelector.js", [d["Core/Axis/Axis.js"], d["Core/Chart/Chart.js"], d["Core/Globals.js"], d["Core/DefaultOptions.js"], d["Core/Color/Palette.js"], d["Core/Renderer/SVG/SVGElement.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K) {
          function A(a) {
            if (-1 !== a.indexOf("%L")) return "text";
            var b = "aAdewbBmoyY".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            }),
                c = "HkIlMS".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            });
            return b && c ? "datetime-local" : b ? "date" : c ? "time" : "text";
          }

          var r = G.defaultOptions,
              k = K.addEvent,
              h = K.createElement,
              a = K.css,
              g = K.defined,
              y = K.destroyObjectProperties,
              n = K.discardElement,
              t = K.extend,
              B = K.find,
              m = K.fireEvent,
              N = K.isNumber,
              L = K.merge,
              x = K.objectEach,
              M = K.pad,
              H = K.pick,
              w = K.pInt,
              f = K.splat;
          t(r, {
            rangeSelector: {
              allButtonsEnabled: !1,
              buttons: void 0,
              buttonSpacing: 5,
              dropdown: "responsive",
              enabled: void 0,
              verticalAlign: "top",
              buttonTheme: {
                width: 28,
                height: 18,
                padding: 2,
                zIndex: 7
              },
              floating: !1,
              x: 0,
              y: 0,
              height: void 0,
              inputBoxBorderColor: "none",
              inputBoxHeight: 17,
              inputBoxWidth: void 0,
              inputDateFormat: "%b %e, %Y",
              inputDateParser: void 0,
              inputEditDateFormat: "%Y-%m-%d",
              inputEnabled: !0,
              inputPosition: {
                align: "right",
                x: 0,
                y: 0
              },
              inputSpacing: 5,
              selected: void 0,
              buttonPosition: {
                align: "left",
                x: 0,
                y: 0
              },
              inputStyle: {
                color: C.highlightColor80,
                cursor: "pointer"
              },
              labelStyle: {
                color: C.neutralColor60
              }
            }
          });
          t(r.lang, {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "\u2192"
          });

          var b = function () {
            function b(a) {
              this.buttons = void 0;
              this.buttonOptions = b.prototype.defaultButtons;
              this.initialButtonGroupWidth = 0;
              this.options = void 0;
              this.chart = a;
              this.init(a);
            }

            b.prototype.clickButton = function (a, b) {
              var d = this.chart,
                  e = this.buttonOptions[a],
                  h = d.xAxis[0],
                  l = d.scroller && d.scroller.getUnionExtremes() || h || {},
                  q = l.dataMin,
                  n = l.dataMax,
                  u = h && Math.round(Math.min(h.max, H(n, h.max))),
                  r = e.type;
              l = e._range;
              var t,
                  v = e.dataGrouping;

              if (null !== q && null !== n) {
                d.fixedRange = l;
                this.setSelected(a);
                v && (this.forcedDataGrouping = !0, c.prototype.setDataGrouping.call(h || {
                  chart: this.chart
                }, v, !1), this.frozenStates = e.preserveDataGrouping);
                if ("month" === r || "year" === r) {
                  if (h) {
                    r = {
                      range: e,
                      max: u,
                      chart: d,
                      dataMin: q,
                      dataMax: n
                    };
                    var w = h.minFromRange.call(r);
                    N(r.newMax) && (u = r.newMax);
                  } else l = e;
                } else if (l) w = Math.max(u - l, q), u = Math.min(w + l, n);else if ("ytd" === r) {
                  if (h) "undefined" === typeof n && (q = Number.MAX_VALUE, n = Number.MIN_VALUE, d.series.forEach(function (a) {
                    a = a.xData;
                    q = Math.min(a[0], q);
                    n = Math.max(a[a.length - 1], n);
                  }), b = !1), u = this.getYTDExtremes(n, q, d.time.useUTC), w = t = u.min, u = u.max;else {
                    this.deferredYTDClick = a;
                    return;
                  }
                } else "all" === r && h && (d.navigator && d.navigator.baseSeries[0] && (d.navigator.baseSeries[0].xAxis.options.range = void 0), w = q, u = n);
                g(w) && (w += e._offsetMin);
                g(u) && (u += e._offsetMax);
                this.dropdown && (this.dropdown.selectedIndex = a + 1);
                if (h) h.setExtremes(w, u, H(b, !0), void 0, {
                  trigger: "rangeSelectorButton",
                  rangeSelectorButton: e
                });else {
                  var x = f(d.options.xAxis)[0];
                  var y = x.range;
                  x.range = l;
                  var A = x.min;
                  x.min = t;
                  k(d, "load", function () {
                    x.range = y;
                    x.min = A;
                  });
                }
                m(this, "afterBtnClick");
              }
            };

            b.prototype.setSelected = function (a) {
              this.selected = this.options.selected = a;
            };

            b.prototype.init = function (a) {
              var b = this,
                  c = a.options.rangeSelector,
                  d = c.buttons || b.defaultButtons.slice(),
                  e = c.selected,
                  f = function f() {
                var a = b.minInput,
                    c = b.maxInput;
                a && a.blur && m(a, "blur");
                c && c.blur && m(c, "blur");
              };

              b.chart = a;
              b.options = c;
              b.buttons = [];
              b.buttonOptions = d;
              this.eventsToUnbind = [];
              this.eventsToUnbind.push(k(a.container, "mousedown", f));
              this.eventsToUnbind.push(k(a, "resize", f));
              d.forEach(b.computeButtonRange);
              "undefined" !== typeof e && d[e] && this.clickButton(e, !1);
              this.eventsToUnbind.push(k(a, "load", function () {
                a.xAxis && a.xAxis[0] && k(a.xAxis[0], "setExtremes", function (c) {
                  this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);
                });
              }));
            };

            b.prototype.updateButtonStates = function () {
              var a = this,
                  b = this.chart,
                  c = this.dropdown,
                  d = b.xAxis[0],
                  e = Math.round(d.max - d.min),
                  f = !d.hasVisibleSeries,
                  g = b.scroller && b.scroller.getUnionExtremes() || d,
                  h = g.dataMin,
                  k = g.dataMax;
              b = a.getYTDExtremes(k, h, b.time.useUTC);
              var m = b.min,
                  n = b.max,
                  r = a.selected,
                  t = N(r),
                  v = a.options.allButtonsEnabled,
                  w = a.buttons;
              a.buttonOptions.forEach(function (b, g) {
                var l = b._range,
                    p = b.type,
                    q = b.count || 1,
                    z = w[g],
                    u = 0,
                    I = b._offsetMax - b._offsetMin;
                b = g === r;
                var x = l > k - h,
                    y = l < d.minRange,
                    A = !1,
                    B = !1;
                l = l === e;
                ("month" === p || "year" === p) && e + 36E5 >= 864E5 * {
                  month: 28,
                  year: 365
                }[p] * q - I && e - 36E5 <= 864E5 * {
                  month: 31,
                  year: 366
                }[p] * q + I ? l = !0 : "ytd" === p ? (l = n - m + I === e, A = !b) : "all" === p && (l = d.max - d.min >= k - h, B = !b && t && l);
                p = !v && (x || y || B || f);
                q = b && l || l && !t && !A || b && a.frozenStates;
                p ? u = 3 : q && (t = !0, u = 2);
                z.state !== u && (z.setState(u), c && (c.options[g + 1].disabled = p, 2 === u && (c.selectedIndex = g + 1)), 0 === u && r === g && a.setSelected());
              });
            };

            b.prototype.computeButtonRange = function (a) {
              var b = a.type,
                  c = a.count || 1,
                  d = {
                millisecond: 1,
                second: 1E3,
                minute: 6E4,
                hour: 36E5,
                day: 864E5,
                week: 6048E5
              };
              if (d[b]) a._range = d[b] * c;else if ("month" === b || "year" === b) a._range = 864E5 * {
                month: 30,
                year: 365
              }[b] * c;
              a._offsetMin = H(a.offsetMin, 0);
              a._offsetMax = H(a.offsetMax, 0);
              a._range += a._offsetMax - a._offsetMin;
            };

            b.prototype.getInputValue = function (a) {
              a = "min" === a ? this.minInput : this.maxInput;
              var b = this.chart.options.rangeSelector,
                  c = this.chart.time;
              return a ? ("text" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;
            };

            b.prototype.setInputValue = function (a, b) {
              var c = this.options,
                  d = this.chart.time,
                  e = "min" === a ? this.minInput : this.maxInput;
              a = "min" === a ? this.minDateBox : this.maxDateBox;

              if (e) {
                var f = e.getAttribute("data-hc-time");
                f = g(f) ? Number(f) : void 0;
                g(b) && (g(f) && e.setAttribute("data-hc-time-previous", f), e.setAttribute("data-hc-time", b), f = b);
                e.value = d.dateFormat(this.inputTypeFormats[e.type] || c.inputEditDateFormat, f);
                a && a.attr({
                  text: d.dateFormat(c.inputDateFormat, f)
                });
              }
            };

            b.prototype.setInputExtremes = function (a, b, c) {
              if (a = "min" === a ? this.minInput : this.maxInput) {
                var d = this.inputTypeFormats[a.type],
                    e = this.chart.time;
                d && (b = e.dateFormat(d, b), a.min !== b && (a.min = b), c = e.dateFormat(d, c), a.max !== c && (a.max = c));
              }
            };

            b.prototype.showInput = function (b) {
              var c = "min" === b ? this.minDateBox : this.maxDateBox;

              if ((b = "min" === b ? this.minInput : this.maxInput) && c && this.inputGroup) {
                var d = "text" === b.type,
                    e = this.inputGroup,
                    f = e.translateX;
                e = e.translateY;
                var g = this.options.inputBoxWidth;
                a(b, {
                  width: d ? c.width + (g ? -2 : 20) + "px" : "auto",
                  height: d ? c.height - 2 + "px" : "auto",
                  border: "2px solid silver"
                });
                d && g ? a(b, {
                  left: f + c.x + "px",
                  top: e + "px"
                }) : a(b, {
                  left: Math.min(Math.round(c.x + f - (b.offsetWidth - c.width) / 2), this.chart.chartWidth - b.offsetWidth) + "px",
                  top: e - (b.offsetHeight - c.height) / 2 + "px"
                });
              }
            };

            b.prototype.hideInput = function (b) {
              (b = "min" === b ? this.minInput : this.maxInput) && a(b, {
                top: "-9999em",
                border: 0,
                width: "1px",
                height: "1px"
              });
            };

            b.prototype.defaultInputDateParser = function (a, b, c) {
              var d = a.split("/").join("-").split(" ").join("T");
              -1 === d.indexOf("T") && (d += "T00:00");
              if (b) d += "Z";else {
                var e;
                if (e = E.isSafari) e = d, e = !(6 < e.length && (e.lastIndexOf("-") === e.length - 6 || e.lastIndexOf("+") === e.length - 6));
                e && (e = new Date(d).getTimezoneOffset() / 60, d += 0 >= e ? "+" + M(-e) + ":00" : "-" + M(e) + ":00");
              }
              d = Date.parse(d);
              N(d) || (a = a.split("-"), d = Date.UTC(w(a[0]), w(a[1]) - 1, w(a[2])));
              c && b && N(d) && (d += c.getTimezoneOffset(d));
              return d;
            };

            b.prototype.drawInput = function (b) {
              function c() {
                var a = g.getInputValue(b),
                    c = d.xAxis[0],
                    e = d.scroller && d.scroller.xAxis ? d.scroller.xAxis : c,
                    f = e.dataMin;
                e = e.dataMax;
                var h = g.maxInput,
                    l = g.minInput;
                a !== Number(w.getAttribute("data-hc-time-previous")) && N(a) && (w.setAttribute("data-hc-time-previous", a), n && h && N(f) ? a > Number(h.getAttribute("data-hc-time")) ? a = void 0 : a < f && (a = f) : l && N(e) && (a < Number(l.getAttribute("data-hc-time")) ? a = void 0 : a > e && (a = e)), "undefined" !== typeof a && c.setExtremes(n ? a : c.min, n ? c.max : a, void 0, void 0, {
                  trigger: "rangeSelectorInput"
                }));
              }

              var d = this.chart,
                  e = this.div,
                  f = this.inputGroup,
                  g = this,
                  k = d.renderer.style || {},
                  m = d.renderer,
                  q = d.options.rangeSelector,
                  n = "min" === b,
                  v = r.lang[n ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
              v = m.label(v, 0).addClass("highcharts-range-label").attr({
                padding: v ? 2 : 0,
                height: v ? q.inputBoxHeight : 0
              }).add(f);
              m = m.label("", 0).addClass("highcharts-range-input").attr({
                padding: 2,
                width: q.inputBoxWidth,
                height: q.inputBoxHeight,
                "text-align": "center"
              }).on("click", function () {
                g.showInput(b);
                g[b + "Input"].focus();
              });
              d.styledMode || m.attr({
                stroke: q.inputBoxBorderColor,
                "stroke-width": 1
              });
              m.add(f);
              var w = h("input", {
                name: b,
                className: "highcharts-range-selector"
              }, void 0, e);
              w.setAttribute("type", A(q.inputDateFormat || "%b %e, %Y"));
              d.styledMode || (v.css(L(k, q.labelStyle)), m.css(L({
                color: C.neutralColor80
              }, k, q.inputStyle)), a(w, t({
                position: "absolute",
                border: 0,
                boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                width: "1px",
                height: "1px",
                padding: 0,
                textAlign: "center",
                fontSize: k.fontSize,
                fontFamily: k.fontFamily,
                top: "-9999em"
              }, q.inputStyle)));

              w.onfocus = function () {
                g.showInput(b);
              };

              w.onblur = function () {
                w === E.doc.activeElement && c();
                g.hideInput(b);
                g.setInputValue(b);
                w.blur();
              };

              var x = !1;

              w.onchange = function () {
                x || (c(), g.hideInput(b), w.blur());
              };

              w.onkeypress = function (a) {
                13 === a.keyCode && c();
              };

              w.onkeydown = function (a) {
                x = !0;
                38 !== a.keyCode && 40 !== a.keyCode || c();
              };

              w.onkeyup = function () {
                x = !1;
              };

              return {
                dateBox: m,
                input: w,
                label: v
              };
            };

            b.prototype.getPosition = function () {
              var a = this.chart,
                  b = a.options.rangeSelector;
              a = "top" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;
              return {
                buttonTop: a + b.buttonPosition.y,
                inputTop: a + b.inputPosition.y - 10
              };
            };

            b.prototype.getYTDExtremes = function (a, b, c) {
              var d = this.chart.time,
                  e = new d.Date(a),
                  f = d.get("FullYear", e);
              c = c ? d.Date.UTC(f, 0, 1) : +new d.Date(f, 0, 1);
              b = Math.max(b, c);
              e = e.getTime();
              return {
                max: Math.min(a || e, e),
                min: b
              };
            };

            b.prototype.render = function (a, b) {
              var c = this.chart,
                  d = c.renderer,
                  e = c.container,
                  f = c.options,
                  l = f.rangeSelector,
                  k = H(f.chart.style && f.chart.style.zIndex, 0) + 1;
              f = l.inputEnabled;

              if (!1 !== l.enabled) {
                this.rendered || (this.group = d.g("range-selector-group").attr({
                  zIndex: 7
                }).add(), this.div = h("div", void 0, {
                  position: "relative",
                  height: 0,
                  zIndex: k
                }), this.buttonOptions.length && this.renderButtons(), e.parentNode && e.parentNode.insertBefore(this.div, e), f && (this.inputGroup = d.g("input-group").add(this.group), d = this.drawInput("min"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput("max"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));

                if (f && (this.setInputValue("min", a), this.setInputValue("max", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, g(a.dataMin) && g(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes("min", a.dataMin, Math.min(a.dataMax, this.getInputValue("max")) - c), this.setInputExtremes("max", Math.max(a.dataMin, this.getInputValue("min")) + c, a.dataMax)), this.inputGroup)) {
                  var m = 0;
                  [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {
                    if (a) {
                      var b = a.getBBox().width;
                      b && (a.attr({
                        x: m
                      }), m += b + l.inputSpacing);
                    }
                  });
                }

                this.alignElements();
                this.rendered = !0;
              }
            };

            b.prototype.renderButtons = function () {
              var a = this,
                  b = this.buttons,
                  c = this.options,
                  d = r.lang,
                  e = this.chart.renderer,
                  f = L(c.buttonTheme),
                  g = f && f.states,
                  n = f.width || 28;
              delete f.width;
              delete f.states;
              this.buttonGroup = e.g("range-selector-buttons").add(this.group);
              var u = this.dropdown = h("select", void 0, {
                position: "absolute",
                width: "1px",
                height: "1px",
                padding: 0,
                border: 0,
                top: "-9999em",
                cursor: "pointer",
                opacity: .0001
              }, this.div);
              k(u, "touchstart", function () {
                u.style.fontSize = "16px";
              });
              [[E.isMS ? "mouseover" : "mouseenter"], [E.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(function (c) {
                var d = c[0],
                    e = c[1];
                k(u, d, function () {
                  var c = b[a.currentButtonIndex()];
                  c && m(c.element, e || d);
                });
              });
              this.zoomText = e.label(d && d.rangeSelectorZoom || "", 0).attr({
                padding: c.buttonTheme.padding,
                height: c.buttonTheme.height,
                paddingLeft: 0,
                paddingRight: 0
              }).add(this.buttonGroup);
              this.chart.styledMode || (this.zoomText.css(c.labelStyle), f["stroke-width"] = H(f["stroke-width"], 0));
              h("option", {
                textContent: this.zoomText.textStr,
                disabled: !0
              }, void 0, u);
              this.buttonOptions.forEach(function (c, d) {
                h("option", {
                  textContent: c.title || c.text
                }, void 0, u);
                b[d] = e.button(c.text, 0, 0, function (b) {
                  var e = c.events && c.events.click,
                      f;
                  e && (f = e.call(c, b));
                  !1 !== f && a.clickButton(d);
                  a.isActive = !0;
                }, f, g && g.hover, g && g.select, g && g.disabled).attr({
                  "text-align": "center",
                  width: n
                }).add(a.buttonGroup);
                c.title && b[d].attr("title", c.title);
              });
            };

            b.prototype.alignElements = function () {
              var a = this,
                  b = this.buttonGroup,
                  c = this.buttons,
                  d = this.chart,
                  e = this.group,
                  f = this.inputGroup,
                  g = this.options,
                  h = this.zoomText,
                  k = d.options,
                  m = k.exporting && !1 !== k.exporting.enabled && k.navigation && k.navigation.buttonOptions;
              k = g.buttonPosition;

              var n = g.inputPosition,
                  r = g.verticalAlign,
                  t = function t(b, c) {
                return m && a.titleCollision(d) && "top" === r && "right" === c.align && c.y - b.getBBox().height - 12 < (m.y || 0) + (m.height || 0) + d.spacing[0] ? -40 : 0;
              },
                  w = d.plotLeft;

              if (e && k && n) {
                var v = k.x - d.spacing[3];

                if (b) {
                  this.positionButtons();

                  if (!this.initialButtonGroupWidth) {
                    var x = 0;
                    h && (x += h.getBBox().width + 5);
                    c.forEach(function (a, b) {
                      x += a.width;
                      b !== c.length - 1 && (x += g.buttonSpacing);
                    });
                    this.initialButtonGroupWidth = x;
                  }

                  w -= d.spacing[3];
                  this.updateButtonStates();
                  h = t(b, k);
                  this.alignButtonGroup(h);
                  e.placed = b.placed = d.hasLoaded;
                }

                b = 0;
                f && (b = t(f, n), "left" === n.align ? v = w : "right" === n.align && (v = -Math.max(d.axisOffset[1], -b)), f.align({
                  y: n.y,
                  width: f.getBBox().width,
                  align: n.align,
                  x: n.x + v - 2
                }, !0, d.spacingBox), f.placed = d.hasLoaded);
                this.handleCollision(b);
                e.align({
                  verticalAlign: r
                }, !0, d.spacingBox);
                f = e.alignAttr.translateY;
                b = e.getBBox().height + 20;
                t = 0;
                "bottom" === r && (t = (t = d.legend && d.legend.options) && "bottom" === t.verticalAlign && t.enabled && !t.floating ? d.legend.legendHeight + H(t.margin, 10) : 0, b = b + t - 20, t = f - b - (g.floating ? 0 : g.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);
                if ("top" === r) g.floating && (t = 0), d.titleOffset && d.titleOffset[0] && (t = d.titleOffset[0]), t += d.margin[0] - d.spacing[0] || 0;else if ("middle" === r) if (n.y === k.y) t = f;else if (n.y || k.y) t = 0 > n.y || 0 > k.y ? t - Math.min(n.y, k.y) : f - b;
                e.translate(g.x, g.y + Math.floor(t));
                k = this.minInput;
                n = this.maxInput;
                f = this.dropdown;
                g.inputEnabled && k && n && (k.style.marginTop = e.translateY + "px", n.style.marginTop = e.translateY + "px");
                f && (f.style.marginTop = e.translateY + "px");
              }
            };

            b.prototype.alignButtonGroup = function (a, b) {
              var c = this.chart,
                  d = this.buttonGroup,
                  e = this.options.buttonPosition,
                  f = c.plotLeft - c.spacing[3],
                  g = e.x - c.spacing[3];
              "right" === e.align ? g += a - f : "center" === e.align && (g -= f / 2);
              d && d.align({
                y: e.y,
                width: H(b, this.initialButtonGroupWidth),
                align: e.align,
                x: g
              }, !0, c.spacingBox);
            };

            b.prototype.positionButtons = function () {
              var a = this.buttons,
                  b = this.chart,
                  c = this.options,
                  d = this.zoomText,
                  e = b.hasLoaded ? "animate" : "attr",
                  f = c.buttonPosition,
                  g = b.plotLeft,
                  h = g;
              d && "hidden" !== d.visibility && (d[e]({
                x: H(g + f.x, g)
              }), h += f.x + d.getBBox().width + 5);
              this.buttonOptions.forEach(function (b, d) {
                if ("hidden" !== a[d].visibility) a[d][e]({
                  x: h
                }), h += a[d].width + c.buttonSpacing;else a[d][e]({
                  x: g
                });
              });
            };

            b.prototype.handleCollision = function (a) {
              var b = this,
                  c = this.chart,
                  d = this.buttonGroup,
                  e = this.inputGroup,
                  f = this.options,
                  g = f.buttonPosition,
                  h = f.dropdown,
                  k = f.inputPosition;

              f = function f() {
                var a = 0;
                b.buttons.forEach(function (b) {
                  b = b.getBBox();
                  b.width > a && (a = b.width);
                });
                return a;
              };

              var m = function m(b) {
                if (e && d) {
                  var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,
                      f = e.alignOptions.width,
                      h = d.alignAttr.translateX + d.getBBox().x;
                  return h + b > c && c + f > h && g.y < k.y + e.getBBox().height;
                }

                return !1;
              },
                  n = function n() {
                e && d && e.attr({
                  translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),
                  translateY: e.alignAttr.translateY + d.getBBox().height + 10
                });
              };

              if (d) {
                if ("always" === h) {
                  this.collapseButtons(a);
                  m(f()) && n();
                  return;
                }

                "never" === h && this.expandButtons();
              }

              e && d ? k.align === g.align || m(this.initialButtonGroupWidth + 20) ? "responsive" === h ? (this.collapseButtons(a), m(f()) && n()) : n() : "responsive" === h && this.expandButtons() : d && "responsive" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());
            };

            b.prototype.collapseButtons = function (a) {
              var b = this.buttons,
                  c = this.buttonOptions,
                  d = this.chart,
                  e = this.dropdown,
                  f = this.options,
                  g = this.zoomText,
                  h = d.userOptions.rangeSelector && d.userOptions.rangeSelector.buttonTheme || {},
                  k = function k(a) {
                return {
                  text: a ? a + " \u25BE" : "\u25BE",
                  width: "auto",
                  paddingLeft: H(f.buttonTheme.paddingLeft, h.padding, 8),
                  paddingRight: H(f.buttonTheme.paddingRight, h.padding, 8)
                };
              };

              g && g.hide();
              var m = !1;
              c.forEach(function (a, c) {
                c = b[c];
                2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), m = !0);
              });
              m || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));
              c = f.buttonPosition.align;
              this.positionButtons();
              "right" !== c && "center" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);
              this.showDropdown();
            };

            b.prototype.expandButtons = function () {
              var a = this.buttons,
                  b = this.buttonOptions,
                  c = this.options,
                  d = this.zoomText;
              this.hideDropdown();
              d && d.show();
              b.forEach(function (b, d) {
                d = a[d];
                d.show();
                d.attr({
                  text: b.text,
                  width: c.buttonTheme.width || 28,
                  paddingLeft: H(c.buttonTheme.paddingLeft, "unset"),
                  paddingRight: H(c.buttonTheme.paddingRight, "unset")
                });
                2 > d.state && d.setState(0);
              });
              this.positionButtons();
            };

            b.prototype.currentButtonIndex = function () {
              var a = this.dropdown;
              return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;
            };

            b.prototype.showDropdown = function () {
              var b = this.buttonGroup,
                  c = this.buttons,
                  d = this.chart,
                  e = this.dropdown;

              if (b && e) {
                var f = b.translateX;
                b = b.translateY;
                c = c[this.currentButtonIndex()].getBBox();
                a(e, {
                  left: d.plotLeft + f + "px",
                  top: b + .5 + "px",
                  width: c.width + "px",
                  height: c.height + "px"
                });
                this.hasVisibleDropdown = !0;
              }
            };

            b.prototype.hideDropdown = function () {
              var b = this.dropdown;
              b && (a(b, {
                top: "-9999em",
                width: "1px",
                height: "1px"
              }), this.hasVisibleDropdown = !1);
            };

            b.prototype.getHeight = function () {
              var a = this.options,
                  b = this.group,
                  c = a.y,
                  d = a.buttonPosition.y,
                  e = a.inputPosition.y;
              if (a.height) return a.height;
              this.alignElements();
              a = b ? b.getBBox(!0).height + 13 + c : 0;
              b = Math.min(e, d);
              if (0 > e && 0 > d || 0 < e && 0 < d) a += Math.abs(b);
              return a;
            };

            b.prototype.titleCollision = function (a) {
              return !(a.options.title.text || a.options.subtitle.text);
            };

            b.prototype.update = function (a) {
              var b = this.chart;
              L(!0, b.options.rangeSelector, a);
              this.destroy();
              this.init(b);
              this.render();
            };

            b.prototype.destroy = function () {
              var a = this,
                  c = a.minInput,
                  d = a.maxInput;
              a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {
                return a();
              }), a.eventsToUnbind = void 0);
              y(a.buttons);
              c && (c.onfocus = c.onblur = c.onchange = null);
              d && (d.onfocus = d.onblur = d.onchange = null);
              x(a, function (c, d) {
                c && "chart" !== d && (c instanceof D ? c.destroy() : c instanceof window.HTMLElement && n(c));
                c !== b.prototype[d] && (a[d] = null);
              }, this);
            };

            return b;
          }();

          b.prototype.defaultButtons = [{
            type: "month",
            count: 1,
            text: "1m",
            title: "View 1 month"
          }, {
            type: "month",
            count: 3,
            text: "3m",
            title: "View 3 months"
          }, {
            type: "month",
            count: 6,
            text: "6m",
            title: "View 6 months"
          }, {
            type: "ytd",
            text: "YTD",
            title: "View year to date"
          }, {
            type: "year",
            count: 1,
            text: "1y",
            title: "View 1 year"
          }, {
            type: "all",
            text: "All",
            title: "View all"
          }];
          b.prototype.inputTypeFormats = {
            "datetime-local": "%Y-%m-%dT%H:%M:%S",
            date: "%Y-%m-%d",
            time: "%H:%M:%S"
          };

          c.prototype.minFromRange = function () {
            var a = this.range,
                b = a.type,
                c = this.max,
                d = this.chart.time,
                f = function f(a, c) {
              var e = "year" === b ? "FullYear" : "Month",
                  f = new d.Date(a),
                  g = d.get(e, f);
              d.set(e, f, g + c);
              g === d.get(e, f) && d.set("Date", f, 0);
              return f.getTime() - a;
            };

            if (N(a)) {
              var g = c - a;
              var h = a;
            } else g = c + f(c, -a.count), this.chart && (this.chart.fixedRange = c - g);

            var k = H(this.dataMin, Number.MIN_VALUE);
            N(g) || (g = k);
            g <= k && (g = k, "undefined" === typeof h && (h = f(g, a.count)), this.newMax = Math.min(g + h, this.dataMax));
            N(c) || (g = void 0);
            return g;
          };

          if (!E.RangeSelector) {
            var v = [],
                F = function F(a) {
              function b() {
                d && (c = a.xAxis[0].getExtremes(), e = a.legend, g = d && d.options.verticalAlign, N(c.min) && d.render(c.min, c.max), e.display && "top" === g && g === e.options.verticalAlign && (f = L(a.spacingBox), f.y = "vertical" === e.options.layout ? a.plotTop : f.y + d.getHeight(), e.group.placed = !1, e.align(f)));
              }

              var c,
                  d = a.rangeSelector,
                  e,
                  f,
                  g;
              d && (B(v, function (b) {
                return b[0] === a;
              }) || v.push([a, [k(a.xAxis[0], "afterSetExtremes", function (a) {
                d && d.render(a.min, a.max);
              }), k(a, "redraw", b)]]), b());
            };

            k(d, "afterGetContainer", function () {
              this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new b(this));
            });
            k(d, "beforeRender", function () {
              var a = this.axes,
                  b = this.rangeSelector;
              b && (N(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {
                a.updateNames();
                a.setScale();
              }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || ("bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0)));
            });
            k(d, "update", function (a) {
              var c = a.options.rangeSelector;
              a = this.rangeSelector;
              var d = this.extraBottomMargin,
                  e = this.extraTopMargin;
              c && c.enabled && !g(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new b(this));
              this.extraTopMargin = this.extraBottomMargin = !1;
              a && (F(this), c = c && c.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || ("bottom" === c ? this.extraBottomMargin = !0 : "middle" !== c && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== e) && (this.isDirtyBox = !0);
            });
            k(d, "render", function () {
              var a = this.rangeSelector;
              a && !a.options.floating && (a.render(), a = a.options.verticalAlign, "bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0));
            });
            k(d, "getMargins", function () {
              var a = this.rangeSelector;
              a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));
            });
            d.prototype.callbacks.push(F);
            k(d, "destroy", function () {
              for (var a = 0; a < v.length; a++) {
                var b = v[a];

                if (b[0] === this) {
                  b[1].forEach(function (a) {
                    return a();
                  });
                  v.splice(a, 1);
                  break;
                }
              }
            });
            E.RangeSelector = b;
          }

          return b;
        });
        M(d, "Core/Chart/StockChart.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Axis/Axis.js"], d["Core/Chart/Chart.js"], d["Core/FormatUtilities.js"], d["Core/DefaultOptions.js"], d["Core/Color/Palette.js"], d["Core/Series/Point.js"], d["Core/Series/Series.js"], d["Core/Renderer/SVG/SVGRenderer.js"], d["Core/Utilities.js"]], function (c, d, E, G, C, D, K, A, r, k) {
          function h(a, b) {
            return "xAxis" === a ? {
              minPadding: 0,
              maxPadding: 0,
              overscroll: 0,
              ordinal: !0,
              title: {
                text: null
              },
              labels: {
                overflow: "justify"
              },
              showLastLabel: !0
            } : "yAxis" === a ? {
              labels: {
                y: -2
              },
              opposite: e(b.opposite, !0),
              showLastLabel: !(!b.categories && "category" !== b.type),
              title: {
                text: null
              }
            } : {};
          }

          function a(a, b) {
            if ("xAxis" === a) {
              a = t();
              var c = {
                type: "datetime",
                categories: void 0
              };
              e(b.navigator && b.navigator.enabled, a.navigator.enabled, !0) && (c.startOnTick = !1, c.endOnTick = !1);
              return c;
            }

            return {};
          }

          var g = this && this.__extends || function () {
            var _a7 = function a(b, c) {
              _a7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var c in b) {
                  b.hasOwnProperty(c) && (a[c] = b[c]);
                }
              };

              return _a7(b, c);
            };

            return function (b, c) {
              function d() {
                this.constructor = b;
              }

              _a7(b, c);

              b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());
            };
          }(),
              y = c.animObject,
              n = G.format,
              t = C.getOptions,
              B = K.prototype.tooltipFormatter;

          c = A.prototype;
          var m = c.init,
              N = c.processData;
          c = k.addEvent;
          var L = k.arrayMax,
              x = k.arrayMin,
              M = k.clamp,
              H = k.defined,
              w = k.extend,
              f = k.find,
              b = k.isNumber,
              v = k.isString,
              F = k.merge,
              e = k.pick,
              q = k.splat;

          k = function (b) {
            function c() {
              return null !== b && b.apply(this, arguments) || this;
            }

            g(c, b);

            c.prototype.init = function (c, d) {
              var f = t(),
                  g = c.xAxis,
                  l = c.yAxis,
                  k = e(c.navigator && c.navigator.enabled, f.navigator.enabled, !0);
              c.xAxis = c.yAxis = void 0;
              k = F({
                chart: {
                  panning: {
                    enabled: !0,
                    type: "x"
                  },
                  pinchType: "x"
                },
                navigator: {
                  enabled: k
                },
                scrollbar: {
                  enabled: e(f.scrollbar && f.scrollbar.enabled, !0)
                },
                rangeSelector: {
                  enabled: e(f.rangeSelector.enabled, !0)
                },
                title: {
                  text: null
                },
                tooltip: {
                  split: e(f.tooltip.split, !0),
                  crosshairs: !0
                },
                legend: {
                  enabled: !1
                }
              }, c, {
                isStock: !0
              });
              c.xAxis = g;
              c.yAxis = l;
              k.xAxis = q(c.xAxis || {}).map(function (b, d) {
                return F(h("xAxis", b), f.xAxis, f.xAxis && f.xAxis[d], b, a("xAxis", c));
              });
              k.yAxis = q(c.yAxis || {}).map(function (a, b) {
                return F(h("yAxis", a), f.yAxis, f.yAxis && f.yAxis[b], a);
              });
              b.prototype.init.call(this, k, d);
            };

            c.prototype.createAxis = function (c, d) {
              d.axis = F(h(c, d.axis), d.axis, a(c, this.userOptions));
              return b.prototype.createAxis.call(this, c, d);
            };

            return c;
          }(E);

          (function (a) {
            a.stockChart = function (b, c, d) {
              return new a(b, c, d);
            };
          })(k || (k = {}));

          c(A, "setOptions", function (a) {
            var b;
            this.chart.options.isStock && (this.is("column") || this.is("columnrange") ? b = {
              borderWidth: 0,
              shadow: !1
            } : this.is("scatter") || this.is("sma") || (b = {
              marker: {
                enabled: !1,
                radius: 2
              }
            }), b && (a.plotOptions[this.type] = F(a.plotOptions[this.type], b)));
          });
          c(d, "autoLabelAlign", function (a) {
            var b = this.chart,
                c = this.options;
            b = b._labelPanes = b._labelPanes || {};
            var d = this.options.labels;
            this.chart.options.isStock && "yAxis" === this.coll && (c = c.top + "," + c.height, !b[c] && d.enabled && (15 === d.x && (d.x = 0), "undefined" === typeof d.align && (d.align = "right"), b[c] = this, a.align = "right", a.preventDefault()));
          });
          c(d, "destroy", function () {
            var a = this.chart,
                b = this.options && this.options.top + "," + this.options.height;
            b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b];
          });
          c(d, "getPlotLinePath", function (a) {
            function c(a) {
              var c = "xAxis" === a ? "yAxis" : "xAxis";
              a = d.options[c];
              return b(a) ? [h[c][a]] : v(a) ? [h.get(a)] : g.map(function (a) {
                return a[c];
              });
            }

            var d = this,
                g = this.isLinked && !this.series ? this.linkedParent.series : this.series,
                h = d.chart,
                l = h.renderer,
                k = d.left,
                m = d.top,
                n,
                q,
                r,
                t,
                w = [],
                x = [],
                y = a.translatedValue,
                A = a.value,
                B = a.force;

            if (h.options.isStock && !1 !== a.acrossPanes && "xAxis" === d.coll || "yAxis" === d.coll) {
              a.preventDefault();
              x = c(d.coll);
              var C = d.isXAxis ? h.yAxis : h.xAxis;
              C.forEach(function (a) {
                if (H(a.options.id) ? -1 === a.options.id.indexOf("navigator") : 1) {
                  var b = a.isXAxis ? "yAxis" : "xAxis";
                  b = H(a.options[b]) ? h[b][a.options[b]] : h[b][0];
                  d === b && x.push(a);
                }
              });
              var D = x.length ? [] : [d.isXAxis ? h.yAxis[0] : h.xAxis[0]];
              x.forEach(function (a) {
                -1 !== D.indexOf(a) || f(D, function (b) {
                  return b.pos === a.pos && b.len === a.len;
                }) || D.push(a);
              });
              var E = e(y, d.translate(A, null, null, a.old));
              b(E) && (d.horiz ? D.forEach(function (a) {
                var b;
                q = a.pos;
                t = q + a.len;
                n = r = Math.round(E + d.transB);
                "pass" !== B && (n < k || n > k + d.width) && (B ? n = r = M(n, k, k + d.width) : b = !0);
                b || w.push(["M", n, q], ["L", r, t]);
              }) : D.forEach(function (a) {
                var b;
                n = a.pos;
                r = n + a.len;
                q = t = Math.round(m + d.height - E);
                "pass" !== B && (q < m || q > m + d.height) && (B ? q = t = M(q, m, m + d.height) : b = !0);
                b || w.push(["M", n, q], ["L", r, t]);
              }));
              a.path = 0 < w.length ? l.crispPolyLine(w, a.lineWidth || 1) : null;
            }
          });

          r.prototype.crispPolyLine = function (a, b) {
            for (var c = 0; c < a.length; c += 2) {
              var d = a[c],
                  e = a[c + 1];
              d[1] === e[1] && (d[1] = e[1] = Math.round(d[1]) - b % 2 / 2);
              d[2] === e[2] && (d[2] = e[2] = Math.round(d[2]) + b % 2 / 2);
            }

            return a;
          };

          c(d, "afterHideCrosshair", function () {
            this.crossLabel && (this.crossLabel = this.crossLabel.hide());
          });
          c(d, "afterDrawCrosshair", function (a) {
            var c, d;

            if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && b(this.min) && b(this.max)) {
              var f = this.chart,
                  g = this.logarithmic,
                  h = this.crosshair.label,
                  l = this.horiz,
                  k = this.opposite,
                  m = this.left,
                  q = this.top,
                  r = this.crossLabel,
                  t = h.format,
                  v = "",
                  x = "inside" === this.options.tickPosition,
                  y = !1 !== this.crosshair.snap,
                  A = 0,
                  B = a.e || this.cross && this.cross.e;
              a = a.point;
              var C = this.min,
                  E = this.max;
              g && (C = g.lin2log(C), E = g.lin2log(E));
              g = l ? "center" : k ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
              r || (r = this.crossLabel = f.renderer.label("", 0, void 0, h.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (a ? a.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
                align: h.align || g,
                padding: e(h.padding, 8),
                r: e(h.borderRadius, 3),
                zIndex: 2
              }).add(this.labelGroup), f.styledMode || r.attr({
                fill: h.backgroundColor || a && a.series && a.series.color || D.neutralColor60,
                stroke: h.borderColor || "",
                "stroke-width": h.borderWidth || 0
              }).css(w({
                color: D.backgroundColor,
                fontWeight: "normal",
                fontSize: "11px",
                textAlign: "center"
              }, h.style || {})));
              l ? (g = y ? (a.plotX || 0) + m : B.chartX, q += k ? 0 : this.height) : (g = k ? this.width + m : 0, q = y ? (a.plotY || 0) + q : B.chartY);
              t || h.formatter || (this.dateTime && (v = "%b %d, %Y"), t = "{value" + (v ? ":" + v : "") + "}");
              v = y ? this.isXAxis ? a.x : a.y : this.toValue(l ? B.chartX : B.chartY);
              y = a ? a.series.isPointInside(a) : b(v) && v > C && v < E;
              B = "";
              t ? B = n(t, {
                value: v
              }, f) : h.formatter && b(v) && (B = h.formatter.call(this, v));
              r.attr({
                text: B,
                x: g,
                y: q,
                visibility: y ? "visible" : "hidden"
              });
              h = r.getBBox();
              if (b(r.y)) if (l) {
                if (x && !k || !x && k) q = r.y - h.height;
              } else q = r.y - h.height / 2;
              l ? (c = m - h.x, d = m + this.width - h.x) : (c = "left" === this.labelAlign ? m : 0, d = "right" === this.labelAlign ? m + this.width : f.chartWidth);
              r.translateX < c && (A = c - r.translateX);
              r.translateX + h.width >= d && (A = -(r.translateX + h.width - d));
              r.attr({
                x: g + A,
                y: q,
                anchorX: l ? g : this.opposite ? 0 : f.chartWidth,
                anchorY: l ? this.opposite ? f.chartHeight : 0 : q + h.height / 2
              });
            }
          });

          A.prototype.init = function () {
            m.apply(this, arguments);
            this.initCompare(this.options.compare);
          };

          A.prototype.setCompare = function (a) {
            this.initCompare(a);
            this.userOptions.compare = a;
          };

          A.prototype.initCompare = function (a) {
            this.modifyValue = "value" === a || "percent" === a ? function (b, c) {
              var d = this.compareValue;
              return "undefined" !== typeof b && "undefined" !== typeof d ? (b = "value" === a ? b - d : b / d * 100 - (100 === this.options.compareBase ? 0 : 100), c && (c.change = b), b) : 0;
            } : null;
            this.chart.hasRendered && (this.isDirty = !0);
          };

          A.prototype.forceCropping = function () {
            var a = this.chart,
                b = this.options.dataGrouping;
            return !1 !== this.allowDG && b && e(b.enabled, a.options.isStock);
          };

          A.prototype.processData = function (a) {
            var c,
                d = -1,
                e = !0 === this.options.compareStart ? 0 : 1;
            N.apply(this, arguments);

            if (this.xAxis && this.processedYData) {
              var f = this.processedXData;
              var g = this.processedYData;
              var h = g.length;
              this.pointArrayMap && (d = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || "y"));

              for (c = 0; c < h - e; c++) {
                var l = g[c] && -1 < d ? g[c][d] : g[c];

                if (b(l) && f[c + e] >= this.xAxis.min && 0 !== l) {
                  this.compareValue = l;
                  break;
                }
              }
            }
          };

          c(A, "afterGetExtremes", function (a) {
            a = a.dataExtremes;

            if (this.modifyValue && a) {
              var b = [this.modifyValue(a.dataMin), this.modifyValue(a.dataMax)];
              a.dataMin = x(b);
              a.dataMax = L(b);
            }
          });

          d.prototype.setCompare = function (a, b) {
            this.isXAxis || (this.series.forEach(function (b) {
              b.setCompare(a);
            }), e(b, !0) && this.chart.redraw());
          };

          K.prototype.tooltipFormatter = function (a) {
            var b = this.series.chart.numberFormatter;
            a = a.replace("{point.change}", (0 < this.change ? "+" : "") + b(this.change, e(this.series.tooltipOptions.changeDecimals, 2)));
            return B.apply(this, [a]);
          };

          c(A, "render", function () {
            var a = this.chart;

            if (!(a.is3d && a.is3d() || a.polar) && this.xAxis && !this.xAxis.isRadial && !1 !== this.options.clip) {
              var b = this.yAxis.len;

              if (this.xAxis.axisLine) {
                var c = a.plotTop + a.plotHeight - this.yAxis.pos - this.yAxis.len,
                    d = Math.floor(this.xAxis.axisLine.strokeWidth() / 2);
                0 <= c && (b -= Math.max(d - c, 0));
              }

              if (!a.hasLoaded || !this.clipBox && this.isDirty && !this.isDirtyData) this.clipBox = this.clipBox || F(a.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = b;
              a.hasRendered && (c = y(this.options.animation), c = this.getSharedClipKey(c), d = a.sharedClips[c]) && (d.animate({
                width: this.xAxis.len,
                height: b
              }), (a = a.sharedClips[c + "m"]) && a.animate({
                width: this.xAxis.len
              }));
            }
          });
          c(E, "update", function (a) {
            a = a.options;
            "scrollbar" in a && this.navigator && (F(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);
          });
          "";
          return k;
        });
        M(d, "masters/modules/stock.src.js", [d["Core/Globals.js"], d["Core/Axis/OrdinalAxis.js"], d["Core/Scrollbar.js"], d["Core/Chart/StockChart.js"]], function (c, d, E, G) {
          c.Scrollbar = E;
          c.StockChart = c.stockChart = G.stockChart;
          E.compose(c.Axis);
          d.compose(c.Axis, c.Series, c.Chart);
        });
        M(d, "masters/highstock.src.js", [d["masters/highcharts.src.js"]], function (c) {
          c.product = "Highstock";
          return c;
        });
        d["masters/highstock.src.js"]._modules = d;
        return d["masters/highstock.src.js"];
      }); //# sourceMappingURL=highstock.js.map

      /***/

    },

    /***/
    "6n/F":
    /*!***********************************************!*\
      !*** ./node_modules/highcharts/highcharts.js ***!
      \***********************************************/

    /*! no static exports found */

    /***/
    function nF(module, exports, __webpack_require__) {
      "use strict";

      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*
      Highcharts JS v9.2.2 (2021-08-24)
      (c) 2009-2021 Torstein Honsi
      License: www.highcharts.com/license
      */


      (function (aa, M) {
        true && module.exports ? (M["default"] = M, module.exports = aa.document ? M(aa) : M) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return M(aa);
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
      })("undefined" !== typeof window ? window : this, function (aa) {
        function M(r, a, C, E) {
          r.hasOwnProperty(a) || (r[a] = E.apply(null, C));
        }

        var a = {};
        M(a, "Core/Globals.js", [], function () {
          var r = "undefined" !== typeof aa ? aa : "undefined" !== typeof window ? window : {},
              a;

          (function (a) {
            a.SVG_NS = "http://www.w3.org/2000/svg";
            a.product = "Highcharts";
            a.version = "9.2.2";
            a.win = r;
            a.doc = a.win.document;
            a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, "svg").createSVGRect;
            a.userAgent = a.win.navigator && a.win.navigator.userAgent || "";
            a.isChrome = -1 !== a.userAgent.indexOf("Chrome");
            a.isFirefox = -1 !== a.userAgent.indexOf("Firefox");
            a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;
            a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf("Safari");
            a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);
            a.isWebKit = -1 !== a.userAgent.indexOf("AppleWebKit");
            a.deg2rad = 2 * Math.PI / 360;
            a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split("Firefox/")[1], 10);
            a.hasTouch = !!a.win.TouchEvent;
            a.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];

            a.noop = function () {};

            a.supportsPassiveEvents = function () {
              var r = !1;

              if (!a.isMS) {
                var w = Object.defineProperty({}, "passive", {
                  get: function get() {
                    r = !0;
                  }
                });
                a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener("testPassive", a.noop, w), a.win.removeEventListener("testPassive", a.noop, w));
              }

              return r;
            }();

            a.charts = [];
            a.dateFormats = {};
            a.seriesTypes = {};
            a.symbolSizes = {};
            a.chartCount = 0;
          })(a || (a = {}));

          "";
          return a;
        });
        M(a, "Core/Utilities.js", [a["Core/Globals.js"]], function (a) {
          function r(b, d, e, p) {
            var y = d ? "Highcharts error" : "Highcharts warning";
            32 === b && (b = y + ": Deprecated member");
            var F = m(b),
                c = F ? y + " #" + b + ": www.highcharts.com/errors/" + b + "/" : b.toString();

            if ("undefined" !== typeof p) {
              var k = "";
              F && (c += "?");
              I(p, function (b, K) {
                k += "\n - " + K + ": " + b;
                F && (c += encodeURI(K) + "=" + encodeURI(b));
              });
              c += k;
            }

            B(a, "displayError", {
              chart: e,
              code: b,
              message: c,
              params: p
            }, function () {
              if (d) throw Error(c);
              h.console && -1 === r.messages.indexOf(c) && console.warn(c);
            });
            r.messages.push(c);
          }

          function C(b, d) {
            var y = {};
            I(b, function (h, c) {
              if (J(b[c], !0) && !b.nodeType && d[c]) h = C(b[c], d[c]), Object.keys(h).length && (y[c] = h);else if (J(b[c]) || b[c] !== d[c]) y[c] = b[c];
            });
            return y;
          }

          function E(b, d) {
            return parseInt(b, d || 10);
          }

          function z(b) {
            return "string" === typeof b;
          }

          function x(b) {
            b = Object.prototype.toString.call(b);
            return "[object Array]" === b || "[object Array Iterator]" === b;
          }

          function J(b, d) {
            return !!b && "object" === typeof b && (!d || !x(b));
          }

          function u(b) {
            return J(b) && "number" === typeof b.nodeType;
          }

          function n(b) {
            var d = b && b.constructor;
            return !(!J(b, !0) || u(b) || !d || !d.name || "Object" === d.name);
          }

          function m(b) {
            return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
          }

          function g(b) {
            return "undefined" !== typeof b && null !== b;
          }

          function c(b, d, h) {
            var y;
            z(d) ? g(h) ? b.setAttribute(d, h) : b && b.getAttribute && ((y = b.getAttribute(d)) || "class" !== d || (y = b.getAttribute(d + "Name"))) : I(d, function (d, y) {
              b.setAttribute(y, d);
            });
            return y;
          }

          function e(b, d) {
            var y;
            b || (b = {});

            for (y in d) {
              b[y] = d[y];
            }

            return b;
          }

          function l() {
            for (var b = arguments, d = b.length, h = 0; h < d; h++) {
              var c = b[h];
              if ("undefined" !== typeof c && null !== c) return c;
            }
          }

          function f(b, d) {
            a.isMS && !a.svg && d && "undefined" !== typeof d.opacity && (d.filter = "alpha(opacity=" + 100 * d.opacity + ")");
            e(b.style, d);
          }

          function v(b, d, h, c, p) {
            b = t.createElement(b);
            d && e(b, d);
            p && f(b, {
              padding: "0",
              border: "none",
              margin: "0"
            });
            h && f(b, h);
            c && c.appendChild(b);
            return b;
          }

          function q(b, d) {
            return parseFloat(b.toPrecision(d || 14));
          }

          function k(b, d, c) {
            var y = a.getStyle || k;
            if ("width" === d) return d = Math.min(b.offsetWidth, b.scrollWidth), c = b.getBoundingClientRect && b.getBoundingClientRect().width, c < d && c >= d - 1 && (d = Math.floor(c)), Math.max(0, d - (y(b, "padding-left", !0) || 0) - (y(b, "padding-right", !0) || 0));
            if ("height" === d) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (y(b, "padding-top", !0) || 0) - (y(b, "padding-bottom", !0) || 0));
            h.getComputedStyle || r(27, !0);

            if (b = h.getComputedStyle(b, void 0)) {
              var e = b.getPropertyValue(d);
              l(c, "opacity" !== d) && (e = E(e));
            }

            return e;
          }

          function I(b, d, h) {
            for (var y in b) {
              Object.hasOwnProperty.call(b, y) && d.call(h || b[y], b[y], y, b);
            }
          }

          function D(b, d, h) {
            function y(d, H) {
              var K = b.removeEventListener || a.removeEventListenerPolyfill;
              K && K.call(b, d, H, !1);
            }

            function c(h) {
              var H;

              if (b.nodeName) {
                if (d) {
                  var K = {};
                  K[d] = !0;
                } else K = h;

                I(K, function (b, d) {
                  if (h[d]) for (H = h[d].length; H--;) {
                    y(d, h[d][H].fn);
                  }
                });
              }
            }

            var e = "function" === typeof b && b.prototype || b;

            if (Object.hasOwnProperty.call(e, "hcEvents")) {
              var p = e.hcEvents;
              d ? (e = p[d] || [], h ? (p[d] = e.filter(function (b) {
                return h !== b.fn;
              }), y(d, h)) : (c(p), p[d] = [])) : (c(p), delete e.hcEvents);
            }
          }

          function B(b, d, h, c) {
            h = h || {};

            if (t.createEvent && (b.dispatchEvent || b.fireEvent && b !== a)) {
              var y = t.createEvent("Events");
              y.initEvent(d, !0, !0);
              h = e(y, h);
              b.dispatchEvent ? b.dispatchEvent(h) : b.fireEvent(d, h);
            } else if (b.hcEvents) {
              h.target || e(h, {
                preventDefault: function preventDefault() {
                  h.defaultPrevented = !0;
                },
                target: b,
                type: d
              });
              y = [];

              for (var p = b, k = !1; p.hcEvents;) {
                Object.hasOwnProperty.call(p, "hcEvents") && p.hcEvents[d] && (y.length && (k = !0), y.unshift.apply(y, p.hcEvents[d])), p = Object.getPrototypeOf(p);
              }

              k && y.sort(function (b, d) {
                return b.order - d.order;
              });
              y.forEach(function (d) {
                !1 === d.fn.call(b, h) && h.preventDefault();
              });
            }

            c && !h.defaultPrevented && c.call(b, h);
          }

          var O = a.charts,
              t = a.doc,
              h = a.win;
          (r || (r = {})).messages = [];
          var d;

          Math.easeInOutSine = function (b) {
            return -.5 * (Math.cos(Math.PI * b) - 1);
          };

          var b = Array.prototype.find ? function (b, d) {
            return b.find(d);
          } : function (b, d) {
            var h,
                y = b.length;

            for (h = 0; h < y; h++) {
              if (d(b[h], h)) return b[h];
            }
          };
          I({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function (b, d) {
            a[d] = function (h) {
              var y;
              r(32, !1, void 0, (y = {}, y["Highcharts." + d] = "use Array." + b, y));
              return Array.prototype[b].apply(h, [].slice.call(arguments, 1));
            };
          });

          var p,
              G = function () {
            var b = Math.random().toString(36).substring(2, 9) + "-",
                d = 0;
            return function () {
              return "highcharts-" + (p ? "" : b) + d++;
            };
          }();

          h.jQuery && (h.jQuery.fn.highcharts = function () {
            var b = [].slice.call(arguments);
            if (this[0]) return b[0] ? (new a[z(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : O[c(this[0], "data-highcharts-chart")];
          });
          b = {
            addEvent: function addEvent(b, d, h, c) {
              void 0 === c && (c = {});
              var y = "function" === typeof b && b.prototype || b;
              Object.hasOwnProperty.call(y, "hcEvents") || (y.hcEvents = {});
              y = y.hcEvents;
              a.Point && b instanceof a.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
              var p = b.addEventListener || a.addEventListenerPolyfill;
              p && p.call(b, d, h, a.supportsPassiveEvents ? {
                passive: void 0 === c.passive ? -1 !== d.indexOf("touch") : c.passive,
                capture: !1
              } : !1);
              y[d] || (y[d] = []);
              y[d].push({
                fn: h,
                order: "number" === typeof c.order ? c.order : Infinity
              });
              y[d].sort(function (b, d) {
                return b.order - d.order;
              });
              return function () {
                D(b, d, h);
              };
            },
            arrayMax: function arrayMax(b) {
              for (var d = b.length, h = b[0]; d--;) {
                b[d] > h && (h = b[d]);
              }

              return h;
            },
            arrayMin: function arrayMin(b) {
              for (var d = b.length, h = b[0]; d--;) {
                b[d] < h && (h = b[d]);
              }

              return h;
            },
            attr: c,
            clamp: function clamp(b, d, h) {
              return b > d ? b < h ? b : h : d;
            },
            cleanRecursively: C,
            clearTimeout: function (_clearTimeout2) {
              function clearTimeout(_x2) {
                return _clearTimeout2.apply(this, arguments);
              }

              clearTimeout.toString = function () {
                return _clearTimeout2.toString();
              };

              return clearTimeout;
            }(function (b) {
              g(b) && clearTimeout(b);
            }),
            correctFloat: q,
            createElement: v,
            css: f,
            defined: g,
            destroyObjectProperties: function destroyObjectProperties(b, d) {
              I(b, function (h, c) {
                h && h !== d && h.destroy && h.destroy();
                delete b[c];
              });
            },
            discardElement: function discardElement(b) {
              d || (d = v("div"));
              b && d.appendChild(b);
              d.innerHTML = "";
            },
            erase: function erase(b, d) {
              for (var h = b.length; h--;) {
                if (b[h] === d) {
                  b.splice(h, 1);
                  break;
                }
              }
            },
            error: r,
            extend: e,
            extendClass: function extendClass(b, d) {
              var h = function h() {};

              h.prototype = new b();
              e(h.prototype, d);
              return h;
            },
            find: b,
            fireEvent: B,
            getMagnitude: function getMagnitude(b) {
              return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
            },
            getNestedProperty: function getNestedProperty(b, d) {
              for (b = b.split("."); b.length && g(d);) {
                var c = b.shift();
                if ("undefined" === typeof c || "__proto__" === c) return;
                d = d[c];
                if (!g(d) || "function" === typeof d || "number" === typeof d.nodeType || d === h) return;
              }

              return d;
            },
            getStyle: k,
            inArray: function inArray(b, d, h) {
              r(32, !1, void 0, {
                "Highcharts.inArray": "use Array.indexOf"
              });
              return d.indexOf(b, h);
            },
            isArray: x,
            isClass: n,
            isDOMElement: u,
            isFunction: function isFunction(b) {
              return "function" === typeof b;
            },
            isNumber: m,
            isObject: J,
            isString: z,
            keys: function keys(b) {
              r(32, !1, void 0, {
                "Highcharts.keys": "use Object.keys"
              });
              return Object.keys(b);
            },
            merge: function merge() {
              var b,
                  d = arguments,
                  h = {},
                  c = function c(b, d) {
                "object" !== typeof b && (b = {});
                I(d, function (h, H) {
                  "__proto__" !== H && "constructor" !== H && (!J(h, !0) || n(h) || u(h) ? b[H] = d[H] : b[H] = c(b[H] || {}, h));
                });
                return b;
              };

              !0 === d[0] && (h = d[1], d = Array.prototype.slice.call(d, 2));
              var p = d.length;

              for (b = 0; b < p; b++) {
                h = c(h, d[b]);
              }

              return h;
            },
            normalizeTickInterval: function normalizeTickInterval(b, d, h, c, p) {
              var e = b;
              h = l(h, 1);
              var k = b / h;
              d || (d = p ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === c && (1 === h ? d = d.filter(function (b) {
                return 0 === b % 1;
              }) : .1 >= h && (d = [1 / h])));

              for (c = 0; c < d.length && !(e = d[c], p && e * h >= b || !p && k <= (d[c] + (d[c + 1] || d[c])) / 2); c++) {
                ;
              }

              return e = q(e * h, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: I,
            offset: function offset(b) {
              var d = t.documentElement;
              b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
              };
              return {
                top: b.top + (h.pageYOffset || d.scrollTop) - (d.clientTop || 0),
                left: b.left + (h.pageXOffset || d.scrollLeft) - (d.clientLeft || 0),
                width: b.width,
                height: b.height
              };
            },
            pad: function pad(b, d, h) {
              return Array((d || 2) + 1 - String(b).replace("-", "").length).join(h || "0") + b;
            },
            pick: l,
            pInt: E,
            relativeLength: function relativeLength(b, d, h) {
              return /%$/.test(b) ? d * parseFloat(b) / 100 + (h || 0) : parseFloat(b);
            },
            removeEvent: D,
            splat: function splat(b) {
              return x(b) ? b : [b];
            },
            stableSort: function stableSort(b, d) {
              var h = b.length,
                  c,
                  p;

              for (p = 0; p < h; p++) {
                b[p].safeI = p;
              }

              b.sort(function (b, h) {
                c = d(b, h);
                return 0 === c ? b.safeI - h.safeI : c;
              });

              for (p = 0; p < h; p++) {
                delete b[p].safeI;
              }
            },
            syncTimeout: function syncTimeout(b, d, h) {
              if (0 < d) return setTimeout(b, d, h);
              b.call(0, h);
              return -1;
            },
            timeUnits: {
              millisecond: 1,
              second: 1E3,
              minute: 6E4,
              hour: 36E5,
              day: 864E5,
              week: 6048E5,
              month: 24192E5,
              year: 314496E5
            },
            uniqueKey: G,
            useSerialIds: function useSerialIds(b) {
              return p = l(b, p);
            },
            wrap: function wrap(b, d, h) {
              var c = b[d];

              b[d] = function () {
                var b = Array.prototype.slice.call(arguments),
                    d = arguments,
                    p = this;

                p.proceed = function () {
                  c.apply(p, arguments.length ? arguments : d);
                };

                b.unshift(c);
                b = h.apply(this, b);
                p.proceed = null;
                return b;
              };
            }
          };
          "";
          return b;
        });
        M(a, "Core/Color/Palette.js", [], function () {
          return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            backgroundColor: "#ffffff",
            neutralColor100: "#000000",
            neutralColor80: "#333333",
            neutralColor60: "#666666",
            neutralColor40: "#999999",
            neutralColor20: "#cccccc",
            neutralColor10: "#e6e6e6",
            neutralColor5: "#f2f2f2",
            neutralColor3: "#f7f7f7",
            highlightColor100: "#003399",
            highlightColor80: "#335cad",
            highlightColor60: "#6685c2",
            highlightColor20: "#ccd6eb",
            highlightColor10: "#e6ebf5",
            positiveColor: "#06b535",
            negativeColor: "#f21313"
          };
        });
        M(a, "Core/Chart/ChartDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          return {
            panning: {
              enabled: !1,
              type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: a.highlightColor80,
            backgroundColor: a.backgroundColor,
            plotBorderColor: a.neutralColor20
          };
        });
        M(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, w) {
          var r = w.isNumber,
              E = w.merge,
              z = w.pInt;

          w = function () {
            function x(r) {
              this.rgba = [NaN, NaN, NaN, NaN];
              this.input = r;
              var u = a.Color;
              if (u && u !== x) return new u(r);
              if (!(this instanceof x)) return new x(r);
              this.init(r);
            }

            x.parse = function (a) {
              return a ? new x(a) : x.None;
            };

            x.prototype.init = function (a) {
              var u;
              if ("object" === typeof a && "undefined" !== typeof a.stops) this.stops = a.stops.map(function (c) {
                return new x(c[1]);
              });else if ("string" === typeof a) {
                this.input = a = x.names[a.toLowerCase()] || a;

                if ("#" === a.charAt(0)) {
                  var n = a.length;
                  var m = parseInt(a.substr(1), 16);
                  7 === n ? u = [(m & 16711680) >> 16, (m & 65280) >> 8, m & 255, 1] : 4 === n && (u = [(m & 3840) >> 4 | (m & 3840) >> 8, (m & 240) >> 4 | m & 240, (m & 15) << 4 | m & 15, 1]);
                }

                if (!u) for (m = x.parsers.length; m-- && !u;) {
                  var g = x.parsers[m];
                  (n = g.regex.exec(a)) && (u = g.parse(n));
                }
              }
              u && (this.rgba = u);
            };

            x.prototype.get = function (a) {
              var u = this.input,
                  n = this.rgba;

              if ("object" === typeof u && "undefined" !== typeof this.stops) {
                var m = E(u);
                m.stops = [].slice.call(m.stops);
                this.stops.forEach(function (g, c) {
                  m.stops[c] = [m.stops[c][0], g.get(a)];
                });
                return m;
              }

              return n && r(n[0]) ? "rgb" === a || !a && 1 === n[3] ? "rgb(" + n[0] + "," + n[1] + "," + n[2] + ")" : "a" === a ? "" + n[3] : "rgba(" + n.join(",") + ")" : u;
            };

            x.prototype.brighten = function (a) {
              var u = this.rgba;
              if (this.stops) this.stops.forEach(function (m) {
                m.brighten(a);
              });else if (r(a) && 0 !== a) for (var n = 0; 3 > n; n++) {
                u[n] += z(255 * a), 0 > u[n] && (u[n] = 0), 255 < u[n] && (u[n] = 255);
              }
              return this;
            };

            x.prototype.setOpacity = function (a) {
              this.rgba[3] = a;
              return this;
            };

            x.prototype.tweenTo = function (a, u) {
              var n = this.rgba,
                  m = a.rgba;
              if (!r(n[0]) || !r(m[0])) return a.input || "none";
              a = 1 !== m[3] || 1 !== n[3];
              return (a ? "rgba(" : "rgb(") + Math.round(m[0] + (n[0] - m[0]) * (1 - u)) + "," + Math.round(m[1] + (n[1] - m[1]) * (1 - u)) + "," + Math.round(m[2] + (n[2] - m[2]) * (1 - u)) + (a ? "," + (m[3] + (n[3] - m[3]) * (1 - u)) : "") + ")";
            };

            x.names = {
              white: "#ffffff",
              black: "#000000"
            };
            x.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(a) {
                return [z(a[1]), z(a[2]), z(a[3]), parseFloat(a[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(a) {
                return [z(a[1]), z(a[2]), z(a[3]), 1];
              }
            }];
            x.None = new x("");
            return x;
          }();

          "";
          return w;
        });
        M(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, w) {
          var r = a.win,
              E = w.defined,
              z = w.error,
              x = w.extend,
              J = w.isObject,
              u = w.merge,
              n = w.objectEach,
              m = w.pad,
              g = w.pick,
              c = w.splat,
              e = w.timeUnits,
              l = a.isSafari && r.Intl && r.Intl.DateTimeFormat.prototype.formatRange,
              f = a.isSafari && r.Intl && !r.Intl.DateTimeFormat.prototype.formatRange;

          w = function () {
            function v(c) {
              this.options = {};
              this.variableTimezone = this.useUTC = !1;
              this.Date = r.Date;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.update(c);
            }

            v.prototype.get = function (c, e) {
              if (this.variableTimezone || this.timezoneOffset) {
                var k = e.getTime(),
                    f = k - this.getTimezoneOffset(e);
                e.setTime(f);
                c = e["getUTC" + c]();
                e.setTime(k);
                return c;
              }

              return this.useUTC ? e["getUTC" + c]() : e["get" + c]();
            };

            v.prototype.set = function (c, e, f) {
              if (this.variableTimezone || this.timezoneOffset) {
                if ("Milliseconds" === c || "Seconds" === c || "Minutes" === c && 0 === this.getTimezoneOffset(e) % 36E5) return e["setUTC" + c](f);
                var k = this.getTimezoneOffset(e);
                k = e.getTime() - k;
                e.setTime(k);
                e["setUTC" + c](f);
                c = this.getTimezoneOffset(e);
                k = e.getTime() + c;
                return e.setTime(k);
              }

              return this.useUTC || l && "FullYear" === c ? e["setUTC" + c](f) : e["set" + c](f);
            };

            v.prototype.update = function (c) {
              var e = g(c && c.useUTC, !0);
              this.options = c = u(!0, this.options || {}, c);
              this.Date = c.Date || r.Date || Date;
              this.timezoneOffset = (this.useUTC = e) && c.timezoneOffset;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.variableTimezone = e && !(!c.getTimezoneOffset && !c.timezone);
            };

            v.prototype.makeTime = function (c, e, l, v, B, a) {
              if (this.useUTC) {
                var k = this.Date.UTC.apply(0, arguments);
                var h = this.getTimezoneOffset(k);
                k += h;
                var d = this.getTimezoneOffset(k);
                h !== d ? k += d - h : h - 36E5 !== this.getTimezoneOffset(k - 36E5) || f || (k -= 36E5);
              } else k = new this.Date(c, e, g(l, 1), g(v, 0), g(B, 0), g(a, 0)).getTime();

              return k;
            };

            v.prototype.timezoneOffsetFunction = function () {
              var c = this,
                  e = this.options,
                  f = e.moment || r.moment;
              if (!this.useUTC) return function (c) {
                return 6E4 * new Date(c.toString()).getTimezoneOffset();
              };

              if (e.timezone) {
                if (f) return function (c) {
                  return 6E4 * -f.tz(c, e.timezone).utcOffset();
                };
                z(25);
              }

              return this.useUTC && e.getTimezoneOffset ? function (c) {
                return 6E4 * e.getTimezoneOffset(c.valueOf());
              } : function () {
                return 6E4 * (c.timezoneOffset || 0);
              };
            };

            v.prototype.dateFormat = function (c, e, f) {
              if (!E(e) || isNaN(e)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
              c = g(c, "%Y-%m-%d %H:%M:%S");
              var k = this,
                  l = new this.Date(e),
                  q = this.get("Hours", l),
                  t = this.get("Day", l),
                  h = this.get("Date", l),
                  d = this.get("Month", l),
                  b = this.get("FullYear", l),
                  p = a.defaultOptions.lang,
                  G = p && p.weekdays,
                  y = p && p.shortWeekdays;
              l = x({
                a: y ? y[t] : G[t].substr(0, 3),
                A: G[t],
                d: m(h),
                e: m(h, 2, " "),
                w: t,
                b: p.shortMonths[d],
                B: p.months[d],
                m: m(d + 1),
                o: d + 1,
                y: b.toString().substr(2, 2),
                Y: b,
                H: m(q),
                k: q,
                I: m(q % 12 || 12),
                l: q % 12 || 12,
                M: m(this.get("Minutes", l)),
                p: 12 > q ? "AM" : "PM",
                P: 12 > q ? "am" : "pm",
                S: m(l.getSeconds()),
                L: m(Math.floor(e % 1E3), 3)
              }, a.dateFormats);
              n(l, function (b, d) {
                for (; -1 !== c.indexOf("%" + d);) {
                  c = c.replace("%" + d, "function" === typeof b ? b.call(k, e) : b);
                }
              });
              return f ? c.substr(0, 1).toUpperCase() + c.substr(1) : c;
            };

            v.prototype.resolveDTLFormat = function (e) {
              return J(e, !0) ? e : (e = c(e), {
                main: e[0],
                from: e[1],
                to: e[2]
              });
            };

            v.prototype.getTimeTicks = function (c, k, f, l) {
              var q = this,
                  v = [],
                  t = {},
                  h = new q.Date(k),
                  d = c.unitRange,
                  b = c.count || 1,
                  p;
              l = g(l, 1);

              if (E(k)) {
                q.set("Milliseconds", h, d >= e.second ? 0 : b * Math.floor(q.get("Milliseconds", h) / b));
                d >= e.second && q.set("Seconds", h, d >= e.minute ? 0 : b * Math.floor(q.get("Seconds", h) / b));
                d >= e.minute && q.set("Minutes", h, d >= e.hour ? 0 : b * Math.floor(q.get("Minutes", h) / b));
                d >= e.hour && q.set("Hours", h, d >= e.day ? 0 : b * Math.floor(q.get("Hours", h) / b));
                d >= e.day && q.set("Date", h, d >= e.month ? 1 : Math.max(1, b * Math.floor(q.get("Date", h) / b)));

                if (d >= e.month) {
                  q.set("Month", h, d >= e.year ? 0 : b * Math.floor(q.get("Month", h) / b));
                  var G = q.get("FullYear", h);
                }

                d >= e.year && q.set("FullYear", h, G - G % b);
                d === e.week && (G = q.get("Day", h), q.set("Date", h, q.get("Date", h) - G + l + (G < l ? -7 : 0)));
                G = q.get("FullYear", h);
                l = q.get("Month", h);
                var y = q.get("Date", h),
                    a = q.get("Hours", h);
                k = h.getTime();
                !q.variableTimezone && q.useUTC || !E(f) || (p = f - k > 4 * e.month || q.getTimezoneOffset(k) !== q.getTimezoneOffset(f));
                k = h.getTime();

                for (h = 1; k < f;) {
                  v.push(k), k = d === e.year ? q.makeTime(G + h * b, 0) : d === e.month ? q.makeTime(G, l + h * b) : !p || d !== e.day && d !== e.week ? p && d === e.hour && 1 < b ? q.makeTime(G, l, y, a + h * b) : k + d * b : q.makeTime(G, l, y + h * b * (d === e.day ? 1 : 7)), h++;
                }

                v.push(k);
                d <= e.hour && 1E4 > v.length && v.forEach(function (b) {
                  0 === b % 18E5 && "000000000" === q.dateFormat("%H%M%S%L", b) && (t[b] = "day");
                });
              }

              v.info = x(c, {
                higherRanks: t,
                totalRange: d * b
              });
              return v;
            };

            v.prototype.getDateFormat = function (c, k, f, g) {
              var l = this.dateFormat("%m-%d %H:%M:%S.%L", k),
                  q = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
              },
                  t = "millisecond";

              for (h in e) {
                if (c === e.week && +this.dateFormat("%w", k) === f && "00:00:00.000" === l.substr(6)) {
                  var h = "week";
                  break;
                }

                if (e[h] > c) {
                  h = t;
                  break;
                }

                if (q[h] && l.substr(q[h]) !== "01-01 00:00:00.000".substr(q[h])) break;
                "week" !== h && (t = h);
              }

              if (h) var d = this.resolveDTLFormat(g[h]).main;
              return d;
            };

            return v;
          }();

          "";
          return w;
        });
        M(a, "Core/DefaultOptions.js", [a["Core/Chart/ChartDefaults.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Time.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x) {
          w = w.parse;
          var r = x.merge,
              u = {
            colors: E.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
              loading: "Loading...",
              months: "January February March April May June July August September October November December".split(" "),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
              weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
              decimalPoint: ".",
              numericSymbols: "kMGTPE".split(""),
              resetZoom: "Reset zoom",
              resetZoomTitle: "Reset zoom level 1:1",
              thousandsSep: " "
            },
            global: {},
            time: {
              Date: void 0,
              getTimezoneOffset: void 0,
              timezone: void 0,
              timezoneOffset: 0,
              useUTC: !0
            },
            chart: a,
            title: {
              text: "Chart title",
              align: "center",
              margin: 15,
              widthAdjust: -44
            },
            subtitle: {
              text: "",
              align: "center",
              widthAdjust: -44
            },
            caption: {
              margin: 15,
              text: "",
              align: "left",
              verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
              style: {
                position: "absolute",
                color: E.neutralColor80
              }
            },
            legend: {
              enabled: !0,
              align: "center",
              alignColumns: !0,
              className: "highcharts-no-tooltip",
              layout: "horizontal",
              labelFormatter: function labelFormatter() {
                return this.name;
              },
              borderColor: E.neutralColor40,
              borderRadius: 0,
              navigation: {
                activeColor: E.highlightColor100,
                inactiveColor: E.neutralColor20
              },
              itemStyle: {
                color: E.neutralColor80,
                cursor: "pointer",
                fontSize: "12px",
                fontWeight: "bold",
                textOverflow: "ellipsis"
              },
              itemHoverStyle: {
                color: E.neutralColor100
              },
              itemHiddenStyle: {
                color: E.neutralColor20
              },
              shadow: !1,
              itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
              },
              squareSymbol: !0,
              symbolPadding: 5,
              verticalAlign: "bottom",
              x: 0,
              y: 0,
              title: {
                style: {
                  fontWeight: "bold"
                }
              }
            },
            loading: {
              labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
              },
              style: {
                position: "absolute",
                backgroundColor: E.backgroundColor,
                opacity: .5,
                textAlign: "center"
              }
            },
            tooltip: {
              enabled: !0,
              animation: C.svg,
              borderRadius: 3,
              dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
              },
              footerFormat: "",
              headerShape: "callout",
              hideDelay: 500,
              padding: 8,
              shape: "callout",
              shared: !1,
              snap: C.isTouchDevice ? 25 : 10,
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
              backgroundColor: w(E.neutralColor3).setOpacity(.85).get(),
              borderWidth: 1,
              shadow: !0,
              stickOnContact: !1,
              style: {
                color: E.neutralColor80,
                cursor: "default",
                fontSize: "12px",
                whiteSpace: "nowrap"
              },
              useHTML: !1
            },
            credits: {
              enabled: !0,
              href: "https://www.highcharts.com?credits",
              position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
              },
              style: {
                cursor: "pointer",
                color: E.neutralColor40,
                fontSize: "9px"
              },
              text: "Highcharts.com"
            }
          };
          u.chart.styledMode = !1;
          "";
          var n = new z(r(u.global, u.time));
          a = {
            defaultOptions: u,
            defaultTime: n,
            getOptions: function getOptions() {
              return u;
            },
            setOptions: function setOptions(a) {
              r(!0, u, a);
              if (a.time || a.global) C.time ? C.time.update(r(u.global, u.time, a.global, a.time)) : C.time = n;
              return u;
            }
          };
          "";
          return a;
        });
        M(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = a.parse,
              z = w.win,
              x = C.isNumber,
              J = C.objectEach;
          return function () {
            function a(a, m, g) {
              this.pos = NaN;
              this.options = m;
              this.elem = a;
              this.prop = g;
            }

            a.prototype.dSetter = function () {
              var a = this.paths,
                  m = a && a[0];
              a = a && a[1];
              var g = this.now || 0,
                  c = [];
              if (1 !== g && m && a) {
                if (m.length === a.length && 1 > g) for (var e = 0; e < a.length; e++) {
                  for (var l = m[e], f = a[e], v = [], q = 0; q < f.length; q++) {
                    var k = l[q],
                        I = f[q];
                    x(k) && x(I) && ("A" !== f[0] || 4 !== q && 5 !== q) ? v[q] = k + g * (I - k) : v[q] = I;
                  }

                  c.push(v);
                } else c = a;
              } else c = this.toD || [];
              this.elem.attr("d", c, void 0, !0);
            };

            a.prototype.update = function () {
              var a = this.elem,
                  m = this.prop,
                  g = this.now,
                  c = this.options.step;
              if (this[m + "Setter"]) this[m + "Setter"]();else a.attr ? a.element && a.attr(m, g, null, !0) : a.style[m] = g + this.unit;
              c && c.call(a, g, this);
            };

            a.prototype.run = function (n, m, g) {
              var c = this,
                  e = c.options,
                  l = function l(e) {
                return l.stopped ? !1 : c.step(e);
              },
                  f = z.requestAnimationFrame || function (c) {
                setTimeout(c, 13);
              },
                  v = function v() {
                for (var c = 0; c < a.timers.length; c++) {
                  a.timers[c]() || a.timers.splice(c--, 1);
                }

                a.timers.length && f(v);
              };

              n !== m || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = n, this.end = m, this.unit = g, this.now = this.start, this.pos = 0, l.elem = this.elem, l.prop = this.prop, l() && 1 === a.timers.push(l) && f(v)) : (delete e.curAnim[this.prop], e.complete && 0 === Object.keys(e.curAnim).length && e.complete.call(this.elem));
            };

            a.prototype.step = function (a) {
              var m = +new Date(),
                  g = this.options,
                  c = this.elem,
                  e = g.complete,
                  l = g.duration,
                  f = g.curAnim;
              if (c.attr && !c.element) a = !1;else if (a || m >= l + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                var v = f[this.prop] = !0;
                J(f, function (c) {
                  !0 !== c && (v = !1);
                });
                v && e && e.call(c);
                a = !1;
              } else this.pos = g.easing((m - this.startTime) / l), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0;
              return a;
            };

            a.prototype.initPath = function (a, m, g) {
              function c(c, e) {
                for (; c.length < D;) {
                  var f = c[0],
                      h = e[D - c.length];
                  h && "M" === f[0] && (c[0] = "C" === h[0] ? ["C", f[1], f[2], f[1], f[2], f[1], f[2]] : ["L", f[1], f[2]]);
                  c.unshift(f);
                  v && (f = c.pop(), c.push(c[c.length - 1], f));
                }
              }

              function e(c, e) {
                for (; c.length < D;) {
                  if (e = c[Math.floor(c.length / q) - 1].slice(), "C" === e[0] && (e[1] = e[5], e[2] = e[6]), v) {
                    var f = c[Math.floor(c.length / q)].slice();
                    c.splice(c.length / 2, 0, e, f);
                  } else c.push(e);
                }
              }

              var l = a.startX,
                  f = a.endX;
              g = g.slice();
              var v = a.isArea,
                  q = v ? 2 : 1;
              m = m && m.slice();
              if (!m) return [g, g];

              if (l && f && f.length) {
                for (a = 0; a < l.length; a++) {
                  if (l[a] === f[0]) {
                    var k = a;
                    break;
                  } else if (l[0] === f[f.length - l.length + a]) {
                    k = a;
                    var I = !0;
                    break;
                  } else if (l[l.length - 1] === f[f.length - l.length + a]) {
                    k = l.length - a;
                    break;
                  }
                }

                "undefined" === typeof k && (m = []);
              }

              if (m.length && x(k)) {
                var D = g.length + k * q;
                I ? (c(m, g), e(g, m)) : (c(g, m), e(m, g));
              }

              return [m, g];
            };

            a.prototype.fillSetter = function () {
              a.prototype.strokeSetter.apply(this, arguments);
            };

            a.prototype.strokeSetter = function () {
              this.elem.attr(this.prop, r(this.start).tweenTo(r(this.end), this.pos), null, !0);
            };

            a.timers = [];
            return a;
          }();
        });
        M(a, "Core/Animation/AnimationUtilities.js", [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]], function (a, w) {
          function r(c) {
            return n(c) ? m({
              duration: 500,
              defer: 0
            }, c) : {
              duration: c ? 500 : 0,
              defer: 0
            };
          }

          function E(c, g) {
            for (var e = a.timers.length; e--;) {
              a.timers[e].elem !== c || g && g !== a.timers[e].prop || (a.timers[e].stopped = !0);
            }
          }

          var z = w.defined,
              x = w.getStyle,
              J = w.isArray,
              u = w.isNumber,
              n = w.isObject,
              m = w.merge,
              g = w.objectEach,
              c = w.pick;
          return {
            animate: function animate(c, l, f) {
              var e,
                  q = "",
                  k,
                  I;

              if (!n(f)) {
                var D = arguments;
                f = {
                  duration: D[2],
                  easing: D[3],
                  complete: D[4]
                };
              }

              u(f.duration) || (f.duration = 400);
              f.easing = "function" === typeof f.easing ? f.easing : Math[f.easing] || Math.easeInOutSine;
              f.curAnim = m(l);
              g(l, function (g, v) {
                E(c, v);
                I = new a(c, f, v);
                k = void 0;
                "d" === v && J(l.d) ? (I.paths = I.initPath(c, c.pathArray, l.d), I.toD = l.d, e = 0, k = 1) : c.attr ? e = c.attr(v) : (e = parseFloat(x(c, v)) || 0, "opacity" !== v && (q = "px"));
                k || (k = g);
                "string" === typeof k && k.match("px") && (k = k.replace(/px/g, ""));
                I.run(e, k, q);
              });
            },
            animObject: r,
            getDeferredAnimation: function getDeferredAnimation(c, g, f) {
              var e = r(g),
                  a = 0,
                  k = 0;
              (f ? [f] : c.series).forEach(function (c) {
                c = r(c.options.animation);
                a = g && z(g.defer) ? e.defer : Math.max(a, c.duration + c.defer);
                k = Math.min(e.duration, c.duration);
              });
              c.renderer.forExport && (a = 0);
              return {
                defer: Math.max(0, a - k),
                duration: Math.min(a, k)
              };
            },
            setAnimation: function setAnimation(e, g) {
              g.renderer.globalAnimation = c(e, g.options.chart.animation, !0);
            },
            stop: E
          };
        });
        M(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, w) {
          var r = a.SVG_NS,
              E = w.attr,
              z = w.createElement,
              x = w.discardElement,
              J = w.error,
              u = w.isString,
              n = w.objectEach,
              m = w.splat;

          try {
            var g = !!new DOMParser().parseFromString("", "text/html");
          } catch (c) {
            g = !1;
          }

          w = function () {
            function c(c) {
              this.nodes = "string" === typeof c ? this.parseMarkup(c) : c;
            }

            c.filterUserAttributes = function (e) {
              n(e, function (g, f) {
                var a = !0;
                -1 === c.allowedAttributes.indexOf(f) && (a = !1);
                -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(f) && (a = u(g) && c.allowedReferences.some(function (c) {
                  return 0 === g.indexOf(c);
                }));
                a || (J("Highcharts warning: Invalid attribute '" + f + "' in config"), delete e[f]);
              });
              return e;
            };

            c.setElementHTML = function (e, g) {
              e.innerHTML = "";
              g && new c(g).addToDOM(e);
            };

            c.prototype.addToDOM = function (e) {
              function g(e, l) {
                var f;
                m(e).forEach(function (e) {
                  var k = e.tagName,
                      q = e.textContent ? a.doc.createTextNode(e.textContent) : void 0;
                  if (k) if ("#text" === k) var v = q;else if (-1 !== c.allowedTags.indexOf(k)) {
                    k = a.doc.createElementNS("svg" === k ? r : l.namespaceURI || r, k);
                    var m = e.attributes || {};
                    n(e, function (c, h) {
                      "tagName" !== h && "attributes" !== h && "children" !== h && "textContent" !== h && (m[h] = c);
                    });
                    E(k, c.filterUserAttributes(m));
                    q && k.appendChild(q);
                    g(e.children || [], k);
                    v = k;
                  } else J("Highcharts warning: Invalid tagName '" + k + "' in config");
                  v && l.appendChild(v);
                  f = v;
                });
                return f;
              }

              return g(this.nodes, e);
            };

            c.prototype.parseMarkup = function (c) {
              var e = [];
              c = c.trim();
              if (g) c = new DOMParser().parseFromString(c, "text/html");else {
                var f = z("div");
                f.innerHTML = c;
                c = {
                  body: f
                };
              }

              var a = function a(c, e) {
                var f = c.nodeName.toLowerCase(),
                    k = {
                  tagName: f
                };
                "#text" === f && (k.textContent = c.textContent || "");

                if (f = c.attributes) {
                  var g = {};
                  [].forEach.call(f, function (c) {
                    g[c.name] = c.value;
                  });
                  k.attributes = g;
                }

                if (c.childNodes.length) {
                  var l = [];
                  [].forEach.call(c.childNodes, function (c) {
                    a(c, l);
                  });
                  l.length && (k.children = l);
                }

                e.push(k);
              };

              [].forEach.call(c.body.childNodes, function (c) {
                return a(c, e);
              });
              f && x(f);
              return e;
            };

            c.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            c.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            c.allowedTags = "a b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            return c;
          }();

          "";
          return w;
        });
        M(a, "Core/FormatUtilities.js", [a["Core/DefaultOptions.js"], a["Core/Utilities.js"]], function (a, w) {
          function r(a, g, c, e) {
            a = +a || 0;
            g = +g;
            var l = E.lang,
                f = (a.toString().split(".")[1] || "").split("e")[0].length,
                v = a.toString().split("e"),
                q = g;
            if (-1 === g) g = Math.min(f, 20);else if (!J(g)) g = 2;else if (g && v[1] && 0 > v[1]) {
              var k = g + +v[1];
              0 <= k ? (v[0] = (+v[0]).toExponential(k).split("e")[0], g = k) : (v[0] = v[0].split(".")[0] || 0, a = 20 > g ? (v[0] * Math.pow(10, v[1])).toFixed(g) : 0, v[1] = 0);
            }
            k = (Math.abs(v[1] ? v[0] : a) + Math.pow(10, -Math.max(g, f) - 1)).toFixed(g);
            f = String(n(k));
            var m = 3 < f.length ? f.length % 3 : 0;
            c = u(c, l.decimalPoint);
            e = u(e, l.thousandsSep);
            a = (0 > a ? "-" : "") + (m ? f.substr(0, m) + e : "");
            a = 0 > +v[1] && !q ? "0" : a + f.substr(m).replace(/(\d{3})(?=\d)/g, "$1" + e);
            g && (a += c + k.slice(-g));
            v[1] && 0 !== +a && (a += "e" + v[1]);
            return a;
          }

          var E = a.defaultOptions,
              z = a.defaultTime,
              x = w.getNestedProperty,
              J = w.isNumber,
              u = w.pick,
              n = w.pInt;
          return {
            dateFormat: function dateFormat(a, g, c) {
              return z.dateFormat(a, g, c);
            },
            format: function format(a, g, c) {
              var e = "{",
                  l = !1,
                  f = /f$/,
                  v = /\.([0-9])/,
                  q = E.lang,
                  k = c && c.time || z;
              c = c && c.numberFormatter || r;

              for (var m = []; a;) {
                var D = a.indexOf(e);
                if (-1 === D) break;
                var B = a.slice(0, D);

                if (l) {
                  B = B.split(":");
                  e = x(B.shift() || "", g);
                  if (B.length && "number" === typeof e) if (B = B.join(":"), f.test(B)) {
                    var u = parseInt((B.match(v) || ["", "-1"])[1], 10);
                    null !== e && (e = c(e, u, q.decimalPoint, -1 < B.indexOf(",") ? q.thousandsSep : ""));
                  } else e = k.dateFormat(B, e);
                  m.push(e);
                } else m.push(B);

                a = a.slice(D + 1);
                e = (l = !l) ? "}" : "{";
              }

              m.push(a);
              return m.join("");
            },
            numberFormat: r
          };
        });
        M(a, "Core/Renderer/RendererUtilities.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.clamp,
              C = a.pick,
              E = a.stableSort,
              z;

          (function (a) {
            function x(a, n, m) {
              var g = a,
                  c = g.reducedLen || n,
                  e = function e(c, _e) {
                return (_e.rank || 0) - (c.rank || 0);
              },
                  l = function l(c, e) {
                return c.target - e.target;
              },
                  f,
                  v = !0,
                  q = [],
                  k = 0;

              for (f = a.length; f--;) {
                k += a[f].size;
              }

              if (k > c) {
                E(a, e);

                for (k = f = 0; k <= c;) {
                  k += a[f].size, f++;
                }

                q = a.splice(f - 1, a.length);
              }

              E(a, l);

              for (a = a.map(function (c) {
                return {
                  size: c.size,
                  targets: [c.target],
                  align: C(c.align, .5)
                };
              }); v;) {
                for (f = a.length; f--;) {
                  c = a[f], e = (Math.min.apply(0, c.targets) + Math.max.apply(0, c.targets)) / 2, c.pos = r(e - c.size * c.align, 0, n - c.size);
                }

                f = a.length;

                for (v = !1; f--;) {
                  0 < f && a[f - 1].pos + a[f - 1].size > a[f].pos && (a[f - 1].size += a[f].size, a[f - 1].targets = a[f - 1].targets.concat(a[f].targets), a[f - 1].align = .5, a[f - 1].pos + a[f - 1].size > n && (a[f - 1].pos = n - a[f - 1].size), a.splice(f, 1), v = !0);
                }
              }

              g.push.apply(g, q);
              f = 0;
              a.some(function (c) {
                var e = 0;
                return (c.targets || []).some(function () {
                  g[f].pos = c.pos + e;
                  if ("undefined" !== typeof m && Math.abs(g[f].pos - g[f].target) > m) return g.slice(0, f + 1).forEach(function (c) {
                    return delete c.pos;
                  }), g.reducedLen = (g.reducedLen || n) - .1 * n, g.reducedLen > .1 * n && x(g, n, m), !0;
                  e += g[f].size;
                  f++;
                  return !1;
                });
              });
              E(g, l);
              return g;
            }

            a.distribute = x;
          })(z || (z = {}));

          return z;
        });
        M(a, "Core/Renderer/SVG/SVGElement.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x) {
          var r = a.animate,
              u = a.animObject,
              n = a.stop,
              m = E.deg2rad,
              g = E.doc,
              c = E.noop,
              e = E.svg,
              l = E.SVG_NS,
              f = E.win,
              v = x.addEvent,
              q = x.attr,
              k = x.createElement,
              I = x.css,
              D = x.defined,
              B = x.erase,
              O = x.extend,
              t = x.fireEvent,
              h = x.isArray,
              d = x.isFunction,
              b = x.isNumber,
              p = x.isString,
              G = x.merge,
              y = x.objectEach,
              L = x.pick,
              F = x.pInt,
              P = x.syncTimeout,
              S = x.uniqueKey;

          a = function () {
            function a() {
              this.element = void 0;
              this.onEvents = {};
              this.opacity = 1;
              this.renderer = void 0;
              this.SVG_NS = l;
              this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }

            a.prototype._defaultGetter = function (b) {
              b = L(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
              /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
              return b;
            };

            a.prototype._defaultSetter = function (b, d, c) {
              c.setAttribute(d, b);
            };

            a.prototype.add = function (b) {
              var d = this.renderer,
                  c = this.element;
              b && (this.parentGroup = b);
              this.parentInverted = b && b.inverted;
              "undefined" !== typeof this.textStr && "text" === this.element.nodeName && d.buildText(this);
              this.added = !0;
              if (!b || b.handleZ || this.zIndex) var K = this.zIndexSetter();
              K || (b ? b.element : d.box).appendChild(c);
              if (this.onAdd) this.onAdd();
              return this;
            };

            a.prototype.addClass = function (b, d) {
              var c = d ? "" : this.attr("class") || "";
              b = (b || "").split(/ /g).reduce(function (b, d) {
                -1 === c.indexOf(d) && b.push(d);
                return b;
              }, c ? [c] : []).join(" ");
              b !== c && this.attr("class", b);
              return this;
            };

            a.prototype.afterSetters = function () {
              this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };

            a.prototype.align = function (b, d, c) {
              var K = {},
                  h = this.renderer,
                  H = h.alignedObjects,
                  a,
                  e,
                  A;

              if (b) {
                if (this.alignOptions = b, this.alignByTranslate = d, !c || p(c)) this.alignTo = a = c || "renderer", B(H, this), H.push(this), c = void 0;
              } else b = this.alignOptions, d = this.alignByTranslate, a = this.alignTo;

              c = L(c, h[a], "scrollablePlotBox" === a ? h.plotBox : void 0, h);
              a = b.align;
              var f = b.verticalAlign;
              h = (c.x || 0) + (b.x || 0);
              H = (c.y || 0) + (b.y || 0);
              "right" === a ? e = 1 : "center" === a && (e = 2);
              e && (h += (c.width - (b.width || 0)) / e);
              K[d ? "translateX" : "x"] = Math.round(h);
              "bottom" === f ? A = 1 : "middle" === f && (A = 2);
              A && (H += (c.height - (b.height || 0)) / A);
              K[d ? "translateY" : "y"] = Math.round(H);
              this[this.placed ? "animate" : "attr"](K);
              this.placed = !0;
              this.alignAttr = K;
              return this;
            };

            a.prototype.alignSetter = function (b) {
              var d = {
                left: "start",
                center: "middle",
                right: "end"
              };
              d[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", d[b]));
            };

            a.prototype.animate = function (b, d, c) {
              var h = this,
                  H = u(L(d, this.renderer.globalAnimation, !0));
              d = H.defer;
              L(g.hidden, g.msHidden, g.webkitHidden, !1) && (H.duration = 0);
              0 !== H.duration ? (c && (H.complete = c), P(function () {
                h.element && r(h, b, H);
              }, d)) : (this.attr(b, void 0, c), y(b, function (b, d) {
                H.step && H.step.call(this, b, {
                  prop: d,
                  pos: 1,
                  elem: this
                });
              }, this));
              return this;
            };

            a.prototype.applyTextOutline = function (b) {
              var d = this.element;
              -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(d.style.fill)));
              var c = b.split(" ");
              b = c[c.length - 1];

              if ((c = c[0]) && "none" !== c && E.svg) {
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                c = c.replace(/(^[\d\.]+)(.*?)$/g, function (b, d, c) {
                  return 2 * Number(d) + c;
                });
                this.removeTextOutline();
                var h = g.createElementNS(l, "tspan");
                q(h, {
                  "class": "highcharts-text-outline",
                  fill: b,
                  stroke: b,
                  "stroke-width": c,
                  "stroke-linejoin": "round"
                });
                [].forEach.call(d.childNodes, function (b) {
                  var d = b.cloneNode(!0);
                  d.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
                    return d.removeAttribute(b);
                  });
                  h.appendChild(d);
                });
                var a = g.createElementNS(l, "tspan");
                a.textContent = "\u200B";
                ["x", "y"].forEach(function (b) {
                  var c = d.getAttribute(b);
                  c && a.setAttribute(b, c);
                });
                h.appendChild(a);
                d.insertBefore(h, d.firstChild);
              }
            };

            a.prototype.attr = function (b, d, c, h) {
              var K = this.element,
                  H = this.symbolCustomAttribs,
                  a,
                  e = this,
                  A,
                  p;

              if ("string" === typeof b && "undefined" !== typeof d) {
                var f = b;
                b = {};
                b[f] = d;
              }

              "string" === typeof b ? e = (this[b + "Getter"] || this._defaultGetter).call(this, b, K) : (y(b, function (d, c) {
                A = !1;
                h || n(this, c);
                this.symbolName && -1 !== H.indexOf(c) && (a || (this.symbolAttr(b), a = !0), A = !0);
                !this.rotation || "x" !== c && "y" !== c || (this.doTransform = !0);
                A || (p = this[c + "Setter"] || this._defaultSetter, p.call(this, d, c, K), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) && this.updateShadows(c, d, p));
              }, this), this.afterSetters());
              c && c.call(this);
              return e;
            };

            a.prototype.clip = function (b) {
              return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
            };

            a.prototype.crisp = function (b, d) {
              d = d || b.strokeWidth || 0;
              var c = Math.round(d) % 2 / 2;
              b.x = Math.floor(b.x || this.x || 0) + c;
              b.y = Math.floor(b.y || this.y || 0) + c;
              b.width = Math.floor((b.width || this.width || 0) - 2 * c);
              b.height = Math.floor((b.height || this.height || 0) - 2 * c);
              D(b.strokeWidth) && (b.strokeWidth = d);
              return b;
            };

            a.prototype.complexColor = function (b, d, c) {
              var K = this.renderer,
                  a,
                  H,
                  e,
                  p,
                  A,
                  f,
                  k,
                  g,
                  l,
                  q,
                  v = [],
                  F;
              t(this.renderer, "complexColor", {
                args: arguments
              }, function () {
                b.radialGradient ? H = "radialGradient" : b.linearGradient && (H = "linearGradient");

                if (H) {
                  e = b[H];
                  A = K.gradients;
                  f = b.stops;
                  l = c.radialReference;
                  h(e) && (b[H] = e = {
                    x1: e[0],
                    y1: e[1],
                    x2: e[2],
                    y2: e[3],
                    gradientUnits: "userSpaceOnUse"
                  });
                  "radialGradient" === H && l && !D(e.gradientUnits) && (p = e, e = G(e, K.getRadialAttr(l, p), {
                    gradientUnits: "userSpaceOnUse"
                  }));
                  y(e, function (b, d) {
                    "id" !== d && v.push(d, b);
                  });
                  y(f, function (b) {
                    v.push(b);
                  });
                  v = v.join(",");
                  if (A[v]) q = A[v].attr("id");else {
                    e.id = q = S();
                    var N = A[v] = K.createElement(H).attr(e).add(K.defs);
                    N.radAttr = p;
                    N.stops = [];
                    f.forEach(function (b) {
                      0 === b[1].indexOf("rgba") ? (a = C.parse(b[1]), k = a.get("rgb"), g = a.get("a")) : (k = b[1], g = 1);
                      b = K.createElement("stop").attr({
                        offset: b[0],
                        "stop-color": k,
                        "stop-opacity": g
                      }).add(N);
                      N.stops.push(b);
                    });
                  }
                  F = "url(" + K.url + "#" + q + ")";
                  c.setAttribute(d, F);
                  c.gradient = v;

                  b.toString = function () {
                    return F;
                  };
                }
              });
            };

            a.prototype.css = function (b) {
              var d = this.styles,
                  c = {},
                  h = this.element,
                  a = ["textOutline", "textOverflow", "width"],
                  p = "",
                  f = !d;
              b && b.color && (b.fill = b.color);
              d && y(b, function (b, h) {
                d && d[h] !== b && (c[h] = b, f = !0);
              });

              if (f) {
                d && (b = O(d, c));
                if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === h.nodeName.toLowerCase() && b.width) var k = this.textWidth = F(b.width);
                this.styles = b;
                k && !e && this.renderer.forExport && delete b.width;

                if (h.namespaceURI === this.SVG_NS) {
                  var A = function A(b, d) {
                    return "-" + d.toLowerCase();
                  };

                  y(b, function (b, d) {
                    -1 === a.indexOf(d) && (p += d.replace(/([A-Z])/g, A) + ":" + b + ";");
                  });
                  p && q(h, "style", p);
                } else I(h, b);

                this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
              }

              return this;
            };

            a.prototype.dashstyleSetter = function (b) {
              var d = this["stroke-width"];
              "inherit" === d && (d = 1);

              if (b = b && b.toLowerCase()) {
                var c = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

                for (b = c.length; b--;) {
                  c[b] = "" + F(c[b]) * L(d, NaN);
                }

                b = c.join(",").replace(/NaN/g, "none");
                this.element.setAttribute("stroke-dasharray", b);
              }
            };

            a.prototype.destroy = function () {
              var b = this,
                  d = b.element || {},
                  c = b.renderer,
                  h = d.ownerSVGElement,
                  a = c.isSVG && "SPAN" === d.nodeName && b.parentGroup || void 0;
              d.onclick = d.onmouseout = d.onmouseover = d.onmousemove = d.point = null;
              n(b);

              if (b.clipPath && h) {
                var e = b.clipPath;
                [].forEach.call(h.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
                  -1 < b.getAttribute("clip-path").indexOf(e.element.id) && b.removeAttribute("clip-path");
                });
                b.clipPath = e.destroy();
              }

              if (b.stops) {
                for (h = 0; h < b.stops.length; h++) {
                  b.stops[h].destroy();
                }

                b.stops.length = 0;
                b.stops = void 0;
              }

              b.safeRemoveChild(d);

              for (c.styledMode || b.destroyShadows(); a && a.div && 0 === a.div.childNodes.length;) {
                d = a.parentGroup, b.safeRemoveChild(a.div), delete a.div, a = d;
              }

              b.alignTo && B(c.alignedObjects, b);
              y(b, function (d, c) {
                b[c] && b[c].parentGroup === b && b[c].destroy && b[c].destroy();
                delete b[c];
              });
            };

            a.prototype.destroyShadows = function () {
              (this.shadows || []).forEach(function (b) {
                this.safeRemoveChild(b);
              }, this);
              this.shadows = void 0;
            };

            a.prototype.destroyTextPath = function (b, d) {
              var c = b.getElementsByTagName("text")[0];

              if (c) {
                if (c.removeAttribute("dx"), c.removeAttribute("dy"), d.element.setAttribute("id", ""), this.textPathWrapper && c.getElementsByTagName("textPath").length) {
                  for (b = this.textPathWrapper.element.childNodes; b.length;) {
                    c.appendChild(b[0]);
                  }

                  c.removeChild(this.textPathWrapper.element);
                }
              } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");

              this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };

            a.prototype.dSetter = function (b, d, c) {
              h(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, d, c) {
                return d && d.join ? (c ? b + " " : "") + d.join(" ") : (d || "").toString();
              }, ""));
              /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
              this[d] !== b && (c.setAttribute(d, b), this[d] = b);
            };

            a.prototype.fadeOut = function (b) {
              var d = this;
              d.animate({
                opacity: 0
              }, {
                duration: L(b, 150),
                complete: function complete() {
                  d.attr({
                    y: -9999
                  }).hide();
                }
              });
            };

            a.prototype.fillSetter = function (b, d, c) {
              "string" === typeof b ? c.setAttribute(d, b) : b && this.complexColor(b, d, c);
            };

            a.prototype.getBBox = function (b, c) {
              var h = this.renderer,
                  K = this.element,
                  e = this.styles,
                  p = this.textStr,
                  f = h.cache,
                  k = h.cacheKeys,
                  A = K.namespaceURI === this.SVG_NS;
              c = L(c, this.rotation, 0);
              var g = h.styledMode ? K && a.prototype.getStyle.call(K, "font-size") : e && e.fontSize,
                  y;

              if (D(p)) {
                var G = p.toString();
                -1 === G.indexOf("<") && (G = G.replace(/[0-9]/g, "0"));
                G += ["", c, g, this.textWidth, e && e.textOverflow, e && e.fontWeight].join();
              }

              G && !b && (y = f[G]);

              if (!y) {
                if (A || h.forExport) {
                  try {
                    var l = this.fakeTS && function (b) {
                      var d = K.querySelector(".highcharts-text-outline");
                      d && I(d, {
                        display: b
                      });
                    };

                    d(l) && l("none");
                    y = K.getBBox ? O({}, K.getBBox()) : {
                      width: K.offsetWidth,
                      height: K.offsetHeight
                    };
                    d(l) && l("");
                  } catch (Y) {
                    "";
                  }

                  if (!y || 0 > y.width) y = {
                    width: 0,
                    height: 0
                  };
                } else y = this.htmlGetBBox();

                h.isSVG && (b = y.width, h = y.height, A && (y.height = h = {
                  "11px,17": 14,
                  "13px,20": 16
                }[e && e.fontSize + "," + Math.round(h)] || h), c && (e = c * m, y.width = Math.abs(h * Math.sin(e)) + Math.abs(b * Math.cos(e)), y.height = Math.abs(h * Math.cos(e)) + Math.abs(b * Math.sin(e))));

                if (G && ("" === p || 0 < y.height)) {
                  for (; 250 < k.length;) {
                    delete f[k.shift()];
                  }

                  f[G] || k.push(G);
                  f[G] = y;
                }
              }

              return y;
            };

            a.prototype.getStyle = function (b) {
              return f.getComputedStyle(this.element || this, "").getPropertyValue(b);
            };

            a.prototype.hasClass = function (b) {
              return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
            };

            a.prototype.hide = function (b) {
              b ? this.attr({
                y: -9999
              }) : this.attr({
                visibility: "hidden"
              });
              return this;
            };

            a.prototype.htmlGetBBox = function () {
              return {
                height: 0,
                width: 0,
                x: 0,
                y: 0
              };
            };

            a.prototype.init = function (b, d) {
              this.element = "span" === d ? k(d) : g.createElementNS(this.SVG_NS, d);
              this.renderer = b;
              t(this, "afterInit");
            };

            a.prototype.invert = function (b) {
              this.inverted = b;
              this.updateTransform();
              return this;
            };

            a.prototype.on = function (b, d) {
              var c = this.onEvents;
              if (c[b]) c[b]();
              c[b] = v(this.element, b, d);
              return this;
            };

            a.prototype.opacitySetter = function (b, d, c) {
              this.opacity = b = Number(Number(b).toFixed(3));
              c.setAttribute(d, b);
            };

            a.prototype.removeClass = function (b) {
              return this.attr("class", ("" + this.attr("class")).replace(p(b) ? new RegExp("(^| )" + b + "( |$)") : b, " ").replace(/ +/g, " ").trim());
            };

            a.prototype.removeTextOutline = function () {
              var b = this.element.querySelector("tspan.highcharts-text-outline");
              b && this.safeRemoveChild(b);
            };

            a.prototype.safeRemoveChild = function (b) {
              var d = b.parentNode;
              d && d.removeChild(b);
            };

            a.prototype.setRadialReference = function (b) {
              var d = this.element.gradient && this.renderer.gradients[this.element.gradient];
              this.element.radialReference = b;
              d && d.radAttr && d.animate(this.renderer.getRadialAttr(b, d.radAttr));
              return this;
            };

            a.prototype.setTextPath = function (d, h) {
              var a = this.element,
                  K = this.text ? this.text.element : a,
                  e = {
                textAnchor: "text-anchor"
              },
                  p = !1,
                  f = this.textPathWrapper,
                  k = !f;
              h = G(!0, {
                enabled: !0,
                attributes: {
                  dy: -5,
                  startOffset: "50%",
                  textAnchor: "middle"
                }
              }, h);
              var A = w.filterUserAttributes(h.attributes);

              if (d && h && h.enabled) {
                f && null === f.element.parentNode ? (k = !0, f = f.destroy()) : f && this.removeTextOutline.call(f.parentGroup);
                this.options && this.options.padding && (A.dx = -this.options.padding);
                f || (this.textPathWrapper = f = this.renderer.createElement("textPath"), p = !0);
                var g = f.element;
                (h = d.element.getAttribute("id")) || d.element.setAttribute("id", h = S());
                if (k) for (K.setAttribute("y", 0), b(A.dx) && K.setAttribute("x", -A.dx), d = [].slice.call(K.childNodes), k = 0; k < d.length; k++) {
                  var l = d[k];
                  l.nodeType !== Node.TEXT_NODE && "tspan" !== l.nodeName || g.appendChild(l);
                }
                p && f && f.add({
                  element: K
                });
                g.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + h);
                D(A.dy) && (g.parentNode.setAttribute("dy", A.dy), delete A.dy);
                D(A.dx) && (g.parentNode.setAttribute("dx", A.dx), delete A.dx);
                y(A, function (b, d) {
                  g.setAttribute(e[d] || d, b);
                });
                a.removeAttribute("transform");
                this.removeTextOutline.call(f);
                this.text && !this.renderer.styledMode && this.attr({
                  fill: "none",
                  "stroke-width": 0
                });
                this.applyTextOutline = this.updateTransform = c;
              } else f && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(a, d), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

              return this;
            };

            a.prototype.shadow = function (b, d, c) {
              var h = [],
                  a = this.element,
                  e = this.oldShadowOptions,
                  H = {
                color: z.neutralColor100,
                offsetX: this.parentInverted ? -1 : 1,
                offsetY: this.parentInverted ? -1 : 1,
                opacity: .15,
                width: 3
              },
                  p = !1,
                  A;
              !0 === b ? A = H : "object" === typeof b && (A = O(H, b));
              A && (A && e && y(A, function (b, d) {
                b !== e[d] && (p = !0);
              }), p && this.destroyShadows(), this.oldShadowOptions = A);
              if (!A) this.destroyShadows();else if (!this.shadows) {
                var f = A.opacity / A.width;
                var k = this.parentInverted ? "translate(" + A.offsetY + ", " + A.offsetX + ")" : "translate(" + A.offsetX + ", " + A.offsetY + ")";

                for (H = 1; H <= A.width; H++) {
                  var g = a.cloneNode(!1);
                  var G = 2 * A.width + 1 - 2 * H;
                  q(g, {
                    stroke: b.color || z.neutralColor100,
                    "stroke-opacity": f * H,
                    "stroke-width": G,
                    transform: k,
                    fill: "none"
                  });
                  g.setAttribute("class", (g.getAttribute("class") || "") + " highcharts-shadow");
                  c && (q(g, "height", Math.max(q(g, "height") - G, 0)), g.cutHeight = G);
                  d ? d.element.appendChild(g) : a.parentNode && a.parentNode.insertBefore(g, a);
                  h.push(g);
                }

                this.shadows = h;
              }
              return this;
            };

            a.prototype.show = function (b) {
              return this.attr({
                visibility: b ? "inherit" : "visible"
              });
            };

            a.prototype.strokeSetter = function (b, d, c) {
              this[d] = b;
              this.stroke && this["stroke-width"] ? (a.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === d && 0 === b && this.hasStroke ? (c.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
            };

            a.prototype.strokeWidth = function () {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              var b = this.getStyle("stroke-width"),
                  d = 0;
              if (b.indexOf("px") === b.length - 2) d = F(b);else if ("" !== b) {
                var c = g.createElementNS(l, "rect");
                q(c, {
                  width: b,
                  "stroke-width": 0
                });
                this.element.parentNode.appendChild(c);
                d = c.getBBox().width;
                c.parentNode.removeChild(c);
              }
              return d;
            };

            a.prototype.symbolAttr = function (b) {
              var d = this;
              "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (c) {
                d[c] = L(b[c], d[c]);
              });
              d.attr({
                d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)
              });
            };

            a.prototype.textSetter = function (b) {
              b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
            };

            a.prototype.titleSetter = function (b) {
              var d = this.element,
                  c = d.getElementsByTagName("title")[0] || g.createElementNS(this.SVG_NS, "title");
              d.insertBefore ? d.insertBefore(c, d.firstChild) : d.appendChild(c);
              c.textContent = String(L(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };

            a.prototype.toFront = function () {
              var b = this.element;
              b.parentNode.appendChild(b);
              return this;
            };

            a.prototype.translate = function (b, d) {
              return this.attr({
                translateX: b,
                translateY: d
              });
            };

            a.prototype.updateShadows = function (b, d, c) {
              var h = this.shadows;
              if (h) for (var a = h.length; a--;) {
                c.call(h[a], "height" === b ? Math.max(d - (h[a].cutHeight || 0), 0) : "d" === b ? this.d : d, b, h[a]);
              }
            };

            a.prototype.updateTransform = function () {
              var b = this.scaleX,
                  d = this.scaleY,
                  c = this.inverted,
                  h = this.rotation,
                  a = this.matrix,
                  e = this.element,
                  p = this.translateX || 0,
                  f = this.translateY || 0;
              c && (p += this.width, f += this.height);
              p = ["translate(" + p + "," + f + ")"];
              D(a) && p.push("matrix(" + a.join(",") + ")");
              c ? p.push("rotate(90) scale(-1,1)") : h && p.push("rotate(" + h + " " + L(this.rotationOriginX, e.getAttribute("x"), 0) + " " + L(this.rotationOriginY, e.getAttribute("y") || 0) + ")");
              (D(b) || D(d)) && p.push("scale(" + L(b, 1) + " " + L(d, 1) + ")");
              p.length && e.setAttribute("transform", p.join(" "));
            };

            a.prototype.visibilitySetter = function (b, d, c) {
              "inherit" === b ? c.removeAttribute(d) : this[d] !== b && c.setAttribute(d, b);
              this[d] = b;
            };

            a.prototype.xGetter = function (b) {
              "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
              return this._defaultGetter(b);
            };

            a.prototype.zIndexSetter = function (b, d) {
              var c = this.renderer,
                  h = this.parentGroup,
                  a = (h || c).element || c.box,
                  e = this.element;
              c = a === c.box;
              var p = !1;
              var f = this.added;
              var A;
              D(b) ? (e.setAttribute("data-z-index", b), b = +b, this[d] === b && (f = !1)) : D(this[d]) && e.removeAttribute("data-z-index");
              this[d] = b;

              if (f) {
                (b = this.zIndex) && h && (h.handleZ = !0);
                d = a.childNodes;

                for (A = d.length - 1; 0 <= A && !p; A--) {
                  h = d[A];
                  f = h.getAttribute("data-z-index");
                  var k = !D(f);
                  if (h !== e) if (0 > b && k && !c && !A) a.insertBefore(e, d[A]), p = !0;else if (F(f) <= b || k && (!D(b) || 0 <= b)) a.insertBefore(e, d[A + 1] || null), p = !0;
                }

                p || (a.insertBefore(e, d[c ? 3 : 0] || null), p = !0);
              }

              return p;
            };

            return a;
          }();

          a.prototype["stroke-widthSetter"] = a.prototype.strokeSetter;
          a.prototype.yGetter = a.prototype.xGetter;

          a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function (b, d) {
            this[d] = b;
            this.doTransform = !0;
          };

          "";
          return a;
        });
        M(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function (a) {
          var r;

          (function (r) {
            r.rendererTypes = {};
            var w;

            r.getRendererType = function (a) {
              void 0 === a && (a = w);
              return r.rendererTypes[a] || r.rendererTypes[w];
            };

            r.registerRendererType = function (C, x, E) {
              r.rendererTypes[C] = x;
              if (!w || E) w = C, a.Renderer = x;
            };
          })(r || (r = {}));

          return r;
        });
        M(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, w) {
          var r = this && this.__extends || function () {
            var _a8 = function a(g, c) {
              _a8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, a) {
                c.__proto__ = a;
              } || function (c, a) {
                for (var e in a) {
                  a.hasOwnProperty(e) && (c[e] = a[e]);
                }
              };

              return _a8(g, c);
            };

            return function (g, c) {
              function e() {
                this.constructor = g;
              }

              _a8(g, c);

              g.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());
            };
          }(),
              E = w.defined,
              z = w.extend,
              x = w.isNumber,
              J = w.merge,
              u = w.pick,
              n = w.removeEvent;

          return function (m) {
            function g(c, a, l, f, v, q, k, I, D, B) {
              var e = m.call(this) || this;
              e.paddingLeftSetter = e.paddingSetter;
              e.paddingRightSetter = e.paddingSetter;
              e.init(c, "g");
              e.textStr = a;
              e.x = l;
              e.y = f;
              e.anchorX = q;
              e.anchorY = k;
              e.baseline = D;
              e.className = B;
              e.addClass("button" === B ? "highcharts-no-tooltip" : "highcharts-label");
              B && e.addClass("highcharts-" + B);
              e.text = c.text(void 0, 0, 0, I).attr({
                zIndex: 1
              });
              var t;
              "string" === typeof v && ((t = /^url\((.*?)\)$/.test(v)) || e.renderer.symbols[v]) && (e.symbolKey = v);
              e.bBox = g.emptyBBox;
              e.padding = 3;
              e.baselineOffset = 0;
              e.needsBox = c.styledMode || t;
              e.deferredAttr = {};
              e.alignFactor = 0;
              return e;
            }

            r(g, m);

            g.prototype.alignSetter = function (c) {
              c = {
                left: 0,
                center: .5,
                right: 1
              }[c];
              c !== this.alignFactor && (this.alignFactor = c, this.bBox && x(this.xSetting) && this.attr({
                x: this.xSetting
              }));
            };

            g.prototype.anchorXSetter = function (c, a) {
              this.anchorX = c;
              this.boxAttr(a, Math.round(c) - this.getCrispAdjust() - this.xSetting);
            };

            g.prototype.anchorYSetter = function (c, a) {
              this.anchorY = c;
              this.boxAttr(a, c - this.ySetting);
            };

            g.prototype.boxAttr = function (c, a) {
              this.box ? this.box.attr(c, a) : this.deferredAttr[c] = a;
            };

            g.prototype.css = function (c) {
              if (c) {
                var e = {};
                c = J(c);
                g.textProps.forEach(function (a) {
                  "undefined" !== typeof c[a] && (e[a] = c[a], delete c[a]);
                });
                this.text.css(e);
                var l = ("width" in e);
                "fontSize" in e || "fontWeight" in e ? this.updateTextPadding() : l && this.updateBoxSize();
              }

              return a.prototype.css.call(this, c);
            };

            g.prototype.destroy = function () {
              n(this.element, "mouseenter");
              n(this.element, "mouseleave");
              this.text && this.text.destroy();
              this.box && (this.box = this.box.destroy());
              a.prototype.destroy.call(this);
            };

            g.prototype.fillSetter = function (c, a) {
              c && (this.needsBox = !0);
              this.fill = c;
              this.boxAttr(a, c);
            };

            g.prototype.getBBox = function () {
              this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
              var c = this.padding,
                  a = u(this.paddingLeft, c);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - a,
                y: this.bBox.y - c
              };
            };

            g.prototype.getCrispAdjust = function () {
              return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };

            g.prototype.heightSetter = function (c) {
              this.heightSetting = c;
            };

            g.prototype.onAdd = function () {
              var c = this.textStr;
              this.text.add(this);
              this.attr({
                text: E(c) ? c : "",
                x: this.x,
                y: this.y
              });
              this.box && E(this.anchorX) && this.attr({
                anchorX: this.anchorX,
                anchorY: this.anchorY
              });
            };

            g.prototype.paddingSetter = function (c, a) {
              x(c) ? c !== this[a] && (this[a] = c, this.updateTextPadding()) : this[a] = void 0;
            };

            g.prototype.rSetter = function (c, a) {
              this.boxAttr(a, c);
            };

            g.prototype.shadow = function (c) {
              c && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(c));
              return this;
            };

            g.prototype.strokeSetter = function (c, a) {
              this.stroke = c;
              this.boxAttr(a, c);
            };

            g.prototype["stroke-widthSetter"] = function (c, a) {
              c && (this.needsBox = !0);
              this["stroke-width"] = c;
              this.boxAttr(a, c);
            };

            g.prototype["text-alignSetter"] = function (c) {
              this.textAlign = c;
            };

            g.prototype.textSetter = function (c) {
              "undefined" !== typeof c && this.text.attr({
                text: c
              });
              this.updateTextPadding();
            };

            g.prototype.updateBoxSize = function () {
              var c = this.text.element.style,
                  a = {},
                  l = this.padding,
                  f = this.bBox = x(this.widthSetting) && x(this.heightSetting) && !this.textAlign || !E(this.text.textStr) ? g.emptyBBox : this.text.getBBox();
              this.width = this.getPaddedWidth();
              this.height = (this.heightSetting || f.height || 0) + 2 * l;
              c = this.renderer.fontMetrics(c && c.fontSize, this.text);
              this.baselineOffset = l + Math.min((this.text.firstLineMetrics || c).b, f.height || Infinity);
              this.heightSetting && (this.baselineOffset += (this.heightSetting - c.h) / 2);
              this.needsBox && (this.box || (l = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), l.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), l.add(this)), l = this.getCrispAdjust(), a.x = l, a.y = (this.baseline ? -this.baselineOffset : 0) + l, a.width = Math.round(this.width), a.height = Math.round(this.height), this.box.attr(z(a, this.deferredAttr)), this.deferredAttr = {});
            };

            g.prototype.updateTextPadding = function () {
              var c = this.text;
              this.updateBoxSize();
              var a = this.baseline ? 0 : this.baselineOffset,
                  g = u(this.paddingLeft, this.padding);
              E(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (g += {
                center: .5,
                right: 1
              }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (g !== c.x || a !== c.y) c.attr("x", g), c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0)), "undefined" !== typeof a && c.attr("y", a);
              c.x = g;
              c.y = a;
            };

            g.prototype.widthSetter = function (c) {
              this.widthSetting = x(c) ? c : void 0;
            };

            g.prototype.getPaddedWidth = function () {
              var c = this.padding,
                  a = u(this.paddingLeft, c);
              c = u(this.paddingRight, c);
              return (this.widthSetting || this.bBox.width || 0) + a + c;
            };

            g.prototype.xSetter = function (c) {
              this.x = c;
              this.alignFactor && (c -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
              this.xSetting = Math.round(c);
              this.attr("translateX", this.xSetting);
            };

            g.prototype.ySetter = function (c) {
              this.ySetting = this.y = Math.round(c);
              this.attr("translateY", this.ySetting);
            };

            g.emptyBBox = {
              width: 0,
              height: 0,
              x: 0,
              y: 0
            };
            g.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return g;
          }(a);
        });
        M(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function (a) {
          function r(a, n, m, g, c) {
            var e = [];

            if (c) {
              var l = c.start || 0,
                  f = J(c.r, m);
              m = J(c.r, g || m);
              var v = (c.end || 0) - .001;
              g = c.innerR;
              var q = J(c.open, .001 > Math.abs((c.end || 0) - l - 2 * Math.PI)),
                  k = Math.cos(l),
                  I = Math.sin(l),
                  D = Math.cos(v),
                  B = Math.sin(v);
              l = J(c.longArc, .001 > v - l - Math.PI ? 0 : 1);
              e.push(["M", a + f * k, n + m * I], ["A", f, m, 0, l, J(c.clockwise, 1), a + f * D, n + m * B]);
              z(g) && e.push(q ? ["M", a + g * D, n + g * B] : ["L", a + g * D, n + g * B], ["A", g, g, 0, l, z(c.clockwise) ? 1 - c.clockwise : 0, a + g * k, n + g * I]);
              q || e.push(["Z"]);
            }

            return e;
          }

          function C(a, n, m, g, c) {
            return c && c.r ? E(a, n, m, g, c) : [["M", a, n], ["L", a + m, n], ["L", a + m, n + g], ["L", a, n + g], ["Z"]];
          }

          function E(a, n, m, g, c) {
            c = c && c.r || 0;
            return [["M", a + c, n], ["L", a + m - c, n], ["C", a + m, n, a + m, n, a + m, n + c], ["L", a + m, n + g - c], ["C", a + m, n + g, a + m, n + g, a + m - c, n + g], ["L", a + c, n + g], ["C", a, n + g, a, n + g, a, n + g - c], ["L", a, n + c], ["C", a, n, a, n, a + c, n]];
          }

          var z = a.defined,
              x = a.isNumber,
              J = a.pick;
          return {
            arc: r,
            callout: function callout(a, n, m, g, c) {
              var e = Math.min(c && c.r || 0, m, g),
                  l = e + 6,
                  f = c && c.anchorX;
              c = c && c.anchorY || 0;
              var v = E(a, n, m, g, {
                r: e
              });
              if (!x(f)) return v;
              a + f >= m ? c > n + l && c < n + g - l ? v.splice(3, 1, ["L", a + m, c - 6], ["L", a + m + 6, c], ["L", a + m, c + 6], ["L", a + m, n + g - e]) : v.splice(3, 1, ["L", a + m, g / 2], ["L", f, c], ["L", a + m, g / 2], ["L", a + m, n + g - e]) : 0 >= a + f ? c > n + l && c < n + g - l ? v.splice(7, 1, ["L", a, c + 6], ["L", a - 6, c], ["L", a, c - 6], ["L", a, n + e]) : v.splice(7, 1, ["L", a, g / 2], ["L", f, c], ["L", a, g / 2], ["L", a, n + e]) : c && c > g && f > a + l && f < a + m - l ? v.splice(5, 1, ["L", f + 6, n + g], ["L", f, n + g + 6], ["L", f - 6, n + g], ["L", a + e, n + g]) : c && 0 > c && f > a + l && f < a + m - l && v.splice(1, 1, ["L", f - 6, n], ["L", f, n - 6], ["L", f + 6, n], ["L", m - e, n]);
              return v;
            },
            circle: function circle(a, n, m, g) {
              return r(a + m / 2, n + g / 2, m / 2, g / 2, {
                start: .5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1
              });
            },
            diamond: function diamond(a, n, m, g) {
              return [["M", a + m / 2, n], ["L", a + m, n + g / 2], ["L", a + m / 2, n + g], ["L", a, n + g / 2], ["Z"]];
            },
            rect: C,
            roundedRect: E,
            square: C,
            triangle: function triangle(a, n, m, g) {
              return [["M", a + m / 2, n], ["L", a + m, n + g], ["L", a, n + g], ["Z"]];
            },
            "triangle-down": function triangleDown(a, n, m, g) {
              return [["M", a, n], ["L", a + m, n], ["L", a + m / 2, n + g], ["Z"]];
            }
          };
        });
        M(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = w.doc,
              z = w.SVG_NS,
              x = C.attr,
              J = C.isString,
              u = C.objectEach,
              n = C.pick;
          return function () {
            function m(a) {
              var c = a.styles;
              this.renderer = a.renderer;
              this.svgElement = a;
              this.width = a.textWidth;
              this.textLineHeight = c && c.lineHeight;
              this.textOutline = c && c.textOutline;
              this.ellipsis = !(!c || "ellipsis" !== c.textOverflow);
              this.noWrap = !(!c || "nowrap" !== c.whiteSpace);
              this.fontSize = c && c.fontSize;
            }

            m.prototype.buildSVG = function () {
              var g = this.svgElement,
                  c = g.element,
                  e = g.renderer,
                  l = n(g.textStr, "").toString(),
                  f = -1 !== l.indexOf("<"),
                  v = c.childNodes;
              e = this.width && !g.added && e.box;
              var q = /<br.*?>/g,
                  k = [l, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();

              if (k !== g.textCache) {
                g.textCache = k;
                delete g.actualWidth;

                for (k = v.length; k--;) {
                  c.removeChild(v[k]);
                }

                f || this.ellipsis || this.width || -1 !== l.indexOf(" ") && (!this.noWrap || q.test(l)) ? "" !== l && (e && e.appendChild(c), l = new a(l), this.modifyTree(l.nodes), l.addToDOM(g.element), this.modifyDOM(), this.ellipsis && -1 !== (c.textContent || "").indexOf("\u2026") && g.attr("title", this.unescapeEntities(g.textStr || "", ["&lt;", "&gt;"])), e && e.removeChild(c)) : c.appendChild(r.createTextNode(this.unescapeEntities(l)));
                J(this.textOutline) && g.applyTextOutline && g.applyTextOutline(this.textOutline);
              }
            };

            m.prototype.modifyDOM = function () {
              var a = this,
                  c = this.svgElement,
                  e = x(c.element, "x");
              c.firstLineMetrics = void 0;

              for (var l; l = c.element.firstChild;) {
                if (/^[\s\u200B]*$/.test(l.textContent || " ")) c.element.removeChild(l);else break;
              }

              [].forEach.call(c.element.querySelectorAll("tspan.highcharts-br"), function (f, g) {
                f.nextSibling && f.previousSibling && (0 === g && 1 === f.previousSibling.nodeType && (c.firstLineMetrics = c.renderer.fontMetrics(void 0, f.previousSibling)), x(f, {
                  dy: a.getLineHeight(f.nextSibling),
                  x: e
                }));
              });
              var f = this.width || 0;

              if (f) {
                var v = function v(k, g) {
                  var l = k.textContent || "",
                      q = l.replace(/([^\^])-/g, "$1- ").split(" "),
                      v = !a.noWrap && (1 < q.length || 1 < c.element.childNodes.length),
                      t = a.getLineHeight(g),
                      h = 0,
                      d = c.actualWidth;
                  if (a.ellipsis) l && a.truncate(k, l, void 0, 0, Math.max(0, f - parseInt(a.fontSize || 12, 10)), function (b, d) {
                    return b.substring(0, d) + "\u2026";
                  });else if (v) {
                    l = [];

                    for (v = []; g.firstChild && g.firstChild !== k;) {
                      v.push(g.firstChild), g.removeChild(g.firstChild);
                    }

                    for (; q.length;) {
                      q.length && !a.noWrap && 0 < h && (l.push(k.textContent || ""), k.textContent = q.join(" ").replace(/- /g, "-")), a.truncate(k, void 0, q, 0 === h ? d || 0 : 0, f, function (b, d) {
                        return q.slice(0, d).join(" ").replace(/- /g, "-");
                      }), d = c.actualWidth, h++;
                    }

                    v.forEach(function (b) {
                      g.insertBefore(b, k);
                    });
                    l.forEach(function (b) {
                      g.insertBefore(r.createTextNode(b), k);
                      b = r.createElementNS(z, "tspan");
                      b.textContent = "\u200B";
                      x(b, {
                        dy: t,
                        x: e
                      });
                      g.insertBefore(b, k);
                    });
                  }
                },
                    q = function q(a) {
                  [].slice.call(a.childNodes).forEach(function (e) {
                    e.nodeType === Node.TEXT_NODE ? v(e, a) : (-1 !== e.className.baseVal.indexOf("highcharts-br") && (c.actualWidth = 0), q(e));
                  });
                };

                q(c.element);
              }
            };

            m.prototype.getLineHeight = function (a) {
              var c;
              a = a.nodeType === Node.TEXT_NODE ? a.parentElement : a;
              this.renderer.styledMode || (c = a && /(px|em)$/.test(a.style.fontSize) ? a.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
              return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(c, a || this.svgElement.element).h;
            };

            m.prototype.modifyTree = function (a) {
              var c = this,
                  e = function e(g, f) {
                var l = g.tagName,
                    q = c.renderer.styledMode,
                    k = g.attributes || {};
                if ("b" === l || "strong" === l) q ? k["class"] = "highcharts-strong" : k.style = "font-weight:bold;" + (k.style || "");else if ("i" === l || "em" === l) q ? k["class"] = "highcharts-emphasized" : k.style = "font-style:italic;" + (k.style || "");
                J(k.style) && (k.style = k.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
                "br" === l && (k["class"] = "highcharts-br", g.textContent = "\u200B", (f = a[f + 1]) && f.textContent && (f.textContent = f.textContent.replace(/^ +/gm, "")));
                "#text" !== l && "a" !== l && (g.tagName = "tspan");
                g.attributes = k;
                g.children && g.children.filter(function (c) {
                  return "#text" !== c.tagName;
                }).forEach(e);
              };

              a.forEach(e);
            };

            m.prototype.truncate = function (a, c, e, l, f, v) {
              var g = this.svgElement,
                  k = g.renderer,
                  m = g.rotation,
                  D = [],
                  B = e ? 1 : 0,
                  n = (c || e || "").length,
                  t = n,
                  h,
                  d = function d(b, _d) {
                _d = _d || b;
                var h = a.parentNode;
                if (h && "undefined" === typeof D[_d]) if (h.getSubStringLength) try {
                  D[_d] = l + h.getSubStringLength(0, e ? _d + 1 : _d);
                } catch (L) {
                  "";
                } else k.getSpanWidth && (a.textContent = v(c || e, b), D[_d] = l + k.getSpanWidth(g, a));
                return D[_d];
              };

              g.rotation = 0;
              var b = d(a.textContent.length);

              if (l + b > f) {
                for (; B <= n;) {
                  t = Math.ceil((B + n) / 2), e && (h = v(e, t)), b = d(t, h && h.length - 1), B === n ? B = n + 1 : b > f ? n = t - 1 : B = t;
                }

                0 === n ? a.textContent = "" : c && n === c.length - 1 || (a.textContent = h || v(c || e, t));
              }

              e && e.splice(0, t);
              g.actualWidth = b;
              g.rotation = m;
            };

            m.prototype.unescapeEntities = function (a, c) {
              u(this.renderer.escapes, function (e, g) {
                c && -1 !== c.indexOf(e) || (a = a.toString().replace(new RegExp(e, "g"), g));
              });
              return a;
            };

            return m;
          }();
        });
        M(a, "Core/Renderer/SVG/SVGRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGLabel.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Renderer/SVG/TextBuilder.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x, J, u, n, m) {
          var g = C.charts,
              c = C.deg2rad,
              e = C.doc,
              l = C.isFirefox,
              f = C.isMS,
              v = C.isWebKit,
              q = C.noop,
              k = C.SVG_NS,
              I = C.symbolSizes,
              D = C.win,
              B = m.addEvent,
              r = m.attr,
              t = m.createElement,
              h = m.css,
              d = m.defined,
              b = m.destroyObjectProperties,
              p = m.extend,
              G = m.isArray,
              y = m.isNumber,
              L = m.isObject,
              F = m.isString,
              P = m.merge,
              S = m.pick,
              Q = m.pInt,
              V = m.uniqueKey,
              fa;

          C = function () {
            function H(b, d, c, a, h, e, p) {
              this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
              this.init(b, d, c, a, h, e, p);
            }

            H.prototype.init = function (b, d, c, a, p, A, H) {
              var K = this.createElement("svg").attr({
                version: "1.1",
                "class": "highcharts-root"
              }),
                  f = K.element;
              H || K.css(this.getStyle(a));
              b.appendChild(f);
              r(b, "dir", "ltr");
              -1 === b.innerHTML.indexOf("xmlns") && r(f, "xmlns", this.SVG_NS);
              this.isSVG = !0;
              this.box = f;
              this.boxWrapper = K;
              this.alignedObjects = [];
              this.url = this.getReferenceURL();
              this.createElement("desc").add().element.appendChild(e.createTextNode("Created with Highcharts 9.2.2"));
              this.defs = this.createElement("defs").add();
              this.allowHTML = A;
              this.forExport = p;
              this.styledMode = H;
              this.gradients = {};
              this.cache = {};
              this.cacheKeys = [];
              this.imgCount = 0;
              this.setSize(d, c, !1);
              var k;
              l && b.getBoundingClientRect && (d = function d() {
                h(b, {
                  left: 0,
                  top: 0
                });
                k = b.getBoundingClientRect();
                h(b, {
                  left: Math.ceil(k.left) - k.left + "px",
                  top: Math.ceil(k.top) - k.top + "px"
                });
              }, d(), this.unSubPixelFix = B(D, "resize", d));
            };

            H.prototype.definition = function (b) {
              return new a([b]).addToDOM(this.defs.element);
            };

            H.prototype.getReferenceURL = function () {
              if ((l || v) && e.getElementsByTagName("base").length) {
                if (!d(fa)) {
                  var b = V();
                  b = new a([{
                    tagName: "svg",
                    attributes: {
                      width: 8,
                      height: 8
                    },
                    children: [{
                      tagName: "defs",
                      children: [{
                        tagName: "clipPath",
                        attributes: {
                          id: b
                        },
                        children: [{
                          tagName: "rect",
                          attributes: {
                            width: 4,
                            height: 4
                          }
                        }]
                      }]
                    }, {
                      tagName: "rect",
                      attributes: {
                        id: "hitme",
                        width: 8,
                        height: 8,
                        "clip-path": "url(#" + b + ")",
                        fill: "rgba(0,0,0,0.001)"
                      }
                    }]
                  }]).addToDOM(e.body);
                  h(b, {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    zIndex: 9E5
                  });
                  var c = e.elementFromPoint(6, 6);
                  fa = "hitme" === (c && c.id);
                  e.body.removeChild(b);
                }

                if (fa) return D.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
              }

              return "";
            };

            H.prototype.getStyle = function (b) {
              return this.style = p({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
              }, b);
            };

            H.prototype.setStyle = function (b) {
              this.boxWrapper.css(this.getStyle(b));
            };

            H.prototype.isHidden = function () {
              return !this.boxWrapper.getBBox().width;
            };

            H.prototype.destroy = function () {
              var d = this.defs;
              this.box = null;
              this.boxWrapper = this.boxWrapper.destroy();
              b(this.gradients || {});
              this.gradients = null;
              d && (this.defs = d.destroy());
              this.unSubPixelFix && this.unSubPixelFix();
              return this.alignedObjects = null;
            };

            H.prototype.createElement = function (b) {
              var d = new this.Element();
              d.init(this, b);
              return d;
            };

            H.prototype.getRadialAttr = function (b, d) {
              return {
                cx: b[0] - b[2] / 2 + (d.cx || 0) * b[2],
                cy: b[1] - b[2] / 2 + (d.cy || 0) * b[2],
                r: (d.r || 0) * b[2]
              };
            };

            H.prototype.buildText = function (b) {
              new n(b).buildSVG();
            };

            H.prototype.getContrast = function (b) {
              b = w.parse(b).rgba;
              b[0] *= 1;
              b[1] *= 1.2;
              b[2] *= .5;
              return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
            };

            H.prototype.button = function (b, d, c, h, e, A, H, k, g, y) {
              var K = this.label(b, d, c, g, void 0, void 0, y, void 0, "button"),
                  G = this.styledMode,
                  l = 0,
                  t = e ? P(e) : {};
              b = t && t.style || {};
              t = a.filterUserAttributes(t);
              K.attr(P({
                padding: 8,
                r: 2
              }, t));

              if (!G) {
                t = P({
                  fill: E.neutralColor3,
                  stroke: E.neutralColor20,
                  "stroke-width": 1,
                  style: {
                    color: E.neutralColor80,
                    cursor: "pointer",
                    fontWeight: "normal"
                  }
                }, {
                  style: b
                }, t);
                var N = t.style;
                delete t.style;
                A = P(t, {
                  fill: E.neutralColor10
                }, a.filterUserAttributes(A || {}));
                var q = A.style;
                delete A.style;
                H = P(t, {
                  fill: E.highlightColor10,
                  style: {
                    color: E.neutralColor100,
                    fontWeight: "bold"
                  }
                }, a.filterUserAttributes(H || {}));
                var v = H.style;
                delete H.style;
                k = P(t, {
                  style: {
                    color: E.neutralColor20
                  }
                }, a.filterUserAttributes(k || {}));
                var F = k.style;
                delete k.style;
              }

              B(K.element, f ? "mouseover" : "mouseenter", function () {
                3 !== l && K.setState(1);
              });
              B(K.element, f ? "mouseout" : "mouseleave", function () {
                3 !== l && K.setState(l);
              });

              K.setState = function (b) {
                1 !== b && (K.state = l = b);
                K.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
                G || K.attr([t, A, H, k][b || 0]).css([N, q, v, F][b || 0]);
              };

              G || K.attr(t).css(p({
                cursor: "default"
              }, N));
              return K.on("touchstart", function (b) {
                return b.stopPropagation();
              }).on("click", function (b) {
                3 !== l && h.call(K, b);
              });
            };

            H.prototype.crispLine = function (b, c, a) {
              void 0 === a && (a = "round");
              var h = b[0],
                  e = b[1];
              d(h[1]) && h[1] === e[1] && (h[1] = e[1] = Math[a](h[1]) - c % 2 / 2);
              d(h[2]) && h[2] === e[2] && (h[2] = e[2] = Math[a](h[2]) + c % 2 / 2);
              return b;
            };

            H.prototype.path = function (b) {
              var d = this.styledMode ? {} : {
                fill: "none"
              };
              G(b) ? d.d = b : L(b) && p(d, b);
              return this.createElement("path").attr(d);
            };

            H.prototype.circle = function (b, d, c) {
              b = L(b) ? b : "undefined" === typeof b ? {} : {
                x: b,
                y: d,
                r: c
              };
              d = this.createElement("circle");

              d.xSetter = d.ySetter = function (b, d, c) {
                c.setAttribute("c" + d, b);
              };

              return d.attr(b);
            };

            H.prototype.arc = function (b, d, c, a, h, e) {
              L(b) ? (a = b, d = a.y, c = a.r, b = a.x) : a = {
                innerR: a,
                start: h,
                end: e
              };
              b = this.symbol("arc", b, d, c, c, a);
              b.r = c;
              return b;
            };

            H.prototype.rect = function (b, d, c, a, h, e) {
              h = L(b) ? b.r : h;
              var p = this.createElement("rect");
              b = L(b) ? b : "undefined" === typeof b ? {} : {
                x: b,
                y: d,
                width: Math.max(c, 0),
                height: Math.max(a, 0)
              };
              this.styledMode || ("undefined" !== typeof e && (b["stroke-width"] = e, b = p.crisp(b)), b.fill = "none");
              h && (b.r = h);

              p.rSetter = function (b, d, c) {
                p.r = b;
                r(c, {
                  rx: b,
                  ry: b
                });
              };

              p.rGetter = function () {
                return p.r || 0;
              };

              return p.attr(b);
            };

            H.prototype.setSize = function (b, d, c) {
              this.width = b;
              this.height = d;
              this.boxWrapper.animate({
                width: b,
                height: d
              }, {
                step: function step() {
                  this.attr({
                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                  });
                },
                duration: S(c, !0) ? void 0 : 0
              });
              this.alignElements();
            };

            H.prototype.g = function (b) {
              var d = this.createElement("g");
              return b ? d.attr({
                "class": "highcharts-" + b
              }) : d;
            };

            H.prototype.image = function (b, d, c, a, h, e) {
              var A = {
                preserveAspectRatio: "none"
              },
                  H = function H(b, d) {
                b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", d) : b.setAttribute("hc-svg-href", d);
              };

              1 < arguments.length && p(A, {
                x: d,
                y: c,
                width: a,
                height: h
              });
              var f = this.createElement("image").attr(A);

              A = function A(d) {
                H(f.element, b);
                e.call(f, d);
              };

              if (e) {
                H(f.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
                var K = new D.Image();
                B(K, "load", A);
                K.src = b;
                K.complete && A({});
              } else H(f.element, b);

              return f;
            };

            H.prototype.symbol = function (b, c, a, H, f, A) {
              var K = this,
                  k = /^url\((.*?)\)$/,
                  y = k.test(b),
                  G = !y && (this.symbols[b] ? b : "circle"),
                  l = G && this.symbols[G],
                  q;

              if (l) {
                "number" === typeof c && (q = l.call(this.symbols, Math.round(c || 0), Math.round(a || 0), H || 0, f || 0, A));
                var v = this.path(q);
                K.styledMode || v.attr("fill", "none");
                p(v, {
                  symbolName: G || void 0,
                  x: c,
                  y: a,
                  width: H,
                  height: f
                });
                A && p(v, A);
              } else if (y) {
                var F = b.match(k)[1];
                var m = v = this.image(F);
                m.imgwidth = S(I[F] && I[F].width, A && A.width);
                m.imgheight = S(I[F] && I[F].height, A && A.height);

                var L = function L(b) {
                  return b.attr({
                    width: b.width,
                    height: b.height
                  });
                };

                ["width", "height"].forEach(function (b) {
                  m[b + "Setter"] = function (b, c) {
                    var a = this["img" + c];
                    this[c] = b;
                    d(a) && (A && "within" === A.backgroundSize && this.width && this.height && (a = Math.round(a * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(c, a), this.alignByTranslate || (b = ((this[c] || 0) - a) / 2, this.attr("width" === c ? {
                      translateX: b
                    } : {
                      translateY: b
                    })));
                  };
                });
                d(c) && m.attr({
                  x: c,
                  y: a
                });
                m.isImg = !0;
                d(m.imgwidth) && d(m.imgheight) ? L(m) : (m.attr({
                  width: 0,
                  height: 0
                }), t("img", {
                  onload: function onload() {
                    var b = g[K.chartIndex];
                    0 === this.width && (h(this, {
                      position: "absolute",
                      top: "-999em"
                    }), e.body.appendChild(this));
                    I[F] = {
                      width: this.width,
                      height: this.height
                    };
                    m.imgwidth = this.width;
                    m.imgheight = this.height;
                    m.element && L(m);
                    this.parentNode && this.parentNode.removeChild(this);
                    K.imgCount--;
                    if (!K.imgCount && b && !b.hasLoaded) b.onload();
                  },
                  src: F
                }), this.imgCount++);
              }

              return v;
            };

            H.prototype.clipRect = function (b, d, c, a) {
              var h = V() + "-",
                  e = this.createElement("clipPath").attr({
                id: h
              }).add(this.defs);
              b = this.rect(b, d, c, a, 0).add(e);
              b.id = h;
              b.clipPath = e;
              b.count = 0;
              return b;
            };

            H.prototype.text = function (b, c, a, h) {
              var e = {};
              if (h && (this.allowHTML || !this.forExport)) return this.html(b, c, a);
              e.x = Math.round(c || 0);
              a && (e.y = Math.round(a));
              d(b) && (e.text = b);
              b = this.createElement("text").attr(e);
              if (!h || this.forExport && !this.allowHTML) b.xSetter = function (b, d, c) {
                for (var a = c.getElementsByTagName("tspan"), h = c.getAttribute(d), e = 0, p; e < a.length; e++) {
                  p = a[e], p.getAttribute(d) === h && p.setAttribute(d, b);
                }

                c.setAttribute(d, b);
              };
              return b;
            };

            H.prototype.fontMetrics = function (b, d) {
              b = !this.styledMode && /px/.test(b) || !D.getComputedStyle ? b || d && d.style && d.style.fontSize || this.style && this.style.fontSize : d && x.prototype.getStyle.call(d, "font-size");
              b = /px/.test(b) ? Q(b) : 12;
              d = 24 > b ? b + 3 : Math.round(1.2 * b);
              return {
                h: d,
                b: Math.round(.8 * d),
                f: b
              };
            };

            H.prototype.rotCorr = function (b, d, a) {
              var h = b;
              d && a && (h = Math.max(h * Math.cos(d * c), 4));
              return {
                x: -b / 3 * Math.sin(d * c),
                y: h
              };
            };

            H.prototype.pathToSegments = function (b) {
              for (var d = [], c = [], a = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
              }, h = 0; h < b.length; h++) {
                F(c[0]) && y(b[h]) && c.length === a[c[0].toUpperCase()] && b.splice(h, 0, c[0].replace("M", "L").replace("m", "l")), "string" === typeof b[h] && (c.length && d.push(c.slice(0)), c.length = 0), c.push(b[h]);
              }

              d.push(c.slice(0));
              return d;
            };

            H.prototype.label = function (b, d, c, a, h, e, p, H, f) {
              return new J(this, b, d, c, a, h, e, p, H, f);
            };

            H.prototype.alignElements = function () {
              this.alignedObjects.forEach(function (b) {
                return b.align();
              });
            };

            return H;
          }();

          p(C.prototype, {
            Element: x,
            SVG_NS: k,
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            symbols: u,
            draw: q
          });
          z.registerRendererType("svg", C, !0);
          "";
          return C;
        });
        M(a, "Core/Renderer/HTML/HTMLElement.js", [a["Core/Globals.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = this && this.__extends || function () {
            var _c13 = function c(a, e) {
              _c13 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (c, a) {
                c.__proto__ = a;
              } || function (c, a) {
                for (var e in a) {
                  a.hasOwnProperty(e) && (c[e] = a[e]);
                }
              };

              return _c13(a, e);
            };

            return function (a, e) {
              function f() {
                this.constructor = a;
              }

              _c13(a, e);

              a.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
            };
          }(),
              z = a.isFirefox,
              x = a.isMS,
              J = a.isWebKit,
              u = a.win,
              n = C.css,
              m = C.defined,
              g = C.extend,
              c = C.pick,
              e = C.pInt;

          return function (a) {
            function f() {
              return null !== a && a.apply(this, arguments) || this;
            }

            r(f, a);

            f.compose = function (c) {
              if (-1 === f.composedClasses.indexOf(c)) {
                f.composedClasses.push(c);
                var a = f.prototype,
                    e = c.prototype;
                e.getSpanCorrection = a.getSpanCorrection;
                e.htmlCss = a.htmlCss;
                e.htmlGetBBox = a.htmlGetBBox;
                e.htmlUpdateTransform = a.htmlUpdateTransform;
                e.setSpanRotation = a.setSpanRotation;
              }

              return c;
            };

            f.prototype.getSpanCorrection = function (c, a, e) {
              this.xCorr = -c * e;
              this.yCorr = -a;
            };

            f.prototype.htmlCss = function (a) {
              var e = "SPAN" === this.element.tagName && a && "width" in a,
                  f = c(e && a.width, void 0);

              if (e) {
                delete a.width;
                this.textWidth = f;
                var l = !0;
              }

              a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
              this.styles = g(this.styles, a);
              n(this.element, a);
              l && this.htmlUpdateTransform();
              return this;
            };

            f.prototype.htmlGetBBox = function () {
              var c = this.element;
              return {
                x: c.offsetLeft,
                y: c.offsetTop,
                width: c.offsetWidth,
                height: c.offsetHeight
              };
            };

            f.prototype.htmlUpdateTransform = function () {
              if (this.added) {
                var c = this.renderer,
                    a = this.element,
                    f = this.translateX || 0,
                    g = this.translateY || 0,
                    l = this.x || 0,
                    B = this.y || 0,
                    r = this.textAlign || "left",
                    t = {
                  left: 0,
                  center: .5,
                  right: 1
                }[r],
                    h = this.styles;
                h = h && h.whiteSpace;
                n(a, {
                  marginLeft: f,
                  marginTop: g
                });
                !c.styledMode && this.shadows && this.shadows.forEach(function (b) {
                  n(b, {
                    marginLeft: f + 1,
                    marginTop: g + 1
                  });
                });
                this.inverted && [].forEach.call(a.childNodes, function (b) {
                  c.invertChild(b, a);
                });

                if ("SPAN" === a.tagName) {
                  var d = this.rotation,
                      b = this.textWidth && e(this.textWidth),
                      p = [d, r, a.innerHTML, this.textWidth, this.textAlign].join(),
                      G = void 0;
                  (G = b !== this.oldTextWidth) && !(G = b > this.oldTextWidth) && ((G = this.textPxLength) || (n(a, {
                    width: "",
                    whiteSpace: h || "nowrap"
                  }), G = a.offsetWidth), G = G > b);
                  G && (/[ \-]/.test(a.textContent || a.innerText) || "ellipsis" === a.style.textOverflow) ? (n(a, {
                    width: b + "px",
                    display: "block",
                    whiteSpace: h || "normal"
                  }), this.oldTextWidth = b, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
                  p !== this.cTT && (G = c.fontMetrics(a.style.fontSize, a).b, !m(d) || d === (this.oldRotation || 0) && r === this.oldAlign || this.setSpanRotation(d, t, G), this.getSpanCorrection(!m(d) && this.textPxLength || a.offsetWidth, G, t, d, r));
                  n(a, {
                    left: l + (this.xCorr || 0) + "px",
                    top: B + (this.yCorr || 0) + "px"
                  });
                  this.cTT = p;
                  this.oldRotation = d;
                  this.oldAlign = r;
                }
              } else this.alignOnAdd = !0;
            };

            f.prototype.setSpanRotation = function (c, a, e) {
              var f = {},
                  g = x && !/Edge/.test(u.navigator.userAgent) ? "-ms-transform" : J ? "-webkit-transform" : z ? "MozTransform" : u.opera ? "-o-transform" : void 0;
              g && (f[g] = f.transform = "rotate(" + c + "deg)", f[g + (z ? "Origin" : "-origin")] = f.transformOrigin = 100 * a + "% " + e + "px", n(this.element, f));
            };

            f.composedClasses = [];
            return f;
          }(w);
        });
        M(a, "Core/Renderer/HTML/HTMLRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function (a, w, C, E) {
          var r = this && this.__extends || function () {
            var _a9 = function a(g, c) {
              _a9 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (a[e] = c[e]);
                }
              };

              return _a9(g, c);
            };

            return function (g, c) {
              function e() {
                this.constructor = g;
              }

              _a9(g, c);

              g.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());
            };
          }(),
              x = E.attr,
              J = E.createElement,
              u = E.extend,
              n = E.pick;

          return function (m) {
            function g() {
              return null !== m && m.apply(this, arguments) || this;
            }

            r(g, m);

            g.compose = function (c) {
              -1 === g.composedClasses.indexOf(c) && (g.composedClasses.push(c), c.prototype.html = g.prototype.html);
              return c;
            };

            g.prototype.html = function (c, e, g) {
              var f = this.createElement("span"),
                  l = f.element,
                  q = f.renderer,
                  k = q.isSVG,
                  m = function m(c, a) {
                ["opacity", "visibility"].forEach(function (e) {
                  c[e + "Setter"] = function (f, h, d) {
                    var b = c.div ? c.div.style : a;
                    w.prototype[e + "Setter"].call(this, f, h, d);
                    b && (b[h] = f);
                  };
                });
                c.addedSetters = !0;
              };

              f.textSetter = function (c) {
                c !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, n(c, "")), this.textStr = c, f.doTransform = !0);
              };

              k && m(f, f.element.style);

              f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (c, a) {
                "align" === a ? f.alignValue = f.textAlign = c : f[a] = c;
                f.doTransform = !0;
              };

              f.afterSetters = function () {
                this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
              };

              f.attr({
                text: c,
                x: Math.round(e),
                y: Math.round(g)
              }).css({
                position: "absolute"
              });
              q.styledMode || f.css({
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
              });
              l.style.whiteSpace = "nowrap";
              f.css = f.htmlCss;
              k && (f.add = function (c) {
                var a = q.box.parentNode,
                    e = [];

                if (this.parentGroup = c) {
                  var g = c.div;

                  if (!g) {
                    for (; c;) {
                      e.push(c), c = c.parentGroup;
                    }

                    e.reverse().forEach(function (c) {
                      function d(b, d) {
                        c[d] = b;
                        "translateX" === d ? k.left = b + "px" : k.top = b + "px";
                        c.doTransform = !0;
                      }

                      var b = x(c.element, "class"),
                          h = c.styles || {};
                      g = c.div = c.div || J("div", b ? {
                        className: b
                      } : void 0, {
                        position: "absolute",
                        left: (c.translateX || 0) + "px",
                        top: (c.translateY || 0) + "px",
                        display: c.display,
                        opacity: c.opacity,
                        cursor: h.cursor,
                        pointerEvents: h.pointerEvents,
                        visibility: c.visibility
                      }, g || a);
                      var k = g.style;
                      u(c, {
                        classSetter: function (b) {
                          return function (d) {
                            this.element.setAttribute("class", d);
                            b.className = d;
                          };
                        }(g),
                        on: function on() {
                          e[0].div && f.on.apply({
                            element: e[0].div,
                            onEvents: c.onEvents
                          }, arguments);
                          return c;
                        },
                        translateXSetter: d,
                        translateYSetter: d
                      });
                      c.addedSetters || m(c);
                    });
                  }
                } else g = a;

                g.appendChild(l);
                f.added = !0;
                f.alignOnAdd && f.htmlUpdateTransform();
                return f;
              });
              return f;
            };

            g.composedClasses = [];
            return g;
          }(C);
        });
        M(a, "Core/Axis/AxisDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          var r;

          (function (r) {
            r.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: !1
                },
                second: {
                  main: "%H:%M:%S",
                  range: !1
                },
                minute: {
                  main: "%H:%M",
                  range: !1
                },
                hour: {
                  main: "%H:%M",
                  range: !1
                },
                day: {
                  main: "%e. %b"
                },
                week: {
                  main: "%e. %b"
                },
                month: {
                  main: "%b '%y"
                },
                year: {
                  main: "%Y"
                }
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: void 0,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                x: 0,
                zIndex: 7,
                style: {
                  color: a.neutralColor60,
                  cursor: "default",
                  fontSize: "11px"
                }
              },
              maxPadding: .01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minPadding: .01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                  color: a.neutralColor60
                }
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: a.neutralColor5,
              minorGridLineWidth: 1,
              minorTickColor: a.neutralColor40,
              lineColor: a.highlightColor20,
              lineWidth: 1,
              gridLineColor: a.neutralColor10,
              gridLineWidth: void 0,
              tickColor: a.highlightColor20
            };
            r.defaultYAxisOptions = {
              reversedStacks: !0,
              endOnTick: !0,
              maxPadding: .05,
              minPadding: .05,
              tickPixelInterval: 72,
              showLastLabel: !0,
              labels: {
                x: -8
              },
              startOnTick: !0,
              title: {
                rotation: 270,
                text: "Values"
              },
              stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function formatter() {
                  var a = this.axis.chart.numberFormatter;
                  return a(this.total, -1);
                },
                style: {
                  color: a.neutralColor100,
                  fontSize: "11px",
                  fontWeight: "bold",
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
            };
            r.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            r.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            r.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            r.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(r || (r = {}));

          return r;
        });
        M(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.addEvent,
              C = a.isFunction,
              E = a.objectEach,
              z = a.removeEvent;
          return {
            registerEventOptions: function registerEventOptions(a, w) {
              a.eventOptions = a.eventOptions || {};
              E(w.events, function (u, n) {
                a.eventOptions[n] !== u && (a.eventOptions[n] && (z(a, n, a.eventOptions[n]), delete a.eventOptions[n]), C(u) && (a.eventOptions[n] = u, r(a, n, u)));
              });
            }
          };
        });
        M(a, "Core/Axis/Tick.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = w.deg2rad,
              z = C.clamp,
              x = C.correctFloat,
              J = C.defined,
              u = C.destroyObjectProperties,
              n = C.extend,
              m = C.fireEvent,
              g = C.isNumber,
              c = C.merge,
              e = C.objectEach,
              l = C.pick;

          w = function () {
            function f(c, a, e, f, g) {
              this.isNewLabel = this.isNew = !0;
              this.axis = c;
              this.pos = a;
              this.type = e || "";
              this.parameters = g || {};
              this.tickmarkOffset = this.parameters.tickmarkOffset;
              this.options = this.parameters.options;
              m(this, "init");
              e || f || this.addLabel();
            }

            f.prototype.addLabel = function () {
              var c = this,
                  e = c.axis,
                  f = e.options,
                  I = e.chart,
                  D = e.categories,
                  B = e.logarithmic,
                  r = e.names,
                  t = c.pos,
                  h = l(c.options && c.options.labels, f.labels),
                  d = e.tickPositions,
                  b = t === d[0],
                  p = t === d[d.length - 1],
                  G = (!h.step || 1 === h.step) && 1 === e.tickInterval;
              d = d.info;
              var y = c.label,
                  L;
              D = this.parameters.category || (D ? l(D[t], r[t], t) : t);
              B && g(D) && (D = x(B.lin2log(D)));
              if (e.dateTime) if (d) {
                var F = I.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && d.higherRanks[t] || d.unitName]);
                var P = F.main;
              } else g(D) && (P = e.dateTime.getXDateFormat(D, f.dateTimeLabelFormats || {}));
              c.isFirst = b;
              c.isLast = p;
              var S = {
                axis: e,
                chart: I,
                dateTimeLabelFormat: P,
                isFirst: b,
                isLast: p,
                pos: t,
                tick: c,
                tickPositionInfo: d,
                value: D
              };
              m(this, "labelFormat", S);

              var Q = function Q(b) {
                return h.formatter ? h.formatter.call(b, b) : h.format ? (b.text = e.defaultLabelFormatter.call(b), a.format(h.format, b, I)) : e.defaultLabelFormatter.call(b, b);
              };

              f = Q.call(S, S);
              var u = F && F.list;
              c.shortenLabel = u ? function () {
                for (L = 0; L < u.length; L++) {
                  if (n(S, {
                    dateTimeLabelFormat: u[L]
                  }), y.attr({
                    text: Q.call(S, S)
                  }), y.getBBox().width < e.getSlotWidth(c) - 2 * h.padding) return;
                }

                y.attr({
                  text: ""
                });
              } : void 0;
              G && e._addedPlotLB && c.moveLabel(f, h);
              J(y) || c.movedLabel ? y && y.textStr !== f && !G && (!y.textWidth || h.style.width || y.styles.width || y.css({
                width: null
              }), y.attr({
                text: f
              }), y.textPxLength = y.getBBox().width) : (c.label = y = c.createLabel({
                x: 0,
                y: 0
              }, f, h), c.rotation = 0);
            };

            f.prototype.createLabel = function (a, e, f) {
              var g = this.axis,
                  k = g.chart;
              if (a = J(e) && f.enabled ? k.renderer.text(e, a.x, a.y, f.useHTML).add(g.labelGroup) : null) k.styledMode || a.css(c(f.style)), a.textPxLength = a.getBBox().width;
              return a;
            };

            f.prototype.destroy = function () {
              u(this, this.axis);
            };

            f.prototype.getPosition = function (c, a, e, f) {
              var g = this.axis,
                  k = g.chart,
                  l = f && k.oldChartHeight || k.chartHeight;
              c = {
                x: c ? x(g.translate(a + e, null, null, f) + g.transB) : g.left + g.offset + (g.opposite ? (f && k.oldChartWidth || k.chartWidth) - g.right - g.left : 0),
                y: c ? l - g.bottom + g.offset - (g.opposite ? g.height : 0) : x(l - g.translate(a + e, null, null, f) - g.transB)
              };
              c.y = z(c.y, -1E5, 1E5);
              m(this, "afterGetPosition", {
                pos: c
              });
              return c;
            };

            f.prototype.getLabelPosition = function (c, a, e, f, g, l, n, t) {
              var h = this.axis,
                  d = h.transA,
                  b = h.isLinked && h.linkedParent ? h.linkedParent.reversed : h.reversed,
                  p = h.staggerLines,
                  k = h.tickRotCorr || {
                x: 0,
                y: 0
              },
                  y = f || h.reserveSpaceDefault ? 0 : -h.labelOffset * ("center" === h.labelAlign ? .5 : 1),
                  q = {},
                  F = g.y;
              J(F) || (F = 0 === h.side ? e.rotation ? -8 : -e.getBBox().height : 2 === h.side ? k.y + 8 : Math.cos(e.rotation * r) * (k.y - e.getBBox(!1, 0).height / 2));
              c = c + g.x + y + k.x - (l && f ? l * d * (b ? -1 : 1) : 0);
              a = a + F - (l && !f ? l * d * (b ? 1 : -1) : 0);
              p && (e = n / (t || 1) % p, h.opposite && (e = p - e - 1), a += h.labelOffset / p * e);
              q.x = c;
              q.y = Math.round(a);
              m(this, "afterGetLabelPosition", {
                pos: q,
                tickmarkOffset: l,
                index: n
              });
              return q;
            };

            f.prototype.getLabelSize = function () {
              return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };

            f.prototype.getMarkPath = function (c, a, e, f, g, l) {
              return l.crispLine([["M", c, a], ["L", c + (g ? 0 : -e), a + (g ? e : 0)]], f);
            };

            f.prototype.handleOverflow = function (c) {
              var a = this.axis,
                  e = a.options.labels,
                  f = c.x,
                  g = a.chart.chartWidth,
                  m = a.chart.spacing,
                  v = l(a.labelLeft, Math.min(a.pos, m[3]));
              m = l(a.labelRight, Math.max(a.isRadial ? 0 : a.pos + a.len, g - m[1]));
              var t = this.label,
                  h = this.rotation,
                  d = {
                left: 0,
                center: .5,
                right: 1
              }[a.labelAlign || t.attr("align")],
                  b = t.getBBox().width,
                  p = a.getSlotWidth(this),
                  G = {},
                  y = p,
                  L = 1,
                  F;
              if (h || "justify" !== e.overflow) 0 > h && f - d * b < v ? F = Math.round(f / Math.cos(h * r) - v) : 0 < h && f + d * b > m && (F = Math.round((g - f) / Math.cos(h * r)));else if (g = f + (1 - d) * b, f - d * b < v ? y = c.x + y * (1 - d) - v : g > m && (y = m - c.x + y * d, L = -1), y = Math.min(p, y), y < p && "center" === a.labelAlign && (c.x += L * (p - y - d * (p - Math.min(b, y)))), b > y || a.autoRotation && (t.styles || {}).width) F = y;
              F && (this.shortenLabel ? this.shortenLabel() : (G.width = Math.floor(F) + "px", (e.style || {}).textOverflow || (G.textOverflow = "ellipsis"), t.css(G)));
            };

            f.prototype.moveLabel = function (c, a) {
              var f = this,
                  g = f.label,
                  l = f.axis,
                  m = l.reversed,
                  q = !1;
              g && g.textStr === c ? (f.movedLabel = g, q = !0, delete f.label) : e(l.ticks, function (a) {
                q || a.isNew || a === f || !a.label || a.label.textStr !== c || (f.movedLabel = a.label, q = !0, a.labelPos = f.movedLabel.xy, delete a.label);
              });

              if (!q && (f.labelPos || g)) {
                var t = f.labelPos || g.xy;
                g = l.horiz ? m ? 0 : l.width + l.left : t.x;
                l = l.horiz ? t.y : m ? l.width + l.left : 0;
                f.movedLabel = f.createLabel({
                  x: g,
                  y: l
                }, c, a);
                f.movedLabel && f.movedLabel.attr({
                  opacity: 0
                });
              }
            };

            f.prototype.render = function (a, c, e) {
              var f = this.axis,
                  g = f.horiz,
                  k = this.pos,
                  q = l(this.tickmarkOffset, f.tickmarkOffset);
              k = this.getPosition(g, k, q, c);
              q = k.x;
              var t = k.y;
              f = g && q === f.pos + f.len || !g && t === f.pos ? -1 : 1;
              g = l(e, this.label && this.label.newOpacity, 1);
              e = l(e, 1);
              this.isActive = !0;
              this.renderGridLine(c, e, f);
              this.renderMark(k, e, f);
              this.renderLabel(k, c, g, a);
              this.isNew = !1;
              m(this, "afterRender");
            };

            f.prototype.renderGridLine = function (c, a, e) {
              var f = this.axis,
                  g = f.options,
                  k = {},
                  m = this.pos,
                  t = this.type,
                  h = l(this.tickmarkOffset, f.tickmarkOffset),
                  d = f.chart.renderer,
                  b = this.gridLine,
                  p = g.gridLineWidth,
                  G = g.gridLineColor,
                  y = g.gridLineDashStyle;
              "minor" === this.type && (p = g.minorGridLineWidth, G = g.minorGridLineColor, y = g.minorGridLineDashStyle);
              b || (f.chart.styledMode || (k.stroke = G, k["stroke-width"] = p || 0, k.dashstyle = y), t || (k.zIndex = 1), c && (a = 0), this.gridLine = b = d.path().attr(k).addClass("highcharts-" + (t ? t + "-" : "") + "grid-line").add(f.gridGroup));
              if (b && (e = f.getPlotLinePath({
                value: m + h,
                lineWidth: b.strokeWidth() * e,
                force: "pass",
                old: c
              }))) b[c || this.isNew ? "attr" : "animate"]({
                d: e,
                opacity: a
              });
            };

            f.prototype.renderMark = function (c, a, e) {
              var f = this.axis,
                  g = f.options,
                  k = f.chart.renderer,
                  m = this.type,
                  t = f.tickSize(m ? m + "Tick" : "tick"),
                  h = c.x;
              c = c.y;
              var d = l(g["minor" !== m ? "tickWidth" : "minorTickWidth"], !m && f.isXAxis ? 1 : 0);
              g = g["minor" !== m ? "tickColor" : "minorTickColor"];
              var b = this.mark,
                  p = !b;
              t && (f.opposite && (t[0] = -t[0]), b || (this.mark = b = k.path().addClass("highcharts-" + (m ? m + "-" : "") + "tick").add(f.axisGroup), f.chart.styledMode || b.attr({
                stroke: g,
                "stroke-width": d
              })), b[p ? "attr" : "animate"]({
                d: this.getMarkPath(h, c, t[0], b.strokeWidth() * e, f.horiz, k),
                opacity: a
              }));
            };

            f.prototype.renderLabel = function (c, a, e, f) {
              var k = this.axis,
                  m = k.horiz,
                  q = k.options,
                  t = this.label,
                  h = q.labels,
                  d = h.step;
              k = l(this.tickmarkOffset, k.tickmarkOffset);
              var b = c.x;
              c = c.y;
              var p = !0;
              t && g(b) && (t.xy = c = this.getLabelPosition(b, c, t, m, h, k, f, d), this.isFirst && !this.isLast && !q.showFirstLabel || this.isLast && !this.isFirst && !q.showLastLabel ? p = !1 : !m || h.step || h.rotation || a || 0 === e || this.handleOverflow(c), d && f % d && (p = !1), p && g(c.y) ? (c.opacity = e, t[this.isNewLabel ? "attr" : "animate"](c), this.isNewLabel = !1) : (t.attr("y", -9999), this.isNewLabel = !0));
            };

            f.prototype.replaceMovedLabel = function () {
              var c = this.label,
                  a = this.axis,
                  e = a.reversed;

              if (c && !this.isNew) {
                var f = a.horiz ? e ? a.left : a.width + a.left : c.xy.x;
                e = a.horiz ? c.xy.y : e ? a.width + a.top : a.top;
                c.animate({
                  x: f,
                  y: e,
                  opacity: 0
                }, void 0, c.destroy);
                delete this.label;
              }

              a.isDirty = !0;
              this.label = this.movedLabel;
              delete this.movedLabel;
            };

            return f;
          }();

          "";
          return w;
        });
        M(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/Color/Palette.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x, J, u, n) {
          var m = a.animObject,
              g = z.defaultOptions,
              c = x.registerEventOptions,
              e = J.deg2rad,
              l = n.arrayMax,
              f = n.arrayMin,
              v = n.clamp,
              q = n.correctFloat,
              k = n.defined,
              r = n.destroyObjectProperties,
              D = n.erase,
              B = n.error,
              O = n.extend,
              t = n.fireEvent,
              h = n.getMagnitude,
              d = n.isArray,
              b = n.isNumber,
              p = n.isString,
              G = n.merge,
              y = n.normalizeTickInterval,
              L = n.objectEach,
              F = n.pick,
              P = n.relativeLength,
              S = n.removeEvent,
              Q = n.splat,
              V = n.syncTimeout;

          a = function () {
            function a(b, a) {
              this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
              this.init(b, a);
            }

            a.prototype.init = function (a, d) {
              var h = d.isX;
              this.chart = a;
              this.horiz = a.inverted && !this.isZAxis ? !h : h;
              this.isXAxis = h;
              this.coll = this.coll || (h ? "xAxis" : "yAxis");
              t(this, "init", {
                userOptions: d
              });
              this.opposite = F(d.opposite, this.opposite);
              this.side = F(d.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
              this.setOptions(d);
              var e = this.options,
                  f = e.labels,
                  p = e.type;
              this.userOptions = d;
              this.minPixelPadding = 0;
              this.reversed = F(e.reversed, this.reversed);
              this.visible = e.visible;
              this.zoomEnabled = e.zoomEnabled;
              this.hasNames = "category" === p || !0 === e.categories;
              this.categories = e.categories || this.hasNames;
              this.names || (this.names = [], this.names.keys = {});
              this.plotLinesAndBandsGroups = {};
              this.positiveValuesOnly = !!this.logarithmic;
              this.isLinked = k(e.linkedTo);
              this.ticks = {};
              this.labelEdge = [];
              this.minorTicks = {};
              this.plotLinesAndBands = [];
              this.alternateBands = {};
              this.len = 0;
              this.minRange = this.userMinRange = e.minRange || e.maxZoom;
              this.range = e.range;
              this.offset = e.offset || 0;
              this.min = this.max = null;
              d = F(e.crosshair, Q(a.options.tooltip.crosshairs)[h ? 0 : 1]);
              this.crosshair = !0 === d ? {} : d;
              -1 === a.axes.indexOf(this) && (h ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));
              this.series = this.series || [];
              a.inverted && !this.isZAxis && h && "undefined" === typeof this.reversed && (this.reversed = !0);
              this.labelRotation = b(f.rotation) ? f.rotation : void 0;
              c(this, e);
              t(this, "afterInit");
            };

            a.prototype.setOptions = function (b) {
              this.options = G(w.defaultXAxisOptions, "yAxis" === this.coll && w.defaultYAxisOptions, [w.defaultTopAxisOptions, w.defaultRightAxisOptions, w.defaultBottomAxisOptions, w.defaultLeftAxisOptions][this.side], G(g[this.coll], b));
              t(this, "afterSetOptions", {
                userOptions: b
              });
            };

            a.prototype.defaultLabelFormatter = function (a) {
              var d = this.axis;
              a = this.chart.numberFormatter;
              var c = b(this.value) ? this.value : NaN,
                  e = d.chart.time,
                  h = this.dateTimeLabelFormat,
                  f = g.lang,
                  p = f.numericSymbols;
              f = f.numericSymbolMagnitude || 1E3;
              var H = d.logarithmic ? Math.abs(c) : d.tickInterval,
                  y = p && p.length;
              if (d.categories) var k = "" + this.value;else if (h) k = e.dateFormat(h, c);else if (y && 1E3 <= H) for (; y-- && "undefined" === typeof k;) {
                d = Math.pow(f, y + 1), H >= d && 0 === 10 * c % d && null !== p[y] && 0 !== c && (k = a(c / d, -1) + p[y]);
              }
              "undefined" === typeof k && (k = 1E4 <= Math.abs(c) ? a(c, -1) : a(c, -1, void 0, ""));
              return k;
            };

            a.prototype.getSeriesExtremes = function () {
              var a = this,
                  d = a.chart,
                  c;
              t(this, "getSeriesExtremes", null, function () {
                a.hasVisibleSeries = !1;
                a.dataMin = a.dataMax = a.threshold = null;
                a.softThreshold = !a.isXAxis;
                a.stacking && a.stacking.buildStacks();
                a.series.forEach(function (e) {
                  if (e.visible || !d.options.chart.ignoreHiddenSeries) {
                    var h = e.options,
                        f = h.threshold;
                    a.hasVisibleSeries = !0;
                    a.positiveValuesOnly && 0 >= f && (f = null);

                    if (a.isXAxis) {
                      if (h = e.xData, h.length) {
                        h = a.logarithmic ? h.filter(a.validatePositiveValue) : h;
                        c = e.getXExtremes(h);
                        var p = c.min;
                        var g = c.max;
                        b(p) || p instanceof Date || (h = h.filter(b), c = e.getXExtremes(h), p = c.min, g = c.max);
                        h.length && (a.dataMin = Math.min(F(a.dataMin, p), p), a.dataMax = Math.max(F(a.dataMax, g), g));
                      }
                    } else if (e = e.applyExtremes(), b(e.dataMin) && (p = e.dataMin, a.dataMin = Math.min(F(a.dataMin, p), p)), b(e.dataMax) && (g = e.dataMax, a.dataMax = Math.max(F(a.dataMax, g), g)), k(f) && (a.threshold = f), !h.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
                  }
                });
              });
              t(this, "afterGetSeriesExtremes");
            };

            a.prototype.translate = function (a, d, c, e, h, f) {
              var p = this.linkedParent || this,
                  g = e && p.old ? p.old.min : p.min,
                  H = p.minPixelPadding;
              h = (p.isOrdinal || p.brokenAxis && p.brokenAxis.hasBreaks || p.logarithmic && h) && p.lin2val;
              var K = 1,
                  y = 0;
              e = e && p.old ? p.old.transA : p.transA;
              e || (e = p.transA);
              c && (K *= -1, y = p.len);
              p.reversed && (K *= -1, y -= K * (p.sector || p.len));
              d ? (a = (a * K + y - H) / e + g, h && (a = p.lin2val(a))) : (h && (a = p.val2lin(a)), a = b(g) ? K * (a - g) * e + y + K * H + (b(f) ? e * f : 0) : void 0);
              return a;
            };

            a.prototype.toPixels = function (b, a) {
              return this.translate(b, !1, !this.horiz, null, !0) + (a ? 0 : this.pos);
            };

            a.prototype.toValue = function (b, a) {
              return this.translate(b - (a ? 0 : this.pos), !0, !this.horiz, null, !0);
            };

            a.prototype.getPlotLinePath = function (a) {
              function d(b, a, d) {
                if ("pass" !== m && b < a || b > d) m ? b = v(b, a, d) : r = !0;
                return b;
              }

              var c = this,
                  e = c.chart,
                  h = c.left,
                  f = c.top,
                  p = a.old,
                  g = a.value,
                  H = a.lineWidth,
                  y = p && e.oldChartHeight || e.chartHeight,
                  k = p && e.oldChartWidth || e.chartWidth,
                  G = c.transB,
                  l = a.translatedValue,
                  m = a.force,
                  L,
                  q,
                  n,
                  B,
                  r;
              a = {
                value: g,
                lineWidth: H,
                old: p,
                force: m,
                acrossPanes: a.acrossPanes,
                translatedValue: l
              };
              t(this, "getPlotLinePath", a, function (a) {
                l = F(l, c.translate(g, null, null, p));
                l = v(l, -1E5, 1E5);
                L = n = Math.round(l + G);
                q = B = Math.round(y - l - G);
                b(l) ? c.horiz ? (q = f, B = y - c.bottom, L = n = d(L, h, h + c.width)) : (L = h, n = k - c.right, q = B = d(q, f, f + c.height)) : (r = !0, m = !1);
                a.path = r && !m ? null : e.renderer.crispLine([["M", L, q], ["L", n, B]], H || 1);
              });
              return a.path;
            };

            a.prototype.getLinearTickPositions = function (b, a, d) {
              var c = q(Math.floor(a / b) * b);
              d = q(Math.ceil(d / b) * b);
              var e = [],
                  h;
              q(c + b) === c && (h = 20);
              if (this.single) return [a];

              for (a = c; a <= d;) {
                e.push(a);
                a = q(a + b, h);
                if (a === f) break;
                var f = a;
              }

              return e;
            };

            a.prototype.getMinorTickInterval = function () {
              var b = this.options;
              return !0 === b.minorTicks ? F(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
            };

            a.prototype.getMinorTickPositions = function () {
              var b = this.options,
                  a = this.tickPositions,
                  d = this.minorTickInterval,
                  c = this.pointRangePadding || 0,
                  e = this.min - c;
              c = this.max + c;
              var h = c - e,
                  f = [];

              if (h && h / d < this.len / 3) {
                var p = this.logarithmic;
                if (p) this.paddedTicks.forEach(function (b, a, c) {
                  a && f.push.apply(f, p.getLogTickPositions(d, c[a - 1], c[a], !0));
                });else if (this.dateTime && "auto" === this.getMinorTickInterval()) f = f.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(d), e, c, b.startOfWeek));else for (b = e + (a[0] - e) % d; b <= c && b !== f[0]; b += d) {
                  f.push(b);
                }
              }

              0 !== f.length && this.trimTicks(f);
              return f;
            };

            a.prototype.adjustForMinRange = function () {
              var b = this.options,
                  a = this.logarithmic,
                  d = this.min,
                  c = this.max,
                  e = 0,
                  h,
                  p,
                  g,
                  y;
              this.isXAxis && "undefined" === typeof this.minRange && !a && (k(b.min) || k(b.max) ? this.minRange = null : (this.series.forEach(function (b) {
                g = b.xData;
                y = b.xIncrement ? 1 : g.length - 1;
                if (1 < g.length) for (h = y; 0 < h; h--) {
                  if (p = g[h] - g[h - 1], !e || p < e) e = p;
                }
              }), this.minRange = Math.min(5 * e, this.dataMax - this.dataMin)));

              if (c - d < this.minRange) {
                var G = this.dataMax - this.dataMin >= this.minRange;
                var t = this.minRange;
                var m = (t - c + d) / 2;
                m = [d - m, F(b.min, d - m)];
                G && (m[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                d = l(m);
                c = [d + t, F(b.max, d + t)];
                G && (c[2] = a ? a.log2lin(this.dataMax) : this.dataMax);
                c = f(c);
                c - d < t && (m[0] = c - t, m[1] = F(b.min, c - t), d = l(m));
              }

              this.min = d;
              this.max = c;
            };

            a.prototype.getClosest = function () {
              var b;
              this.categories ? b = 1 : this.series.forEach(function (a) {
                var d = a.closestPointRange,
                    c = a.visible || !a.chart.options.chart.ignoreHiddenSeries;
                !a.noSharedTooltip && k(d) && c && (b = k(b) ? Math.min(b, d) : d);
              });
              return b;
            };

            a.prototype.nameToX = function (b) {
              var a = d(this.categories),
                  c = a ? this.categories : this.names,
                  e = b.options.x;
              b.series.requireSorting = !1;
              k(e) || (e = this.options.uniqueNames ? a ? c.indexOf(b.name) : F(c.keys[b.name], -1) : b.series.autoIncrement());

              if (-1 === e) {
                if (!a) var h = c.length;
              } else h = e;

              "undefined" !== typeof h && (this.names[h] = b.name, this.names.keys[b.name] = h);
              return h;
            };

            a.prototype.updateNames = function () {
              var b = this,
                  a = this.names;
              0 < a.length && (Object.keys(a.keys).forEach(function (b) {
                delete a.keys[b];
              }), a.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (a) {
                a.xIncrement = null;
                if (!a.points || a.isDirtyData) b.max = Math.max(b.max, a.xData.length - 1), a.processData(), a.generatePoints();
                a.data.forEach(function (d, c) {
                  if (d && d.options && "undefined" !== typeof d.name) {
                    var e = b.nameToX(d);
                    "undefined" !== typeof e && e !== d.x && (d.x = e, a.xData[c] = e);
                  }
                });
              }));
            };

            a.prototype.setAxisTranslation = function () {
              var b = this,
                  a = b.max - b.min,
                  d = b.linkedParent,
                  c = !!b.categories,
                  e = b.isXAxis,
                  h = b.axisPointRange || 0,
                  f = 0,
                  g = 0,
                  y = b.transA;

              if (e || c || h) {
                var k = b.getClosest();
                d ? (f = d.minPointOffset, g = d.pointRangePadding) : b.series.forEach(function (a) {
                  var d = c ? 1 : e ? F(a.options.pointRange, k, 0) : b.axisPointRange || 0,
                      A = a.options.pointPlacement;
                  h = Math.max(h, d);
                  if (!b.single || c) a = a.is("xrange") ? !e : e, f = Math.max(f, a && p(A) ? 0 : d / 2), g = Math.max(g, a && "on" === A ? 0 : d);
                });
                d = b.ordinal && b.ordinal.slope && k ? b.ordinal.slope / k : 1;
                b.minPointOffset = f *= d;
                b.pointRangePadding = g *= d;
                b.pointRange = Math.min(h, b.single && c ? 1 : a);
                e && (b.closestPointRange = k);
              }

              b.translationSlope = b.transA = y = b.staticScale || b.len / (a + g || 1);
              b.transB = b.horiz ? b.left : b.bottom;
              b.minPixelPadding = y * f;
              t(this, "afterSetAxisTranslation");
            };

            a.prototype.minFromRange = function () {
              return this.max - this.range;
            };

            a.prototype.setTickInterval = function (a) {
              var d = this,
                  c = d.chart,
                  e = d.logarithmic,
                  f = d.options,
                  p = d.isXAxis,
                  g = d.isLinked,
                  l = f.tickPixelInterval,
                  G = d.categories,
                  H = d.softThreshold,
                  m = f.maxPadding,
                  L = f.minPadding,
                  n = f.tickInterval,
                  v = b(d.threshold) ? d.threshold : null;
              d.dateTime || G || g || this.getTickAmount();
              var r = F(d.userMin, f.min);
              var P = F(d.userMax, f.max);

              if (g) {
                d.linkedParent = c[d.coll][f.linkedTo];
                var D = d.linkedParent.getExtremes();
                d.min = F(D.min, D.dataMin);
                d.max = F(D.max, D.dataMax);
                f.type !== d.linkedParent.options.type && B(11, 1, c);
              } else {
                if (H && k(v)) if (d.dataMin >= v) D = v, L = 0;else if (d.dataMax <= v) {
                  var I = v;
                  m = 0;
                }
                d.min = F(r, D, d.dataMin);
                d.max = F(P, I, d.dataMax);
              }

              e && (d.positiveValuesOnly && !a && 0 >= Math.min(d.min, F(d.dataMin, d.min)) && B(10, 1, c), d.min = q(e.log2lin(d.min), 16), d.max = q(e.log2lin(d.max), 16));
              d.range && k(d.max) && (d.userMin = d.min = r = Math.max(d.dataMin, d.minFromRange()), d.userMax = P = d.max, d.range = null);
              t(d, "foundExtremes");
              d.beforePadding && d.beforePadding();
              d.adjustForMinRange();
              !(G || d.axisPointRange || d.stacking && d.stacking.usePercentage || g) && k(d.min) && k(d.max) && (c = d.max - d.min) && (!k(r) && L && (d.min -= c * L), !k(P) && m && (d.max += c * m));
              b(d.userMin) || (b(f.softMin) && f.softMin < d.min && (d.min = r = f.softMin), b(f.floor) && (d.min = Math.max(d.min, f.floor)));
              b(d.userMax) || (b(f.softMax) && f.softMax > d.max && (d.max = P = f.softMax), b(f.ceiling) && (d.max = Math.min(d.max, f.ceiling)));
              H && k(d.dataMin) && (v = v || 0, !k(r) && d.min < v && d.dataMin >= v ? d.min = d.options.minRange ? Math.min(v, d.max - d.minRange) : v : !k(P) && d.max > v && d.dataMax <= v && (d.max = d.options.minRange ? Math.max(v, d.min + d.minRange) : v));
              b(d.min) && b(d.max) && !this.chart.polar && d.min > d.max && (k(d.options.min) ? d.max = d.min : k(d.options.max) && (d.min = d.max));
              d.tickInterval = d.min === d.max || "undefined" === typeof d.min || "undefined" === typeof d.max ? 1 : g && d.linkedParent && !n && l === d.linkedParent.options.tickPixelInterval ? n = d.linkedParent.tickInterval : F(n, this.tickAmount ? (d.max - d.min) / Math.max(this.tickAmount - 1, 1) : void 0, G ? 1 : (d.max - d.min) * l / Math.max(d.len, l));
              p && !a && (d.series.forEach(function (b) {
                b.forceCrop = b.forceCropping && b.forceCropping();
                b.processData(d.min !== (d.old && d.old.min) || d.max !== (d.old && d.old.max));
              }), t(this, "postProcessData"));
              d.setAxisTranslation();
              t(this, "initialAxisTranslation");
              d.pointRange && !n && (d.tickInterval = Math.max(d.pointRange, d.tickInterval));
              a = F(f.minTickInterval, d.dateTime && !d.series.some(function (b) {
                return b.noSharedTooltip;
              }) ? d.closestPointRange : 0);
              !n && d.tickInterval < a && (d.tickInterval = a);
              d.dateTime || d.logarithmic || n || (d.tickInterval = y(d.tickInterval, void 0, h(d.tickInterval), F(f.allowDecimals, .5 > d.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
              this.tickAmount || (d.tickInterval = d.unsquish());
              this.setTickPositions();
            };

            a.prototype.setTickPositions = function () {
              var b = this.options,
                  d = b.tickPositions,
                  a = this.getMinorTickInterval(),
                  c = this.hasVerticalPanning(),
                  e = "colorAxis" === this.coll,
                  h = (e || !c) && b.startOnTick;
              c = (e || !c) && b.endOnTick;
              e = b.tickPositioner;
              this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
              this.minorTickInterval = "auto" === a && this.tickInterval ? this.tickInterval / 5 : a;
              this.single = this.min === this.max && k(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
              this.tickPositions = a = d && d.slice();
              !a && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? a = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (a = [this.min, this.max], B(19, !1, this.chart)), a.length > this.len && (a = [a[0], a.pop()], a[0] === a[1] && (a.length = 1)), this.tickPositions = a, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = a = e);
              this.paddedTicks = a.slice(0);
              this.trimTicks(a, h, c);
              this.isLinked || (this.single && 2 > a.length && !this.categories && !this.series.some(function (b) {
                return b.is("heatmap") && "between" === b.options.pointPlacement;
              }) && (this.min -= .5, this.max += .5), d || e || this.adjustTickAmount());
              t(this, "afterSetTickPositions");
            };

            a.prototype.trimTicks = function (b, d, a) {
              var c = b[0],
                  e = b[b.length - 1],
                  h = !this.isOrdinal && this.minPointOffset || 0;
              t(this, "trimTicks");

              if (!this.isLinked) {
                if (d && -Infinity !== c) this.min = c;else for (; this.min - h > b[0];) {
                  b.shift();
                }
                if (a) this.max = e;else for (; this.max + h < b[b.length - 1];) {
                  b.pop();
                }
                0 === b.length && k(c) && !this.options.tickPositions && b.push((e + c) / 2);
              }
            };

            a.prototype.alignToOthers = function () {
              var b = {},
                  d = this.options,
                  a;
              !1 !== this.chart.options.chart.alignTicks && d.alignTicks && !1 !== d.startOnTick && !1 !== d.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (d) {
                var c = d.options;
                c = [d.horiz ? c.left : c.top, c.width, c.height, c.pane].join();
                d.series.length && (b[c] ? a = !0 : b[c] = 1);
              });
              return a;
            };

            a.prototype.getTickAmount = function () {
              var b = this.options,
                  d = b.tickPixelInterval,
                  a = b.tickAmount;
              !k(b.tickInterval) && !a && this.len < d && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (a = 2);
              !a && this.alignToOthers() && (a = Math.ceil(this.len / d) + 1);
              4 > a && (this.finalTickAmt = a, a = 5);
              this.tickAmount = a;
            };

            a.prototype.adjustTickAmount = function () {
              var d = this.options,
                  a = this.tickInterval,
                  c = this.tickPositions,
                  e = this.tickAmount,
                  h = this.finalTickAmt,
                  f = c && c.length,
                  p = F(this.threshold, this.softThreshold ? 0 : null);

              if (this.hasData() && b(this.min) && b(this.max)) {
                if (f < e) {
                  for (; c.length < e;) {
                    c.length % 2 || this.min === p ? c.push(q(c[c.length - 1] + a)) : c.unshift(q(c[0] - a));
                  }

                  this.transA *= (f - 1) / (e - 1);
                  this.min = d.startOnTick ? c[0] : Math.min(this.min, c[0]);
                  this.max = d.endOnTick ? c[c.length - 1] : Math.max(this.max, c[c.length - 1]);
                } else f > e && (this.tickInterval *= 2, this.setTickPositions());

                if (k(h)) {
                  for (a = d = c.length; a--;) {
                    (3 === h && 1 === a % 2 || 2 >= h && 0 < a && a < d - 1) && c.splice(a, 1);
                  }

                  this.finalTickAmt = void 0;
                }
              }
            };

            a.prototype.setScale = function () {
              var b = !1,
                  d = !1;
              this.series.forEach(function (a) {
                b = b || a.isDirtyData || a.isDirty;
                d = d || a.xAxis && a.xAxis.isDirty || !1;
              });
              this.setAxisSize();
              var a = this.len !== (this.old && this.old.len);
              a || b || d || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = a || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
              b && this.panningState && (this.panningState.isDirty = !0);
              t(this, "afterSetScale");
            };

            a.prototype.setExtremes = function (b, d, a, c, e) {
              var h = this,
                  f = h.chart;
              a = F(a, !0);
              h.series.forEach(function (b) {
                delete b.kdTree;
              });
              e = O(e, {
                min: b,
                max: d
              });
              t(h, "setExtremes", e, function () {
                h.userMin = b;
                h.userMax = d;
                h.eventArgs = e;
                a && f.redraw(c);
              });
            };

            a.prototype.zoom = function (b, d) {
              var a = this,
                  c = this.dataMin,
                  e = this.dataMax,
                  h = this.options,
                  f = Math.min(c, F(h.min, c)),
                  p = Math.max(e, F(h.max, e));
              b = {
                newMin: b,
                newMax: d
              };
              t(this, "zoom", b, function (b) {
                var d = b.newMin,
                    h = b.newMax;
                if (d !== a.min || h !== a.max) a.allowZoomOutside || (k(c) && (d < f && (d = f), d > p && (d = p)), k(e) && (h < f && (h = f), h > p && (h = p))), a.displayBtn = "undefined" !== typeof d || "undefined" !== typeof h, a.setExtremes(d, h, !1, void 0, {
                  trigger: "zoom"
                });
                b.zoomed = !0;
              });
              return b.zoomed;
            };

            a.prototype.setAxisSize = function () {
              var b = this.chart,
                  d = this.options,
                  a = d.offsets || [0, 0, 0, 0],
                  c = this.horiz,
                  e = this.width = Math.round(P(F(d.width, b.plotWidth - a[3] + a[1]), b.plotWidth)),
                  h = this.height = Math.round(P(F(d.height, b.plotHeight - a[0] + a[2]), b.plotHeight)),
                  f = this.top = Math.round(P(F(d.top, b.plotTop + a[0]), b.plotHeight, b.plotTop));
              d = this.left = Math.round(P(F(d.left, b.plotLeft + a[3]), b.plotWidth, b.plotLeft));
              this.bottom = b.chartHeight - h - f;
              this.right = b.chartWidth - e - d;
              this.len = Math.max(c ? e : h, 0);
              this.pos = c ? d : f;
            };

            a.prototype.getExtremes = function () {
              var b = this.logarithmic;
              return {
                min: b ? q(b.lin2log(this.min)) : this.min,
                max: b ? q(b.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
              };
            };

            a.prototype.getThreshold = function (b) {
              var d = this.logarithmic,
                  a = d ? d.lin2log(this.min) : this.min;
              d = d ? d.lin2log(this.max) : this.max;
              null === b || -Infinity === b ? b = a : Infinity === b ? b = d : a > b ? b = a : d < b && (b = d);
              return this.translate(b, 0, 1, 0, 1);
            };

            a.prototype.autoLabelAlign = function (b) {
              var d = (F(b, 0) - 90 * this.side + 720) % 360;
              b = {
                align: "center"
              };
              t(this, "autoLabelAlign", b, function (b) {
                15 < d && 165 > d ? b.align = "right" : 195 < d && 345 > d && (b.align = "left");
              });
              return b.align;
            };

            a.prototype.tickSize = function (b) {
              var d = this.options,
                  a = F(d["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
                  c = d["tick" === b ? "tickLength" : "minorTickLength"];

              if (a && c) {
                "inside" === d[b + "Position"] && (c = -c);
                var e = [c, a];
              }

              b = {
                tickSize: e
              };
              t(this, "afterTickSize", b);
              return b.tickSize;
            };

            a.prototype.labelMetrics = function () {
              var b = this.tickPositions && this.tickPositions[0] || 0;
              return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
            };

            a.prototype.unsquish = function () {
              var d = this.options.labels,
                  a = this.horiz,
                  c = this.tickInterval,
                  h = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),
                  f = d.rotation,
                  p = this.labelMetrics(),
                  g = Math.max(this.max - this.min, 0),
                  y = function y(b) {
                var d = b / (h || 1);
                d = 1 < d ? Math.ceil(d) : 1;
                d * c > g && Infinity !== b && Infinity !== h && g && (d = Math.ceil(g / c));
                return q(d * c);
              },
                  k = c,
                  l,
                  G,
                  t = Number.MAX_VALUE;

              if (a) {
                if (!d.staggerLines && !d.step) if (b(f)) var m = [f];else h < d.autoRotationLimit && (m = d.autoRotation);
                m && m.forEach(function (b) {
                  if (b === f || b && -90 <= b && 90 >= b) {
                    G = y(Math.abs(p.h / Math.sin(e * b)));
                    var d = G + Math.abs(b / 360);
                    d < t && (t = d, l = b, k = G);
                  }
                });
              } else d.step || (k = y(p.h));

              this.autoRotation = m;
              this.labelRotation = F(l, b(f) ? f : 0);
              return k;
            };

            a.prototype.getSlotWidth = function (d) {
              var a = this.chart,
                  c = this.horiz,
                  e = this.options.labels,
                  h = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                  f = a.margin[3];
              if (d && b(d.slotWidth)) return d.slotWidth;
              if (c && 2 > e.step) return e.rotation ? 0 : (this.staggerLines || 1) * this.len / h;

              if (!c) {
                d = e.style.width;
                if (void 0 !== d) return parseInt(String(d), 10);
                if (f) return f - a.spacing[3];
              }

              return .33 * a.chartWidth;
            };

            a.prototype.renderUnsquish = function () {
              var b = this.chart,
                  d = b.renderer,
                  a = this.tickPositions,
                  c = this.ticks,
                  e = this.options.labels,
                  h = e.style,
                  f = this.horiz,
                  g = this.getSlotWidth(),
                  y = Math.max(1, Math.round(g - 2 * e.padding)),
                  k = {},
                  G = this.labelMetrics(),
                  l = h.textOverflow,
                  t = 0;
              p(e.rotation) || (k.rotation = e.rotation || 0);
              a.forEach(function (b) {
                b = c[b];
                b.movedLabel && b.replaceMovedLabel();
                b && b.label && b.label.textPxLength > t && (t = b.label.textPxLength);
              });
              this.maxLabelLength = t;
              if (this.autoRotation) t > y && t > G.h ? k.rotation = this.labelRotation : this.labelRotation = 0;else if (g) {
                var m = y;

                if (!l) {
                  var F = "clip";

                  for (y = a.length; !f && y--;) {
                    var L = a[y];
                    if (L = c[L].label) L.styles && "ellipsis" === L.styles.textOverflow ? L.css({
                      textOverflow: "clip"
                    }) : L.textPxLength > g && L.css({
                      width: g + "px"
                    }), L.getBBox().height > this.len / a.length - (G.h - G.f) && (L.specificTextOverflow = "ellipsis");
                  }
                }
              }
              k.rotation && (m = t > .5 * b.chartHeight ? .33 * b.chartHeight : t, l || (F = "ellipsis"));
              if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) k.align = this.labelAlign;
              a.forEach(function (b) {
                var d = (b = c[b]) && b.label,
                    a = h.width,
                    e = {};
                d && (d.attr(k), b.shortenLabel ? b.shortenLabel() : m && !a && "nowrap" !== h.whiteSpace && (m < d.textPxLength || "SPAN" === d.element.tagName) ? (e.width = m + "px", l || (e.textOverflow = d.specificTextOverflow || F), d.css(e)) : d.styles && d.styles.width && !e.width && !a && d.css({
                  width: null
                }), delete d.specificTextOverflow, b.rotation = k.rotation);
              }, this);
              this.tickRotCorr = d.rotCorr(G.b, this.labelRotation || 0, 0 !== this.side);
            };

            a.prototype.hasData = function () {
              return this.series.some(function (b) {
                return b.hasData();
              }) || this.options.showEmpty && k(this.min) && k(this.max);
            };

            a.prototype.addTitle = function (b) {
              var d = this.chart.renderer,
                  a = this.horiz,
                  c = this.opposite,
                  e = this.options.title,
                  h = this.chart.styledMode,
                  f;
              this.axisTitle || ((f = e.textAlign) || (f = (a ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: c ? "right" : "left",
                middle: "center",
                high: c ? "left" : "right"
              })[e.align]), this.axisTitle = d.text(e.text || "", 0, 0, e.useHTML).attr({
                zIndex: 7,
                rotation: e.rotation,
                align: f
              }).addClass("highcharts-axis-title"), h || this.axisTitle.css(G(e.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
              h || e.style.width || this.isRadial || this.axisTitle.css({
                width: this.len + "px"
              });
              this.axisTitle[b ? "show" : "hide"](b);
            };

            a.prototype.generateTick = function (b) {
              var d = this.ticks;
              d[b] ? d[b].addLabel() : d[b] = new u(this, b);
            };

            a.prototype.getOffset = function () {
              var b = this,
                  d = this,
                  a = d.chart,
                  c = a.renderer,
                  e = d.options,
                  h = d.tickPositions,
                  f = d.ticks,
                  p = d.horiz,
                  g = d.side,
                  y = a.inverted && !d.isZAxis ? [1, 0, 3, 2][g] : g,
                  G = d.hasData(),
                  l = e.title,
                  m = e.labels,
                  q = a.axisOffset;
              a = a.clipOffset;
              var v = [-1, 1, 1, -1][g],
                  n = e.className,
                  B = d.axisParent,
                  r,
                  P = 0,
                  D = 0,
                  ca = 0;
              d.showAxis = r = G || e.showEmpty;
              d.staggerLines = d.horiz && m.staggerLines || void 0;

              if (!d.axisGroup) {
                var ia = function ia(d, a, e) {
                  return c.g(d).attr({
                    zIndex: e
                  }).addClass("highcharts-" + b.coll.toLowerCase() + a + " " + (b.isRadial ? "highcharts-radial-axis" + a + " " : "") + (n || "")).add(B);
                };

                d.gridGroup = ia("grid", "-grid", e.gridZIndex);
                d.axisGroup = ia("axis", "", e.zIndex);
                d.labelGroup = ia("axis-labels", "-labels", m.zIndex);
              }

              G || d.isLinked ? (h.forEach(function (b) {
                d.generateTick(b);
              }), d.renderUnsquish(), d.reserveSpaceDefault = 0 === g || 2 === g || {
                1: "left",
                3: "right"
              }[g] === d.labelAlign, F(m.reserveSpace, "center" === d.labelAlign ? !0 : null, d.reserveSpaceDefault) && h.forEach(function (b) {
                ca = Math.max(f[b].getLabelSize(), ca);
              }), d.staggerLines && (ca *= d.staggerLines), d.labelOffset = ca * (d.opposite ? -1 : 1)) : L(f, function (b, d) {
                b.destroy();
                delete f[d];
              });

              if (l && l.text && !1 !== l.enabled && (d.addTitle(r), r && !1 !== l.reserveSpace)) {
                d.titleOffset = P = d.axisTitle.getBBox()[p ? "height" : "width"];
                var I = l.offset;
                D = k(I) ? 0 : F(l.margin, p ? 5 : 10);
              }

              d.renderLine();
              d.offset = v * F(e.offset, q[g] ? q[g] + (e.margin || 0) : 0);
              d.tickRotCorr = d.tickRotCorr || {
                x: 0,
                y: 0
              };
              l = 0 === g ? -d.labelMetrics().h : 2 === g ? d.tickRotCorr.y : 0;
              G = Math.abs(ca) + D;
              ca && (G = G - l + v * (p ? F(m.y, d.tickRotCorr.y + 8 * v) : m.x));
              d.axisTitleMargin = F(I, G);
              d.getMaxLabelDimensions && (d.maxLabelDimensions = d.getMaxLabelDimensions(f, h));
              p = this.tickSize("tick");
              q[g] = Math.max(q[g], (d.axisTitleMargin || 0) + P + v * d.offset, G, h && h.length && p ? p[0] + v * d.offset : 0);
              e = e.offset ? 0 : 2 * Math.floor(d.axisLine.strokeWidth() / 2);
              a[y] = Math.max(a[y], e);
              t(this, "afterGetOffset");
            };

            a.prototype.getLinePath = function (b) {
              var d = this.chart,
                  a = this.opposite,
                  c = this.offset,
                  e = this.horiz,
                  h = this.left + (a ? this.width : 0) + c;
              c = d.chartHeight - this.bottom - (a ? this.height : 0) + c;
              a && (b *= -1);
              return d.renderer.crispLine([["M", e ? this.left : h, e ? c : this.top], ["L", e ? d.chartWidth - this.right : h, e ? c : d.chartHeight - this.bottom]], b);
            };

            a.prototype.renderLine = function () {
              this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              }));
            };

            a.prototype.getTitlePosition = function () {
              var b = this.horiz,
                  d = this.left,
                  a = this.top,
                  c = this.len,
                  e = this.options.title,
                  h = b ? d : a,
                  f = this.opposite,
                  p = this.offset,
                  g = e.x,
                  y = e.y,
                  k = this.axisTitle,
                  G = this.chart.renderer.fontMetrics(e.style.fontSize, k);
              k = Math.max(k.getBBox(null, 0).height - G.h - 1, 0);
              c = {
                low: h + (b ? 0 : c),
                middle: h + c / 2,
                high: h + (b ? c : 0)
              }[e.align];
              d = (b ? a + this.height : d) + (b ? 1 : -1) * (f ? -1 : 1) * this.axisTitleMargin + [-k, k, G.f, -k][this.side];
              b = {
                x: b ? c + g : d + (f ? this.width : 0) + p + g,
                y: b ? d + y - (f ? this.height : 0) + p : c + y
              };
              t(this, "afterGetTitlePosition", {
                titlePosition: b
              });
              return b;
            };

            a.prototype.renderMinorTick = function (b, d) {
              var a = this.minorTicks;
              a[b] || (a[b] = new u(this, b, "minor"));
              d && a[b].isNew && a[b].render(null, !0);
              a[b].render(null, !1, 1);
            };

            a.prototype.renderTick = function (b, d, a) {
              var c = this.ticks;
              if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) c[b] || (c[b] = new u(this, b)), a && c[b].isNew && c[b].render(d, !0, -1), c[b].render(d);
            };

            a.prototype.render = function () {
              var d = this,
                  a = d.chart,
                  c = d.logarithmic,
                  e = d.options,
                  h = d.isLinked,
                  f = d.tickPositions,
                  p = d.axisTitle,
                  g = d.ticks,
                  y = d.minorTicks,
                  k = d.alternateBands,
                  G = e.stackLabels,
                  l = e.alternateGridColor,
                  F = d.tickmarkOffset,
                  q = d.axisLine,
                  v = d.showAxis,
                  n = m(a.renderer.globalAnimation),
                  B,
                  r;
              d.labelEdge.length = 0;
              d.overlap = !1;
              [g, y, k].forEach(function (b) {
                L(b, function (b) {
                  b.isActive = !1;
                });
              });

              if (d.hasData() || h) {
                var P = d.chart.hasRendered && d.old && b(d.old.min);
                d.minorTickInterval && !d.categories && d.getMinorTickPositions().forEach(function (b) {
                  d.renderMinorTick(b, P);
                });
                f.length && (f.forEach(function (b, a) {
                  d.renderTick(b, a, P);
                }), F && (0 === d.min || d.single) && (g[-1] || (g[-1] = new u(d, -1, null, !0)), g[-1].render(-1)));
                l && f.forEach(function (b, e) {
                  r = "undefined" !== typeof f[e + 1] ? f[e + 1] + F : d.max - F;
                  0 === e % 2 && b < d.max && r <= d.max + (a.polar ? -F : F) && (k[b] || (k[b] = new J.PlotLineOrBand(d)), B = b + F, k[b].options = {
                    from: c ? c.lin2log(B) : B,
                    to: c ? c.lin2log(r) : r,
                    color: l,
                    className: "highcharts-alternate-grid"
                  }, k[b].render(), k[b].isActive = !0);
                });
                d._addedPlotLB || (d._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (b) {
                  d.addPlotBandOrLine(b);
                }));
              }

              [g, y, k].forEach(function (b) {
                var d = [],
                    c = n.duration;
                L(b, function (b, a) {
                  b.isActive || (b.render(a, !1, 0), b.isActive = !1, d.push(a));
                });
                V(function () {
                  for (var a = d.length; a--;) {
                    b[d[a]] && !b[d[a]].isActive && (b[d[a]].destroy(), delete b[d[a]]);
                  }
                }, b !== k && a.hasRendered && c ? c : 0);
              });
              q && (q[q.isPlaced ? "animate" : "attr"]({
                d: this.getLinePath(q.strokeWidth())
              }), q.isPlaced = !0, q[v ? "show" : "hide"](v));
              p && v && (e = d.getTitlePosition(), b(e.y) ? (p[p.isNew ? "attr" : "animate"](e), p.isNew = !1) : (p.attr("y", -9999), p.isNew = !0));
              G && G.enabled && d.stacking && d.stacking.renderStackTotals();
              d.old = {
                len: d.len,
                max: d.max,
                min: d.min,
                transA: d.transA,
                userMax: d.userMax,
                userMin: d.userMin
              };
              d.isDirty = !1;
              t(this, "afterRender");
            };

            a.prototype.redraw = function () {
              this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
                b.render();
              }));
              this.series.forEach(function (b) {
                b.isDirty = !0;
              });
            };

            a.prototype.getKeepProps = function () {
              return this.keepProps || a.keepProps;
            };

            a.prototype.destroy = function (b) {
              var d = this,
                  a = d.plotLinesAndBands,
                  c = this.eventOptions;
              t(this, "destroy", {
                keepEvents: b
              });
              b || S(d);
              [d.ticks, d.minorTicks, d.alternateBands].forEach(function (b) {
                r(b);
              });
              if (a) for (b = a.length; b--;) {
                a[b].destroy();
              }
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
                d[b] && (d[b] = d[b].destroy());
              });

              for (var e in d.plotLinesAndBandsGroups) {
                d.plotLinesAndBandsGroups[e] = d.plotLinesAndBandsGroups[e].destroy();
              }

              L(d, function (b, a) {
                -1 === d.getKeepProps().indexOf(a) && delete d[a];
              });
              this.eventOptions = c;
            };

            a.prototype.drawCrosshair = function (b, d) {
              var a = this.crosshair,
                  c = F(a && a.snap, !0),
                  e = this.chart,
                  h,
                  f = this.cross;
              t(this, "drawCrosshair", {
                e: b,
                point: d
              });
              b || (b = this.cross && this.cross.e);

              if (a && !1 !== (k(d) || !c)) {
                c ? k(d) && (h = F("colorAxis" !== this.coll ? d.crosshairPos : null, this.isXAxis ? d.plotX : this.len - d.plotY)) : h = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);

                if (k(h)) {
                  var p = {
                    value: d && (this.isXAxis ? d.x : F(d.stackY, d.y)),
                    translatedValue: h
                  };
                  e.polar && O(p, {
                    isCrosshair: !0,
                    chartX: b && b.chartX,
                    chartY: b && b.chartY,
                    point: d
                  });
                  p = this.getPlotLinePath(p) || null;
                }

                if (!k(p)) {
                  this.hideCrosshair();
                  return;
                }

                c = this.categories && !this.isRadial;
                f || (this.cross = f = e.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (c ? "category " : "thin ") + (a.className || "")).attr({
                  zIndex: F(a.zIndex, 2)
                }).add(), e.styledMode || (f.attr({
                  stroke: a.color || (c ? C.parse(E.highlightColor20).setOpacity(.25).get() : E.neutralColor20),
                  "stroke-width": F(a.width, 1)
                }).css({
                  "pointer-events": "none"
                }), a.dashStyle && f.attr({
                  dashstyle: a.dashStyle
                })));
                f.show().attr({
                  d: p
                });
                c && !a.width && f.attr({
                  "stroke-width": this.transA
                });
                this.cross.e = b;
              } else this.hideCrosshair();

              t(this, "afterDrawCrosshair", {
                e: b,
                point: d
              });
            };

            a.prototype.hideCrosshair = function () {
              this.cross && this.cross.hide();
              t(this, "afterHideCrosshair");
            };

            a.prototype.hasVerticalPanning = function () {
              var b = this.chart.options.chart.panning;
              return !!(b && b.enabled && /y/.test(b.type));
            };

            a.prototype.validatePositiveValue = function (d) {
              return b(d) && 0 < d;
            };

            a.prototype.update = function (b, d) {
              var a = this.chart;
              b = G(this.userOptions, b);
              this.destroy(!0);
              this.init(a, b);
              a.isDirtyBox = !0;
              F(d, !0) && a.redraw();
            };

            a.prototype.remove = function (b) {
              for (var d = this.chart, a = this.coll, c = this.series, e = c.length; e--;) {
                c[e] && c[e].remove(!1);
              }

              D(d.axes, this);
              D(d[a], this);
              d[a].forEach(function (b, d) {
                b.options.index = b.userOptions.index = d;
              });
              this.destroy();
              d.isDirtyBox = !0;
              F(b, !0) && d.redraw();
            };

            a.prototype.setTitle = function (b, d) {
              this.update({
                title: b
              }, d);
            };

            a.prototype.setCategories = function (b, d) {
              this.update({
                categories: b
              }, d);
            };

            a.defaultOptions = w.defaultXAxisOptions;
            a.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return a;
          }();

          "";
          return a;
        });
        M(a, "Core/Axis/DateTimeAxis.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.addEvent,
              C = a.getMagnitude,
              E = a.normalizeTickInterval,
              z = a.timeUnits,
              x;

          (function (a) {
            function u() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }

            function n(a) {
              "datetime" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new g(this));
            }

            var m = [];

            a.compose = function (a) {
              -1 === m.indexOf(a) && (m.push(a), a.keepProps.push("dateTime"), a.prototype.getTimeTicks = u, r(a, "init", n));
              return a;
            };

            var g = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.normalizeTimeTickInterval = function (a, c) {
                var e = c || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                c = e[e.length - 1];
                var g = z[c[0]],
                    l = c[1],
                    k;

                for (k = 0; k < e.length && !(c = e[k], g = z[c[0]], l = c[1], e[k + 1] && a <= (g * l[l.length - 1] + z[e[k + 1][0]]) / 2); k++) {
                  ;
                }

                g === z.year && a < 5 * g && (l = [1, 2, 5]);
                a = E(a / g, l, "year" === c[0] ? Math.max(C(a / g), 1) : 1);
                return {
                  unitRange: g,
                  count: a,
                  unitName: c[0]
                };
              };

              a.prototype.getXDateFormat = function (a, c) {
                var e = this.axis;
                return e.closestPointRange ? e.chart.time.getDateFormat(e.closestPointRange, a, e.options.startOfWeek, c) || c.year : c.day;
              };

              return a;
            }();

            a.Additions = g;
          })(x || (x = {}));

          return x;
        });
        M(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.addEvent,
              C = a.getMagnitude,
              E = a.normalizeTickInterval,
              z = a.pick,
              x;

          (function (a) {
            function u(a) {
              var c = this.logarithmic;
              "logarithmic" !== a.userOptions.type ? this.logarithmic = void 0 : c || (this.logarithmic = new g(this));
            }

            function n() {
              var a = this.logarithmic;
              a && (this.lin2val = function (c) {
                return a.lin2log(c);
              }, this.val2lin = function (c) {
                return a.log2lin(c);
              });
            }

            var m = [];

            a.compose = function (a) {
              -1 === m.indexOf(a) && (m.push(a), a.keepProps.push("logarithmic"), r(a, "init", u), r(a, "afterInit", n));
              return a;
            };

            var g = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.getLogTickPositions = function (a, c, f, g) {
                var e = this.axis,
                    k = e.len,
                    l = e.options,
                    m = [];
                g || (this.minorAutoInterval = void 0);
                if (.5 <= a) a = Math.round(a), m = e.getLinearTickPositions(a, c, f);else if (.08 <= a) {
                  var n = Math.floor(c),
                      v,
                      t = l = void 0;

                  for (k = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; n < f + 1 && !t; n++) {
                    var h = k.length;

                    for (v = 0; v < h && !t; v++) {
                      var d = this.log2lin(this.lin2log(n) * k[v]);
                      d > c && (!g || l <= f) && "undefined" !== typeof l && m.push(l);
                      l > f && (t = !0);
                      l = d;
                    }
                  }
                } else c = this.lin2log(c), f = this.lin2log(f), a = g ? e.getMinorTickInterval() : l.tickInterval, a = z("auto" === a ? null : a, this.minorAutoInterval, l.tickPixelInterval / (g ? 5 : 1) * (f - c) / ((g ? k / e.tickPositions.length : k) || 1)), a = E(a, void 0, C(a)), m = e.getLinearTickPositions(a, c, f).map(this.log2lin), g || (this.minorAutoInterval = a / 5);
                g || (e.tickInterval = a);
                return m;
              };

              a.prototype.lin2log = function (a) {
                return Math.pow(10, a);
              };

              a.prototype.log2lin = function (a) {
                return Math.log(a) / Math.LN10;
              };

              return a;
            }();

            a.Additions = g;
          })(x || (x = {}));

          return x;
        });
        M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.erase,
              C = a.extend,
              E = a.isNumber,
              z;

          (function (a) {
            var x = [],
                u;

            a.compose = function (a, g) {
              u || (u = a);
              -1 === x.indexOf(g) && (x.push(g), C(g.prototype, n.prototype));
              return g;
            };

            var n = function () {
              function a() {}

              a.prototype.getPlotBandPath = function (a, c, e) {
                void 0 === e && (e = this.options);
                var g = this.getPlotLinePath({
                  value: c,
                  force: !0,
                  acrossPanes: e.acrossPanes
                }),
                    f = [],
                    m = this.horiz;
                c = !E(this.min) || !E(this.max) || a < this.min && c < this.min || a > this.max && c > this.max;
                a = this.getPlotLinePath({
                  value: a,
                  force: !0,
                  acrossPanes: e.acrossPanes
                });
                e = 1;

                if (a && g) {
                  if (c) {
                    var q = a.toString() === g.toString();
                    e = 0;
                  }

                  for (c = 0; c < a.length; c += 2) {
                    var k = a[c],
                        n = a[c + 1],
                        r = g[c],
                        B = g[c + 1];
                    "M" !== k[0] && "L" !== k[0] || "M" !== n[0] && "L" !== n[0] || "M" !== r[0] && "L" !== r[0] || "M" !== B[0] && "L" !== B[0] || (m && r[1] === k[1] ? (r[1] += e, B[1] += e) : m || r[2] !== k[2] || (r[2] += e, B[2] += e), f.push(["M", k[1], k[2]], ["L", n[1], n[2]], ["L", B[1], B[2]], ["L", r[1], r[2]], ["Z"]));
                    f.isFlat = q;
                  }
                }

                return f;
              };

              a.prototype.addPlotBand = function (a) {
                return this.addPlotBandOrLine(a, "plotBands");
              };

              a.prototype.addPlotLine = function (a) {
                return this.addPlotBandOrLine(a, "plotLines");
              };

              a.prototype.addPlotBandOrLine = function (a, c) {
                var e = this,
                    g = this.userOptions,
                    f = new u(this, a);
                this.visible && (f = f.render());

                if (f) {
                  this._addedPlotLB || (this._addedPlotLB = !0, (g.plotLines || []).concat(g.plotBands || []).forEach(function (a) {
                    e.addPlotBandOrLine(a);
                  }));

                  if (c) {
                    var m = g[c] || [];
                    m.push(a);
                    g[c] = m;
                  }

                  this.plotLinesAndBands.push(f);
                }

                return f;
              };

              a.prototype.removePlotBandOrLine = function (a) {
                var c = this.plotLinesAndBands,
                    e = this.options,
                    g = this.userOptions;

                if (c) {
                  for (var f = c.length; f--;) {
                    c[f].id === a && c[f].destroy();
                  }

                  [e.plotLines || [], g.plotLines || [], e.plotBands || [], g.plotBands || []].forEach(function (c) {
                    for (f = c.length; f--;) {
                      (c[f] || {}).id === a && r(c, c[f]);
                    }
                  });
                }
              };

              a.prototype.removePlotBand = function (a) {
                this.removePlotBandOrLine(a);
              };

              a.prototype.removePlotLine = function (a) {
                this.removePlotBandOrLine(a);
              };

              return a;
            }();
          })(z || (z = {}));

          return z;
        });
        M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [a["Core/Color/Palette.js"], a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = C.arrayMax,
              z = C.arrayMin,
              x = C.defined,
              J = C.destroyObjectProperties,
              u = C.erase,
              n = C.fireEvent,
              m = C.merge,
              g = C.objectEach,
              c = C.pick;

          C = function () {
            function e(a, c) {
              this.axis = a;
              c && (this.options = c, this.id = c.id);
            }

            e.compose = function (a) {
              return w.compose(e, a);
            };

            e.prototype.render = function () {
              n(this, "render");
              var e = this,
                  f = e.axis,
                  v = f.horiz,
                  q = f.logarithmic,
                  k = e.options,
                  r = k.color,
                  D = c(k.zIndex, 0),
                  B = k.events,
                  u = {},
                  t = f.chart.renderer,
                  h = k.label,
                  d = e.label,
                  b = k.to,
                  p = k.from,
                  G = k.value,
                  y = e.svgElem,
                  L = [],
                  F = x(p) && x(b);
              L = x(G);
              var P = !y,
                  S = {
                "class": "highcharts-plot-" + (F ? "band " : "line ") + (k.className || "")
              },
                  Q = F ? "bands" : "lines";
              q && (p = q.log2lin(p), b = q.log2lin(b), G = q.log2lin(G));
              f.chart.styledMode || (L ? (S.stroke = r || a.neutralColor40, S["stroke-width"] = c(k.width, 1), k.dashStyle && (S.dashstyle = k.dashStyle)) : F && (S.fill = r || a.highlightColor10, k.borderWidth && (S.stroke = k.borderColor, S["stroke-width"] = k.borderWidth)));
              u.zIndex = D;
              Q += "-" + D;
              (q = f.plotLinesAndBandsGroups[Q]) || (f.plotLinesAndBandsGroups[Q] = q = t.g("plot-" + Q).attr(u).add());
              P && (e.svgElem = y = t.path().attr(S).add(q));
              if (L) L = f.getPlotLinePath({
                value: G,
                lineWidth: y.strokeWidth(),
                acrossPanes: k.acrossPanes
              });else if (F) L = f.getPlotBandPath(p, b, k);else return;
              !e.eventsAdded && B && (g(B, function (b, d) {
                y.on(d, function (b) {
                  B[d].apply(e, [b]);
                });
              }), e.eventsAdded = !0);
              (P || !y.d) && L && L.length ? y.attr({
                d: L
              }) : y && (L ? (y.show(!0), y.animate({
                d: L
              })) : y.d && (y.hide(), d && (e.label = d = d.destroy())));
              h && (x(h.text) || x(h.formatter)) && L && L.length && 0 < f.width && 0 < f.height && !L.isFlat ? (h = m({
                align: v && F && "center",
                x: v ? !F && 4 : 10,
                verticalAlign: !v && F && "middle",
                y: v ? F ? 16 : 10 : F ? 6 : -4,
                rotation: v && !F && 90
              }, h), this.renderLabel(h, L, F, D)) : d && d.hide();
              return e;
            };

            e.prototype.renderLabel = function (a, c, e, g) {
              var f = this.axis,
                  l = f.chart.renderer,
                  q = this.label;
              q || (this.label = q = l.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
                align: a.textAlign || a.align,
                rotation: a.rotation,
                "class": "highcharts-plot-" + (e ? "band" : "line") + "-label " + (a.className || ""),
                zIndex: g
              }).add(), f.chart.styledMode || q.css(m({
                textOverflow: "ellipsis"
              }, a.style)));
              g = c.xBounds || [c[0][1], c[1][1], e ? c[2][1] : c[0][1]];
              c = c.yBounds || [c[0][2], c[1][2], e ? c[2][2] : c[0][2]];
              e = z(g);
              l = z(c);
              q.align(a, !1, {
                x: e,
                y: l,
                width: r(g) - e,
                height: r(c) - l
              });
              q.alignValue && "left" !== q.alignValue || q.css({
                width: (90 === q.rotation ? f.height - (q.alignAttr.y - f.top) : f.width - (q.alignAttr.x - f.left)) + "px"
              });
              q.show(!0);
            };

            e.prototype.getLabelText = function (a) {
              return x(a.formatter) ? a.formatter.call(this) : a.text;
            };

            e.prototype.destroy = function () {
              u(this.axis.plotLinesAndBands, this);
              delete this.axis;
              J(this);
            };

            return e;
          }();

          "";
          "";
          return C;
        });
        M(a, "Core/Tooltip.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x) {
          var r = a.format,
              u = w.doc,
              n = E.distribute,
              m = x.addEvent,
              g = x.clamp,
              c = x.css,
              e = x.defined,
              l = x.discardElement,
              f = x.extend,
              v = x.fireEvent,
              q = x.isArray,
              k = x.isNumber,
              I = x.isString,
              D = x.merge,
              B = x.pick,
              O = x.splat,
              t = x.syncTimeout;

          a = function () {
            function a(a, b) {
              this.container = void 0;
              this.crosshairs = [];
              this.distance = 0;
              this.isHidden = !0;
              this.isSticky = !1;
              this.now = {};
              this.options = {};
              this.outside = !1;
              this.chart = a;
              this.init(a, b);
            }

            a.prototype.applyFilter = function () {
              var a = this.chart;
              a.renderer.definition({
                tagName: "filter",
                attributes: {
                  id: "drop-shadow-" + a.index,
                  opacity: .5
                },
                children: [{
                  tagName: "feGaussianBlur",
                  attributes: {
                    "in": "SourceAlpha",
                    stdDeviation: 1
                  }
                }, {
                  tagName: "feOffset",
                  attributes: {
                    dx: 1,
                    dy: 1
                  }
                }, {
                  tagName: "feComponentTransfer",
                  children: [{
                    tagName: "feFuncA",
                    attributes: {
                      type: "linear",
                      slope: .3
                    }
                  }]
                }, {
                  tagName: "feMerge",
                  children: [{
                    tagName: "feMergeNode"
                  }, {
                    tagName: "feMergeNode",
                    attributes: {
                      "in": "SourceGraphic"
                    }
                  }]
                }]
              });
            };

            a.prototype.bodyFormatter = function (a) {
              return a.map(function (b) {
                var a = b.series.tooltipOptions;
                return (a[(b.point.formatPrefix || "point") + "Formatter"] || b.point.tooltipFormatter).call(b.point, a[(b.point.formatPrefix || "point") + "Format"] || "");
              });
            };

            a.prototype.cleanSplit = function (a) {
              this.chart.series.forEach(function (b) {
                var d = b && b.tt;
                d && (!d.isActive || a ? b.tt = d.destroy() : d.isActive = !1);
              });
            };

            a.prototype.defaultFormatter = function (a) {
              var b = this.points || O(this);
              var d = [a.tooltipFooterHeaderFormatter(b[0])];
              d = d.concat(a.bodyFormatter(b));
              d.push(a.tooltipFooterHeaderFormatter(b[0], !0));
              return d;
            };

            a.prototype.destroy = function () {
              this.label && (this.label = this.label.destroy());
              this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
              this.renderer && (this.renderer = this.renderer.destroy(), l(this.container));
              x.clearTimeout(this.hideTimer);
              x.clearTimeout(this.tooltipTimeout);
            };

            a.prototype.getAnchor = function (a, b) {
              var d = this.chart,
                  c = d.pointer,
                  e = d.inverted,
                  h = d.plotTop,
                  f = d.plotLeft,
                  g,
                  k,
                  t = 0,
                  l = 0;
              a = O(a);
              this.followPointer && b ? ("undefined" === typeof b.chartX && (b = c.normalize(b)), c = [b.chartX - f, b.chartY - h]) : a[0].tooltipPos ? c = a[0].tooltipPos : (a.forEach(function (b) {
                g = b.series.yAxis;
                k = b.series.xAxis;
                t += b.plotX || 0;
                l += b.plotLow ? (b.plotLow + (b.plotHigh || 0)) / 2 : b.plotY || 0;
                k && g && (e ? (t += h + d.plotHeight - k.len - k.pos, l += f + d.plotWidth - g.len - g.pos) : (t += k.pos - f, l += g.pos - h));
              }), t /= a.length, l /= a.length, c = [e ? d.plotWidth - l : t, e ? d.plotHeight - t : l], this.shared && 1 < a.length && b && (e ? c[0] = b.chartX - f : c[1] = b.chartY - h));
              return c.map(Math.round);
            };

            a.prototype.getLabel = function () {
              var a = this,
                  b = this.chart.styledMode,
                  h = this.options,
                  f = "tooltip" + (e(h.className) ? " " + h.className : ""),
                  g = h.style.pointerEvents || (!this.followPointer && h.stickOnContact ? "auto" : "none"),
                  k = function k() {
                a.inContact = !0;
              },
                  t = function t(b) {
                var d = a.chart.hoverSeries;
                a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(b.relatedTarget, "highcharts-tooltip");
                if (!a.inContact && d && d.onMouseOut) d.onMouseOut();
              },
                  l,
                  q = this.chart.renderer;

              if (!this.label) {
                if (this.outside) {
                  var n = this.chart.options.chart.style,
                      v = z.getRendererType();
                  this.container = l = w.doc.createElement("div");
                  l.className = "highcharts-tooltip-container";
                  c(l, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: g,
                    zIndex: Math.max(this.options.style.zIndex || 0, (n && n.zIndex || 0) + 3)
                  });
                  m(l, "mouseenter", k);
                  m(l, "mouseleave", t);
                  w.doc.body.appendChild(l);
                  this.renderer = q = new v(l, 0, 0, n, void 0, void 0, q.styledMode);
                }

                this.split ? this.label = q.g(f) : (this.label = q.label("", 0, 0, h.shape, void 0, void 0, h.useHTML, void 0, f).attr({
                  padding: h.padding,
                  r: h.borderRadius
                }), b || this.label.attr({
                  fill: h.backgroundColor,
                  "stroke-width": h.borderWidth
                }).css(h.style).css({
                  pointerEvents: g
                }).shadow(h.shadow));
                b && h.shadow && (this.applyFilter(), this.label.attr({
                  filter: "url(#drop-shadow-" + this.chart.index + ")"
                }));

                if (a.outside && !a.split) {
                  var r = this.label,
                      B = r.xSetter,
                      D = r.ySetter;

                  r.xSetter = function (b) {
                    B.call(r, a.distance);
                    l.style.left = b + "px";
                  };

                  r.ySetter = function (b) {
                    D.call(r, a.distance);
                    l.style.top = b + "px";
                  };
                }

                this.label.on("mouseenter", k).on("mouseleave", t).attr({
                  zIndex: 8
                }).add();
              }

              return this.label;
            };

            a.prototype.getPosition = function (a, b, c) {
              var d = this.chart,
                  e = this.distance,
                  h = {},
                  f = d.inverted && c.h || 0,
                  g = this.outside,
                  p = g ? u.documentElement.clientWidth - 2 * e : d.chartWidth,
                  k = g ? Math.max(u.body.scrollHeight, u.documentElement.scrollHeight, u.body.offsetHeight, u.documentElement.offsetHeight, u.documentElement.clientHeight) : d.chartHeight,
                  l = d.pointer.getChartPosition(),
                  t = function t(h) {
                var f = "x" === h;
                return [h, f ? p : k, f ? a : b].concat(g ? [f ? a * l.scaleX : b * l.scaleY, f ? l.left - e + (c.plotX + d.plotLeft) * l.scaleX : l.top - e + (c.plotY + d.plotTop) * l.scaleY, 0, f ? p : k] : [f ? a : b, f ? c.plotX + d.plotLeft : c.plotY + d.plotTop, f ? d.plotLeft : d.plotTop, f ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);
              },
                  m = t("y"),
                  q = t("x"),
                  n,
                  v = !this.followPointer && B(c.ttBelow, !d.inverted === !!c.negative),
                  r = function r(b, a, d, c, p, k, y) {
                var t = g ? "y" === b ? e * l.scaleY : e * l.scaleX : e,
                    G = (d - c) / 2,
                    A = c < p - e,
                    m = p + e + c < a,
                    F = p - t - d + G;
                p = p + t - G;
                if (v && m) h[b] = p;else if (!v && A) h[b] = F;else if (A) h[b] = Math.min(y - c, 0 > F - f ? F : F - f);else if (m) h[b] = Math.max(k, p + f + d > a ? p : p + f);else return !1;
              },
                  D = function D(b, a, d, c, f) {
                var g;
                f < e || f > a - e ? g = !1 : h[b] = f < d / 2 ? 1 : f > a - c / 2 ? a - c - 2 : f - d / 2;
                return g;
              },
                  A = function A(b) {
                var a = m;
                m = q;
                q = a;
                n = b;
              },
                  U = function U() {
                !1 !== r.apply(0, m) ? !1 !== D.apply(0, q) || n || (A(!0), U()) : n ? h.x = h.y = 0 : (A(!0), U());
              };

              (d.inverted || 1 < this.len) && A();
              U();
              return h;
            };

            a.prototype.hide = function (a) {
              var b = this;
              x.clearTimeout(this.hideTimer);
              a = B(a, this.options.hideDelay);
              this.isHidden || (this.hideTimer = t(function () {
                b.getLabel().fadeOut(a ? void 0 : a);
                b.isHidden = !0;
              }, a));
            };

            a.prototype.init = function (a, b) {
              this.chart = a;
              this.options = b;
              this.crosshairs = [];
              this.now = {
                x: 0,
                y: 0
              };
              this.isHidden = !0;
              this.split = b.split && !a.inverted && !a.polar;
              this.shared = b.shared || this.split;
              this.outside = B(b.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));
            };

            a.prototype.shouldStickOnContact = function () {
              return !(this.followPointer || !this.options.stickOnContact);
            };

            a.prototype.isStickyOnContact = function () {
              return !(!this.shouldStickOnContact() || !this.inContact);
            };

            a.prototype.move = function (a, b, c, e) {
              var d = this,
                  h = d.now,
                  g = !1 !== d.options.animation && !d.isHidden && (1 < Math.abs(a - h.x) || 1 < Math.abs(b - h.y)),
                  p = d.followPointer || 1 < d.len;
              f(h, {
                x: g ? (2 * h.x + a) / 3 : a,
                y: g ? (h.y + b) / 2 : b,
                anchorX: p ? void 0 : g ? (2 * h.anchorX + c) / 3 : c,
                anchorY: p ? void 0 : g ? (h.anchorY + e) / 2 : e
              });
              d.getLabel().attr(h);
              d.drawTracker();
              g && (x.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                d && d.move(a, b, c, e);
              }, 32));
            };

            a.prototype.refresh = function (a, b) {
              var d = this.chart,
                  c = this.options,
                  e = O(a),
                  h = e[0],
                  f = [],
                  g = c.formatter || this.defaultFormatter,
                  k = this.shared,
                  l = d.styledMode,
                  t = {};

              if (c.enabled) {
                x.clearTimeout(this.hideTimer);
                this.followPointer = !this.split && h.series.tooltipOptions.followPointer;
                var m = this.getAnchor(a, b),
                    n = m[0],
                    r = m[1];
                !k || !q(a) && a.series && a.series.noSharedTooltip ? t = h.getLabelConfig() : (d.pointer.applyInactiveState(e), e.forEach(function (b) {
                  b.setState("hover");
                  f.push(b.getLabelConfig());
                }), t = {
                  x: h.category,
                  y: h.y
                }, t.points = f);
                this.len = f.length;
                a = g.call(t, this);
                g = h.series;
                this.distance = B(g.tooltipOptions.distance, 16);
                if (!1 === a) this.hide();else {
                  if (this.split) this.renderSplit(a, e);else if (e = n, k = r, b && d.pointer.isDirectTouch && (e = b.chartX - d.plotLeft, k = b.chartY - d.plotTop), d.polar || !1 === g.options.clip || g.shouldShowTooltip(e, k)) b = this.getLabel(), c.style.width && !l || b.css({
                    width: this.chart.spacingBox.width + "px"
                  }), b.attr({
                    text: a && a.join ? a.join("") : a
                  }), b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + B(h.colorIndex, g.colorIndex)), l || b.attr({
                    stroke: c.borderColor || h.color || g.color || C.neutralColor60
                  }), this.updatePosition({
                    plotX: n,
                    plotY: r,
                    negative: h.negative,
                    ttBelow: h.ttBelow,
                    h: m[2] || 0
                  });else {
                    this.hide();
                    return;
                  }
                  this.isHidden && this.label && this.label.attr({
                    opacity: 1
                  }).show();
                  this.isHidden = !1;
                }
                v(this, "refresh");
              }
            };

            a.prototype.renderSplit = function (a, b) {
              function d(b, a, d, e, h) {
                void 0 === h && (h = !0);
                d ? (a = Y ? 0 : J, b = g(b - e / 2, N.left, N.right - e - (c.outside ? T : 0))) : (a -= da, b = h ? b - e - z : b + z, b = g(b, h ? b : N.left, N.right));
                return {
                  x: b,
                  y: a
                };
              }

              var c = this,
                  e = c.chart,
                  h = c.chart,
                  k = h.chartWidth,
                  l = h.chartHeight,
                  t = h.plotHeight,
                  m = h.plotLeft,
                  q = h.plotTop,
                  r = h.pointer,
                  v = h.scrollablePixelsY;
              v = void 0 === v ? 0 : v;
              var D = h.scrollablePixelsX,
                  x = h.scrollingContainer;
              x = void 0 === x ? {
                scrollLeft: 0,
                scrollTop: 0
              } : x;
              var w = x.scrollLeft;
              x = x.scrollTop;
              var O = h.styledMode,
                  z = c.distance,
                  A = c.options,
                  U = c.options.positioner,
                  N = c.outside && "number" !== typeof D ? u.documentElement.getBoundingClientRect() : {
                left: w,
                right: w + k,
                top: x,
                bottom: x + l
              },
                  W = c.getLabel(),
                  X = this.renderer || e.renderer,
                  Y = !(!e.xAxis[0] || !e.xAxis[0].opposite);
              e = r.getChartPosition();
              var T = e.left;
              e = e.top;
              var da = q + x,
                  E = 0,
                  J = t - v;
              I(a) && (a = [!1, a]);
              a = a.slice(0, b.length + 1).reduce(function (a, e, h) {
                if (!1 !== e && "" !== e) {
                  h = b[h - 1] || {
                    isHeader: !0,
                    plotX: b[0].plotX,
                    plotY: t,
                    series: {}
                  };
                  var f = h.isHeader,
                      p = f ? c : h.series;
                  e = e.toString();
                  var k = p.tt,
                      l = h.isHeader;
                  var y = h.series;
                  var G = "highcharts-color-" + B(h.colorIndex, y.colorIndex, "none");
                  k || (k = {
                    padding: A.padding,
                    r: A.borderRadius
                  }, O || (k.fill = A.backgroundColor, k["stroke-width"] = A.borderWidth), k = X.label("", 0, 0, A[l ? "headerShape" : "shape"], void 0, void 0, A.useHTML).addClass((l ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + G).attr(k).add(W));
                  k.isActive = !0;
                  k.attr({
                    text: e
                  });
                  O || k.css(A.style).shadow(A.shadow).attr({
                    stroke: A.borderColor || h.color || y.color || C.neutralColor80
                  });
                  p = p.tt = k;
                  l = p.getBBox();
                  e = l.width + p.strokeWidth();
                  f && (E = l.height, J += E, Y && (da -= E));
                  y = h.plotX;
                  y = void 0 === y ? 0 : y;
                  G = h.plotY;
                  G = void 0 === G ? 0 : G;
                  k = h.series;

                  if (h.isHeader) {
                    y = m + y;
                    var F = q + t / 2;
                  } else {
                    var n = k.xAxis,
                        ca = k.yAxis;
                    y = n.pos + g(y, -z, n.len + z);
                    k.shouldShowTooltip(0, ca.pos - q + G, {
                      ignoreX: !0
                    }) && (F = ca.pos + G);
                  }

                  y = g(y, N.left - z, N.right + z);
                  "number" === typeof F ? (l = l.height + 1, G = U ? U.call(c, e, l, h) : d(y, F, f, e), a.push({
                    align: U ? 0 : void 0,
                    anchorX: y,
                    anchorY: F,
                    boxWidth: e,
                    point: h,
                    rank: B(G.rank, f ? 1 : 0),
                    size: l,
                    target: G.y,
                    tt: p,
                    x: G.x
                  })) : p.isActive = !1;
                }

                return a;
              }, []);
              !U && a.some(function (b) {
                var a = (c.outside ? T : 0) + b.anchorX;
                return a < N.left && a + b.boxWidth < N.right ? !0 : a < T - N.left + b.boxWidth && N.right - a > a;
              }) && (a = a.map(function (b) {
                var a = d(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
                return f(b, {
                  target: a.y,
                  x: a.x
                });
              }));
              c.cleanSplit();
              n(a, J);
              var ba = T,
                  ea = T;
              a.forEach(function (b) {
                var a = b.x,
                    d = b.boxWidth;
                b = b.isHeader;
                b || (c.outside && T + a < ba && (ba = T + a), !b && c.outside && ba + d > ea && (ea = T + a));
              });
              a.forEach(function (b) {
                var a = b.x,
                    d = b.anchorX,
                    e = b.pos,
                    h = b.point.isHeader;
                e = {
                  visibility: "undefined" === typeof e ? "hidden" : "inherit",
                  x: a,
                  y: e + da,
                  anchorX: d,
                  anchorY: b.anchorY
                };

                if (c.outside && a < d) {
                  var f = T - ba;
                  0 < f && (h || (e.x = a + f, e.anchorX = d + f), h && (e.x = (ea - ba) / 2, e.anchorX = d + f));
                }

                b.tt.attr(e);
              });
              a = c.container;
              v = c.renderer;
              c.outside && a && v && (h = W.getBBox(), v.setSize(h.width + h.x, h.height + h.y, !1), a.style.left = ba + "px", a.style.top = e + "px");
            };

            a.prototype.drawTracker = function () {
              if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
                var a = this.chart,
                    b = this.label,
                    c = this.shared ? a.hoverPoints : a.hoverPoint;

                if (b && c) {
                  var e = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                  c = this.getAnchor(c);
                  var h = b.getBBox();
                  c[0] += a.plotLeft - b.translateX;
                  c[1] += a.plotTop - b.translateY;
                  e.x = Math.min(0, c[0]);
                  e.y = Math.min(0, c[1]);
                  e.width = 0 > c[0] ? Math.max(Math.abs(c[0]), h.width - c[0]) : Math.max(Math.abs(c[0]), h.width);
                  e.height = 0 > c[1] ? Math.max(Math.abs(c[1]), h.height - Math.abs(c[1])) : Math.max(Math.abs(c[1]), h.height);
                  this.tracker ? this.tracker.attr(e) : (this.tracker = b.renderer.rect(e).addClass("highcharts-tracker").add(b), a.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                  }));
                }
              }
            };

            a.prototype.styledModeFormat = function (a) {
              return a.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };

            a.prototype.tooltipFooterHeaderFormatter = function (a, b) {
              var d = a.series,
                  c = d.tooltipOptions,
                  e = d.xAxis,
                  h = e && e.dateTime;
              e = {
                isFooter: b,
                labelConfig: a
              };
              var f = c.xDateFormat,
                  g = c[b ? "footerFormat" : "headerFormat"];
              v(this, "headerFormatter", e, function (b) {
                h && !f && k(a.key) && (f = h.getXDateFormat(a.key, c.dateTimeLabelFormats));
                h && f && (a.point && a.point.tooltipDateKeys || ["key"]).forEach(function (b) {
                  g = g.replace("{point." + b + "}", "{point." + b + ":" + f + "}");
                });
                d.chart.styledMode && (g = this.styledModeFormat(g));
                b.text = r(g, {
                  point: a,
                  series: d
                }, this.chart);
              });
              return e.text;
            };

            a.prototype.update = function (a) {
              this.destroy();
              D(!0, this.chart.options.tooltip.userOptions, a);
              this.init(this.chart, D(!0, this.options, a));
            };

            a.prototype.updatePosition = function (a) {
              var b = this.chart,
                  d = this.options,
                  e = b.pointer,
                  h = this.getLabel();
              e = e.getChartPosition();
              var f = (d.positioner || this.getPosition).call(this, h.width, h.height, a),
                  g = a.plotX + b.plotLeft;
              a = a.plotY + b.plotTop;

              if (this.outside) {
                d = d.borderWidth + 2 * this.distance;
                this.renderer.setSize(h.width + d, h.height + d, !1);
                if (1 !== e.scaleX || 1 !== e.scaleY) c(this.container, {
                  transform: "scale(" + e.scaleX + ", " + e.scaleY + ")"
                }), g *= e.scaleX, a *= e.scaleY;
                g += e.left - f.x;
                a += e.top - f.y;
              }

              this.move(Math.round(f.x), Math.round(f.y || 0), g, a);
            };

            return a;
          }();

          "";
          return a;
        });
        M(a, "Core/Series/Point.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function (a, w, C, E, z) {
          var r = w.animObject,
              J = C.defaultOptions,
              u = E.format,
              n = z.addEvent,
              m = z.defined,
              g = z.erase,
              c = z.extend,
              e = z.fireEvent,
              l = z.getNestedProperty,
              f = z.isArray,
              v = z.isFunction,
              q = z.isNumber,
              k = z.isObject,
              I = z.merge,
              D = z.objectEach,
              B = z.pick,
              O = z.syncTimeout,
              t = z.removeEvent,
              h = z.uniqueKey;

          w = function () {
            function d() {
              this.colorIndex = this.category = void 0;
              this.formatPrefix = "point";
              this.id = void 0;
              this.isNull = !1;
              this.percentage = this.options = this.name = void 0;
              this.selected = !1;
              this.total = this.series = void 0;
              this.visible = !0;
              this.x = void 0;
            }

            d.prototype.animateBeforeDestroy = function () {
              var b = this,
                  a = {
                x: b.startXPos,
                opacity: 0
              },
                  d = b.getGraphicalProps();
              d.singular.forEach(function (d) {
                b[d] = b[d].animate("dataLabel" === d ? {
                  x: b[d].startXPos,
                  y: b[d].startYPos,
                  opacity: 0
                } : a);
              });
              d.plural.forEach(function (a) {
                b[a].forEach(function (a) {
                  a.element && a.animate(c({
                    x: b.startXPos
                  }, a.startYPos ? {
                    x: a.startXPos,
                    y: a.startYPos
                  } : {}));
                });
              });
            };

            d.prototype.applyOptions = function (b, a) {
              var e = this.series,
                  h = e.options.pointValKey || e.pointValKey;
              b = d.prototype.optionsToObject.call(this, b);
              c(this, b);
              this.options = this.options ? c(this.options, b) : b;
              b.group && delete this.group;
              b.dataLabels && delete this.dataLabels;
              h && (this.y = d.prototype.getNestedProperty.call(this, h));
              this.formatPrefix = (this.isNull = B(this.isValid && !this.isValid(), null === this.x || !q(this.y))) ? "null" : "point";
              this.selected && (this.state = "select");
              "name" in this && "undefined" === typeof a && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));
              "undefined" === typeof this.x && e ? this.x = "undefined" === typeof a ? e.autoIncrement() : a : q(b.x) && e.options.relativeXValue && (this.x = e.autoIncrement(b.x));
              return this;
            };

            d.prototype.destroy = function () {
              function b() {
                if (a.graphic || a.dataLabel || a.dataLabels) t(a), a.destroyElements();

                for (f in a) {
                  a[f] = null;
                }
              }

              var a = this,
                  d = a.series,
                  c = d.chart;
              d = d.options.dataSorting;
              var e = c.hoverPoints,
                  h = r(a.series.chart.renderer.globalAnimation),
                  f;
              a.legendItem && c.legend.destroyItem(a);
              e && (a.setState(), g(e, a), e.length || (c.hoverPoints = null));
              if (a === c.hoverPoint) a.onMouseOut();
              d && d.enabled ? (this.animateBeforeDestroy(), O(b, h.duration)) : b();
              c.pointCount--;
            };

            d.prototype.destroyElements = function (b) {
              var a = this;
              b = a.getGraphicalProps(b);
              b.singular.forEach(function (b) {
                a[b] = a[b].destroy();
              });
              b.plural.forEach(function (b) {
                a[b].forEach(function (b) {
                  b.element && b.destroy();
                });
                delete a[b];
              });
            };

            d.prototype.firePointEvent = function (b, a, d) {
              var c = this,
                  h = this.series.options;
              (h.point.events[b] || c.options && c.options.events && c.options.events[b]) && c.importEvents();
              "click" === b && h.allowPointSelect && (d = function d(b) {
                c.select && c.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
              });
              e(c, b, a, d);
            };

            d.prototype.getClassName = function () {
              return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };

            d.prototype.getGraphicalProps = function (b) {
              var a = this,
                  d = [],
                  c = {
                singular: [],
                plural: []
              },
                  e;
              b = b || {
                graphic: 1,
                dataLabel: 1
              };
              b.graphic && d.push("graphic", "upperGraphic", "shadowGroup");
              b.dataLabel && d.push("dataLabel", "dataLabelUpper", "connector");

              for (e = d.length; e--;) {
                var h = d[e];
                a[h] && c.singular.push(h);
              }

              ["dataLabel", "connector"].forEach(function (d) {
                var e = d + "s";
                b[d] && a[e] && c.plural.push(e);
              });
              return c;
            };

            d.prototype.getLabelConfig = function () {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
              };
            };

            d.prototype.getNestedProperty = function (b) {
              if (b) return 0 === b.indexOf("custom.") ? l(b, this.options) : this[b];
            };

            d.prototype.getZone = function () {
              var b = this.series,
                  a = b.zones;
              b = b.zoneAxis || "y";
              var d,
                  c = 0;

              for (d = a[c]; this[b] >= d.value;) {
                d = a[++c];
              }

              this.nonZonedColor || (this.nonZonedColor = this.color);
              this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;
              return d;
            };

            d.prototype.hasNewShapeType = function () {
              return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };

            d.prototype.init = function (b, a, d) {
              this.series = b;
              this.applyOptions(a, d);
              this.id = m(this.id) ? this.id : h();
              this.resolveColor();
              b.chart.pointCount++;
              e(this, "afterInit");
              return this;
            };

            d.prototype.optionsToObject = function (b) {
              var a = this.series,
                  c = a.options.keys,
                  e = c || a.pointArrayMap || ["y"],
                  h = e.length,
                  g = {},
                  k = 0,
                  l = 0;
              if (q(b) || null === b) g[e[0]] = b;else if (f(b)) for (!c && b.length > h && (a = typeof b[0], "string" === a ? g.name = b[0] : "number" === a && (g.x = b[0]), k++); l < h;) {
                c && "undefined" === typeof b[k] || (0 < e[l].indexOf(".") ? d.prototype.setNestedProperty(g, b[k], e[l]) : g[e[l]] = b[k]), k++, l++;
              } else "object" === typeof b && (g = b, b.dataLabels && (a._hasPointLabels = !0), b.marker && (a._hasPointMarkers = !0));
              return g;
            };

            d.prototype.resolveColor = function () {
              var b = this.series,
                  a = b.chart.styledMode;
              var d = b.chart.options.chart.colorCount;
              delete this.nonZonedColor;

              if (b.options.colorByPoint) {
                if (!a) {
                  d = b.options.colors || b.chart.options.colors;
                  var c = d[b.colorCounter];
                  d = d.length;
                }

                a = b.colorCounter;
                b.colorCounter++;
                b.colorCounter === d && (b.colorCounter = 0);
              } else a || (c = b.color), a = b.colorIndex;

              this.colorIndex = B(this.options.colorIndex, a);
              this.color = B(this.options.color, c);
            };

            d.prototype.setNestedProperty = function (b, a, d) {
              d.split(".").reduce(function (b, d, c, e) {
                b[d] = e.length - 1 === c ? a : k(b[d], !0) ? b[d] : {};
                return b[d];
              }, b);
              return b;
            };

            d.prototype.tooltipFormatter = function (b) {
              var a = this.series,
                  d = a.tooltipOptions,
                  c = B(d.valueDecimals, ""),
                  e = d.valuePrefix || "",
                  h = d.valueSuffix || "";
              a.chart.styledMode && (b = a.chart.tooltip.styledModeFormat(b));
              (a.pointArrayMap || ["y"]).forEach(function (a) {
                a = "{point." + a;
                if (e || h) b = b.replace(RegExp(a + "}", "g"), e + a + "}" + h);
                b = b.replace(RegExp(a + "}", "g"), a + ":,." + c + "f}");
              });
              return u(b, {
                point: this,
                series: this.series
              }, a.chart);
            };

            d.prototype.update = function (b, a, d, c) {
              function e() {
                h.applyOptions(b);
                var c = g && h.hasDummyGraphic;
                c = null === h.y ? !c : c;
                g && c && (h.graphic = g.destroy(), delete h.hasDummyGraphic);
                k(b, !0) && (g && g.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (h.graphic = g.destroy()), b && b.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));
                t = h.index;
                f.updateParallelArrays(h, t);
                l.data[t] = k(l.data[t], !0) || k(b, !0) ? h.options : B(b, l.data[t]);
                f.isDirty = f.isDirtyData = !0;
                !f.fixedBox && f.hasCartesianSeries && (p.isDirtyBox = !0);
                "point" === l.legendType && (p.isDirtyLegend = !0);
                a && p.redraw(d);
              }

              var h = this,
                  f = h.series,
                  g = h.graphic,
                  p = f.chart,
                  l = f.options,
                  t;
              a = B(a, !0);
              !1 === c ? e() : h.firePointEvent("update", {
                options: b
              }, e);
            };

            d.prototype.remove = function (b, a) {
              this.series.removePoint(this.series.data.indexOf(this), b, a);
            };

            d.prototype.select = function (b, a) {
              var d = this,
                  c = d.series,
                  e = c.chart;
              this.selectedStaging = b = B(b, !d.selected);
              d.firePointEvent(b ? "select" : "unselect", {
                accumulate: a
              }, function () {
                d.selected = d.options.selected = b;
                c.options.data[c.data.indexOf(d)] = d.options;
                d.setState(b && "select");
                a || e.getSelectedPoints().forEach(function (b) {
                  var a = b.series;
                  b.selected && b !== d && (b.selected = b.options.selected = !1, a.options.data[a.data.indexOf(b)] = b.options, b.setState(e.hoverPoints && a.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
                });
              });
              delete this.selectedStaging;
            };

            d.prototype.onMouseOver = function (b) {
              var a = this.series.chart,
                  d = a.pointer;
              b = b ? d.normalize(b) : d.getChartCoordinatesFromPoint(this, a.inverted);
              d.runPointActions(b, this);
            };

            d.prototype.onMouseOut = function () {
              var b = this.series.chart;
              this.firePointEvent("mouseOut");
              this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {
                b.setState();
              });
              b.hoverPoints = b.hoverPoint = null;
            };

            d.prototype.importEvents = function () {
              if (!this.hasImportedEvents) {
                var b = this,
                    a = I(b.series.options.point, b.options).events;
                b.events = a;
                D(a, function (a, d) {
                  v(a) && n(b, d, a);
                });
                this.hasImportedEvents = !0;
              }
            };

            d.prototype.setState = function (b, d) {
              var h = this.series,
                  f = this.state,
                  g = h.options.states[b || "normal"] || {},
                  k = J.plotOptions[h.type].marker && h.options.marker,
                  p = k && !1 === k.enabled,
                  l = k && k.states && k.states[b || "normal"] || {},
                  t = !1 === l.enabled,
                  m = this.marker || {},
                  n = h.chart,
                  v = k && h.markerAttribs,
                  r = h.halo,
                  D,
                  I = h.stateMarkerGraphic;
              b = b || "";

              if (!(b === this.state && !d || this.selected && "select" !== b || !1 === g.enabled || b && (t || p && !1 === l.enabled) || b && m.states && m.states[b] && !1 === m.states[b].enabled)) {
                this.state = b;
                v && (D = h.markerAttribs(this, b));

                if (this.graphic && !this.hasDummyGraphic) {
                  f && this.graphic.removeClass("highcharts-point-" + f);
                  b && this.graphic.addClass("highcharts-point-" + b);

                  if (!n.styledMode) {
                    var u = h.pointAttribs(this, b);
                    var x = B(n.options.chart.animation, g.animation);
                    h.options.inactiveOtherPoints && q(u.opacity) && ((this.dataLabels || []).forEach(function (b) {
                      b && b.animate({
                        opacity: u.opacity
                      }, x);
                    }), this.connector && this.connector.animate({
                      opacity: u.opacity
                    }, x));
                    this.graphic.animate(u, x);
                  }

                  D && this.graphic.animate(D, B(n.options.chart.animation, l.animation, k.animation));
                  I && I.hide();
                } else {
                  if (b && l) {
                    f = m.symbol || h.symbol;
                    I && I.currentSymbol !== f && (I = I.destroy());
                    if (D) if (I) I[d ? "animate" : "attr"]({
                      x: D.x,
                      y: D.y
                    });else f && (h.stateMarkerGraphic = I = n.renderer.symbol(f, D.x, D.y, D.width, D.height).add(h.markerGroup), I.currentSymbol = f);
                    !n.styledMode && I && I.attr(h.pointAttribs(this, b));
                  }

                  I && (I[b && this.isInside ? "show" : "hide"](), I.element.point = this, I.addClass(this.getClassName(), !0));
                }

                g = g.halo;
                D = (I = this.graphic || I) && I.visibility || "inherit";
                g && g.size && I && "hidden" !== D && !this.isCluster ? (r || (h.halo = r = n.renderer.path().add(I.parentGroup)), r.show()[d ? "animate" : "attr"]({
                  d: this.haloPath(g.size)
                }), r.attr({
                  "class": "highcharts-halo highcharts-color-" + B(this.colorIndex, h.colorIndex) + (this.className ? " " + this.className : ""),
                  visibility: D,
                  zIndex: -1
                }), r.point = this, n.styledMode || r.attr(c({
                  fill: this.color || h.color,
                  "fill-opacity": g.opacity
                }, a.filterUserAttributes(g.attributes || {})))) : r && r.point && r.point.haloPath && r.animate({
                  d: r.point.haloPath(0)
                }, null, r.hide);
                e(this, "afterSetState", {
                  state: b
                });
              }
            };

            d.prototype.haloPath = function (b) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - b, this.plotY - b, 2 * b, 2 * b);
            };

            return d;
          }();

          "";
          return w;
        });
        M(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Tooltip.js"], a["Core/Utilities.js"]], function (a, w, C, E, z) {
          var r = a.parse,
              J = w.charts,
              u = w.noop,
              n = z.addEvent,
              m = z.attr,
              g = z.css,
              c = z.defined,
              e = z.extend,
              l = z.find,
              f = z.fireEvent,
              v = z.isNumber,
              q = z.isObject,
              k = z.objectEach,
              I = z.offset,
              D = z.pick,
              B = z.splat;

          a = function () {
            function a(a, c) {
              this.lastValidTouch = {};
              this.pinchDown = [];
              this.runChartClick = !1;
              this.eventsToUnbind = [];
              this.chart = a;
              this.hasDragged = !1;
              this.options = c;
              this.init(a, c);
            }

            a.prototype.applyInactiveState = function (a) {
              var c = [],
                  d;
              (a || []).forEach(function (b) {
                d = b.series;
                c.push(d);
                d.linkedParent && c.push(d.linkedParent);
                d.linkedSeries && (c = c.concat(d.linkedSeries));
                d.navigatorSeries && c.push(d.navigatorSeries);
              });
              this.chart.series.forEach(function (b) {
                -1 === c.indexOf(b) ? b.setState("inactive", !0) : b.options.inactiveOtherPoints && b.setAllPointsToState("inactive");
              });
            };

            a.prototype.destroy = function () {
              var c = this;
              this.eventsToUnbind.forEach(function (a) {
                return a();
              });
              this.eventsToUnbind = [];
              w.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
              clearInterval(c.tooltipTimeout);
              k(c, function (a, d) {
                c[d] = void 0;
              });
            };

            a.prototype.drag = function (a) {
              var c = this.chart,
                  d = c.options.chart,
                  b = this.zoomHor,
                  e = this.zoomVert,
                  f = c.plotLeft,
                  g = c.plotTop,
                  k = c.plotWidth,
                  l = c.plotHeight,
                  t = this.mouseDownX || 0,
                  m = this.mouseDownY || 0,
                  n = q(d.panning) ? d.panning && d.panning.enabled : d.panning,
                  v = d.panKey && a[d.panKey + "Key"],
                  B = a.chartX,
                  D = a.chartY,
                  I = this.selectionMarker;
              if (!I || !I.touch) if (B < f ? B = f : B > f + k && (B = f + k), D < g ? D = g : D > g + l && (D = g + l), this.hasDragged = Math.sqrt(Math.pow(t - B, 2) + Math.pow(m - D, 2)), 10 < this.hasDragged) {
                var u = c.isInsidePlot(t - f, m - g, {
                  visiblePlotOnly: !0
                });
                c.hasCartesianSeries && (this.zoomX || this.zoomY) && u && !v && !I && (this.selectionMarker = I = c.renderer.rect(f, g, b ? 1 : k, e ? 1 : l, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add(), c.styledMode || I.attr({
                  fill: d.selectionMarkerFill || r(C.highlightColor80).setOpacity(.25).get()
                }));
                I && b && (b = B - t, I.attr({
                  width: Math.abs(b),
                  x: (0 < b ? 0 : b) + t
                }));
                I && e && (b = D - m, I.attr({
                  height: Math.abs(b),
                  y: (0 < b ? 0 : b) + m
                }));
                u && !I && n && c.pan(a, d.panning);
              }
            };

            a.prototype.dragStart = function (a) {
              var c = this.chart;
              c.mouseIsDown = a.type;
              c.cancelClick = !1;
              c.mouseDownX = this.mouseDownX = a.chartX;
              c.mouseDownY = this.mouseDownY = a.chartY;
            };

            a.prototype.drop = function (a) {
              var h = this,
                  d = this.chart,
                  b = this.hasPinched;

              if (this.selectionMarker) {
                var k = {
                  originalEvent: a,
                  xAxis: [],
                  yAxis: []
                },
                    l = this.selectionMarker,
                    t = l.attr ? l.attr("x") : l.x,
                    m = l.attr ? l.attr("y") : l.y,
                    q = l.attr ? l.attr("width") : l.width,
                    n = l.attr ? l.attr("height") : l.height,
                    r;
                if (this.hasDragged || b) d.axes.forEach(function (d) {
                  if (d.zoomEnabled && c(d.min) && (b || h[{
                    xAxis: "zoomX",
                    yAxis: "zoomY"
                  }[d.coll]]) && v(t) && v(m)) {
                    var e = d.horiz,
                        f = "touchend" === a.type ? d.minPixelPadding : 0,
                        g = d.toValue((e ? t : m) + f);
                    e = d.toValue((e ? t + q : m + n) - f);
                    k[d.coll].push({
                      axis: d,
                      min: Math.min(g, e),
                      max: Math.max(g, e)
                    });
                    r = !0;
                  }
                }), r && f(d, "selection", k, function (a) {
                  d.zoom(e(a, b ? {
                    animation: !1
                  } : null));
                });
                v(d.index) && (this.selectionMarker = this.selectionMarker.destroy());
                b && this.scaleGroups();
              }

              d && v(d.index) && (g(d.container, {
                cursor: d._cursor
              }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
            };

            a.prototype.findNearestKDPoint = function (a, c, d) {
              var b = this.chart,
                  e = b.hoverPoint;
              b = b.tooltip;
              if (e && b && b.isStickyOnContact()) return e;
              var h;
              a.forEach(function (b) {
                var a = !(b.noSharedTooltip && c) && 0 > b.options.findNearestPointBy.indexOf("y");
                b = b.searchPoint(d, a);

                if ((a = q(b, !0) && b.series) && !(a = !q(h, !0))) {
                  a = h.distX - b.distX;
                  var e = h.dist - b.dist,
                      f = (b.series.group && b.series.group.zIndex) - (h.series.group && h.series.group.zIndex);
                  a = 0 < (0 !== a && c ? a : 0 !== e ? e : 0 !== f ? f : h.series.index > b.series.index ? -1 : 1);
                }

                a && (h = b);
              });
              return h;
            };

            a.prototype.getChartCoordinatesFromPoint = function (a, c) {
              var d = a.series,
                  b = d.xAxis;
              d = d.yAxis;
              var e = a.shapeArgs;

              if (b && d) {
                var h = D(a.clientX, a.plotX),
                    f = a.plotY || 0;
                a.isNode && e && v(e.x) && v(e.y) && (h = e.x, f = e.y);
                return c ? {
                  chartX: d.len + d.pos - f,
                  chartY: b.len + b.pos - h
                } : {
                  chartX: h + b.pos,
                  chartY: f + d.pos
                };
              }

              if (e && e.x && e.y) return {
                chartX: e.x,
                chartY: e.y
              };
            };

            a.prototype.getChartPosition = function () {
              if (this.chartPosition) return this.chartPosition;
              var a = this.chart.container,
                  c = I(a);
              this.chartPosition = {
                left: c.left,
                top: c.top,
                scaleX: 1,
                scaleY: 1
              };
              var d = a.offsetWidth;
              a = a.offsetHeight;
              2 < d && 2 < a && (this.chartPosition.scaleX = c.width / d, this.chartPosition.scaleY = c.height / a);
              return this.chartPosition;
            };

            a.prototype.getCoordinates = function (a) {
              var c = {
                xAxis: [],
                yAxis: []
              };
              this.chart.axes.forEach(function (d) {
                c[d.isXAxis ? "xAxis" : "yAxis"].push({
                  axis: d,
                  value: d.toValue(a[d.horiz ? "chartX" : "chartY"])
                });
              });
              return c;
            };

            a.prototype.getHoverData = function (a, c, d, b, e, g) {
              var h = [];
              b = !(!b || !a);
              var k = {
                chartX: g ? g.chartX : void 0,
                chartY: g ? g.chartY : void 0,
                shared: e
              };
              f(this, "beforeGetHoverData", k);
              var p = c && !c.stickyTracking ? [c] : d.filter(function (b) {
                return k.filter ? k.filter(b) : b.visible && !(!e && b.directTouch) && D(b.options.enableMouseTracking, !0) && b.stickyTracking;
              });
              var t = b || !g ? a : this.findNearestKDPoint(p, e, g);
              c = t && t.series;
              t && (e && !c.noSharedTooltip ? (p = d.filter(function (b) {
                return k.filter ? k.filter(b) : b.visible && !(!e && b.directTouch) && D(b.options.enableMouseTracking, !0) && !b.noSharedTooltip;
              }), p.forEach(function (b) {
                var a = l(b.points, function (b) {
                  return b.x === t.x && !b.isNull;
                });
                q(a) && (b.chart.isBoosting && (a = b.getPoint(a)), h.push(a));
              })) : h.push(t));
              k = {
                hoverPoint: t
              };
              f(this, "afterGetHoverData", k);
              return {
                hoverPoint: k.hoverPoint,
                hoverSeries: c,
                hoverPoints: h
              };
            };

            a.prototype.getPointFromEvent = function (a) {
              a = a.target;

              for (var c; a && !c;) {
                c = a.point, a = a.parentNode;
              }

              return c;
            };

            a.prototype.onTrackerMouseOut = function (a) {
              a = a.relatedTarget || a.toElement;
              var c = this.chart.hoverSeries;
              this.isDirectTouch = !1;
              if (!(!c || !a || c.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + c.index) && this.inClass(a, "highcharts-tracker"))) c.onMouseOut();
            };

            a.prototype.inClass = function (a, c) {
              for (var d; a;) {
                if (d = m(a, "class")) {
                  if (-1 !== d.indexOf(c)) return !0;
                  if (-1 !== d.indexOf("highcharts-container")) return !1;
                }

                a = a.parentNode;
              }
            };

            a.prototype.init = function (a, c) {
              this.options = c;
              this.chart = a;
              this.runChartClick = !(!c.chart.events || !c.chart.events.click);
              this.pinchDown = [];
              this.lastValidTouch = {};
              E && (a.tooltip = new E(a, c.tooltip), this.followTouchMove = D(c.tooltip.followTouchMove, !0));
              this.setDOMEvents();
            };

            a.prototype.normalize = function (a, c) {
              var d = a.touches,
                  b = d ? d.length ? d.item(0) : D(d.changedTouches, a.changedTouches)[0] : a;
              c || (c = this.getChartPosition());
              d = b.pageX - c.left;
              b = b.pageY - c.top;
              d /= c.scaleX;
              b /= c.scaleY;
              return e(a, {
                chartX: Math.round(d),
                chartY: Math.round(b)
              });
            };

            a.prototype.onContainerClick = function (a) {
              var c = this.chart,
                  d = c.hoverPoint;
              a = this.normalize(a);
              var b = c.plotLeft,
                  g = c.plotTop;
              c.cancelClick || (d && this.inClass(a.target, "highcharts-tracker") ? (f(d.series, "click", e(a, {
                point: d
              })), c.hoverPoint && d.firePointEvent("click", a)) : (e(a, this.getCoordinates(a)), c.isInsidePlot(a.chartX - b, a.chartY - g, {
                visiblePlotOnly: !0
              }) && f(c, "click", a)));
            };

            a.prototype.onContainerMouseDown = function (a) {
              var c = 1 === ((a.buttons || a.button) & 1);
              a = this.normalize(a);
              if (w.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
              if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);
            };

            a.prototype.onContainerMouseLeave = function (c) {
              var e = J[D(a.hoverChartIndex, -1)],
                  d = this.chart.tooltip;
              d && d.shouldStickOnContact() && this.inClass(c.relatedTarget, "highcharts-tooltip-container") || (c = this.normalize(c), e && (c.relatedTarget || c.toElement) && (e.pointer.reset(), e.pointer.chartPosition = void 0), d && !d.isHidden && this.reset());
            };

            a.prototype.onContainerMouseEnter = function (a) {
              delete this.chartPosition;
            };

            a.prototype.onContainerMouseMove = function (a) {
              var c = this.chart;
              a = this.normalize(a);
              this.setHoverChartIndex();
              a.preventDefault || (a.returnValue = !1);
              ("mousedown" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);
              c.openMenu || !this.inClass(a.target, "highcharts-tracker") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
            };

            a.prototype.onDocumentTouchEnd = function (c) {
              var e = J[D(a.hoverChartIndex, -1)];
              e && e.pointer.drop(c);
            };

            a.prototype.onContainerTouchMove = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
            };

            a.prototype.onContainerTouchStart = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
            };

            a.prototype.onDocumentMouseMove = function (a) {
              var c = this.chart,
                  d = this.chartPosition;
              a = this.normalize(a, d);
              var b = c.tooltip;
              !d || b && b.isStickyOnContact() || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                visiblePlotOnly: !0
              }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
            };

            a.prototype.onDocumentMouseUp = function (c) {
              var e = J[D(a.hoverChartIndex, -1)];
              e && e.pointer.drop(c);
            };

            a.prototype.pinch = function (a) {
              var c = this,
                  d = c.chart,
                  b = c.pinchDown,
                  f = a.touches || [],
                  g = f.length,
                  k = c.lastValidTouch,
                  l = c.hasZoom,
                  m = {},
                  t = 1 === g && (c.inClass(a.target, "highcharts-tracker") && d.runTrackerClick || c.runChartClick),
                  q = {},
                  n = c.selectionMarker;
              1 < g ? c.initiated = !0 : 1 === g && this.followTouchMove && (c.initiated = !1);
              l && c.initiated && !t && !1 !== a.cancelable && a.preventDefault();
              [].map.call(f, function (b) {
                return c.normalize(b);
              });
              "touchstart" === a.type ? ([].forEach.call(f, function (a, d) {
                b[d] = {
                  chartX: a.chartX,
                  chartY: a.chartY
                };
              }), k.x = [b[0].chartX, b[1] && b[1].chartX], k.y = [b[0].chartY, b[1] && b[1].chartY], d.axes.forEach(function (b) {
                if (b.zoomEnabled) {
                  var a = d.bounds[b.horiz ? "h" : "v"],
                      c = b.minPixelPadding,
                      e = b.toPixels(Math.min(D(b.options.min, b.dataMin), b.dataMin)),
                      h = b.toPixels(Math.max(D(b.options.max, b.dataMax), b.dataMax)),
                      f = Math.max(e, h);
                  a.min = Math.min(b.pos, Math.min(e, h) - c);
                  a.max = Math.max(b.pos + b.len, f + c);
                }
              }), c.res = !0) : c.followTouchMove && 1 === g ? this.runPointActions(c.normalize(a)) : b.length && (n || (c.selectionMarker = n = e({
                destroy: u,
                touch: !0
              }, d.plotBox)), c.pinchTranslate(b, f, m, n, q, k), c.hasPinched = l, c.scaleGroups(m, q), c.res && (c.res = !1, this.reset(!1, 0)));
            };

            a.prototype.pinchTranslate = function (a, c, d, b, e, f) {
              this.zoomHor && this.pinchTranslateDirection(!0, a, c, d, b, e, f);
              this.zoomVert && this.pinchTranslateDirection(!1, a, c, d, b, e, f);
            };

            a.prototype.pinchTranslateDirection = function (a, c, d, b, e, f, g, k) {
              var h = this.chart,
                  l = a ? "x" : "y",
                  p = a ? "X" : "Y",
                  m = "chart" + p,
                  y = a ? "width" : "height",
                  t = h["plot" + (a ? "Left" : "Top")],
                  q = h.inverted,
                  n = h.bounds[a ? "h" : "v"],
                  r = 1 === c.length,
                  v = c[0][m],
                  B = !r && c[1][m];

              c = function c() {
                "number" === typeof I && 20 < Math.abs(v - B) && (D = k || Math.abs(N - I) / Math.abs(v - B));
                A = (t - N) / D + v;
                G = h["plot" + (a ? "Width" : "Height")] / D;
              };

              var G,
                  A,
                  D = k || 1,
                  N = d[0][m],
                  I = !r && d[1][m];
              c();
              d = A;

              if (d < n.min) {
                d = n.min;
                var L = !0;
              } else d + G > n.max && (d = n.max - G, L = !0);

              L ? (N -= .8 * (N - g[l][0]), "number" === typeof I && (I -= .8 * (I - g[l][1])), c()) : g[l] = [N, I];
              q || (f[l] = A - t, f[y] = G);
              f = q ? 1 / D : D;
              e[y] = G;
              e[l] = d;
              b[q ? a ? "scaleY" : "scaleX" : "scale" + p] = D;
              b["translate" + p] = f * t + (N - f * v);
            };

            a.prototype.reset = function (a, c) {
              var d = this.chart,
                  b = d.hoverSeries,
                  e = d.hoverPoint,
                  h = d.hoverPoints,
                  f = d.tooltip,
                  g = f && f.shared ? h : e;
              a && g && B(g).forEach(function (b) {
                b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
              });
              if (a) f && g && B(g).length && (f.refresh(g), f.shared && h ? h.forEach(function (b) {
                b.setState(b.state, !0);
                b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
              }) : e && (e.setState(e.state, !0), d.axes.forEach(function (b) {
                b.crosshair && e.series[b.coll] === b && b.drawCrosshair(null, e);
              })));else {
                if (e) e.onMouseOut();
                h && h.forEach(function (b) {
                  b.setState();
                });
                if (b) b.onMouseOut();
                f && f.hide(c);
                this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                d.axes.forEach(function (b) {
                  b.hideCrosshair();
                });
                this.hoverX = d.hoverPoints = d.hoverPoint = null;
              }
            };

            a.prototype.runPointActions = function (c, e) {
              var d = this.chart,
                  b = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,
                  h = b ? b.shared : !1,
                  f = e || d.hoverPoint,
                  g = f && f.series || d.hoverSeries;
              e = this.getHoverData(f, g, d.series, (!c || "touchmove" !== c.type) && (!!e || g && g.directTouch && this.isDirectTouch), h, c);
              f = e.hoverPoint;
              g = e.hoverSeries;
              var k = e.hoverPoints;
              e = g && g.tooltipOptions.followPointer && !g.tooltipOptions.split;
              h = h && g && !g.noSharedTooltip;

              if (f && (f !== d.hoverPoint || b && b.isHidden)) {
                (d.hoverPoints || []).forEach(function (b) {
                  -1 === k.indexOf(b) && b.setState();
                });
                if (d.hoverSeries !== g) g.onMouseOver();
                this.applyInactiveState(k);
                (k || []).forEach(function (b) {
                  b.setState("hover");
                });
                d.hoverPoint && d.hoverPoint.firePointEvent("mouseOut");
                if (!f.series) return;
                d.hoverPoints = k;
                d.hoverPoint = f;
                f.firePointEvent("mouseOver");
                b && b.refresh(h ? k : f, c);
              } else e && b && !b.isHidden && (f = b.getAnchor([{}], c), d.isInsidePlot(f[0], f[1], {
                visiblePlotOnly: !0
              }) && b.updatePosition({
                plotX: f[0],
                plotY: f[1]
              }));

              this.unDocMouseMove || (this.unDocMouseMove = n(d.container.ownerDocument, "mousemove", function (b) {
                var d = J[a.hoverChartIndex];
                if (d) d.pointer.onDocumentMouseMove(b);
              }), this.eventsToUnbind.push(this.unDocMouseMove));
              d.axes.forEach(function (b) {
                var a = D((b.crosshair || {}).snap, !0),
                    e;
                a && ((e = d.hoverPoint) && e.series[b.coll] === b || (e = l(k, function (a) {
                  return a.series[b.coll] === b;
                })));
                e || !a ? b.drawCrosshair(c, e) : b.hideCrosshair();
              });
            };

            a.prototype.scaleGroups = function (a, c) {
              var d = this.chart;
              d.series.forEach(function (b) {
                var e = a || b.getPlotBox();
                b.xAxis && b.xAxis.zoomEnabled && b.group && (b.group.attr(e), b.markerGroup && (b.markerGroup.attr(e), b.markerGroup.clip(c ? d.clipRect : null)), b.dataLabelsGroup && b.dataLabelsGroup.attr(e));
              });
              d.clipRect.attr(c || d.clipBox);
            };

            a.prototype.setDOMEvents = function () {
              var c = this,
                  e = this.chart.container,
                  d = e.ownerDocument;
              e.onmousedown = this.onContainerMouseDown.bind(this);
              e.onmousemove = this.onContainerMouseMove.bind(this);
              e.onclick = this.onContainerClick.bind(this);
              this.eventsToUnbind.push(n(e, "mouseenter", this.onContainerMouseEnter.bind(this)));
              this.eventsToUnbind.push(n(e, "mouseleave", this.onContainerMouseLeave.bind(this)));
              a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = n(d, "mouseup", this.onDocumentMouseUp.bind(this)));

              for (var b = this.chart.renderTo.parentElement; b && "BODY" !== b.tagName;) {
                this.eventsToUnbind.push(n(b, "scroll", function () {
                  delete c.chartPosition;
                })), b = b.parentElement;
              }

              w.hasTouch && (this.eventsToUnbind.push(n(e, "touchstart", this.onContainerTouchStart.bind(this), {
                passive: !1
              })), this.eventsToUnbind.push(n(e, "touchmove", this.onContainerTouchMove.bind(this), {
                passive: !1
              })), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = n(d, "touchend", this.onDocumentTouchEnd.bind(this), {
                passive: !1
              })));
            };

            a.prototype.setHoverChartIndex = function () {
              var c = this.chart,
                  e = w.charts[D(a.hoverChartIndex, -1)];
              if (e && e !== c) e.pointer.onContainerMouseLeave({
                relatedTarget: !0
              });
              e && e.mouseIsDown || (a.hoverChartIndex = c.index);
            };

            a.prototype.touch = function (a, c) {
              var d = this.chart,
                  b;
              this.setHoverChartIndex();
              if (1 === a.touches.length) {
                if (a = this.normalize(a), (b = d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {
                  visiblePlotOnly: !0
                })) && !d.openMenu) {
                  c && this.runPointActions(a);

                  if ("touchmove" === a.type) {
                    c = this.pinchDown;
                    var e = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1;
                  }

                  D(e, !0) && this.pinch(a);
                } else c && this.reset();
              } else 2 === a.touches.length && this.pinch(a);
            };

            a.prototype.touchSelect = function (a) {
              return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
            };

            a.prototype.zoomOption = function (a) {
              var c = this.chart,
                  d = c.options.chart;
              c = c.inverted;
              var b = d.zoomType || "";
              /touch/.test(a.type) && (b = D(d.pinchType, b));
              this.zoomX = a = /x/.test(b);
              this.zoomY = d = /y/.test(b);
              this.zoomHor = a && !c || d && c;
              this.zoomVert = d && !c || a && c;
              this.hasZoom = a || d;
            };

            return a;
          }();

          "";
          return a;
        });
        M(a, "Core/MSPointer.js", [a["Core/Globals.js"], a["Core/Pointer.js"], a["Core/Utilities.js"]], function (a, w, C) {
          function r() {
            var a = [];

            a.item = function (a) {
              return this[a];
            };

            e(f, function (c) {
              a.push({
                pageX: c.pageX,
                pageY: c.pageY,
                target: c.target
              });
            });
            return a;
          }

          function z(a, c, e, f) {
            var g = J[w.hoverChartIndex || NaN];
            "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !g || (g = g.pointer, f(a), g[c]({
              type: e,
              target: a.currentTarget,
              preventDefault: n,
              touches: r()
            }));
          }

          var x = this && this.__extends || function () {
            var _a10 = function a(c, e) {
              _a10 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (a[e] = c[e]);
                }
              };

              return _a10(c, e);
            };

            return function (c, e) {
              function f() {
                this.constructor = c;
              }

              _a10(c, e);

              c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
            };
          }(),
              J = a.charts,
              u = a.doc,
              n = a.noop,
              m = a.win,
              g = C.addEvent,
              c = C.css,
              e = C.objectEach,
              l = C.removeEvent,
              f = {},
              v = !!m.PointerEvent;

          return function (e) {
            function k() {
              return null !== e && e.apply(this, arguments) || this;
            }

            x(k, e);

            k.isRequired = function () {
              return !(a.hasTouch || !m.PointerEvent && !m.MSPointerEvent);
            };

            k.prototype.batchMSEvents = function (a) {
              a(this.chart.container, v ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              a(this.chart.container, v ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              a(u, v ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };

            k.prototype.destroy = function () {
              this.batchMSEvents(l);
              e.prototype.destroy.call(this);
            };

            k.prototype.init = function (a, f) {
              e.prototype.init.call(this, a, f);
              this.hasZoom && c(a.container, {
                "-ms-touch-action": "none",
                "touch-action": "none"
              });
            };

            k.prototype.onContainerPointerDown = function (a) {
              z(a, "onContainerTouchStart", "touchstart", function (a) {
                f[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY,
                  target: a.currentTarget
                };
              });
            };

            k.prototype.onContainerPointerMove = function (a) {
              z(a, "onContainerTouchMove", "touchmove", function (a) {
                f[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY
                };
                f[a.pointerId].target || (f[a.pointerId].target = a.currentTarget);
              });
            };

            k.prototype.onDocumentPointerUp = function (a) {
              z(a, "onDocumentTouchEnd", "touchend", function (a) {
                delete f[a.pointerId];
              });
            };

            k.prototype.setDOMEvents = function () {
              e.prototype.setDOMEvents.call(this);
              (this.hasZoom || this.followTouchMove) && this.batchMSEvents(g);
            };

            return k;
          }(w);
        });
        M(a, "Core/Legend/Legend.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x) {
          var r = a.animObject,
              u = a.setAnimation,
              n = w.format;
          a = C.isFirefox;
          var m = C.marginNames;
          C = C.win;
          var g = z.distribute,
              c = x.addEvent,
              e = x.createElement,
              l = x.css,
              f = x.defined,
              v = x.discardElement,
              q = x.find,
              k = x.fireEvent,
              I = x.isNumber,
              D = x.merge,
              B = x.pick,
              O = x.relativeLength,
              t = x.stableSort,
              h = x.syncTimeout;
          z = x.wrap;

          x = function () {
            function a(a, d) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = !1;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = {};
              this.padding = 0;
              this.pages = [];
              this.proximate = !1;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = a;
              this.init(a, d);
            }

            a.prototype.init = function (a, d) {
              this.chart = a;
              this.setOptions(d);
              d.enabled && (this.render(), c(this.chart, "endResize", function () {
                this.legend.positionCheckboxes();
              }), this.proximate ? this.unchartrender = c(this.chart, "render", function () {
                this.legend.proximatePositions();
                this.legend.positionItems();
              }) : this.unchartrender && this.unchartrender());
            };

            a.prototype.setOptions = function (a) {
              var b = B(a.padding, 8);
              this.options = a;
              this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = D(this.itemStyle, a.itemHiddenStyle));
              this.itemMarginTop = a.itemMarginTop || 0;
              this.itemMarginBottom = a.itemMarginBottom || 0;
              this.padding = b;
              this.initialItemY = b - 5;
              this.symbolWidth = B(a.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === a.layout && !this.chart.inverted;
              this.baseline = void 0;
            };

            a.prototype.update = function (a, d) {
              var b = this.chart;
              this.setOptions(D(!0, this.options, a));
              this.destroy();
              b.isDirtyLegend = b.isDirtyBox = !0;
              B(d, !0) && b.redraw();
              k(this, "afterUpdate");
            };

            a.prototype.colorizeItem = function (a, d) {
              a.legendGroup[d ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

              if (!this.chart.styledMode) {
                var b = this.options,
                    c = a.legendItem,
                    e = a.legendLine,
                    h = a.legendSymbol,
                    f = this.itemHiddenStyle.color;
                b = d ? b.itemStyle.color : f;
                var g = d ? a.color || f : f,
                    l = a.options && a.options.marker,
                    p = {
                  fill: g
                };
                c && c.css({
                  fill: b,
                  color: b
                });
                e && e.attr({
                  stroke: g
                });
                h && (l && h.isMarker && (p = a.pointAttribs(), d || (p.stroke = p.fill = f)), h.attr(p));
              }

              k(this, "afterColorizeItem", {
                item: a,
                visible: d
              });
            };

            a.prototype.positionItems = function () {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            };

            a.prototype.positionItem = function (a) {
              var b = this,
                  d = this.options,
                  c = d.symbolPadding,
                  e = !d.rtl,
                  h = a._legendItemPos;
              d = h[0];
              h = h[1];
              var g = a.checkbox,
                  l = a.legendGroup;
              l && l.element && (c = {
                translateX: e ? d : this.legendWidth - d - 2 * c - 4,
                translateY: h
              }, e = function e() {
                k(b, "afterPositionItem", {
                  item: a
                });
              }, f(l.translateY) ? l.animate(c, void 0, e) : (l.attr(c), e()));
              g && (g.x = d, g.y = h);
            };

            a.prototype.destroyItem = function (a) {
              var b = a.checkbox;
              ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (b) {
                a[b] && (a[b] = a[b].destroy());
              });
              b && v(a.checkbox);
            };

            a.prototype.destroy = function () {
              function a(a) {
                this[a] && (this[a] = this[a].destroy());
              }

              this.getAllItems().forEach(function (b) {
                ["legendItem", "legendGroup"].forEach(a, b);
              });
              "clipRect up down pager nav box title group".split(" ").forEach(a, this);
              this.display = null;
            };

            a.prototype.positionCheckboxes = function () {
              var a = this.group && this.group.alignAttr,
                  d = this.clipHeight || this.legendHeight,
                  c = this.titleHeight;

              if (a) {
                var e = a.translateY;
                this.allItems.forEach(function (b) {
                  var h = b.checkbox;

                  if (h) {
                    var f = e + c + h.y + (this.scrollOffset || 0) + 3;
                    l(h, {
                      left: a.translateX + b.checkboxOffset + h.x - 20 + "px",
                      top: f + "px",
                      display: this.proximate || f > e - 6 && f < e + d - 6 ? "" : "none"
                    });
                  }
                }, this);
              }
            };

            a.prototype.renderTitle = function () {
              var a = this.options,
                  d = this.padding,
                  c = a.title,
                  e = 0;
              c.text && (this.title || (this.title = this.chart.renderer.label(c.text, d - 3, d - 4, null, null, null, a.useHTML, null, "legend-title").attr({
                zIndex: 1
              }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({
                width: this.maxLegendWidth + "px"
              }), a = this.title.getBBox(), e = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
                translateY: e
              }));
              this.titleHeight = e;
            };

            a.prototype.setText = function (a) {
              var b = this.options;
              a.legendItem.attr({
                text: b.labelFormat ? n(b.labelFormat, a, this.chart) : b.labelFormatter.call(a)
              });
            };

            a.prototype.renderItem = function (a) {
              var b = this.chart,
                  d = b.renderer,
                  c = this.options,
                  e = this.symbolWidth,
                  h = c.symbolPadding || 0,
                  f = this.itemStyle,
                  g = this.itemHiddenStyle,
                  k = "horizontal" === c.layout ? B(c.itemDistance, 20) : 0,
                  l = !c.rtl,
                  m = !a.series,
                  n = !m && a.series.drawLegendSymbol ? a.series : a,
                  q = n.options,
                  t = this.createCheckboxForItem && q && q.showCheckbox,
                  v = c.useHTML,
                  r = a.options.className,
                  I = a.legendItem;
              q = e + h + k + (t ? 20 : 0);
              I || (a.legendGroup = d.g("legend-item").addClass("highcharts-" + n.type + "-series highcharts-color-" + a.colorIndex + (r ? " " + r : "") + (m ? " highcharts-series-" + a.index : "")).attr({
                zIndex: 1
              }).add(this.scrollGroup), a.legendItem = I = d.text("", l ? e + h : -h, this.baseline || 0, v), b.styledMode || I.css(D(a.visible ? f : g)), I.attr({
                align: l ? "left" : "right",
                zIndex: 2
              }).add(a.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(b.styledMode ? 12 : f.fontSize, I), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, I.attr("y", this.baseline), this.symbolHeight = c.symbolHeight || this.fontMetrics.f, c.squareSymbol && (this.symbolWidth = B(c.symbolWidth, Math.max(this.symbolHeight, 16)), q = this.symbolWidth + h + k + (t ? 20 : 0), l && I.attr("x", this.symbolWidth + h))), n.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, I, v));
              t && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);
              this.colorizeItem(a, a.visible);
              !b.styledMode && f.width || I.css({
                width: (c.itemWidth || this.widthOption || b.spacingBox.width) - q + "px"
              });
              this.setText(a);
              b = I.getBBox();
              a.itemWidth = a.checkboxOffset = c.itemWidth || a.legendItemWidth || b.width + q;
              this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
              this.totalItemWidth += a.itemWidth;
              this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);
            };

            a.prototype.layoutItem = function (a) {
              var b = this.options,
                  d = this.padding,
                  c = "horizontal" === b.layout,
                  e = a.itemHeight,
                  h = this.itemMarginBottom,
                  f = this.itemMarginTop,
                  g = c ? B(b.itemDistance, 20) : 0,
                  k = this.maxLegendWidth;
              b = b.alignColumns && this.totalItemWidth > k ? this.maxItemWidth : a.itemWidth;
              c && this.itemX - d + b > k && (this.itemX = d, this.lastLineHeight && (this.itemY += f + this.lastLineHeight + h), this.lastLineHeight = 0);
              this.lastItemY = f + this.itemY + h;
              this.lastLineHeight = Math.max(e, this.lastLineHeight);
              a._legendItemPos = [this.itemX, this.itemY];
              c ? this.itemX += b : (this.itemY += f + e + h, this.lastLineHeight = e);
              this.offsetWidth = this.widthOption || Math.max((c ? this.itemX - d - (a.checkbox ? 0 : g) : b) + d, this.offsetWidth);
            };

            a.prototype.getAllItems = function () {
              var a = [];
              this.chart.series.forEach(function (b) {
                var d = b && b.options;
                b && B(d.showInLegend, f(d.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === d.legendType ? b.data : b)));
              });
              k(this, "afterGetAllItems", {
                allItems: a
              });
              return a;
            };

            a.prototype.getAlignment = function () {
              var a = this.options;
              return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
            };

            a.prototype.adjustMargins = function (a, d) {
              var b = this.chart,
                  c = this.options,
                  e = this.getAlignment();
              e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (h, g) {
                h.test(e) && !f(a[g]) && (b[m[g]] = Math.max(b[m[g]], b.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * c[g % 2 ? "x" : "y"] + B(c.margin, 12) + d[g] + (b.titleOffset[g] || 0)));
              });
            };

            a.prototype.proximatePositions = function () {
              var a = this.chart,
                  d = [],
                  c = "left" === this.options.align;
              this.allItems.forEach(function (b) {
                var e;
                var h = c;

                if (b.yAxis) {
                  b.xAxis.options.reversed && (h = !h);
                  b.points && (e = q(h ? b.points : b.points.slice(0).reverse(), function (a) {
                    return I(a.plotY);
                  }));
                  h = this.itemMarginTop + b.legendItem.getBBox().height + this.itemMarginBottom;
                  var f = b.yAxis.top - a.plotTop;
                  b.visible ? (e = e ? e.plotY : b.yAxis.height, e += f - .3 * h) : e = f + b.yAxis.height;
                  d.push({
                    target: e,
                    size: h,
                    item: b
                  });
                }
              }, this);
              g(d, a.plotHeight).forEach(function (b) {
                b.item._legendItemPos && (b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos);
              });
            };

            a.prototype.render = function () {
              var a = this.chart,
                  d = a.renderer,
                  c = this.options,
                  e = this.padding,
                  h = this.getAllItems(),
                  f = this.group,
                  g = this.box;
              this.itemX = e;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = O(c.width, a.spacingBox.width - e);
              var l = a.spacingBox.width - 2 * e - c.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (l /= 2);
              this.maxLegendWidth = this.widthOption || l;
              f || (this.group = f = d.g("legend").addClass(c.className || "").attr({
                zIndex: 7
              }).add(), this.contentGroup = d.g().attr({
                zIndex: 1
              }).add(f), this.scrollGroup = d.g().add(this.contentGroup));
              this.renderTitle();
              t(h, function (a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
              });
              c.reversed && h.reverse();
              this.allItems = h;
              this.display = l = !!h.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              h.forEach(this.renderItem, this);
              h.forEach(this.layoutItem, this);
              h = (this.widthOption || this.offsetWidth) + e;
              var m = this.lastItemY + this.lastLineHeight + this.titleHeight;
              m = this.handleOverflow(m);
              m += e;
              g || (this.box = g = d.rect().addClass("highcharts-legend-box").attr({
                r: c.borderRadius
              }).add(f), g.isNew = !0);
              a.styledMode || g.attr({
                stroke: c.borderColor,
                "stroke-width": c.borderWidth || 0,
                fill: c.backgroundColor || "none"
              }).shadow(c.shadow);
              0 < h && 0 < m && (g[g.isNew ? "attr" : "animate"](g.crisp.call({}, {
                x: 0,
                y: 0,
                width: h,
                height: m
              }, g.strokeWidth())), g.isNew = !1);
              g[l ? "show" : "hide"]();
              a.styledMode && "none" === f.getStyle("display") && (h = m = 0);
              this.legendWidth = h;
              this.legendHeight = m;
              l && this.align();
              this.proximate || this.positionItems();
              k(this, "afterRender");
            };

            a.prototype.align = function (a) {
              void 0 === a && (a = this.chart.spacingBox);
              var b = this.chart,
                  d = this.options,
                  c = a.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? c += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (c -= b.titleOffset[2]);
              c !== a.y && (a = D(a, {
                y: c
              }));
              this.group.align(D(d, {
                width: this.legendWidth,
                height: this.legendHeight,
                verticalAlign: this.proximate ? "top" : d.verticalAlign
              }), !0, a);
            };

            a.prototype.handleOverflow = function (a) {
              var b = this,
                  d = this.chart,
                  c = d.renderer,
                  e = this.options,
                  h = e.y,
                  f = "top" === e.verticalAlign,
                  g = this.padding,
                  k = e.maxHeight,
                  l = e.navigation,
                  m = B(l.animation, !0),
                  n = l.arrowSize || 12,
                  q = this.pages,
                  t = this.allItems,
                  v = function v(a) {
                "number" === typeof a ? N.attr({
                  height: a
                }) : N && (b.clipRect = N.destroy(), b.contentGroup.clip());
                b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + g + "px,9999px," + (g + a) + "px,0)" : "auto");
              },
                  r = function r(a) {
                b[a] = c.circle(0, 0, 1.3 * n).translate(n / 2, n / 2).add(U);
                d.styledMode || b[a].attr("fill", "rgba(0,0,0,0.0001)");
                return b[a];
              },
                  I,
                  A;

              h = d.spacingBox.height + (f ? -h : h) - g;
              var U = this.nav,
                  N = this.clipRect;
              "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (h /= 2);
              k && (h = Math.min(h, k));
              q.length = 0;
              a && 0 < h && a > h && !1 !== l.enabled ? (this.clipHeight = I = Math.max(h - 20 - this.titleHeight - g, 0), this.currentPage = B(this.currentPage, 1), this.fullHeight = a, t.forEach(function (a, b) {
                var d = a._legendItemPos[1],
                    c = Math.round(a.legendItem.getBBox().height),
                    e = q.length;
                if (!e || d - q[e - 1] > I && (A || d) !== q[e - 1]) q.push(A || d), e++;
                a.pageIx = e - 1;
                A && (t[b - 1].pageIx = e - 1);
                b === t.length - 1 && d + c - q[e - 1] > I && d !== A && (q.push(d), a.pageIx = e);
                d !== A && (A = d);
              }), N || (N = b.clipRect = c.clipRect(0, g, 9999, 0), b.contentGroup.clip(N)), v(I), U || (this.nav = U = c.g().attr({
                zIndex: 1
              }).add(this.group), this.up = c.symbol("triangle", 0, 0, n, n).add(U), r("upTracker").on("click", function () {
                b.scroll(-1, m);
              }), this.pager = c.text("", 15, 10).addClass("highcharts-legend-navigation"), d.styledMode || this.pager.css(l.style), this.pager.add(U), this.down = c.symbol("triangle-down", 0, 0, n, n).add(U), r("downTracker").on("click", function () {
                b.scroll(1, m);
              })), b.scroll(0), a = h) : U && (v(), this.nav = U.destroy(), this.scrollGroup.attr({
                translateY: 1
              }), this.clipHeight = 0);
              return a;
            };

            a.prototype.scroll = function (a, d) {
              var b = this,
                  c = this.chart,
                  e = this.pages,
                  f = e.length,
                  g = this.clipHeight,
                  l = this.options.navigation,
                  m = this.pager,
                  p = this.padding,
                  n = this.currentPage + a;
              n > f && (n = f);
              0 < n && ("undefined" !== typeof d && u(d, c), this.nav.attr({
                translateX: p,
                translateY: g + this.padding + 7 + this.titleHeight,
                visibility: "visible"
              }), [this.up, this.upTracker].forEach(function (a) {
                a.attr({
                  "class": 1 === n ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }), m.attr({
                text: n + "/" + f
              }), [this.down, this.downTracker].forEach(function (a) {
                a.attr({
                  x: 18 + this.pager.getBBox().width,
                  "class": n === f ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }, this), c.styledMode || (this.up.attr({
                fill: 1 === n ? l.inactiveColor : l.activeColor
              }), this.upTracker.css({
                cursor: 1 === n ? "default" : "pointer"
              }), this.down.attr({
                fill: n === f ? l.inactiveColor : l.activeColor
              }), this.downTracker.css({
                cursor: n === f ? "default" : "pointer"
              })), this.scrollOffset = -e[n - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: this.scrollOffset
              }), this.currentPage = n, this.positionCheckboxes(), a = r(B(d, c.renderer.globalAnimation, !0)), h(function () {
                k(b, "afterScroll", {
                  currentPage: n
                });
              }, a.duration));
            };

            a.prototype.setItemEvents = function (a, d, c) {
              var b = this,
                  e = b.chart.renderer.boxWrapper,
                  h = a instanceof E,
                  f = "highcharts-legend-" + (h ? "point" : "series") + "-active",
                  g = b.chart.styledMode,
                  l = function l(d) {
                b.allItems.forEach(function (b) {
                  a !== b && [b].concat(b.linkedSeries || []).forEach(function (a) {
                    a.setState(d, !h);
                  });
                });
              };

              (c ? [d, a.legendSymbol] : [a.legendGroup]).forEach(function (c) {
                if (c) c.on("mouseover", function () {
                  a.visible && l("inactive");
                  a.setState("hover");
                  a.visible && e.addClass(f);
                  g || d.css(b.options.itemHoverStyle);
                }).on("mouseout", function () {
                  b.chart.styledMode || d.css(D(a.visible ? b.itemStyle : b.itemHiddenStyle));
                  l("");
                  e.removeClass(f);
                  a.setState();
                }).on("click", function (b) {
                  var d = function d() {
                    a.setVisible && a.setVisible();
                    l(a.visible ? "inactive" : "");
                  };

                  e.removeClass(f);
                  b = {
                    browserEvent: b
                  };
                  a.firePointEvent ? a.firePointEvent("legendItemClick", b, d) : k(a, "legendItemClick", b, d);
                });
              });
            };

            a.prototype.createCheckboxForItem = function (a) {
              a.checkbox = e("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: a.selected,
                defaultChecked: a.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              c(a.checkbox, "click", function (b) {
                k(a.series || a, "checkboxClick", {
                  checked: b.target.checked,
                  item: a
                }, function () {
                  a.select();
                });
              });
            };

            return a;
          }();

          (/Trident\/7\.0/.test(C.navigator && C.navigator.userAgent) || a) && z(x.prototype, "positionItem", function (a, b) {
            var d = this,
                c = function c() {
              b._legendItemPos && a.call(d, b);
            };

            c();
            d.bubbleLegend || setTimeout(c);
          });
          "";
          return x;
        });
        M(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/DefaultOptions.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, w, C, E) {
          var r = w.defaultOptions,
              x = E.error,
              J = E.extendClass,
              u = E.merge,
              n;

          (function (m) {
            function g(a, e) {
              var c = r.plotOptions || {},
                  f = e.defaultOptions;
              e.prototype.pointClass || (e.prototype.pointClass = C);
              e.prototype.type = a;
              f && (c[a] = f);
              m.seriesTypes[a] = e;
            }

            m.seriesTypes = a.seriesTypes;

            m.getSeries = function (a, e) {
              void 0 === e && (e = {});
              var c = a.options.chart;
              c = e.type || c.type || c.defaultSeriesType || "";
              var f = m.seriesTypes[c];
              m || x(17, !0, a, {
                missingModuleFor: c
              });
              c = new f();
              "function" === typeof c.init && c.init(a, e);
              return c;
            };

            m.registerSeriesType = g;

            m.seriesType = function (a, e, l, f, n) {
              var c = r.plotOptions || {};
              e = e || "";
              c[a] = u(c[e], l);
              g(a, J(m.seriesTypes[e] || function () {}, f));
              m.seriesTypes[a].prototype.type = a;
              n && (m.seriesTypes[a].prototype.pointClass = J(C, n));
              return m.seriesTypes[a];
            };
          })(n || (n = {}));

          return n;
        });
        M(a, "Core/Chart/Chart.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/FormatUtilities.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/Legend.js"], a["Core/MSPointer.js"], a["Core/DefaultOptions.js"], a["Core/Color/Palette.js"], a["Core/Pointer.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Time.js"], a["Core/Utilities.js"], a["Core/Renderer/HTML/AST.js"]], function (a, w, C, E, z, x, J, u, n, m, g, c, e, l, f, v) {
          var q = a.animate,
              k = a.animObject,
              r = a.setAnimation,
              D = C.numberFormat,
              B = E.registerEventOptions,
              O = z.charts,
              t = z.doc,
              h = z.marginNames,
              d = z.svg,
              b = z.win,
              p = u.defaultOptions,
              G = u.defaultTime,
              y = c.seriesTypes,
              L = f.addEvent,
              F = f.attr,
              P = f.cleanRecursively,
              S = f.createElement,
              Q = f.css,
              V = f.defined,
              fa = f.discardElement,
              H = f.erase,
              K = f.error,
              M = f.extend,
              ha = f.find,
              R = f.fireEvent,
              Z = f.getStyle,
              A = f.isArray,
              U = f.isNumber,
              N = f.isObject,
              W = f.isString,
              X = f.merge,
              Y = f.objectEach,
              T = f.pick,
              da = f.pInt,
              ka = f.relativeLength,
              ja = f.removeEvent,
              ba = f.splat,
              ea = f.syncTimeout,
              ma = f.uniqueKey;

          a = function () {
            function a(a, b, d) {
              this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
              this.sharedClips = {};
              this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
              this.getArgs(a, b, d);
            }

            a.chart = function (b, d, c) {
              return new a(b, d, c);
            };

            a.prototype.getArgs = function (a, b, d) {
              W(a) || a.nodeName ? (this.renderTo = a, this.init(b, d)) : this.init(a, b);
            };

            a.prototype.init = function (a, b) {
              var d = a.plotOptions || {};
              R(this, "init", {
                args: arguments
              }, function () {
                var c = X(p, a),
                    e = c.chart;
                Y(c.plotOptions, function (a, b) {
                  N(a) && (a.tooltip = d[b] && X(d[b].tooltip) || void 0);
                });
                c.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;
                this.userOptions = a;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                  h: {},
                  v: {}
                };
                this.labelCollectors = [];
                this.callback = b;
                this.isResizing = 0;
                this.options = c;
                this.axes = [];
                this.series = [];
                this.time = a.time && Object.keys(a.time).length ? new l(a.time) : z.time;
                this.numberFormatter = e.numberFormatter || D;
                this.styledMode = e.styledMode;
                this.hasCartesianSeries = e.showAxes;
                this.index = O.length;
                O.push(this);
                z.chartCount++;
                B(this, e);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                R(this, "afterInit");
                this.firstRender();
              });
            };

            a.prototype.initSeries = function (a) {
              var b = this.options.chart;
              b = a.type || b.type || b.defaultSeriesType;
              var d = y[b];
              d || K(17, !0, this, {
                missingModuleFor: b
              });
              b = new d();
              "function" === typeof b.init && b.init(this, a);
              return b;
            };

            a.prototype.setSeriesData = function () {
              this.getSeriesOrderByLinks().forEach(function (a) {
                a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);
              });
            };

            a.prototype.getSeriesOrderByLinks = function () {
              return this.series.concat().sort(function (a, b) {
                return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;
              });
            };

            a.prototype.orderSeries = function (a) {
              var b = this.series;
              a = a || 0;

              for (var d = b.length; a < d; ++a) {
                b[a] && (b[a].index = a, b[a].name = b[a].getName());
              }
            };

            a.prototype.isInsidePlot = function (a, b, d) {
              void 0 === d && (d = {});
              var c = this.inverted,
                  e = this.plotBox,
                  h = this.plotLeft,
                  f = this.plotTop,
                  g = this.scrollablePlotBox,
                  k = 0;
              var l = 0;
              d.visiblePlotOnly && this.scrollingContainer && (l = this.scrollingContainer, k = l.scrollLeft, l = l.scrollTop);
              var m = d.series;
              e = d.visiblePlotOnly && g || e;
              g = d.inverted ? b : a;
              b = d.inverted ? a : b;
              a = {
                x: g,
                y: b,
                isInsidePlot: !0
              };

              if (!d.ignoreX) {
                var A = m && (c ? m.yAxis : m.xAxis) || {
                  pos: h,
                  len: Infinity
                };
                g = d.paneCoordinates ? A.pos + g : h + g;
                g >= Math.max(k + h, A.pos) && g <= Math.min(k + h + e.width, A.pos + A.len) || (a.isInsidePlot = !1);
              }

              !d.ignoreY && a.isInsidePlot && (c = m && (c ? m.xAxis : m.yAxis) || {
                pos: f,
                len: Infinity
              }, d = d.paneCoordinates ? c.pos + b : f + b, d >= Math.max(l + f, c.pos) && d <= Math.min(l + f + e.height, c.pos + c.len) || (a.isInsidePlot = !1));
              R(this, "afterIsInsidePlot", a);
              return a.isInsidePlot;
            };

            a.prototype.redraw = function (a) {
              R(this, "beforeRedraw");
              var b = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                  d = this.series,
                  c = this.pointer,
                  e = this.legend,
                  h = this.userOptions.legend,
                  f = this.renderer,
                  g = f.isHidden(),
                  k = [],
                  l = this.isDirtyBox,
                  m = this.isDirtyLegend;
              this.setResponsive && this.setResponsive(!1);
              r(this.hasRendered ? a : !1, this);
              g && this.temporaryDisplay();
              this.layOutTitles();

              for (a = d.length; a--;) {
                var A = d[a];

                if (A.options.stacking || A.options.centerInCategory) {
                  var p = !0;

                  if (A.isDirty) {
                    var n = !0;
                    break;
                  }
                }
              }

              if (n) for (a = d.length; a--;) {
                A = d[a], A.options.stacking && (A.isDirty = !0);
              }
              d.forEach(function (a) {
                a.isDirty && ("point" === a.options.legendType ? ("function" === typeof a.updateTotals && a.updateTotals(), m = !0) : h && (h.labelFormatter || h.labelFormat) && (m = !0));
                a.isDirtyData && R(a, "updatedData");
              });
              m && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);
              p && this.getStacks();
              b.forEach(function (a) {
                a.updateNames();
                a.setScale();
              });
              this.getMargins();
              b.forEach(function (a) {
                a.isDirty && (l = !0);
              });
              b.forEach(function (a) {
                var b = a.min + "," + a.max;
                a.extKey !== b && (a.extKey = b, k.push(function () {
                  R(a, "afterSetExtremes", M(a.eventArgs, a.getExtremes()));
                  delete a.eventArgs;
                }));
                (l || p) && a.redraw();
              });
              l && this.drawChartBox();
              R(this, "predraw");
              d.forEach(function (a) {
                (l || a.isDirty) && a.visible && a.redraw();
                a.isDirtyData = !1;
              });
              c && c.reset(!0);
              f.draw();
              R(this, "redraw");
              R(this, "render");
              g && this.temporaryDisplay(!0);
              k.forEach(function (a) {
                a.call();
              });
            };

            a.prototype.get = function (a) {
              function b(b) {
                return b.id === a || b.options && b.options.id === a;
              }

              for (var d = this.series, c = ha(this.axes, b) || ha(this.series, b), e = 0; !c && e < d.length; e++) {
                c = ha(d[e].points || [], b);
              }

              return c;
            };

            a.prototype.getAxes = function () {
              var a = this,
                  b = this.options,
                  d = b.xAxis = ba(b.xAxis || {});
              b = b.yAxis = ba(b.yAxis || {});
              R(this, "getAxes");
              d.forEach(function (a, b) {
                a.index = b;
                a.isX = !0;
              });
              b.forEach(function (a, b) {
                a.index = b;
              });
              d.concat(b).forEach(function (b) {
                new w(a, b);
              });
              R(this, "afterGetAxes");
            };

            a.prototype.getSelectedPoints = function () {
              return this.series.reduce(function (a, b) {
                b.getPointsCollection().forEach(function (b) {
                  T(b.selectedStaging, b.selected) && a.push(b);
                });
                return a;
              }, []);
            };

            a.prototype.getSelectedSeries = function () {
              return this.series.filter(function (a) {
                return a.selected;
              });
            };

            a.prototype.setTitle = function (a, b, d) {
              this.applyDescription("title", a);
              this.applyDescription("subtitle", b);
              this.applyDescription("caption", void 0);
              this.layOutTitles(d);
            };

            a.prototype.applyDescription = function (a, b) {
              var d = this,
                  c = "title" === a ? {
                color: n.neutralColor80,
                fontSize: this.options.isStock ? "16px" : "18px"
              } : {
                color: n.neutralColor60
              };
              c = this.options[a] = X(!this.styledMode && {
                style: c
              }, this.options[a], b);
              var e = this[a];
              e && b && (this[a] = e = e.destroy());
              c && !e && (e = this.renderer.text(c.text, 0, 0, c.useHTML).attr({
                align: c.align,
                "class": "highcharts-" + a,
                zIndex: c.zIndex || 4
              }).add(), e.update = function (b) {
                d[{
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }[a]](b);
              }, this.styledMode || e.css(c.style), this[a] = e);
            };

            a.prototype.layOutTitles = function (a) {
              var b = [0, 0, 0],
                  d = this.renderer,
                  c = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (a) {
                var e = this[a],
                    h = this.options[a],
                    f = h.verticalAlign || "top";
                a = "title" === a ? "top" === f ? -3 : 0 : "top" === f ? b[0] + 2 : 0;
                var g;

                if (e) {
                  this.styledMode || (g = h.style && h.style.fontSize);
                  g = d.fontMetrics(g, e).b;
                  e.css({
                    width: (h.width || c.width + (h.widthAdjust || 0)) + "px"
                  });
                  var k = Math.round(e.getBBox(h.useHTML).height);
                  e.align(M({
                    y: "bottom" === f ? g : a + g,
                    height: k
                  }, h), !1, "spacingBox");
                  h.floating || ("top" === f ? b[0] = Math.ceil(b[0] + k) : "bottom" === f && (b[2] = Math.ceil(b[2] + k)));
                }
              }, this);
              b[0] && "top" === (this.options.title.verticalAlign || "top") && (b[0] += this.options.title.margin);
              b[2] && "bottom" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);
              var e = !this.titleOffset || this.titleOffset.join(",") !== b.join(",");
              this.titleOffset = b;
              R(this, "afterLayOutTitles");
              !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && T(a, !0) && this.isDirtyBox && this.redraw());
            };

            a.prototype.getChartSize = function () {
              var a = this.options.chart,
                  b = a.width;
              a = a.height;
              var d = this.renderTo;
              V(b) || (this.containerWidth = Z(d, "width"));
              V(a) || (this.containerHeight = Z(d, "height"));
              this.chartWidth = Math.max(0, b || this.containerWidth || 600);
              this.chartHeight = Math.max(0, ka(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };

            a.prototype.temporaryDisplay = function (a) {
              var b = this.renderTo;
              if (a) for (; b && b.style;) {
                b.hcOrigStyle && (Q(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (t.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;
              } else for (; b && b.style;) {
                t.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, t.body.appendChild(b));
                if ("none" === Z(b, "display", !1) || b.hcOricDetached) b.hcOrigStyle = {
                  display: b.style.display,
                  height: b.style.height,
                  overflow: b.style.overflow
                }, a = {
                  display: "block",
                  overflow: "hidden"
                }, b !== this.renderTo && (a.height = 0), Q(b, a), b.offsetWidth || b.style.setProperty("display", "block", "important");
                b = b.parentNode;
                if (b === t.body) break;
              }
            };

            a.prototype.setClassName = function (a) {
              this.container.className = "highcharts-container " + (a || "");
            };

            a.prototype.getContainer = function () {
              var a = this.options,
                  b = a.chart,
                  c = ma(),
                  h,
                  f = this.renderTo;
              f || (this.renderTo = f = b.renderTo);
              W(f) && (this.renderTo = f = t.getElementById(f));
              f || K(13, !0, this);
              var k = da(F(f, "data-highcharts-chart"));
              U(k) && O[k] && O[k].hasRendered && O[k].destroy();
              F(f, "data-highcharts-chart", this.index);
              f.innerHTML = "";
              b.skipClone || f.offsetWidth || this.temporaryDisplay();
              this.getChartSize();
              k = this.chartWidth;
              var l = this.chartHeight;
              Q(f, {
                overflow: "hidden"
              });
              this.styledMode || (h = M({
                position: "relative",
                overflow: "hidden",
                width: k + "px",
                height: l + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                userSelect: "none",
                "touch-action": "manipulation",
                outline: "none"
              }, b.style || {}));
              this.container = c = S("div", {
                id: c
              }, h, f);
              this._cursor = c.style.cursor;
              this.renderer = new (b.renderer || !d ? g.getRendererType(b.renderer) : e)(c, k, l, void 0, b.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
              r(void 0, this);
              this.setClassName(b.className);
              if (this.styledMode) for (var m in a.defs) {
                this.renderer.definition(a.defs[m]);
              } else this.renderer.setStyle(b.style);
              this.renderer.chartIndex = this.index;
              R(this, "afterGetContainer");
            };

            a.prototype.getMargins = function (a) {
              var b = this.spacing,
                  d = this.margin,
                  c = this.titleOffset;
              this.resetMargins();
              c[0] && !V(d[0]) && (this.plotTop = Math.max(this.plotTop, c[0] + b[0]));
              c[2] && !V(d[2]) && (this.marginBottom = Math.max(this.marginBottom, c[2] + b[2]));
              this.legend && this.legend.display && this.legend.adjustMargins(d, b);
              R(this, "getMargins");
              a || this.getAxisMargins();
            };

            a.prototype.getAxisMargins = function () {
              var a = this,
                  b = a.axisOffset = [0, 0, 0, 0],
                  d = a.colorAxis,
                  c = a.margin,
                  e = function e(a) {
                a.forEach(function (a) {
                  a.visible && a.getOffset();
                });
              };

              a.hasCartesianSeries ? e(a.axes) : d && d.length && e(d);
              h.forEach(function (d, e) {
                V(c[e]) || (a[d] += b[e]);
              });
              a.setChartSize();
            };

            a.prototype.reflow = function (a) {
              var d = this,
                  c = d.options.chart,
                  e = d.renderTo,
                  h = V(c.width) && V(c.height),
                  g = c.width || Z(e, "width");
              c = c.height || Z(e, "height");
              e = a ? a.target : b;
              delete d.pointer.chartPosition;

              if (!h && !d.isPrinting && g && c && (e === b || e === t)) {
                if (g !== d.containerWidth || c !== d.containerHeight) f.clearTimeout(d.reflowTimeout), d.reflowTimeout = ea(function () {
                  d.container && d.setSize(void 0, void 0, !1);
                }, a ? 100 : 0);
                d.containerWidth = g;
                d.containerHeight = c;
              }
            };

            a.prototype.setReflow = function (a) {
              var d = this;
              !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = L(b, "resize", function (a) {
                d.options && d.reflow(a);
              }), L(this, "destroy", this.unbindReflow));
            };

            a.prototype.setSize = function (a, b, d) {
              var c = this,
                  e = c.renderer;
              c.isResizing += 1;
              r(d, c);
              d = e.globalAnimation;
              c.oldChartHeight = c.chartHeight;
              c.oldChartWidth = c.chartWidth;
              "undefined" !== typeof a && (c.options.chart.width = a);
              "undefined" !== typeof b && (c.options.chart.height = b);
              c.getChartSize();
              c.styledMode || (d ? q : Q)(c.container, {
                width: c.chartWidth + "px",
                height: c.chartHeight + "px"
              }, d);
              c.setChartSize(!0);
              e.setSize(c.chartWidth, c.chartHeight, d);
              c.axes.forEach(function (a) {
                a.isDirty = !0;
                a.setScale();
              });
              c.isDirtyLegend = !0;
              c.isDirtyBox = !0;
              c.layOutTitles();
              c.getMargins();
              c.redraw(d);
              c.oldChartHeight = null;
              R(c, "resize");
              ea(function () {
                c && R(c, "endResize", null, function () {
                  --c.isResizing;
                });
              }, k(d).duration);
            };

            a.prototype.setChartSize = function (a) {
              var b = this.inverted,
                  d = this.renderer,
                  c = this.chartWidth,
                  e = this.chartHeight,
                  h = this.options.chart,
                  f = this.spacing,
                  g = this.clipOffset,
                  k,
                  l,
                  m,
                  A;
              this.plotLeft = k = Math.round(this.plotLeft);
              this.plotTop = l = Math.round(this.plotTop);
              this.plotWidth = m = Math.max(0, Math.round(c - k - this.marginRight));
              this.plotHeight = A = Math.max(0, Math.round(e - l - this.marginBottom));
              this.plotSizeX = b ? A : m;
              this.plotSizeY = b ? m : A;
              this.plotBorderWidth = h.plotBorderWidth || 0;
              this.spacingBox = d.spacingBox = {
                x: f[3],
                y: f[0],
                width: c - f[3] - f[1],
                height: e - f[0] - f[2]
              };
              this.plotBox = d.plotBox = {
                x: k,
                y: l,
                width: m,
                height: A
              };
              b = 2 * Math.floor(this.plotBorderWidth / 2);
              c = Math.ceil(Math.max(b, g[3]) / 2);
              e = Math.ceil(Math.max(b, g[0]) / 2);
              this.clipBox = {
                x: c,
                y: e,
                width: Math.floor(this.plotSizeX - Math.max(b, g[1]) / 2 - c),
                height: Math.max(0, Math.floor(this.plotSizeY - Math.max(b, g[2]) / 2 - e))
              };
              a || (this.axes.forEach(function (a) {
                a.setAxisSize();
                a.setAxisTranslation();
              }), d.alignElements());
              R(this, "afterSetChartSize", {
                skipAxes: a
              });
            };

            a.prototype.resetMargins = function () {
              R(this, "resetMargins");
              var a = this,
                  b = a.options.chart;
              ["margin", "spacing"].forEach(function (d) {
                var c = b[d],
                    e = N(c) ? c : [c, c, c, c];
                ["Top", "Right", "Bottom", "Left"].forEach(function (c, h) {
                  a[d][h] = T(b[d + c], e[h]);
                });
              });
              h.forEach(function (b, d) {
                a[b] = T(a.margin[d], a.spacing[d]);
              });
              a.axisOffset = [0, 0, 0, 0];
              a.clipOffset = [0, 0, 0, 0];
            };

            a.prototype.drawChartBox = function () {
              var a = this.options.chart,
                  b = this.renderer,
                  d = this.chartWidth,
                  c = this.chartHeight,
                  e = this.styledMode,
                  h = this.plotBGImage,
                  f = a.backgroundColor,
                  g = a.plotBackgroundColor,
                  k = a.plotBackgroundImage,
                  l = this.plotLeft,
                  m = this.plotTop,
                  A = this.plotWidth,
                  p = this.plotHeight,
                  n = this.plotBox,
                  q = this.clipRect,
                  N = this.clipBox,
                  t = this.chartBackground,
                  v = this.plotBackground,
                  r = this.plotBorder,
                  B,
                  y = "animate";
              t || (this.chartBackground = t = b.rect().addClass("highcharts-background").add(), y = "attr");
              if (e) var I = B = t.strokeWidth();else {
                I = a.borderWidth || 0;
                B = I + (a.shadow ? 8 : 0);
                f = {
                  fill: f || "none"
                };
                if (I || t["stroke-width"]) f.stroke = a.borderColor, f["stroke-width"] = I;
                t.attr(f).shadow(a.shadow);
              }
              t[y]({
                x: B / 2,
                y: B / 2,
                width: d - B - I % 2,
                height: c - B - I % 2,
                r: a.borderRadius
              });
              y = "animate";
              v || (y = "attr", this.plotBackground = v = b.rect().addClass("highcharts-plot-background").add());
              v[y](n);
              e || (v.attr({
                fill: g || "none"
              }).shadow(a.plotShadow), k && (h ? (k !== h.attr("href") && h.attr("href", k), h.animate(n)) : this.plotBGImage = b.image(k, l, m, A, p).add()));
              q ? q.animate({
                width: N.width,
                height: N.height
              }) : this.clipRect = b.clipRect(N);
              y = "animate";
              r || (y = "attr", this.plotBorder = r = b.rect().addClass("highcharts-plot-border").attr({
                zIndex: 1
              }).add());
              e || r.attr({
                stroke: a.plotBorderColor,
                "stroke-width": a.plotBorderWidth || 0,
                fill: "none"
              });
              r[y](r.crisp({
                x: l,
                y: m,
                width: A,
                height: p
              }, -r.strokeWidth()));
              this.isDirtyBox = !1;
              R(this, "afterDrawChartBox");
            };

            a.prototype.propFromSeries = function () {
              var a = this,
                  b = a.options.chart,
                  d = a.options.series,
                  c,
                  e,
                  h;
              ["inverted", "angular", "polar"].forEach(function (f) {
                e = y[b.type || b.defaultSeriesType];
                h = b[f] || e && e.prototype[f];

                for (c = d && d.length; !h && c--;) {
                  (e = y[d[c].type]) && e.prototype[f] && (h = !0);
                }

                a[f] = h;
              });
            };

            a.prototype.linkSeries = function () {
              var a = this,
                  b = a.series;
              b.forEach(function (a) {
                a.linkedSeries.length = 0;
              });
              b.forEach(function (b) {
                var d = b.options.linkedTo;
                W(d) && (d = ":previous" === d ? a.series[b.index - 1] : a.get(d)) && d.linkedParent !== b && (d.linkedSeries.push(b), b.linkedParent = d, d.enabledDataSorting && b.setDataSortingOptions(), b.visible = T(b.options.visible, d.options.visible, b.visible));
              });
              R(this, "afterLinkSeries");
            };

            a.prototype.renderSeries = function () {
              this.series.forEach(function (a) {
                a.translate();
                a.render();
              });
            };

            a.prototype.renderLabels = function () {
              var a = this,
                  b = a.options.labels;
              b.items && b.items.forEach(function (d) {
                var c = M(b.style, d.style),
                    e = da(c.left) + a.plotLeft,
                    h = da(c.top) + a.plotTop + 12;
                delete c.left;
                delete c.top;
                a.renderer.text(d.html, e, h).attr({
                  zIndex: 2
                }).css(c).add();
              });
            };

            a.prototype.render = function () {
              var a = this.axes,
                  b = this.colorAxis,
                  d = this.renderer,
                  c = this.options,
                  e = function e(a) {
                a.forEach(function (a) {
                  a.visible && a.render();
                });
              },
                  h = 0;

              this.setTitle();
              this.legend = new x(this, c.legend);
              this.getStacks && this.getStacks();
              this.getMargins(!0);
              this.setChartSize();
              c = this.plotWidth;
              a.some(function (a) {
                if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return h = 21, !0;
              });
              var f = this.plotHeight = Math.max(this.plotHeight - h, 0);
              a.forEach(function (a) {
                a.setScale();
              });
              this.getAxisMargins();
              var g = 1.1 < c / this.plotWidth,
                  k = 1.05 < f / this.plotHeight;
              if (g || k) a.forEach(function (a) {
                (a.horiz && g || !a.horiz && k) && a.setTickInterval(!0);
              }), this.getMargins();
              this.drawChartBox();
              this.hasCartesianSeries ? e(a) : b && b.length && e(b);
              this.seriesGroup || (this.seriesGroup = d.g("series-group").attr({
                zIndex: 3
              }).add());
              this.renderSeries();
              this.renderLabels();
              this.addCredits();
              this.setResponsive && this.setResponsive();
              this.hasRendered = !0;
            };

            a.prototype.addCredits = function (a) {
              var d = this,
                  c = X(!0, this.options.credits, a);
              c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                c.href && (b.location.href = c.href);
              }).attr({
                align: c.position.align,
                zIndex: 8
              }), d.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (a) {
                d.credits = d.credits.destroy();
                d.addCredits(a);
              });
            };

            a.prototype.destroy = function () {
              var a = this,
                  b = a.axes,
                  d = a.series,
                  c = a.container,
                  e = c && c.parentNode,
                  h;
              R(a, "destroy");
              a.renderer.forExport ? H(O, a) : O[a.index] = void 0;
              z.chartCount--;
              a.renderTo.removeAttribute("data-highcharts-chart");
              ja(a);

              for (h = b.length; h--;) {
                b[h] = b[h].destroy();
              }

              this.scroller && this.scroller.destroy && this.scroller.destroy();

              for (h = d.length; h--;) {
                d[h] = d[h].destroy();
              }

              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (b) {
                var d = a[b];
                d && d.destroy && (a[b] = d.destroy());
              });
              c && (c.innerHTML = "", ja(c), e && fa(c));
              Y(a, function (b, d) {
                delete a[d];
              });
            };

            a.prototype.firstRender = function () {
              var a = this,
                  b = a.options;

              if (!a.isReadyToRender || a.isReadyToRender()) {
                a.getContainer();
                a.resetMargins();
                a.setChartSize();
                a.propFromSeries();
                a.getAxes();
                (A(b.series) ? b.series : []).forEach(function (b) {
                  a.initSeries(b);
                });
                a.linkSeries();
                a.setSeriesData();
                R(a, "beforeRender");
                m && (J.isRequired() ? a.pointer = new J(a, b) : a.pointer = new m(a, b));
                a.render();
                a.pointer.getChartPosition();
                if (!a.renderer.imgCount && !a.hasLoaded) a.onload();
                a.temporaryDisplay(!0);
              }
            };

            a.prototype.onload = function () {
              this.callbacks.concat([this.callback]).forEach(function (a) {
                a && "undefined" !== typeof this.index && a.apply(this, [this]);
              }, this);
              R(this, "load");
              R(this, "render");
              V(this.index) && this.setReflow(this.options.chart.reflow);
              this.hasLoaded = !0;
            };

            a.prototype.addSeries = function (a, b, d) {
              var c = this,
                  e;
              a && (b = T(b, !0), R(c, "addSeries", {
                options: a
              }, function () {
                e = c.initSeries(a);
                c.isDirtyLegend = !0;
                c.linkSeries();
                e.enabledDataSorting && e.setData(a.data, !1);
                R(c, "afterAddSeries", {
                  series: e
                });
                b && c.redraw(d);
              }));
              return e;
            };

            a.prototype.addAxis = function (a, b, d, c) {
              return this.createAxis(b ? "xAxis" : "yAxis", {
                axis: a,
                redraw: d,
                animation: c
              });
            };

            a.prototype.addColorAxis = function (a, b, d) {
              return this.createAxis("colorAxis", {
                axis: a,
                redraw: b,
                animation: d
              });
            };

            a.prototype.createAxis = function (a, b) {
              a = new w(this, X(b.axis, {
                index: this[a].length,
                isX: "xAxis" === a
              }));
              T(b.redraw, !0) && this.redraw(b.animation);
              return a;
            };

            a.prototype.showLoading = function (a) {
              var b = this,
                  d = b.options,
                  c = d.loading,
                  e = function e() {
                h && Q(h, {
                  left: b.plotLeft + "px",
                  top: b.plotTop + "px",
                  width: b.plotWidth + "px",
                  height: b.plotHeight + "px"
                });
              },
                  h = b.loadingDiv,
                  f = b.loadingSpan;

              h || (b.loadingDiv = h = S("div", {
                className: "highcharts-loading highcharts-loading-hidden"
              }, null, b.container));
              f || (b.loadingSpan = f = S("span", {
                className: "highcharts-loading-inner"
              }, null, h), L(b, "redraw", e));
              h.className = "highcharts-loading";
              v.setElementHTML(f, T(a, d.lang.loading, ""));
              b.styledMode || (Q(h, M(c.style, {
                zIndex: 10
              })), Q(f, c.labelStyle), b.loadingShown || (Q(h, {
                opacity: 0,
                display: ""
              }), q(h, {
                opacity: c.style.opacity || .5
              }, {
                duration: c.showDuration || 0
              })));
              b.loadingShown = !0;
              e();
            };

            a.prototype.hideLoading = function () {
              var a = this.options,
                  b = this.loadingDiv;
              b && (b.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || q(b, {
                opacity: 0
              }, {
                duration: a.loading.hideDuration || 100,
                complete: function complete() {
                  Q(b, {
                    display: "none"
                  });
                }
              }));
              this.loadingShown = !1;
            };

            a.prototype.update = function (a, b, d, c) {
              var e = this,
                  h = {
                credits: "addCredits",
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              },
                  f = a.isResponsiveOptions,
                  g = [],
                  k,
                  m;
              R(e, "update", {
                options: a
              });
              f || e.setResponsive(!1, !0);
              a = P(a, e.options);
              e.userOptions = X(e.userOptions, a);
              var A = a.chart;

              if (A) {
                X(!0, e.options.chart, A);
                "className" in A && e.setClassName(A.className);
                "reflow" in A && e.setReflow(A.reflow);

                if ("inverted" in A || "polar" in A || "type" in A) {
                  e.propFromSeries();
                  var p = !0;
                }

                "alignTicks" in A && (p = !0);
                "events" in A && B(this, A);
                Y(A, function (a, b) {
                  -1 !== e.propsRequireUpdateSeries.indexOf("chart." + b) && (k = !0);
                  -1 !== e.propsRequireDirtyBox.indexOf(b) && (e.isDirtyBox = !0);
                  -1 !== e.propsRequireReflow.indexOf(b) && (f ? e.isDirtyBox = !0 : m = !0);
                });
                !e.styledMode && A.style && e.renderer.setStyle(e.options.chart.style || {});
              }

              !e.styledMode && a.colors && (this.options.colors = a.colors);
              a.time && (this.time === G && (this.time = new l(a.time)), X(!0, e.options.time, a.time));
              Y(a, function (b, d) {
                if (e[d] && "function" === typeof e[d].update) e[d].update(b, !1);else if ("function" === typeof e[h[d]]) e[h[d]](b);else "colors" !== d && -1 === e.collectionsWithUpdate.indexOf(d) && X(!0, e.options[d], a[d]);
                "chart" !== d && -1 !== e.propsRequireUpdateSeries.indexOf(d) && (k = !0);
              });
              this.collectionsWithUpdate.forEach(function (b) {
                if (a[b]) {
                  var c = [];
                  e[b].forEach(function (a, b) {
                    a.options.isInternal || c.push(T(a.options.index, b));
                  });
                  ba(a[b]).forEach(function (a, h) {
                    var f = V(a.id),
                        g;
                    f && (g = e.get(a.id));
                    !g && e[b] && (g = e[b][c ? c[h] : h]) && f && V(g.options.id) && (g = void 0);
                    g && g.coll === b && (g.update(a, !1), d && (g.touched = !0));
                    !g && d && e.collectionsWithInit[b] && (e.collectionsWithInit[b][0].apply(e, [a].concat(e.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);
                  });
                  d && e[b].forEach(function (a) {
                    a.touched || a.options.isInternal ? delete a.touched : g.push(a);
                  });
                }
              });
              g.forEach(function (a) {
                a.chart && a.remove && a.remove(!1);
              });
              p && e.axes.forEach(function (a) {
                a.update({}, !1);
              });
              k && e.getSeriesOrderByLinks().forEach(function (a) {
                a.chart && a.update({}, !1);
              }, this);
              p = A && A.width;
              A = A && (W(A.height) ? ka(A.height, p || e.chartWidth) : A.height);
              m || U(p) && p !== e.chartWidth || U(A) && A !== e.chartHeight ? e.setSize(p, A, c) : T(b, !0) && e.redraw(c);
              R(e, "afterUpdate", {
                options: a,
                redraw: b,
                animation: c
              });
            };

            a.prototype.setSubtitle = function (a, b) {
              this.applyDescription("subtitle", a);
              this.layOutTitles(b);
            };

            a.prototype.setCaption = function (a, b) {
              this.applyDescription("caption", a);
              this.layOutTitles(b);
            };

            a.prototype.showResetZoom = function () {
              function a() {
                b.zoomOut();
              }

              var b = this,
                  d = p.lang,
                  c = b.options.chart.resetZoomButton,
                  e = c.theme,
                  h = e.states,
                  f = "chart" === c.relativeTo || "spacingBox" === c.relativeTo ? null : "scrollablePlotBox";
              R(this, "beforeShowResetZoom", null, function () {
                b.resetZoomButton = b.renderer.button(d.resetZoom, null, null, a, e, h && h.hover).attr({
                  align: c.position.align,
                  title: d.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(c.position, !1, f);
              });
              R(this, "afterShowResetZoom");
            };

            a.prototype.zoomOut = function () {
              R(this, "selection", {
                resetSelection: !0
              }, this.zoom);
            };

            a.prototype.zoom = function (a) {
              var b = this,
                  d = b.pointer,
                  c = b.inverted ? d.mouseDownX : d.mouseDownY,
                  e = !1,
                  h;
              !a || a.resetSelection ? (b.axes.forEach(function (a) {
                h = a.zoom();
              }), d.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
                var f = a.axis,
                    g = b.inverted ? f.left : f.top,
                    k = b.inverted ? g + f.width : g + f.height,
                    l = f.isXAxis,
                    A = !1;
                if (!l && c >= g && c <= k || l || !V(c)) A = !0;
                d[l ? "zoomX" : "zoomY"] && A && (h = f.zoom(a.min, a.max), f.displayBtn && (e = !0));
              });
              var f = b.resetZoomButton;
              e && !f ? b.showResetZoom() : !e && N(f) && (b.resetZoomButton = f.destroy());
              h && b.redraw(T(b.options.chart.animation, a && a.animation, 100 > b.pointCount));
            };

            a.prototype.pan = function (a, b) {
              var d = this,
                  c = d.hoverPoints;
              b = "object" === typeof b ? b : {
                enabled: b,
                type: "x"
              };
              var e = d.options.chart,
                  h = d.options.mapNavigation && d.options.mapNavigation.enabled;
              e && e.panning && (e.panning = b);
              var f = b.type,
                  g;
              R(this, "pan", {
                originalEvent: a
              }, function () {
                c && c.forEach(function (a) {
                  a.setState();
                });
                var b = d.xAxis;
                "xy" === f ? b = b.concat(d.yAxis) : "y" === f && (b = d.yAxis);
                var e = {};
                b.forEach(function (b) {
                  if (b.options.panningEnabled && !b.options.isInternal) {
                    var c = b.horiz,
                        k = a[c ? "chartX" : "chartY"];
                    c = c ? "mouseDownX" : "mouseDownY";
                    var l = d[c],
                        A = b.minPointOffset || 0,
                        m = b.reversed && !d.inverted || !b.reversed && d.inverted ? -1 : 1,
                        p = b.getExtremes(),
                        n = b.toValue(l - k, !0) + A * m,
                        q = b.toValue(l + b.len - k, !0) - (A * m || b.isXAxis && b.pointRangePadding || 0),
                        t = q < n;
                    m = b.hasVerticalPanning();
                    l = t ? q : n;
                    n = t ? n : q;
                    var N = b.panningState;
                    !m || b.isXAxis || N && !N.isDirty || b.series.forEach(function (a) {
                      var b = a.getProcessedData(!0);
                      b = a.getExtremes(b.yData, !0);
                      N || (N = {
                        startMin: Number.MAX_VALUE,
                        startMax: -Number.MAX_VALUE
                      });
                      U(b.dataMin) && U(b.dataMax) && (N.startMin = Math.min(T(a.options.threshold, Infinity), b.dataMin, N.startMin), N.startMax = Math.max(T(a.options.threshold, -Infinity), b.dataMax, N.startMax));
                    });
                    m = Math.min(T(N && N.startMin, p.dataMin), A ? p.min : b.toValue(b.toPixels(p.min) - b.minPixelPadding));
                    q = Math.max(T(N && N.startMax, p.dataMax), A ? p.max : b.toValue(b.toPixels(p.max) + b.minPixelPadding));
                    b.panningState = N;
                    b.isOrdinal || (A = m - l, 0 < A && (n += A, l = m), A = n - q, 0 < A && (n = q, l -= A), b.series.length && l !== p.min && n !== p.max && l >= m && n <= q && (b.setExtremes(l, n, !1, !1, {
                      trigger: "pan"
                    }), d.resetZoomButton || h || l === m || n === q || !f.match("y") || (d.showResetZoom(), b.displayBtn = !1), g = !0), e[c] = k);
                  }
                });
                Y(e, function (a, b) {
                  d[b] = a;
                });
                g && d.redraw(!1);
                Q(d.container, {
                  cursor: "move"
                });
              });
            };

            return a;
          }();

          M(a.prototype, {
            callbacks: [],
            collectionsWithInit: {
              xAxis: [a.prototype.addAxis, [!0]],
              yAxis: [a.prototype.addAxis, [!1]],
              series: [a.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
          });
          "";
          return a;
        });
        M(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.merge,
              C = a.pick,
              E;

          (function (a) {
            a.drawLineMarker = function (a) {
              var x = this.options,
                  u = a.symbolWidth,
                  n = a.symbolHeight,
                  m = n / 2,
                  g = this.chart.renderer,
                  c = this.legendGroup;
              a = a.baseline - Math.round(.3 * a.fontMetrics.b);
              var e = {},
                  l = x.marker;
              this.chart.styledMode || (e = {
                "stroke-width": x.lineWidth || 0
              }, x.dashStyle && (e.dashstyle = x.dashStyle));
              this.legendLine = g.path([["M", 0, a], ["L", u, a]]).addClass("highcharts-graph").attr(e).add(c);
              l && !1 !== l.enabled && u && (x = Math.min(C(l.radius, m), m), 0 === this.symbol.indexOf("url") && (l = r(l, {
                width: n,
                height: n
              }), x = 0), this.legendSymbol = u = g.symbol(this.symbol, u / 2 - x, a - x, 2 * x, 2 * x, l).addClass("highcharts-point").add(c), u.isMarker = !0);
            };

            a.drawRectangle = function (a, r) {
              var u = a.symbolHeight,
                  n = a.options.squareSymbol;
              r.legendSymbol = this.chart.renderer.rect(n ? (a.symbolWidth - u) / 2 : 0, a.baseline - u + 1, n ? u : a.symbolWidth, u, C(a.options.symbolRadius, u / 2)).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(r.legendGroup);
            };
          })(E || (E = {}));

          return E;
        });
        M(a, "Core/Series/SeriesDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
              duration: 1E3
            },
            events: {},
            marker: {
              enabledThreshold: 2,
              lineColor: a.backgroundColor,
              lineWidth: 0,
              radius: 4,
              states: {
                normal: {
                  animation: !0
                },
                hover: {
                  animation: {
                    duration: 50
                  },
                  enabled: !0,
                  radiusPlus: 2,
                  lineWidthPlus: 1
                },
                select: {
                  fillColor: a.neutralColor20,
                  lineColor: a.neutralColor100,
                  lineWidth: 2
                }
              }
            },
            point: {
              events: {}
            },
            dataLabels: {
              animation: {},
              align: "center",
              defer: !0,
              formatter: function formatter() {
                var a = this.series.chart.numberFormatter;
                return "number" !== typeof this.y ? "" : a(this.y, -1);
              },
              padding: 5,
              style: {
                fontSize: "11px",
                fontWeight: "bold",
                color: "contrast",
                textOutline: "1px contrast"
              },
              verticalAlign: "bottom",
              x: 0,
              y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                lineWidthPlus: 1,
                marker: {},
                halo: {
                  size: 10,
                  opacity: .25
                }
              },
              select: {
                animation: {
                  duration: 0
                }
              },
              inactive: {
                animation: {
                  duration: 50
                },
                opacity: .2
              }
            },
            stickyTracking: !0,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
          };
        });
        M(a, "Core/Series/Series.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Color/Palette.js"], a["Core/Series/Point.js"], a["Core/Series/SeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x, J, u, n, m, g) {
          var c = a.animObject,
              e = a.setAnimation,
              l = w.defaultOptions,
              f = C.registerEventOptions,
              v = E.hasTouch,
              q = E.svg,
              k = E.win,
              r = n.seriesTypes,
              D = g.addEvent,
              B = g.arrayMax,
              O = g.arrayMin,
              t = g.clamp,
              h = g.cleanRecursively,
              d = g.correctFloat,
              b = g.defined,
              p = g.erase,
              G = g.error,
              y = g.extend,
              L = g.find,
              F = g.fireEvent,
              P = g.getNestedProperty,
              S = g.isArray,
              Q = g.isNumber,
              V = g.isString,
              M = g.merge,
              H = g.objectEach,
              K = g.pick,
              la = g.removeEvent,
              ha = g.splat,
              R = g.syncTimeout;

          a = function () {
            function a() {
              this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }

            a.prototype.init = function (a, b) {
              F(this, "init", {
                options: b
              });
              var d = this,
                  c = a.series;
              this.eventsToUnbind = [];
              d.chart = a;
              d.options = d.setOptions(b);
              b = d.options;
              d.linkedSeries = [];
              d.bindAxes();
              y(d, {
                name: b.name,
                state: "",
                visible: !1 !== b.visible,
                selected: !0 === b.selected
              });
              f(this, b);
              var e = b.events;
              if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;
              d.getColor();
              d.getSymbol();
              d.parallelArrays.forEach(function (a) {
                d[a + "Data"] || (d[a + "Data"] = []);
              });
              d.isCartesian && (a.hasCartesianSeries = !0);
              var h;
              c.length && (h = c[c.length - 1]);
              d._i = K(h && h._i, -1) + 1;
              d.opacity = d.options.opacity;
              a.orderSeries(this.insert(c));
              b.dataSorting && b.dataSorting.enabled ? d.setDataSortingOptions() : d.points || d.data || d.setData(b.data, !1);
              F(this, "afterInit");
            };

            a.prototype.is = function (a) {
              return r[a] && this instanceof r[a];
            };

            a.prototype.insert = function (a) {
              var b = this.options.index,
                  d;

              if (Q(b)) {
                for (d = a.length; d--;) {
                  if (b >= K(a[d].options.index, a[d]._i)) {
                    a.splice(d + 1, 0, this);
                    break;
                  }
                }

                -1 === d && a.unshift(this);
                d += 1;
              } else a.push(this);

              return K(d, a.length - 1);
            };

            a.prototype.bindAxes = function () {
              var a = this,
                  b = a.options,
                  d = a.chart,
                  c;
              F(this, "bindAxes", null, function () {
                (a.axisTypes || []).forEach(function (e) {
                  var h = 0;
                  d[e].forEach(function (d) {
                    c = d.options;
                    if (b[e] === h && !c.isInternal || "undefined" !== typeof b[e] && b[e] === c.id || "undefined" === typeof b[e] && 0 === c.index) a.insert(d.series), a[e] = d, d.isDirty = !0;
                    c.isInternal || h++;
                  });
                  a[e] || a.optionalAxis === e || G(18, !0, d);
                });
              });
              F(this, "afterBindAxes");
            };

            a.prototype.updateParallelArrays = function (a, b) {
              var d = a.series,
                  c = arguments,
                  e = Q(b) ? function (c) {
                var e = "y" === c && d.toYData ? d.toYData(a) : a[c];
                d[c + "Data"][b] = e;
              } : function (a) {
                Array.prototype[b].apply(d[a + "Data"], Array.prototype.slice.call(c, 2));
              };
              d.parallelArrays.forEach(e);
            };

            a.prototype.hasData = function () {
              return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };

            a.prototype.autoIncrement = function (a) {
              var b = this.options,
                  d = b.pointIntervalUnit,
                  c = b.relativeXValue,
                  e = this.chart.time,
                  h = this.xIncrement,
                  f;
              h = K(h, b.pointStart, 0);
              this.pointInterval = f = K(this.pointInterval, b.pointInterval, 1);
              c && Q(a) && (f *= a);
              d && (b = new e.Date(h), "day" === d ? e.set("Date", b, e.get("Date", b) + f) : "month" === d ? e.set("Month", b, e.get("Month", b) + f) : "year" === d && e.set("FullYear", b, e.get("FullYear", b) + f), f = b.getTime() - h);
              if (c && Q(a)) return h + f;
              this.xIncrement = h + f;
              return h;
            };

            a.prototype.setDataSortingOptions = function () {
              var a = this.options;
              y(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1
              });
              b(a.pointRange) || (a.pointRange = 1);
            };

            a.prototype.setOptions = function (a) {
              var d = this.chart,
                  c = d.options,
                  e = c.plotOptions,
                  h = d.userOptions || {};
              a = M(a);
              d = d.styledMode;
              var f = {
                plotOptions: e,
                userOptions: a
              };
              F(this, "setOptions", f);
              var g = f.plotOptions[this.type],
                  k = h.plotOptions || {};
              this.userOptions = f.userOptions;
              h = M(g, e.series, h.plotOptions && h.plotOptions[this.type], a);
              this.tooltipOptions = M(l.tooltip, l.plotOptions.series && l.plotOptions.series.tooltip, l.plotOptions[this.type].tooltip, c.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, a.tooltip);
              this.stickyTracking = K(a.stickyTracking, k[this.type] && k[this.type].stickyTracking, k.series && k.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : h.stickyTracking);
              null === g.marker && delete h.marker;
              this.zoneAxis = h.zoneAxis;
              e = this.zones = (h.zones || []).slice();
              !h.negativeColor && !h.negativeFillColor || h.zones || (c = {
                value: h[this.zoneAxis + "Threshold"] || h.threshold || 0,
                className: "highcharts-negative"
              }, d || (c.color = h.negativeColor, c.fillColor = h.negativeFillColor), e.push(c));
              e.length && b(e[e.length - 1].value) && e.push(d ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
              F(this, "afterSetOptions", {
                options: h
              });
              return h;
            };

            a.prototype.getName = function () {
              return K(this.options.name, "Series " + (this.index + 1));
            };

            a.prototype.getCyclic = function (a, d, c) {
              var e = this.chart,
                  h = this.userOptions,
                  f = a + "Index",
                  g = a + "Counter",
                  k = c ? c.length : K(e.options.chart[a + "Count"], e[a + "Count"]);

              if (!d) {
                var l = K(h[f], h["_" + f]);
                b(l) || (e.series.length || (e[g] = 0), h["_" + f] = l = e[g] % k, e[g] += 1);
                c && (d = c[l]);
              }

              "undefined" !== typeof l && (this[f] = l);
              this[a] = d;
            };

            a.prototype.getColor = function () {
              this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = x.neutralColor20 : this.getCyclic("color", this.options.color || l.plotOptions[this.type].color, this.chart.options.colors);
            };

            a.prototype.getPointsCollection = function () {
              return (this.hasGroupedData ? this.points : this.data) || [];
            };

            a.prototype.getSymbol = function () {
              this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };

            a.prototype.findPointIndex = function (a, b) {
              var d = a.id,
                  c = a.x,
                  e = this.points,
                  h = this.options.dataSorting,
                  f,
                  g;
              if (d) h = this.chart.get(d), h instanceof J && (f = h);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (f = function f(b) {
                return !b.touched && b.index === a.index;
              }, h && h.matchByName ? f = function f(b) {
                return !b.touched && b.name === a.name;
              } : this.options.relativeXValue && (f = function f(b) {
                return !b.touched && b.options.x === a.x;
              }), f = L(e, f), !f) return;

              if (f) {
                var k = f && f.index;
                "undefined" !== typeof k && (g = !0);
              }

              "undefined" === typeof k && Q(c) && (k = this.xData.indexOf(c, b));
              -1 !== k && "undefined" !== typeof k && this.cropped && (k = k >= this.cropStart ? k - this.cropStart : k);
              !g && Q(k) && e[k] && e[k].touched && (k = void 0);
              return k;
            };

            a.prototype.updateData = function (a, d) {
              var c = this.options,
                  e = c.dataSorting,
                  h = this.points,
                  f = [],
                  g = this.requireSorting,
                  k = a.length === h.length,
                  l,
                  m,
                  A,
                  p = !0;
              this.xIncrement = null;
              a.forEach(function (a, d) {
                var m = b(a) && this.pointClass.prototype.optionsToObject.call({
                  series: this
                }, a) || {},
                    p = m.x;

                if (m.id || Q(p)) {
                  if (m = this.findPointIndex(m, A), -1 === m || "undefined" === typeof m ? f.push(a) : h[m] && a !== c.data[m] ? (h[m].update(a, !1, null, !1), h[m].touched = !0, g && (A = m + 1)) : h[m] && (h[m].touched = !0), !k || d !== m || e && e.enabled || this.hasDerivedData) l = !0;
                } else f.push(a);
              }, this);
              if (l) for (a = h.length; a--;) {
                (m = h[a]) && !m.touched && m.remove && m.remove(!1, d);
              } else !k || e && e.enabled ? p = !1 : (a.forEach(function (a, b) {
                a !== h[b].y && h[b].update && h[b].update(a, !1, null, !1);
              }), f.length = 0);
              h.forEach(function (a) {
                a && (a.touched = !1);
              });
              if (!p) return !1;
              f.forEach(function (a) {
                this.addPoint(a, !1, null, null, !1);
              }, this);
              null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = B(this.xData), this.autoIncrement());
              return !0;
            };

            a.prototype.setData = function (a, b, d, c) {
              var e = this,
                  h = e.points,
                  f = h && h.length || 0,
                  g = e.options,
                  k = e.chart,
                  l = g.dataSorting,
                  m = e.xAxis,
                  A = g.turboThreshold,
                  p = this.xData,
                  n = this.yData,
                  q = e.pointArrayMap;
              q = q && q.length;
              var t = g.keys,
                  v,
                  r = 0,
                  B = 1,
                  y = null;
              a = a || [];
              var N = a.length;
              b = K(b, !0);
              l && l.enabled && (a = this.sortData(a));
              !1 !== c && N && f && !e.cropped && !e.hasGroupedData && e.visible && !e.isSeriesBoosting && (v = this.updateData(a, d));

              if (!v) {
                e.xIncrement = null;
                e.colorCounter = 0;
                this.parallelArrays.forEach(function (a) {
                  e[a + "Data"].length = 0;
                });
                if (A && N > A) {
                  if (y = e.getFirstValidPoint(a), Q(y)) for (d = 0; d < N; d++) {
                    p[d] = this.autoIncrement(), n[d] = a[d];
                  } else if (S(y)) {
                    if (q) for (d = 0; d < N; d++) {
                      c = a[d], p[d] = c[0], n[d] = c.slice(1, q + 1);
                    } else for (t && (r = t.indexOf("x"), B = t.indexOf("y"), r = 0 <= r ? r : 0, B = 0 <= B ? B : 1), d = 0; d < N; d++) {
                      c = a[d], p[d] = c[r], n[d] = c[B];
                    }
                  } else G(12, !1, k);
                } else for (d = 0; d < N; d++) {
                  "undefined" !== typeof a[d] && (c = {
                    series: e
                  }, e.pointClass.prototype.applyOptions.apply(c, [a[d]]), e.updateParallelArrays(c, d));
                }
                n && V(n[0]) && G(14, !0, k);
                e.data = [];
                e.options.data = e.userOptions.data = a;

                for (d = f; d--;) {
                  h[d] && h[d].destroy && h[d].destroy();
                }

                m && (m.minRange = m.userMinRange);
                e.isDirty = k.isDirtyBox = !0;
                e.isDirtyData = !!h;
                d = !1;
              }

              "point" === g.legendType && (this.processData(), this.generatePoints());
              b && k.redraw(d);
            };

            a.prototype.sortData = function (a) {
              var d = this,
                  c = d.options.dataSorting.sortKey || "y",
                  e = function e(a, d) {
                return b(d) && a.pointClass.prototype.optionsToObject.call({
                  series: a
                }, d) || {};
              };

              a.forEach(function (b, c) {
                a[c] = e(d, b);
                a[c].index = c;
              }, this);
              a.concat().sort(function (a, b) {
                a = P(c, a);
                b = P(c, b);
                return b < a ? -1 : b > a ? 1 : 0;
              }).forEach(function (a, b) {
                a.x = b;
              }, this);
              d.linkedSeries && d.linkedSeries.forEach(function (b) {
                var d = b.options,
                    c = d.data;
                d.dataSorting && d.dataSorting.enabled || !c || (c.forEach(function (d, h) {
                  c[h] = e(b, d);
                  a[h] && (c[h].x = a[h].x, c[h].index = h);
                }), b.setData(c, !1));
              });
              return a;
            };

            a.prototype.getProcessedData = function (a) {
              var b = this.xAxis,
                  d = this.options,
                  c = d.cropThreshold,
                  e = a || this.getExtremesFromAll || d.getExtremesFromAll,
                  h = this.isCartesian;
              a = b && b.val2lin;
              d = !(!b || !b.logarithmic);
              var f = 0,
                  g = this.xData,
                  k = this.yData,
                  l = this.requireSorting;
              var m = !1;
              var A = g.length;

              if (b) {
                m = b.getExtremes();
                var p = m.min;
                var n = m.max;
                m = b.categories && !b.names.length;
              }

              if (h && this.sorted && !e && (!c || A > c || this.forceCrop)) if (g[A - 1] < p || g[0] > n) g = [], k = [];else if (this.yData && (g[0] < p || g[A - 1] > n)) {
                var q = this.cropData(this.xData, this.yData, p, n);
                g = q.xData;
                k = q.yData;
                f = q.start;
                q = !0;
              }

              for (c = g.length || 1; --c;) {
                if (b = d ? a(g[c]) - a(g[c - 1]) : g[c] - g[c - 1], 0 < b && ("undefined" === typeof t || b < t)) var t = b;else 0 > b && l && !m && (G(15, !1, this.chart), l = !1);
              }

              return {
                xData: g,
                yData: k,
                cropped: q,
                cropStart: f,
                closestPointRange: t
              };
            };

            a.prototype.processData = function (a) {
              var b = this.xAxis;
              if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;
              a = this.getProcessedData();
              this.cropped = a.cropped;
              this.cropStart = a.cropStart;
              this.processedXData = a.xData;
              this.processedYData = a.yData;
              this.closestPointRange = this.basePointRange = a.closestPointRange;
            };

            a.prototype.cropData = function (a, b, d, c, e) {
              var h = a.length,
                  f,
                  g = 0,
                  k = h;
              e = K(e, this.cropShoulder);

              for (f = 0; f < h; f++) {
                if (a[f] >= d) {
                  g = Math.max(0, f - e);
                  break;
                }
              }

              for (d = f; d < h; d++) {
                if (a[d] > c) {
                  k = d + e;
                  break;
                }
              }

              return {
                xData: a.slice(g, k),
                yData: b.slice(g, k),
                start: g,
                end: k
              };
            };

            a.prototype.generatePoints = function () {
              var a = this.options,
                  b = a.data,
                  d = this.processedXData,
                  c = this.processedYData,
                  e = this.pointClass,
                  h = d.length,
                  f = this.cropStart || 0,
                  g = this.hasGroupedData,
                  k = a.keys,
                  l = [];
              a = a.dataGrouping && a.dataGrouping.groupAll ? f : 0;
              var m,
                  p,
                  n = this.data;

              if (!n && !g) {
                var q = [];
                q.length = b.length;
                n = this.data = q;
              }

              k && g && (this.options.keys = !1);

              for (p = 0; p < h; p++) {
                q = f + p;

                if (g) {
                  var t = new e().init(this, [d[p]].concat(ha(c[p])));
                  t.dataGroup = this.groupMap[a + p];
                  t.dataGroup.options && (t.options = t.dataGroup.options, y(t, t.dataGroup.options), delete t.dataLabels);
                } else (t = n[q]) || "undefined" === typeof b[q] || (n[q] = t = new e().init(this, b[q], d[p]));

                t && (t.index = g ? a + p : q, l[p] = t);
              }

              this.options.keys = k;
              if (n && (h !== (m = n.length) || g)) for (p = 0; p < m; p++) {
                p !== f || g || (p += h), n[p] && (n[p].destroyElements(), n[p].plotX = void 0);
              }
              this.data = n;
              this.points = l;
              F(this, "afterGeneratePoints");
            };

            a.prototype.getXExtremes = function (a) {
              return {
                min: O(a),
                max: B(a)
              };
            };

            a.prototype.getExtremes = function (a, b) {
              var d = this.xAxis,
                  c = this.yAxis,
                  e = this.processedXData || this.xData,
                  h = [],
                  f = this.requireSorting ? this.cropShoulder : 0;
              c = c ? c.positiveValuesOnly : !1;
              var g,
                  k = 0,
                  l = 0,
                  m = 0;
              a = a || this.stackedYData || this.processedYData || [];
              var p = a.length;

              if (d) {
                var n = d.getExtremes();
                k = n.min;
                l = n.max;
              }

              for (g = 0; g < p; g++) {
                var A = e[g];
                n = a[g];
                var q = (Q(n) || S(n)) && (n.length || 0 < n || !c);
                A = b || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !d || (e[g + f] || A) >= k && (e[g - f] || A) <= l;
                if (q && A) if (q = n.length) for (; q--;) {
                  Q(n[q]) && (h[m++] = n[q]);
                } else h[m++] = n;
              }

              a = {
                dataMin: O(h),
                dataMax: B(h)
              };
              F(this, "afterGetExtremes", {
                dataExtremes: a
              });
              return a;
            };

            a.prototype.applyExtremes = function () {
              var a = this.getExtremes();
              this.dataMin = a.dataMin;
              this.dataMax = a.dataMax;
              return a;
            };

            a.prototype.getFirstValidPoint = function (a) {
              for (var b = a.length, d = 0, c = null; null === c && d < b;) {
                c = a[d], d++;
              }

              return c;
            };

            a.prototype.translate = function () {
              this.processedXData || this.processData();
              this.generatePoints();
              var a = this.options,
                  c = a.stacking,
                  e = this.xAxis,
                  h = e.categories,
                  f = this.enabledDataSorting,
                  g = this.yAxis,
                  k = this.points,
                  l = k.length,
                  m = !!this.modifyValue,
                  p = this.pointPlacementToXValue(),
                  n = !!p,
                  q = a.threshold,
                  v = a.startFromThreshold ? q : 0,
                  r = this.zoneAxis || "y",
                  B,
                  y,
                  I = Number.MAX_VALUE;

              for (B = 0; B < l; B++) {
                var D = k[B],
                    u = D.x,
                    G = void 0,
                    x = void 0,
                    w = D.y,
                    L = D.low,
                    z = c && g.stacking && g.stacking.stacks[(this.negStacks && w < (v ? 0 : q) ? "-" : "") + this.stackKey];
                if (g.positiveValuesOnly && !g.validatePositiveValue(w) || e.positiveValuesOnly && !e.validatePositiveValue(u)) D.isNull = !0;
                D.plotX = y = d(t(e.translate(u, 0, 0, 0, 1, p, "flags" === this.type), -1E5, 1E5));

                if (c && this.visible && z && z[u]) {
                  var C = this.getStackIndicator(C, u, this.index);
                  D.isNull || (G = z[u], x = G.points[C.key]);
                }

                S(x) && (L = x[0], w = x[1], L === v && C.key === z[u].base && (L = K(Q(q) && q, g.min)), g.positiveValuesOnly && 0 >= L && (L = null), D.total = D.stackTotal = G.total, D.percentage = G.total && D.y / G.total * 100, D.stackY = w, this.irregularWidths || G.setOffset(this.pointXOffset || 0, this.barW || 0));
                D.yBottom = b(L) ? t(g.translate(L, 0, 1, 0, 1), -1E5, 1E5) : null;
                m && (w = this.modifyValue(w, D));
                D.plotY = void 0;
                Q(w) && (G = g.translate(w, !1, !0, !1, !0), "undefined" !== typeof G && (D.plotY = t(G, -1E5, 1E5)));
                D.isInside = this.isPointInside(D);
                D.clientX = n ? d(e.translate(u, 0, 0, 0, 1, p)) : y;
                D.negative = D[r] < (a[r + "Threshold"] || q || 0);
                D.category = h && "undefined" !== typeof h[D.x] ? h[D.x] : D.x;

                if (!D.isNull && !1 !== D.visible) {
                  "undefined" !== typeof H && (I = Math.min(I, Math.abs(y - H)));
                  var H = y;
                }

                D.zone = this.zones.length && D.getZone();
                !D.graphic && this.group && f && (D.isNew = !0);
              }

              this.closestPointRangePx = I;
              F(this, "afterTranslate");
            };

            a.prototype.getValidPoints = function (a, b, d) {
              var c = this.chart;
              return (a || this.points || []).filter(function (a) {
                return b && !c.isInsidePlot(a.plotX, a.plotY, {
                  inverted: c.inverted
                }) ? !1 : !1 !== a.visible && (d || !a.isNull);
              });
            };

            a.prototype.getClipBox = function (a, b) {
              var d = this.options,
                  c = this.chart,
                  e = c.inverted,
                  h = this.xAxis,
                  f = h && this.yAxis,
                  g = c.options.chart.scrollablePlotArea || {};
              a && !1 === d.clip && f ? a = e ? {
                y: -c.chartWidth + f.len + f.pos,
                height: c.chartWidth,
                width: c.chartHeight,
                x: -c.chartHeight + h.len + h.pos
              } : {
                y: -f.pos,
                height: c.chartHeight,
                width: c.chartWidth,
                x: -h.pos
              } : (a = this.clipBox || c.clipBox, b && (a.width = c.plotSizeX, a.x = (c.scrollablePixelsX || 0) * (g.scrollPositionX || 0)));
              return b ? {
                width: a.width,
                x: a.x
              } : a;
            };

            a.prototype.getSharedClipKey = function (a) {
              if (this.sharedClipKey) return this.sharedClipKey;
              var b = [a && a.duration, a && a.easing, a && a.defer, this.getClipBox(a).height, this.options.xAxis, this.options.yAxis].join();
              if (!1 !== this.options.clip || a) this.sharedClipKey = b;
              return b;
            };

            a.prototype.setClip = function (a) {
              var b = this.chart,
                  d = this.options,
                  c = b.renderer,
                  e = b.inverted,
                  h = this.clipBox,
                  f = this.getClipBox(a),
                  g = this.getSharedClipKey(a),
                  k = b.sharedClips[g],
                  l = b.sharedClips[g + "m"];
              a && (f.width = 0, e && (f.x = b.plotHeight + (!1 !== d.clip ? 0 : b.plotTop)));
              k ? b.hasLoaded || k.attr(f) : (a && (b.sharedClips[g + "m"] = l = c.clipRect(e ? (b.plotSizeX || 0) + 99 : -99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight)), b.sharedClips[g] = k = c.clipRect(f), k.count = {
                length: 0
              });
              a && !k.count[this.index] && (k.count[this.index] = !0, k.count.length += 1);
              if (!1 !== d.clip || a) this.group.clip(a || h ? k : b.clipRect), this.markerGroup.clip(l);
              a || (k.count[this.index] && (delete k.count[this.index], --k.count.length), 0 === k.count.length && (h || (b.sharedClips[g] = k.destroy()), l && (b.sharedClips[g + "m"] = l.destroy())));
            };

            a.prototype.animate = function (a) {
              var b = this.chart,
                  d = c(this.options.animation),
                  e = this.sharedClipKey;
              if (a) this.setClip(d);else if (e) {
                a = b.sharedClips[e];
                e = b.sharedClips[e + "m"];
                var h = this.getClipBox(d, !0);
                a && a.animate(h, d);
                e && e.animate({
                  width: h.width + 99,
                  x: h.x - (b.inverted ? 0 : 99)
                }, d);
              }
            };

            a.prototype.afterAnimate = function () {
              this.setClip();
              F(this, "afterAnimate");
              this.finishedAnimating = !0;
            };

            a.prototype.drawPoints = function () {
              var a = this.points,
                  b = this.chart,
                  d = this.options.marker,
                  c = this[this.specialGroup] || this.markerGroup,
                  e = this.xAxis,
                  h = K(d.enabled, !e || e.isRadial ? !0 : null, this.closestPointRangePx >= d.enabledThreshold * d.radius),
                  f,
                  g;
              if (!1 !== d.enabled || this._hasPointMarkers) for (f = 0; f < a.length; f++) {
                var k = a[f];
                var l = (g = k.graphic) ? "animate" : "attr";
                var m = k.marker || {};
                var p = !!k.marker;

                if ((h && "undefined" === typeof m.enabled || m.enabled) && !k.isNull && !1 !== k.visible) {
                  var n = K(m.symbol, this.symbol, "rect");
                  var q = this.markerAttribs(k, k.selected && "select");
                  this.enabledDataSorting && (k.startXPos = e.reversed ? -(q.width || 0) : e.width);
                  var t = !1 !== k.isInside;
                  g ? g[t ? "show" : "hide"](t).animate(q) : t && (0 < (q.width || 0) || k.hasImage) && (k.graphic = g = b.renderer.symbol(n, q.x, q.y, q.width, q.height, p ? m : d).add(c), this.enabledDataSorting && b.hasRendered && (g.attr({
                    x: k.startXPos
                  }), l = "animate"));
                  g && "animate" === l && g[t ? "show" : "hide"](t).animate(q);
                  if (g && !b.styledMode) g[l](this.pointAttribs(k, k.selected && "select"));
                  g && g.addClass(k.getClassName(), !0);
                } else g && (k.graphic = g.destroy());
              }
            };

            a.prototype.markerAttribs = function (a, b) {
              var d = this.options,
                  c = d.marker,
                  e = a.marker || {},
                  h = e.symbol || c.symbol,
                  f = K(e.radius, c.radius);
              b && (c = c.states[b], b = e.states && e.states[b], f = K(b && b.radius, c && c.radius, f + (c && c.radiusPlus || 0)));
              a.hasImage = h && 0 === h.indexOf("url");
              a.hasImage && (f = 0);
              a = {
                x: d.crisp ? Math.floor(a.plotX - f) : a.plotX - f,
                y: a.plotY - f
              };
              f && (a.width = a.height = 2 * f);
              return a;
            };

            a.prototype.pointAttribs = function (a, b) {
              var d = this.options.marker,
                  c = a && a.options,
                  e = c && c.marker || {},
                  h = c && c.color,
                  f = a && a.color,
                  g = a && a.zone && a.zone.color,
                  k = this.color;
              a = K(e.lineWidth, d.lineWidth);
              c = 1;
              k = h || g || f || k;
              h = e.fillColor || d.fillColor || k;
              f = e.lineColor || d.lineColor || k;
              b = b || "normal";
              d = d.states[b];
              b = e.states && e.states[b] || {};
              a = K(b.lineWidth, d.lineWidth, a + K(b.lineWidthPlus, d.lineWidthPlus, 0));
              h = b.fillColor || d.fillColor || h;
              f = b.lineColor || d.lineColor || f;
              c = K(b.opacity, d.opacity, c);
              return {
                stroke: f,
                "stroke-width": a,
                fill: h,
                opacity: c
              };
            };

            a.prototype.destroy = function (a) {
              var b = this,
                  d = b.chart,
                  c = /AppleWebKit\/533/.test(k.navigator.userAgent),
                  e = b.data || [],
                  h,
                  f,
                  l,
                  n;
              F(b, "destroy");
              this.removeEvents(a);
              (b.axisTypes || []).forEach(function (a) {
                (n = b[a]) && n.series && (p(n.series, b), n.isDirty = n.forceRedraw = !0);
              });
              b.legendItem && b.chart.legend.destroyItem(b);

              for (f = e.length; f--;) {
                (l = e[f]) && l.destroy && l.destroy();
              }

              b.clips && b.clips.forEach(function (a) {
                return a.destroy();
              });
              g.clearTimeout(b.animationTimeout);
              H(b, function (a, b) {
                a instanceof m && !a.survive && (h = c && "group" === b ? "hide" : "destroy", a[h]());
              });
              d.hoverSeries === b && (d.hoverSeries = void 0);
              p(d.series, b);
              d.orderSeries();
              H(b, function (d, c) {
                a && "hcEvents" === c || delete b[c];
              });
            };

            a.prototype.applyZones = function () {
              var a = this,
                  b = this.chart,
                  d = b.renderer,
                  c = this.zones,
                  e = this.clips || [],
                  h = this.graph,
                  f = this.area,
                  g = Math.max(b.chartWidth, b.chartHeight),
                  k = this[(this.zoneAxis || "y") + "Axis"],
                  l = b.inverted,
                  m,
                  p,
                  n,
                  q,
                  v,
                  r,
                  B,
                  y,
                  D = !1;

              if (c.length && (h || f) && k && "undefined" !== typeof k.min) {
                var I = k.reversed;
                var F = k.horiz;
                h && !this.showLine && h.hide();
                f && f.hide();
                var u = k.getExtremes();
                c.forEach(function (c, A) {
                  m = I ? F ? b.plotWidth : 0 : F ? 0 : k.toPixels(u.min) || 0;
                  m = t(K(p, m), 0, g);
                  p = t(Math.round(k.toPixels(K(c.value, u.max), !0) || 0), 0, g);
                  D && (m = p = k.toPixels(u.max));
                  q = Math.abs(m - p);
                  v = Math.min(m, p);
                  r = Math.max(m, p);
                  k.isXAxis ? (n = {
                    x: l ? r : v,
                    y: 0,
                    width: q,
                    height: g
                  }, F || (n.x = b.plotHeight - n.x)) : (n = {
                    x: 0,
                    y: l ? r : v,
                    width: g,
                    height: q
                  }, F && (n.y = b.plotWidth - n.y));
                  l && d.isVML && (n = k.isXAxis ? {
                    x: 0,
                    y: I ? v : r,
                    height: n.width,
                    width: b.chartWidth
                  } : {
                    x: n.y - b.plotLeft - b.spacingBox.x,
                    y: 0,
                    width: n.height,
                    height: b.chartHeight
                  });
                  e[A] ? e[A].animate(n) : e[A] = d.clipRect(n);
                  B = a["zone-area-" + A];
                  y = a["zone-graph-" + A];
                  h && y && y.clip(e[A]);
                  f && B && B.clip(e[A]);
                  D = c.value > u.max;
                  a.resetZones && 0 === p && (p = void 0);
                });
                this.clips = e;
              } else a.visible && (h && h.show(!0), f && f.show(!0));
            };

            a.prototype.invertGroups = function (a) {
              function b() {
                ["group", "markerGroup"].forEach(function (b) {
                  d[b] && (c.renderer.isVML && d[b].attr({
                    width: d.yAxis.len,
                    height: d.xAxis.len
                  }), d[b].width = d.yAxis.len, d[b].height = d.xAxis.len, d[b].invert(d.isRadialSeries ? !1 : a));
                });
              }

              var d = this,
                  c = d.chart;
              d.xAxis && (d.eventsToUnbind.push(D(c, "resize", b)), b(), d.invertGroups = b);
            };

            a.prototype.plotGroup = function (a, d, c, e, h) {
              var f = this[a],
                  g = !f;
              c = {
                visibility: c,
                zIndex: e || .1
              };
              "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c.opacity = this.opacity);
              g && (this[a] = f = this.chart.renderer.g().add(h));
              f.addClass("highcharts-" + d + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (b(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
              f.attr(c)[g ? "attr" : "animate"](this.getPlotBox());
              return f;
            };

            a.prototype.getPlotBox = function () {
              var a = this.chart,
                  b = this.xAxis,
                  d = this.yAxis;
              a.inverted && (b = d, d = this.xAxis);
              return {
                translateX: b ? b.left : a.plotLeft,
                translateY: d ? d.top : a.plotTop,
                scaleX: 1,
                scaleY: 1
              };
            };

            a.prototype.removeEvents = function (a) {
              a || la(this);
              this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
                a();
              }), this.eventsToUnbind.length = 0);
            };

            a.prototype.render = function () {
              var a = this,
                  b = a.chart,
                  d = a.options,
                  e = c(d.animation),
                  h = a.visible ? "inherit" : "hidden",
                  f = d.zIndex,
                  g = a.hasRendered,
                  k = b.seriesGroup,
                  l = b.inverted,
                  m = !a.finishedAnimating && b.renderer.isSVG && e.duration;
              F(this, "render");
              var p = a.plotGroup("group", "series", h, f, k);
              a.markerGroup = a.plotGroup("markerGroup", "markers", h, f, k);
              m && a.animate && a.animate(!0);
              p.inverted = K(a.invertible, a.isCartesian) ? l : !1;
              a.drawGraph && (a.drawGraph(), a.applyZones());
              a.visible && a.drawPoints();
              a.drawDataLabels && a.drawDataLabels();
              a.redrawPoints && a.redrawPoints();
              a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
              a.invertGroups(l);
              !1 === d.clip || a.sharedClipKey || g || p.clip(b.clipRect);
              m && a.animate && a.animate();
              g || (m && e.defer && (m += e.defer), a.animationTimeout = R(function () {
                a.afterAnimate();
              }, m || 0));
              a.isDirty = !1;
              a.hasRendered = !0;
              F(a, "afterRender");
            };

            a.prototype.redraw = function () {
              var a = this.chart,
                  b = this.isDirty || this.isDirtyData,
                  d = this.group,
                  c = this.xAxis,
                  e = this.yAxis;
              d && (a.inverted && d.attr({
                width: a.plotWidth,
                height: a.plotHeight
              }), d.animate({
                translateX: K(c && c.left, a.plotLeft),
                translateY: K(e && e.top, a.plotTop)
              }));
              this.translate();
              this.render();
              b && delete this.kdTree;
            };

            a.prototype.searchPoint = function (a, b) {
              var d = this.xAxis,
                  c = this.yAxis,
                  e = this.chart.inverted;
              return this.searchKDTree({
                clientX: e ? d.len - a.chartY + d.pos : a.chartX - d.pos,
                plotY: e ? c.len - a.chartX + c.pos : a.chartY - c.pos
              }, b, a);
            };

            a.prototype.buildKDTree = function (a) {
              function b(a, c, e) {
                var h = a && a.length;

                if (h) {
                  var f = d.kdAxisArray[c % e];
                  a.sort(function (a, b) {
                    return a[f] - b[f];
                  });
                  h = Math.floor(h / 2);
                  return {
                    point: a[h],
                    left: b(a.slice(0, h), c + 1, e),
                    right: b(a.slice(h + 1), c + 1, e)
                  };
                }
              }

              this.buildingKdTree = !0;
              var d = this,
                  c = -1 < d.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete d.kdTree;
              R(function () {
                d.kdTree = b(d.getValidPoints(null, !d.directTouch), c, c);
                d.buildingKdTree = !1;
              }, d.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
            };

            a.prototype.searchKDTree = function (a, d, c) {
              function e(a, d, c, l) {
                var m = d.point,
                    p = h.kdAxisArray[c % l],
                    n = m,
                    q = b(a[f]) && b(m[f]) ? Math.pow(a[f] - m[f], 2) : null;
                var t = b(a[g]) && b(m[g]) ? Math.pow(a[g] - m[g], 2) : null;
                t = (q || 0) + (t || 0);
                m.dist = b(t) ? Math.sqrt(t) : Number.MAX_VALUE;
                m.distX = b(q) ? Math.sqrt(q) : Number.MAX_VALUE;
                p = a[p] - m[p];
                t = 0 > p ? "left" : "right";
                q = 0 > p ? "right" : "left";
                d[t] && (t = e(a, d[t], c + 1, l), n = t[k] < n[k] ? t : m);
                d[q] && Math.sqrt(p * p) < n[k] && (a = e(a, d[q], c + 1, l), n = a[k] < n[k] ? a : n);
                return n;
              }

              var h = this,
                  f = this.kdAxisArray[0],
                  g = this.kdAxisArray[1],
                  k = d ? "distX" : "dist";
              d = -1 < h.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              this.kdTree || this.buildingKdTree || this.buildKDTree(c);
              if (this.kdTree) return e(a, this.kdTree, d, d);
            };

            a.prototype.pointPlacementToXValue = function () {
              var a = this.options,
                  b = a.pointRange,
                  d = this.xAxis;
              a = a.pointPlacement;
              "between" === a && (a = d.reversed ? -.5 : .5);
              return Q(a) ? a * (b || d.pointRange) : 0;
            };

            a.prototype.isPointInside = function (a) {
              return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;
            };

            a.prototype.drawTracker = function () {
              var a = this,
                  b = a.options,
                  d = b.trackByArea,
                  c = [].concat(d ? a.areaPath : a.graphPath),
                  e = a.chart,
                  h = e.pointer,
                  f = e.renderer,
                  g = e.options.tooltip.snap,
                  k = a.tracker,
                  l = function l(b) {
                if (e.hoverSeries !== a) a.onMouseOver();
              },
                  m = "rgba(192,192,192," + (q ? .0001 : .002) + ")";

              k ? k.attr({
                d: c
              }) : a.graph && (a.tracker = f.path(c).attr({
                visibility: a.visible ? "visible" : "hidden",
                zIndex: 2
              }).addClass(d ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), e.styledMode || a.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: m,
                fill: d ? m : "none",
                "stroke-width": a.graph.strokeWidth() + (d ? 0 : 2 * g)
              }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function (a) {
                if (a && (a.addClass("highcharts-tracker").on("mouseover", l).on("mouseout", function (a) {
                  h.onTrackerMouseOut(a);
                }), b.cursor && !e.styledMode && a.css({
                  cursor: b.cursor
                }), v)) a.on("touchstart", l);
              }));
              F(this, "afterDrawTracker");
            };

            a.prototype.addPoint = function (a, b, d, c, e) {
              var h = this.options,
                  f = this.data,
                  g = this.chart,
                  k = this.xAxis;
              k = k && k.hasNames && k.names;
              var l = h.data,
                  m = this.xData,
                  p;
              b = K(b, !0);
              var n = {
                series: this
              };
              this.pointClass.prototype.applyOptions.apply(n, [a]);
              var q = n.x;
              var t = m.length;
              if (this.requireSorting && q < m[t - 1]) for (p = !0; t && m[t - 1] > q;) {
                t--;
              }
              this.updateParallelArrays(n, "splice", t, 0, 0);
              this.updateParallelArrays(n, t);
              k && n.name && (k[q] = n.name);
              l.splice(t, 0, a);
              p && (this.data.splice(t, 0, null), this.processData());
              "point" === h.legendType && this.generatePoints();
              d && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(n, "shift"), l.shift()));
              !1 !== e && F(this, "addPoint", {
                point: n
              });
              this.isDirtyData = this.isDirty = !0;
              b && g.redraw(c);
            };

            a.prototype.removePoint = function (a, b, d) {
              var c = this,
                  h = c.data,
                  f = h[a],
                  g = c.points,
                  k = c.chart,
                  l = function l() {
                g && g.length === h.length && g.splice(a, 1);
                h.splice(a, 1);
                c.options.data.splice(a, 1);
                c.updateParallelArrays(f || {
                  series: c
                }, "splice", a, 1);
                f && f.destroy();
                c.isDirty = !0;
                c.isDirtyData = !0;
                b && k.redraw();
              };

              e(d, k);
              b = K(b, !0);
              f ? f.firePointEvent("remove", null, l) : l();
            };

            a.prototype.remove = function (a, b, d, c) {
              function e() {
                h.destroy(c);
                f.isDirtyLegend = f.isDirtyBox = !0;
                f.linkSeries();
                K(a, !0) && f.redraw(b);
              }

              var h = this,
                  f = h.chart;
              !1 !== d ? F(h, "remove", null, e) : e();
            };

            a.prototype.update = function (a, b) {
              a = h(a, this.userOptions);
              F(this, "update", {
                options: a
              });
              var d = this,
                  c = d.chart,
                  e = d.userOptions,
                  f = d.initialType || d.type,
                  g = c.options.plotOptions,
                  k = r[f].prototype,
                  l = d.finishedAnimating && {
                animation: !1
              },
                  m = {},
                  p,
                  n = ["eventOptions", "navigatorSeries", "baseSeries"],
                  q = a.type || e.type || c.options.chart.type,
                  t = !(this.hasDerivedData || q && q !== this.type || "undefined" !== typeof a.pointStart || "undefined" !== typeof a.pointInterval || "undefined" !== typeof a.relativeXValue || d.hasOptionChanged("dataGrouping") || d.hasOptionChanged("pointStart") || d.hasOptionChanged("pointInterval") || d.hasOptionChanged("pointIntervalUnit") || d.hasOptionChanged("keys"));
              q = q || f;
              t && (n.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && n.push("area", "graph"), d.parallelArrays.forEach(function (a) {
                n.push(a + "Data");
              }), a.data && (a.dataSorting && y(d.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
              a = M(e, l, {
                index: "undefined" === typeof e.index ? d.index : e.index,
                pointStart: K(g && g.series && g.series.pointStart, e.pointStart, d.xData[0])
              }, !t && {
                data: d.options.data
              }, a);
              t && a.data && (a.data = d.options.data);
              n = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(n);
              n.forEach(function (a) {
                n[a] = d[a];
                delete d[a];
              });
              g = !1;

              if (r[q]) {
                if (g = q !== d.type, d.remove(!1, !1, !1, !0), g) if (Object.setPrototypeOf) Object.setPrototypeOf(d, r[q].prototype);else {
                  l = Object.hasOwnProperty.call(d, "hcEvents") && d.hcEvents;

                  for (p in k) {
                    d[p] = void 0;
                  }

                  y(d, r[q].prototype);
                  l ? d.hcEvents = l : delete d.hcEvents;
                }
              } else G(17, !0, c, {
                missingModuleFor: q
              });

              n.forEach(function (a) {
                d[a] = n[a];
              });
              d.init(c, a);

              if (t && this.points) {
                var v = d.options;
                !1 === v.visible ? (m.graphic = 1, m.dataLabel = 1) : d._hasPointLabels || (a = v.marker, k = v.dataLabels, !a || !1 !== a.enabled && (e.marker && e.marker.symbol) === a.symbol || (m.graphic = 1), k && !1 === k.enabled && (m.dataLabel = 1));
                this.points.forEach(function (a) {
                  a && a.series && (a.resolveColor(), Object.keys(m).length && a.destroyElements(m), !1 === v.showInLegend && a.legendItem && c.legend.destroyItem(a));
                }, this);
              }

              d.initialType = f;
              c.linkSeries();
              g && d.linkedSeries.length && (d.isDirtyData = !0);
              F(this, "afterUpdate");
              K(b, !0) && c.redraw(t ? void 0 : !1);
            };

            a.prototype.setName = function (a) {
              this.name = this.options.name = this.userOptions.name = a;
              this.chart.isDirtyLegend = !0;
            };

            a.prototype.hasOptionChanged = function (a) {
              var b = this.options[a],
                  d = this.chart.options.plotOptions,
                  c = this.userOptions[a];
              return c ? b !== c : b !== K(d && d[this.type] && d[this.type][a], d && d.series && d.series[a], b);
            };

            a.prototype.onMouseOver = function () {
              var a = this.chart,
                  b = a.hoverSeries;
              a.pointer.setHoverChartIndex();
              if (b && b !== this) b.onMouseOut();
              this.options.events.mouseOver && F(this, "mouseOver");
              this.setState("hover");
              a.hoverSeries = this;
            };

            a.prototype.onMouseOut = function () {
              var a = this.options,
                  b = this.chart,
                  d = b.tooltip,
                  c = b.hoverPoint;
              b.hoverSeries = null;
              if (c) c.onMouseOut();
              this && a.events.mouseOut && F(this, "mouseOut");
              !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();
              b.series.forEach(function (a) {
                a.setState("", !0);
              });
            };

            a.prototype.setState = function (a, b) {
              var d = this,
                  c = d.options,
                  e = d.graph,
                  h = c.inactiveOtherPoints,
                  f = c.states,
                  g = K(f[a || "normal"] && f[a || "normal"].animation, d.chart.options.chart.animation),
                  k = c.lineWidth,
                  l = 0,
                  m = c.opacity;
              a = a || "";

              if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (b) {
                b && (d.state && b.removeClass("highcharts-series-" + d.state), a && b.addClass("highcharts-series-" + a));
              }), d.state = a, !d.chart.styledMode)) {
                if (f[a] && !1 === f[a].enabled) return;
                a && (k = f[a].lineWidth || k + (f[a].lineWidthPlus || 0), m = K(f[a].opacity, m));
                if (e && !e.dashstyle) for (c = {
                  "stroke-width": k
                }, e.animate(c, g); d["zone-graph-" + l];) {
                  d["zone-graph-" + l].animate(c, g), l += 1;
                }
                h || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {
                  a && a.animate({
                    opacity: m
                  }, g);
                });
              }

              b && h && d.points && d.setAllPointsToState(a || void 0);
            };

            a.prototype.setAllPointsToState = function (a) {
              this.points.forEach(function (b) {
                b.setState && b.setState(a);
              });
            };

            a.prototype.setVisible = function (a, b) {
              var d = this,
                  c = d.chart,
                  e = d.legendItem,
                  h = c.options.chart.ignoreHiddenSeries,
                  f = d.visible,
                  g = (d.visible = a = d.options.visible = d.userOptions.visible = "undefined" === typeof a ? !f : a) ? "show" : "hide";
              ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
                if (d[a]) d[a][g]();
              });
              if (c.hoverSeries === d || (c.hoverPoint && c.hoverPoint.series) === d) d.onMouseOut();
              e && c.legend.colorizeItem(d, a);
              d.isDirty = !0;
              d.options.stacking && c.series.forEach(function (a) {
                a.options.stacking && a.visible && (a.isDirty = !0);
              });
              d.linkedSeries.forEach(function (b) {
                b.setVisible(a, !1);
              });
              h && (c.isDirtyBox = !0);
              F(d, g);
              !1 !== b && c.redraw();
            };

            a.prototype.show = function () {
              this.setVisible(!0);
            };

            a.prototype.hide = function () {
              this.setVisible(!1);
            };

            a.prototype.select = function (a) {
              this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
              this.checkbox && (this.checkbox.checked = a);
              F(this, a ? "select" : "unselect");
            };

            a.prototype.shouldShowTooltip = function (a, b, d) {
              void 0 === d && (d = {});
              d.series = this;
              d.visiblePlotOnly = !0;
              return this.chart.isInsidePlot(a, b, d);
            };

            a.defaultOptions = u;
            return a;
          }();

          y(a.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: z.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: J,
            requireSorting: !0,
            sorted: !0
          });
          n.series = a;
          "";
          "";
          return a;
        });
        M(a, "Extensions/ScrollablePlotArea.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x) {
          var r = a.stop,
              u = x.addEvent,
              n = x.createElement,
              m = x.merge,
              g = x.pick;
          u(C, "afterSetChartSize", function (a) {
            var c = this.options.chart.scrollablePlotArea,
                g = c && c.minWidth;
            c = c && c.minHeight;

            if (!this.renderer.forExport) {
              if (g) {
                if (this.scrollablePixelsX = g = Math.max(0, g - this.chartWidth)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox);
                  this.plotBox.width = this.plotWidth += g;
                  this.inverted ? this.clipBox.height += g : this.clipBox.width += g;
                  var f = {
                    1: {
                      name: "right",
                      value: g
                    }
                  };
                }
              } else c && (this.scrollablePixelsY = g = Math.max(0, c - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox), this.plotBox.height = this.plotHeight += g, this.inverted ? this.clipBox.width += g : this.clipBox.height += g, f = {
                2: {
                  name: "bottom",
                  value: g
                }
              });

              f && !a.skipAxes && this.axes.forEach(function (a) {
                f[a.side] ? a.getPlotLinePath = function () {
                  var c = f[a.side].name,
                      e = this[c];
                  this[c] = e - f[a.side].value;
                  var g = w.prototype.getPlotLinePath.apply(this, arguments);
                  this[c] = e;
                  return g;
                } : (a.setAxisSize(), a.setAxisTranslation());
              });
            }
          });
          u(C, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });

          C.prototype.setUpScrolling = function () {
            var a = this,
                e = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            this.scrollablePixelsX && (e.overflowX = "auto");
            this.scrollablePixelsY && (e.overflowY = "auto");
            this.scrollingParent = n("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = n("div", {
              className: "highcharts-scrolling"
            }, e, this.scrollingParent);
            u(this.scrollingContainer, "scroll", function () {
              a.pointer && delete a.pointer.chartPosition;
            });
            this.innerContainer = n("div", {
              className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };

          C.prototype.moveFixedElements = function () {
            var a = this.container,
                e = this.fixedRenderer,
                g = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
                f;
            this.scrollablePixelsX && !this.inverted ? f = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? f = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? f = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (f = ".highcharts-yaxis");
            f && g.push(f + ":not(.highcharts-radial-axis)", f + "-labels:not(.highcharts-radial-axis-labels)");
            g.forEach(function (c) {
              [].forEach.call(a.querySelectorAll(c), function (a) {
                (a.namespaceURI === e.SVG_NS ? e.box : e.box.parentNode).appendChild(a);
                a.style.pointerEvents = "auto";
              });
            });
          };

          C.prototype.applyFixed = function () {
            var a = !this.fixedDiv,
                e = this.options.chart,
                l = e.scrollablePlotArea,
                f = z.getRendererType();
            a ? (this.fixedDiv = n("div", {
              className: "highcharts-fixed"
            }, {
              position: "absolute",
              overflow: "hidden",
              pointerEvents: "none",
              zIndex: (e.style && e.style.zIndex || 0) + 2,
              top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = e = new f(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = e.path().attr({
              fill: this.options.chart.backgroundColor || "#fff",
              "fill-opacity": g(l.opacity, .85),
              zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), u(this, "afterShowResetZoom", this.moveFixedElements), u(this, "afterDrilldown", this.moveFixedElements), u(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
            e = this.chartWidth + (this.scrollablePixelsX || 0);
            f = this.chartHeight + (this.scrollablePixelsY || 0);
            r(this.container);
            this.container.style.width = e + "px";
            this.container.style.height = f + "px";
            this.renderer.boxWrapper.attr({
              width: e,
              height: f,
              viewBox: [0, 0, e, f].join(" ")
            });
            this.chartBackground.attr({
              width: e,
              height: f
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            a && (l.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * l.scrollPositionX), l.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * l.scrollPositionY));
            f = this.axisOffset;
            a = this.plotTop - f[0] - 1;
            l = this.plotLeft - f[3] - 1;
            e = this.plotTop + this.plotHeight + f[2] + 1;
            f = this.plotLeft + this.plotWidth + f[1] + 1;
            var m = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                q = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, e], ["L", 0, e], ["Z"], ["M", m, a], ["L", this.chartWidth, a], ["L", this.chartWidth, e], ["L", m, e], ["Z"]] : this.scrollablePixelsY ? [["M", l, 0], ["L", l, this.plotTop - 1], ["L", f, this.plotTop - 1], ["L", f, 0], ["Z"], ["M", l, q], ["L", l, this.chartHeight], ["L", f, this.chartHeight], ["L", f, q], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
              d: a
            });
          };

          u(w, "afterInit", function () {
            this.chart.scrollableDirty = !0;
          });
          u(E, "show", function () {
            this.chart.scrollableDirty = !0;
          });
          "";
        });
        M(a, "Core/Axis/StackingAxis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = a.getDeferredAnimation,
              z = C.addEvent,
              x = C.destroyObjectProperties,
              J = C.fireEvent,
              u = C.isNumber,
              n = C.objectEach,
              m;

          (function (a) {
            function c() {
              var a = this.stacking;

              if (a) {
                var c = a.stacks;
                n(c, function (a, e) {
                  x(a);
                  c[e] = null;
                });
                a && a.stackTotalGroup && a.stackTotalGroup.destroy();
              }
            }

            function e() {
              this.stacking || (this.stacking = new f(this));
            }

            var g = [];

            a.compose = function (a) {
              -1 === g.indexOf(a) && (g.push(a), z(a, "init", e), z(a, "destroy", c));
              return a;
            };

            var f = function () {
              function a(a) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = a;
              }

              a.prototype.buildStacks = function () {
                var a = this.axis,
                    c = a.series,
                    e = a.options.reversedStacks,
                    f = c.length,
                    g;

                if (!a.isXAxis) {
                  this.usePercentage = !1;

                  for (g = f; g--;) {
                    var l = c[e ? g : f - g - 1];
                    l.setStackedPoints();
                    l.setGroupedPoints();
                  }

                  for (g = 0; g < f; g++) {
                    c[g].modifyStacks();
                  }

                  J(a, "afterBuildStacks");
                }
              };

              a.prototype.cleanStacks = function () {
                if (!this.axis.isXAxis) {
                  if (this.oldStacks) var a = this.stacks = this.oldStacks;
                  n(a, function (a) {
                    n(a, function (a) {
                      a.cumulative = a.total;
                    });
                  });
                }
              };

              a.prototype.resetStacks = function () {
                var a = this,
                    c = a.stacks;
                a.axis.isXAxis || n(c, function (c) {
                  n(c, function (e, f) {
                    u(e.touched) && e.touched < a.stacksTouched ? (e.destroy(), delete c[f]) : (e.total = null, e.cumulative = null);
                  });
                });
              };

              a.prototype.renderStackTotals = function () {
                var a = this.axis,
                    c = a.chart,
                    e = c.renderer,
                    f = this.stacks;
                a = r(c, a.options.stackLabels && a.options.stackLabels.animation || !1);
                var g = this.stackTotalGroup = this.stackTotalGroup || e.g("stack-labels").attr({
                  visibility: "visible",
                  zIndex: 6,
                  opacity: 0
                }).add();
                g.translate(c.plotLeft, c.plotTop);
                n(f, function (a) {
                  n(a, function (a) {
                    a.render(g);
                  });
                });
                g.animate({
                  opacity: 1
                }, a);
              };

              return a;
            }();

            a.Additions = f;
          })(m || (m = {}));

          return m;
        });
        M(a, "Extensions/Stacking.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Axis/StackingAxis.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x, J) {
          var r = C.format,
              n = J.correctFloat,
              m = J.defined,
              g = J.destroyObjectProperties,
              c = J.isArray,
              e = J.isNumber,
              l = J.objectEach,
              f = J.pick,
              v = function () {
            function a(a, c, e, f, g) {
              var k = a.chart.inverted;
              this.axis = a;
              this.isNegative = e;
              this.options = c = c || {};
              this.x = f;
              this.total = null;
              this.points = {};
              this.hasValidPoints = !1;
              this.stack = g;
              this.rightCliff = this.leftCliff = 0;
              this.alignOptions = {
                align: c.align || (k ? e ? "left" : "right" : "center"),
                verticalAlign: c.verticalAlign || (k ? "middle" : e ? "bottom" : "top"),
                y: c.y,
                x: c.x
              };
              this.textAlign = c.textAlign || (k ? e ? "right" : "left" : "center");
            }

            a.prototype.destroy = function () {
              g(this, this.axis);
            };

            a.prototype.render = function (a) {
              var c = this.axis.chart,
                  e = this.options,
                  g = e.format;
              g = g ? r(g, this, c) : e.formatter.call(this);
              this.label ? this.label.attr({
                text: g,
                visibility: "hidden"
              }) : (this.label = c.renderer.label(g, null, null, e.shape, null, null, e.useHTML, !1, "stack-labels"), g = {
                r: e.borderRadius || 0,
                text: g,
                rotation: e.rotation,
                padding: f(e.padding, 5),
                visibility: "hidden"
              }, c.styledMode || (g.fill = e.backgroundColor, g.stroke = e.borderColor, g["stroke-width"] = e.borderWidth, this.label.css(e.style)), this.label.attr(g), this.label.added || this.label.add(a));
              this.label.labelrank = c.plotSizeY;
            };

            a.prototype.setOffset = function (a, c, g, l, n) {
              var k = this.axis,
                  h = k.chart;
              l = k.translate(k.stacking.usePercentage ? 100 : l ? l : this.total, 0, 0, 0, 1);
              g = k.translate(g ? g : 0);
              g = m(l) && Math.abs(l - g);
              a = f(n, h.xAxis[0].translate(this.x)) + a;
              k = m(l) && this.getStackBox(h, this, a, l, c, g, k);
              c = this.label;
              g = this.isNegative;
              a = "justify" === f(this.options.overflow, "justify");
              var d = this.textAlign;
              c && k && (n = c.getBBox(), l = c.padding, d = "left" === d ? h.inverted ? -l : l : "right" === d ? n.width : h.inverted && "center" === d ? n.width / 2 : h.inverted ? g ? n.width + l : -l : n.width / 2, g = h.inverted ? n.height / 2 : g ? -l : n.height, this.alignOptions.x = f(this.options.x, 0), this.alignOptions.y = f(this.options.y, 0), k.x -= d, k.y -= g, c.align(this.alignOptions, null, k), h.isInsidePlot(c.alignAttr.x + d - this.alignOptions.x, c.alignAttr.y + g - this.alignOptions.y) ? c.show() : (c.alignAttr.y = -9999, a = !1), a && z.prototype.justifyDataLabel.call(this.axis, c, this.alignOptions, c.alignAttr, n, k), c.attr({
                x: c.alignAttr.x,
                y: c.alignAttr.y
              }), f(!a && this.options.crop, !0) && ((h = e(c.x) && e(c.y) && h.isInsidePlot(c.x - l + c.width, c.y) && h.isInsidePlot(c.x + l, c.y)) || c.hide()));
            };

            a.prototype.getStackBox = function (a, c, e, f, g, l, h) {
              var d = c.axis.reversed,
                  b = a.inverted,
                  k = h.height + h.pos - (b ? a.plotLeft : a.plotTop);
              c = c.isNegative && !d || !c.isNegative && d;
              return {
                x: b ? c ? f - h.right : f - l + h.pos - a.plotLeft : e + a.xAxis[0].transB - a.plotLeft,
                y: b ? h.height - e - g : c ? k - f - l : k - f,
                width: b ? l : g,
                height: b ? g : l
              };
            };

            return a;
          }();

          w.prototype.getStacks = function () {
            var a = this,
                c = a.inverted;
            a.yAxis.forEach(function (a) {
              a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
            });
            a.series.forEach(function (e) {
              var g = e.xAxis && e.xAxis.options || {};
              !e.options.stacking || !0 !== e.visible && !1 !== a.options.chart.ignoreHiddenSeries || (e.stackKey = [e.type, f(e.options.stack, ""), c ? g.top : g.left, c ? g.height : g.width].join());
            });
          };

          x.compose(a);

          z.prototype.setGroupedPoints = function () {
            var a = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? z.prototype.setStackedPoints.call(this, "group") : a && l(a.stacks, function (c, e) {
              "group" === e.slice(-5) && (l(c, function (a) {
                return a.destroy();
              }), delete a.stacks[e]);
            });
          };

          z.prototype.setStackedPoints = function (a) {
            var e = a || this.options.stacking;

            if (e && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
              var g = this.processedXData,
                  l = this.processedYData,
                  q = [],
                  r = l.length,
                  t = this.options,
                  h = t.threshold,
                  d = f(t.startFromThreshold && h, 0);
              t = t.stack;
              a = a ? this.type + "," + e : this.stackKey;
              var b = "-" + a,
                  p = this.negStacks,
                  u = this.yAxis,
                  y = u.stacking.stacks,
                  x = u.stacking.oldStacks,
                  F,
                  w;
              u.stacking.stacksTouched += 1;

              for (w = 0; w < r; w++) {
                var z = g[w];
                var C = l[w];
                var E = this.getStackIndicator(E, z, this.index);
                var J = E.key;
                var H = (F = p && C < (d ? 0 : h)) ? b : a;
                y[H] || (y[H] = {});
                y[H][z] || (x[H] && x[H][z] ? (y[H][z] = x[H][z], y[H][z].total = null) : y[H][z] = new v(u, u.options.stackLabels, F, z, t));
                H = y[H][z];
                null !== C ? (H.points[J] = H.points[this.index] = [f(H.cumulative, d)], m(H.cumulative) || (H.base = J), H.touched = u.stacking.stacksTouched, 0 < E.index && !1 === this.singleStacks && (H.points[J][0] = H.points[this.index + "," + z + ",0"][0])) : H.points[J] = H.points[this.index] = null;
                "percent" === e ? (F = F ? a : b, p && y[F] && y[F][z] ? (F = y[F][z], H.total = F.total = Math.max(F.total, H.total) + Math.abs(C) || 0) : H.total = n(H.total + (Math.abs(C) || 0))) : "group" === e ? (c(C) && (C = C[0]), null !== C && (H.total = (H.total || 0) + 1)) : H.total = n(H.total + (C || 0));
                H.cumulative = "group" === e ? (H.total || 1) - 1 : f(H.cumulative, d) + (C || 0);
                null !== C && (H.points[J].push(H.cumulative), q[w] = H.cumulative, H.hasValidPoints = !0);
              }

              "percent" === e && (u.stacking.usePercentage = !0);
              "group" !== e && (this.stackedYData = q);
              u.stacking.oldStacks = {};
            }
          };

          z.prototype.modifyStacks = function () {
            var a = this,
                c = a.stackKey,
                e = a.yAxis.stacking.stacks,
                f = a.processedXData,
                g,
                l = a.options.stacking;
            a[l + "Stacker"] && [c, "-" + c].forEach(function (c) {
              for (var h = f.length, d, b; h--;) {
                if (d = f[h], g = a.getStackIndicator(g, d, a.index, c), b = (d = e[c] && e[c][d]) && d.points[g.key]) a[l + "Stacker"](b, d, h);
              }
            });
          };

          z.prototype.percentStacker = function (a, c, e) {
            c = c.total ? 100 / c.total : 0;
            a[0] = n(a[0] * c);
            a[1] = n(a[1] * c);
            this.stackedYData[e] = a[1];
          };

          z.prototype.getStackIndicator = function (a, c, e, f) {
            !m(a) || a.x !== c || f && a.key !== f ? a = {
              x: c,
              index: 0,
              key: f
            } : a.index++;
            a.key = [e, c, a.index].join();
            return a;
          };

          E.StackItem = v;
          "";
          return E.StackItem;
        });
        M(a, "Series/Line/LineSeries.js", [a["Core/Color/Palette.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E) {
          var r = this && this.__extends || function () {
            var _a11 = function a(n, m) {
              _a11 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (a[e] = c[e]);
                }
              };

              return _a11(n, m);
            };

            return function (n, m) {
              function g() {
                this.constructor = n;
              }

              _a11(n, m);

              n.prototype = null === m ? Object.create(m) : (g.prototype = m.prototype, new g());
            };
          }(),
              x = E.defined,
              J = E.merge;

          E = function (u) {
            function n() {
              var a = null !== u && u.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(n, u);

            n.prototype.drawGraph = function () {
              var m = this,
                  g = this.options,
                  c = (this.gappedPath || this.getGraphPath).call(this),
                  e = this.chart.styledMode,
                  l = [["graph", "highcharts-graph"]];
              e || l[0].push(g.lineColor || this.color || a.neutralColor20, g.dashStyle);
              l = m.getZonesGraphs(l);
              l.forEach(function (a, l) {
                var f = a[0],
                    k = m[f],
                    n = k ? "animate" : "attr";
                k ? (k.endX = m.preventGraphAnimation ? null : c.xMap, k.animate({
                  d: c
                })) : c.length && (m[f] = k = m.chart.renderer.path(c).addClass(a[1]).attr({
                  zIndex: 1
                }).add(m.group));
                k && !e && (f = {
                  stroke: a[2],
                  "stroke-width": g.lineWidth,
                  fill: m.fillGraph && m.color || "none"
                }, a[3] ? f.dashstyle = a[3] : "square" !== g.linecap && (f["stroke-linecap"] = f["stroke-linejoin"] = "round"), k[n](f).shadow(2 > l && g.shadow));
                k && (k.startX = c.xMap, k.isArea = c.isArea);
              });
            };

            n.prototype.getGraphPath = function (a, g, c) {
              var e = this,
                  l = e.options,
                  f = [],
                  m = [],
                  n,
                  k = l.step;
              a = a || e.points;
              var r = a.reversed;
              r && a.reverse();
              (k = {
                right: 1,
                center: 2
              }[k] || k && 3) && r && (k = 4 - k);
              a = this.getValidPoints(a, !1, !(l.connectNulls && !g && !c));
              a.forEach(function (q, r) {
                var v = q.plotX,
                    t = q.plotY,
                    h = a[r - 1];
                (q.leftCliff || h && h.rightCliff) && !c && (n = !0);
                q.isNull && !x(g) && 0 < r ? n = !l.connectNulls : q.isNull && !g ? n = !0 : (0 === r || n ? r = [["M", q.plotX, q.plotY]] : e.getPointSpline ? r = [e.getPointSpline(a, q, r)] : k ? (r = 1 === k ? [["L", h.plotX, t]] : 2 === k ? [["L", (h.plotX + v) / 2, h.plotY], ["L", (h.plotX + v) / 2, t]] : [["L", v, h.plotY]], r.push(["L", v, t])) : r = [["L", v, t]], m.push(q.x), k && (m.push(q.x), 2 === k && m.push(q.x)), f.push.apply(f, r), n = !1);
              });
              f.xMap = m;
              return e.graphPath = f;
            };

            n.prototype.getZonesGraphs = function (a) {
              this.zones.forEach(function (g, c) {
                c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (g.className || "")];
                this.chart.styledMode || c.push(g.color || this.color, g.dashStyle || this.options.dashStyle);
                a.push(c);
              }, this);
              return a;
            };

            n.defaultOptions = J(w.defaultOptions, {});
            return n;
          }(w);

          C.registerSeriesType("line", E);
          "";
          return E;
        });
        M(a, "Series/Area/AreaSeries.js", [a["Core/Color/Color.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E) {
          var r = this && this.__extends || function () {
            var _a12 = function a(c, e) {
              _a12 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (a[e] = c[e]);
                }
              };

              return _a12(c, e);
            };

            return function (c, e) {
              function g() {
                this.constructor = c;
              }

              _a12(c, e);

              c.prototype = null === e ? Object.create(e) : (g.prototype = e.prototype, new g());
            };
          }(),
              x = a.parse,
              J = C.seriesTypes.line;

          a = E.extend;
          var u = E.merge,
              n = E.objectEach,
              m = E.pick;

          E = function (a) {
            function c() {
              var c = null !== a && a.apply(this, arguments) || this;
              c.data = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            r(c, a);

            c.prototype.drawGraph = function () {
              this.areaPath = [];
              a.prototype.drawGraph.apply(this);
              var c = this,
                  g = this.areaPath,
                  f = this.options,
                  n = [["area", "highcharts-area", this.color, f.fillColor]];
              this.zones.forEach(function (a, e) {
                n.push(["zone-area-" + e, "highcharts-area highcharts-zone-area-" + e + " " + a.className, a.color || c.color, a.fillColor || f.fillColor]);
              });
              n.forEach(function (a) {
                var e = a[0],
                    l = c[e],
                    n = l ? "animate" : "attr",
                    q = {};
                l ? (l.endX = c.preventGraphAnimation ? null : g.xMap, l.animate({
                  d: g
                })) : (q.zIndex = 0, l = c[e] = c.chart.renderer.path(g).addClass(a[1]).add(c.group), l.isArea = !0);
                c.chart.styledMode || (q.fill = m(a[3], x(a[2]).setOpacity(m(f.fillOpacity, .75)).get()));
                l[n](q);
                l.startX = g.xMap;
                l.shiftUnit = f.step ? 2 : 1;
              });
            };

            c.prototype.getGraphPath = function (a) {
              var c = J.prototype.getGraphPath,
                  e = this.options,
                  g = e.stacking,
                  n = this.yAxis,
                  k,
                  r = [],
                  u = [],
                  B = this.index,
                  x = n.stacking.stacks[this.stackKey],
                  t = e.threshold,
                  h = Math.round(n.getThreshold(e.threshold));
              e = m(e.connectNulls, "percent" === g);

              var d = function d(b, _d2, c) {
                var e = a[b];
                b = g && x[e.x].points[B];
                var f = e[c + "Null"] || 0;
                c = e[c + "Cliff"] || 0;
                e = !0;

                if (c || f) {
                  var k = (f ? b[0] : b[1]) + c;
                  var l = b[0] + c;
                  e = !!f;
                } else !g && a[_d2] && a[_d2].isNull && (k = l = t);

                "undefined" !== typeof k && (u.push({
                  plotX: p,
                  plotY: null === k ? h : n.getThreshold(k),
                  isNull: e,
                  isCliff: !0
                }), r.push({
                  plotX: p,
                  plotY: null === l ? h : n.getThreshold(l),
                  doCurve: !1
                }));
              };

              a = a || this.points;
              g && (a = this.getStackPoints(a));

              for (k = 0; k < a.length; k++) {
                g || (a[k].leftCliff = a[k].rightCliff = a[k].leftNull = a[k].rightNull = void 0);
                var b = a[k].isNull;
                var p = m(a[k].rectPlotX, a[k].plotX);
                var G = g ? m(a[k].yBottom, h) : h;
                if (!b || e) e || d(k, k - 1, "left"), b && !g && e || (u.push(a[k]), r.push({
                  x: k,
                  plotX: p,
                  plotY: G
                })), e || d(k, k + 1, "right");
              }

              k = c.call(this, u, !0, !0);
              r.reversed = !0;
              b = c.call(this, r, !0, !0);
              (G = b[0]) && "M" === G[0] && (b[0] = ["L", G[1], G[2]]);
              b = k.concat(b);
              b.length && b.push(["Z"]);
              c = c.call(this, u, !1, e);
              b.xMap = k.xMap;
              this.areaPath = b;
              return c;
            };

            c.prototype.getStackPoints = function (a) {
              var c = this,
                  e = [],
                  g = [],
                  r = this.xAxis,
                  k = this.yAxis,
                  u = k.stacking.stacks[this.stackKey],
                  x = {},
                  B = k.series,
                  w = B.length,
                  t = k.options.reversedStacks ? 1 : -1,
                  h = B.indexOf(c);
              a = a || this.points;

              if (this.options.stacking) {
                for (var d = 0; d < a.length; d++) {
                  a[d].leftNull = a[d].rightNull = void 0, x[a[d].x] = a[d];
                }

                n(u, function (a, b) {
                  null !== a.total && g.push(b);
                });
                g.sort(function (a, b) {
                  return a - b;
                });
                var b = B.map(function (a) {
                  return a.visible;
                });
                g.forEach(function (a, d) {
                  var f = 0,
                      l,
                      n;
                  if (x[a] && !x[a].isNull) e.push(x[a]), [-1, 1].forEach(function (e) {
                    var f = 1 === e ? "rightNull" : "leftNull",
                        k = 0,
                        m = u[g[d + e]];
                    if (m) for (var p = h; 0 <= p && p < w;) {
                      var r = B[p].index;
                      l = m.points[r];
                      l || (r === c.index ? x[a][f] = !0 : b[p] && (n = u[a].points[r]) && (k -= n[1] - n[0]));
                      p += t;
                    }
                    x[a][1 === e ? "rightCliff" : "leftCliff"] = k;
                  });else {
                    for (var p = h; 0 <= p && p < w;) {
                      if (l = u[a].points[B[p].index]) {
                        f = l[1];
                        break;
                      }

                      p += t;
                    }

                    f = m(f, 0);
                    f = k.translate(f, 0, 1, 0, 1);
                    e.push({
                      isNull: !0,
                      plotX: r.translate(a, 0, 0, 0, 1),
                      x: a,
                      plotY: f,
                      yBottom: f
                    });
                  }
                });
              }

              return e;
            };

            c.defaultOptions = u(J.defaultOptions, {
              threshold: 0
            });
            return c;
          }(J);

          a(E.prototype, {
            singleStacks: !1,
            drawLegendSymbol: w.drawRectangle
          });
          C.registerSeriesType("area", E);
          "";
          return E;
        });
        M(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w) {
          var r = this && this.__extends || function () {
            var _a13 = function a(r, n) {
              _a13 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, g) {
                a.__proto__ = g;
              } || function (a, g) {
                for (var c in g) {
                  g.hasOwnProperty(c) && (a[c] = g[c]);
                }
              };

              return _a13(r, n);
            };

            return function (r, n) {
              function m() {
                this.constructor = r;
              }

              _a13(r, n);

              r.prototype = null === n ? Object.create(n) : (m.prototype = n.prototype, new m());
            };
          }(),
              E = a.seriesTypes.line,
              z = w.merge,
              x = w.pick;

          w = function (a) {
            function u() {
              var n = null !== a && a.apply(this, arguments) || this;
              n.data = void 0;
              n.options = void 0;
              n.points = void 0;
              return n;
            }

            r(u, a);

            u.prototype.getPointSpline = function (a, m, g) {
              var c = m.plotX || 0,
                  e = m.plotY || 0,
                  l = a[g - 1];
              g = a[g + 1];

              if (l && !l.isNull && !1 !== l.doCurve && !m.isCliff && g && !g.isNull && !1 !== g.doCurve && !m.isCliff) {
                a = l.plotY || 0;
                var f = g.plotX || 0;
                g = g.plotY || 0;
                var n = 0;
                var r = (1.5 * c + (l.plotX || 0)) / 2.5;
                var k = (1.5 * e + a) / 2.5;
                f = (1.5 * c + f) / 2.5;
                var u = (1.5 * e + g) / 2.5;
                f !== r && (n = (u - k) * (f - c) / (f - r) + e - u);
                k += n;
                u += n;
                k > a && k > e ? (k = Math.max(a, e), u = 2 * e - k) : k < a && k < e && (k = Math.min(a, e), u = 2 * e - k);
                u > g && u > e ? (u = Math.max(g, e), k = 2 * e - u) : u < g && u < e && (u = Math.min(g, e), k = 2 * e - u);
                m.rightContX = f;
                m.rightContY = u;
              }

              m = ["C", x(l.rightContX, l.plotX, 0), x(l.rightContY, l.plotY, 0), x(r, c, 0), x(k, e, 0), c, e];
              l.rightContX = l.rightContY = void 0;
              return m;
            };

            u.defaultOptions = z(E.defaultOptions);
            return u;
          }(E);

          a.registerSeriesType("spline", w);
          "";
          return w;
        });
        M(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Area/AreaSeries.js"], a["Series/Spline/SplineSeries.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E, z) {
          var r = this && this.__extends || function () {
            var _a14 = function a(g, c) {
              _a14 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (a[e] = c[e]);
                }
              };

              return _a14(g, c);
            };

            return function (g, c) {
              function e() {
                this.constructor = g;
              }

              _a14(g, c);

              g.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());
            };
          }(),
              J = a.prototype,
              u = z.extend,
              n = z.merge;

          z = function (m) {
            function g() {
              var a = null !== m && m.apply(this, arguments) || this;
              a.data = void 0;
              a.points = void 0;
              a.options = void 0;
              return a;
            }

            r(g, m);
            g.defaultOptions = n(w.defaultOptions, a.defaultOptions);
            return g;
          }(w);

          u(z.prototype, {
            getGraphPath: J.getGraphPath,
            getStackPoints: J.getStackPoints,
            drawGraph: J.drawGraph,
            drawLegendSymbol: C.drawRectangle
          });
          E.registerSeriesType("areaspline", z);
          "";
          return z;
        });
        M(a, "Series/Column/ColumnSeries.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Color/Palette.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x, J, u) {
          var n = this && this.__extends || function () {
            var _a15 = function a(c, d) {
              _a15 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _a15(c, d);
            };

            return function (c, d) {
              function b() {
                this.constructor = c;
              }

              _a15(c, d);

              c.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              m = a.animObject,
              g = w.parse,
              c = C.hasTouch;

          a = C.noop;
          var e = u.clamp,
              l = u.css,
              f = u.defined,
              r = u.extend,
              q = u.fireEvent,
              k = u.isArray,
              I = u.isNumber,
              D = u.merge,
              B = u.pick,
              O = u.objectEach;

          u = function (a) {
            function h() {
              var d = null !== a && a.apply(this, arguments) || this;
              d.borderWidth = void 0;
              d.data = void 0;
              d.group = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            n(h, a);

            h.prototype.animate = function (a) {
              var b = this,
                  d = this.yAxis,
                  c = b.options,
                  h = this.chart.inverted,
                  f = {},
                  g = h ? "translateX" : "translateY";
              if (a) f.scaleY = .001, a = e(d.toPixels(c.threshold), d.pos, d.pos + d.len), h ? f.translateX = a - d.len : f.translateY = a, b.clipBox && b.setClip(), b.group.attr(f);else {
                var k = Number(b.group.attr(g));
                b.group.animate({
                  scaleY: 1
                }, r(m(b.options.animation), {
                  step: function step(a, c) {
                    b.group && (f[g] = k + c.pos * (d.pos - k), b.group.attr(f));
                  }
                }));
              }
            };

            h.prototype.init = function (d, b) {
              a.prototype.init.apply(this, arguments);
              var c = this;
              d = c.chart;
              d.hasRendered && d.series.forEach(function (a) {
                a.type === c.type && (a.isDirty = !0);
              });
            };

            h.prototype.getColumnMetrics = function () {
              var a = this,
                  b = a.options,
                  c = a.xAxis,
                  e = a.yAxis,
                  h = c.options.reversedStacks;
              h = c.reversed && !h || !c.reversed && h;
              var f = {},
                  g,
                  k = 0;
              !1 === b.grouping ? k = 1 : a.chart.series.forEach(function (b) {
                var d = b.yAxis,
                    c = b.options;

                if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && e.len === d.len && e.pos === d.pos) {
                  if (c.stacking && "group" !== c.stacking) {
                    g = b.stackKey;
                    "undefined" === typeof f[g] && (f[g] = k++);
                    var h = f[g];
                  } else !1 !== c.grouping && (h = k++);

                  b.columnIndex = h;
                }
              });
              var l = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
                  m = l * b.groupPadding,
                  n = (l - 2 * m) / (k || 1);
              b = Math.min(b.maxPointWidth || c.len, B(b.pointWidth, n * (1 - 2 * b.pointPadding)));
              a.columnMetrics = {
                width: b,
                offset: (n - b) / 2 + (m + ((a.columnIndex || 0) + (h ? 1 : 0)) * n - l / 2) * (h ? -1 : 1),
                paddedWidth: n,
                columnCount: k
              };
              return a.columnMetrics;
            };

            h.prototype.crispCol = function (a, b, c, e) {
              var d = this.chart,
                  h = this.borderWidth,
                  f = -(h % 2 ? .5 : 0);
              h = h % 2 ? .5 : 1;
              d.inverted && d.renderer.isVML && (h += 1);
              this.options.crisp && (c = Math.round(a + c) + f, a = Math.round(a) + f, c -= a);
              e = Math.round(b + e) + h;
              f = .5 >= Math.abs(b) && .5 < e;
              b = Math.round(b) + h;
              e -= b;
              f && e && (--b, e += 1);
              return {
                x: a,
                y: b,
                width: c,
                height: e
              };
            };

            h.prototype.adjustForMissingColumns = function (a, b, c, e) {
              var d = this,
                  h = this.options.stacking;

              if (!c.isNull && 1 < e.columnCount) {
                var f = 0,
                    g = 0;
                O(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {
                  if ("number" === typeof c.x && (a = a[c.x.toString()])) {
                    var b = a.points[d.index],
                        e = a.total;
                    h ? (b && (f = g), a.hasValidPoints && g++) : k(b) && (f = b[1], g = e || 0);
                  }
                });
                a = (c.plotX || 0) + ((g - 1) * e.paddedWidth + b) / 2 - b - f * e.paddedWidth;
              }

              return a;
            };

            h.prototype.translate = function () {
              var a = this,
                  b = a.chart,
                  c = a.options,
                  h = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
              h = a.borderWidth = B(c.borderWidth, h ? 0 : 1);
              var g = a.xAxis,
                  k = a.yAxis,
                  l = c.threshold,
                  m = a.translatedThreshold = k.getThreshold(l),
                  n = B(c.minPointLength, 5),
                  r = a.getColumnMetrics(),
                  t = r.width,
                  q = a.pointXOffset = r.offset,
                  v = a.dataMin,
                  u = a.dataMax,
                  w = a.barW = Math.max(t, 1 + 2 * h);
              b.inverted && (m -= .5);
              c.pointPadding && (w = Math.ceil(w));
              x.prototype.translate.apply(a);
              a.points.forEach(function (d) {
                var h = B(d.yBottom, m),
                    p = 999 + Math.abs(h),
                    y = d.plotX || 0;
                p = e(d.plotY, -p, k.len + p);
                var x = Math.min(p, h),
                    F = Math.max(p, h) - x,
                    D = t,
                    G = y + q,
                    z = w;
                n && Math.abs(F) < n && (F = n, y = !k.reversed && !d.negative || k.reversed && d.negative, I(l) && I(u) && d.y === l && u <= l && (k.min || 0) < l && (v !== u || (k.max || 0) <= l) && (y = !y), x = Math.abs(x - m) > n ? h - n : m - (y ? n : 0));
                f(d.options.pointWidth) && (D = z = Math.ceil(d.options.pointWidth), G -= Math.round((D - t) / 2));
                c.centerInCategory && (G = a.adjustForMissingColumns(G, D, d, r));
                d.barX = G;
                d.pointWidth = D;
                d.tooltipPos = b.inverted ? [e(k.len + k.pos - b.plotLeft - p, k.pos - b.plotLeft, k.len + k.pos - b.plotLeft), g.len + g.pos - b.plotTop - G - z / 2, F] : [g.left - b.plotLeft + G + z / 2, e(p + k.pos - b.plotTop, k.pos - b.plotTop, k.len + k.pos - b.plotTop), F];
                d.shapeType = a.pointClass.prototype.shapeType || "rect";
                d.shapeArgs = a.crispCol.apply(a, d.isNull ? [G, m, z, 0] : [G, x, z, F]);
              });
            };

            h.prototype.drawGraph = function () {
              this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };

            h.prototype.pointAttribs = function (a, b) {
              var d = this.options,
                  c = this.pointAttrToOptions || {},
                  e = c.stroke || "borderColor",
                  h = c["stroke-width"] || "borderWidth",
                  f = a && a.color || this.color,
                  k = a && a[e] || d[e] || f;
              c = a && a.options.dashStyle || d.dashStyle;
              var l = a && a[h] || d[h] || this[h] || 0,
                  m = B(a && a.opacity, d.opacity, 1);

              if (a && this.zones.length) {
                var n = a.getZone();
                f = a.options.color || n && (n.color || a.nonZonedColor) || this.color;
                n && (k = n.borderColor || k, c = n.dashStyle || c, l = n.borderWidth || l);
              }

              b && a && (a = D(d.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, f = a.color || "undefined" !== typeof b && g(f).brighten(a.brightness).get() || f, k = a[e] || k, l = a[h] || l, c = a.dashStyle || c, m = B(a.opacity, m));
              e = {
                fill: f,
                stroke: k,
                "stroke-width": l,
                opacity: m
              };
              c && (e.dashstyle = c);
              return e;
            };

            h.prototype.drawPoints = function () {
              var a = this,
                  b = this.chart,
                  c = a.options,
                  e = b.renderer,
                  h = c.animationLimit || 250,
                  f;
              a.points.forEach(function (d) {
                var g = d.graphic,
                    k = !!g,
                    l = g && b.pointCount < h ? "animate" : "attr";

                if (I(d.plotY) && null !== d.y) {
                  f = d.shapeArgs;
                  g && d.hasNewShapeType() && (g = g.destroy());
                  a.enabledDataSorting && (d.startXPos = a.xAxis.reversed ? -(f ? f.width || 0 : 0) : a.xAxis.width);
                  g || (d.graphic = g = e[d.shapeType](f).add(d.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < h && (g.attr({
                    x: d.startXPos
                  }), k = !0, l = "animate");
                  if (g && k) g[l](D(f));
                  if (c.borderRadius) g[l]({
                    r: c.borderRadius
                  });
                  b.styledMode || g[l](a.pointAttribs(d, d.selected && "select")).shadow(!1 !== d.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);
                  g && (g.addClass(d.getClassName(), !0), g.attr({
                    visibility: d.visible ? "inherit" : "hidden"
                  }));
                } else g && (d.graphic = g.destroy());
              });
            };

            h.prototype.drawTracker = function () {
              var a = this,
                  b = a.chart,
                  e = b.pointer,
                  h = function h(a) {
                var b = e.getPointFromEvent(a);
                "undefined" !== typeof b && (e.isDirectTouch = !0, b.onMouseOver(a));
              },
                  f;

              a.points.forEach(function (a) {
                f = k(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
                a.graphic && (a.graphic.element.point = a);
                f.forEach(function (b) {
                  b.div ? b.div.point = a : b.element.point = a;
                });
              });
              a._hasTracking || (a.trackerGroups.forEach(function (d) {
                if (a[d]) {
                  a[d].addClass("highcharts-tracker").on("mouseover", h).on("mouseout", function (a) {
                    e.onTrackerMouseOut(a);
                  });
                  if (c) a[d].on("touchstart", h);
                  !b.styledMode && a.options.cursor && a[d].css(l).css({
                    cursor: a.options.cursor
                  });
                }
              }), a._hasTracking = !0);
              q(this, "afterDrawTracker");
            };

            h.prototype.remove = function () {
              var a = this,
                  b = a.chart;
              b.hasRendered && b.series.forEach(function (b) {
                b.type === a.type && (b.isDirty = !0);
              });
              x.prototype.remove.apply(a, arguments);
            };

            h.defaultOptions = D(x.defaultOptions, {
              borderRadius: 0,
              centerInCategory: !1,
              groupPadding: .2,
              marker: null,
              pointPadding: .1,
              minPointLength: 0,
              cropThreshold: 50,
              pointRange: null,
              states: {
                hover: {
                  halo: !1,
                  brightness: .1
                },
                select: {
                  color: z.neutralColor20,
                  borderColor: z.neutralColor100
                }
              },
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
              },
              startFromThreshold: !0,
              stickyTracking: !1,
              tooltip: {
                distance: 6
              },
              threshold: 0,
              borderColor: z.backgroundColor
            });
            return h;
          }(x);

          r(u.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: E.drawRectangle,
            getSymbol: a,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          J.registerSeriesType("column", u);
          "";
          "";
          return u;
        });
        M(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Color/Palette.js"], a["Core/Utilities.js"]], function (a, w, C, E) {
          var r = a.getDeferredAnimation,
              x = w.format,
              J = E.defined,
              u = E.extend,
              n = E.fireEvent,
              m = E.isArray,
              g = E.merge,
              c = E.objectEach,
              e = E.pick,
              l = E.splat,
              f;

          (function (a) {
            function f(a, c, b, f, g) {
              var d = this,
                  h = this.chart,
                  k = this.isCartesian && h.inverted,
                  l = this.enabledDataSorting,
                  m = e(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
                  n = e(a.plotY, -9999),
                  p = c.getBBox(),
                  r = b.rotation,
                  t = b.align,
                  q = h.isInsidePlot(m, Math.round(n), {
                inverted: k,
                paneCoordinates: !0,
                series: d
              }),
                  v = function v(b) {
                l && d.xAxis && !B && d.setDataLabelStartPos(a, c, g, q, b);
              },
                  B = "justify" === e(b.overflow, l ? "none" : "justify"),
                  x = this.visible && !1 !== a.visible && (a.series.forceDL || l && !B || q || e(b.inside, !!this.options.stacking) && f && h.isInsidePlot(m, k ? f.x + 1 : f.y + f.height - 1, {
                inverted: k,
                paneCoordinates: !0,
                series: d
              }));

              if (x) {
                var w = h.renderer.fontMetrics(h.styledMode ? void 0 : b.style.fontSize, c).b;
                f = u({
                  x: k ? this.yAxis.len - n : m,
                  y: Math.round(k ? this.xAxis.len - m : n),
                  width: 0,
                  height: 0
                }, f);
                u(b, {
                  width: p.width,
                  height: p.height
                });
                r ? (B = !1, m = h.renderer.rotCorr(w, r), m = {
                  x: f.x + (b.x || 0) + f.width / 2 + m.x,
                  y: f.y + (b.y || 0) + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                  }[b.verticalAlign] * f.height
                }, v(m), c[g ? "attr" : "animate"](m).attr({
                  align: t
                }), v = (r + 720) % 360, v = 180 < v && 360 > v, "left" === t ? m.y -= v ? p.height : 0 : "center" === t ? (m.x -= p.width / 2, m.y -= p.height / 2) : "right" === t && (m.x -= p.width, m.y -= v ? 0 : p.height), c.placed = !0, c.alignAttr = m) : (v(f), c.align(b, void 0, f), m = c.alignAttr);
                B && 0 <= f.height ? this.justifyDataLabel(c, b, m, p, f, g) : e(b.crop, !0) && (x = h.isInsidePlot(m.x, m.y, {
                  paneCoordinates: !0,
                  series: d
                }) && h.isInsidePlot(m.x + p.width, m.y + p.height, {
                  paneCoordinates: !0,
                  series: d
                }));
                if (b.shape && !r) c[g ? "attr" : "animate"]({
                  anchorX: k ? h.plotWidth - a.plotY : a.plotX,
                  anchorY: k ? h.plotHeight - a.plotX : a.plotY
                });
              }

              g && l && (c.placed = !1);
              x || l && !B || (c.hide(!0), c.placed = !1);
            }

            function k(a, c) {
              var b = c.filter;
              return b ? (c = b.operator, a = a[b.property], b = b.value, ">" === c && a > b || "<" === c && a < b || ">=" === c && a >= b || "<=" === c && a <= b || "==" === c && a == b || "===" === c && a === b ? !0 : !1) : !0;
            }

            function v() {
              var a = this,
                  d = a.chart,
                  b = a.options,
                  f = a.points,
                  g = a.hasRendered || 0,
                  t = d.renderer,
                  q = b.dataLabels,
                  v,
                  u = q.animation;
              u = q.defer ? r(d, u, a) : {
                defer: 0,
                duration: 0
              };
              q = B(B(d.options.plotOptions && d.options.plotOptions.series && d.options.plotOptions.series.dataLabels, d.options.plotOptions && d.options.plotOptions[a.type] && d.options.plotOptions[a.type].dataLabels), q);
              n(this, "drawDataLabels");

              if (m(q) || q.enabled || a._hasPointLabels) {
                var w = a.plotGroup("dataLabelsGroup", "data-labels", g ? "inherit" : "hidden", q.zIndex || 6);
                w.attr({
                  opacity: +g
                });
                !g && (g = a.dataLabelsGroup) && (a.visible && w.show(!0), g[b.animation ? "animate" : "attr"]({
                  opacity: 1
                }, u));
                f.forEach(function (f) {
                  v = l(B(q, f.dlOptions || f.options && f.options.dataLabels));
                  v.forEach(function (h, g) {
                    var l = h.enabled && (!f.isNull || f.dataLabelOnNull) && k(f, h),
                        m = f.connectors ? f.connectors[g] : f.connector,
                        n = f.dataLabels ? f.dataLabels[g] : f.dataLabel,
                        p = e(h.distance, f.labelDistance),
                        r = !n;

                    if (l) {
                      var q = f.getLabelConfig();
                      var v = e(h[f.formatPrefix + "Format"], h.format);
                      q = J(v) ? x(v, q, d) : (h[f.formatPrefix + "Formatter"] || h.formatter).call(q, h);
                      v = h.style;
                      var u = h.rotation;
                      d.styledMode || (v.color = e(h.color, v.color, a.color, C.neutralColor100), "contrast" === v.color ? (f.contrastColor = t.getContrast(f.color || a.color), v.color = !J(p) && h.inside || 0 > p || b.stacking ? f.contrastColor : C.neutralColor100) : delete f.contrastColor, b.cursor && (v.cursor = b.cursor));
                      var B = {
                        r: h.borderRadius || 0,
                        rotation: u,
                        padding: h.padding,
                        zIndex: 1
                      };
                      d.styledMode || (B.fill = h.backgroundColor, B.stroke = h.borderColor, B["stroke-width"] = h.borderWidth);
                      c(B, function (a, b) {
                        "undefined" === typeof a && delete B[b];
                      });
                    }

                    !n || l && J(q) ? l && J(q) && (n ? B.text = q : (f.dataLabels = f.dataLabels || [], n = f.dataLabels[g] = u ? t.text(q, 0, -9999, h.useHTML).addClass("highcharts-data-label") : t.label(q, 0, -9999, h.shape, null, null, h.useHTML, null, "data-label"), g || (f.dataLabel = n), n.addClass(" highcharts-data-label-color-" + f.colorIndex + " " + (h.className || "") + (h.useHTML ? " highcharts-tracker" : ""))), n.options = h, n.attr(B), d.styledMode || n.css(v).shadow(h.shadow), n.added || n.add(w), h.textPath && !h.useHTML && (n.setTextPath(f.getDataLabelPath && f.getDataLabelPath(n) || f.graphic, h.textPath), f.dataLabelPath && !h.textPath.enabled && (f.dataLabelPath = f.dataLabelPath.destroy())), a.alignDataLabel(f, n, h, null, r)) : (f.dataLabel = f.dataLabel && f.dataLabel.destroy(), f.dataLabels && (1 === f.dataLabels.length ? delete f.dataLabels : delete f.dataLabels[g]), g || delete f.dataLabel, m && (f.connector = f.connector.destroy(), f.connectors && (1 === f.connectors.length ? delete f.connectors : delete f.connectors[g])));
                  });
                });
              }

              n(this, "afterDrawDataLabels");
            }

            function w(a, c, b, e, f, g) {
              var d = this.chart,
                  h = c.align,
                  k = c.verticalAlign,
                  l = a.box ? 0 : a.padding || 0,
                  m = c.x;
              m = void 0 === m ? 0 : m;
              var n = c.y;
              n = void 0 === n ? 0 : n;
              var p = (b.x || 0) + l;

              if (0 > p) {
                "right" === h && 0 <= m ? (c.align = "left", c.inside = !0) : m -= p;
                var r = !0;
              }

              p = (b.x || 0) + e.width - l;
              p > d.plotWidth && ("left" === h && 0 >= m ? (c.align = "right", c.inside = !0) : m += d.plotWidth - p, r = !0);
              p = b.y + l;
              0 > p && ("bottom" === k && 0 <= n ? (c.verticalAlign = "top", c.inside = !0) : n -= p, r = !0);
              p = (b.y || 0) + e.height - l;
              p > d.plotHeight && ("top" === k && 0 >= n ? (c.verticalAlign = "bottom", c.inside = !0) : n += d.plotHeight - p, r = !0);
              r && (c.x = m, c.y = n, a.placed = !g, a.align(c, void 0, f));
              return r;
            }

            function B(a, c) {
              var b = [],
                  d;
              if (m(a) && !m(c)) b = a.map(function (a) {
                return g(a, c);
              });else if (m(c) && !m(a)) b = c.map(function (b) {
                return g(a, b);
              });else if (m(a) || m(c)) for (d = Math.max(a.length, c.length); d--;) {
                b[d] = g(a[d], c[d]);
              } else b = g(a, c);
              return b;
            }

            function z(a, c, b, e, f) {
              var d = this.chart,
                  h = d.inverted,
                  g = this.xAxis,
                  k = g.reversed,
                  l = h ? c.height / 2 : c.width / 2;
              a = (a = a.pointWidth) ? a / 2 : 0;
              c.startXPos = h ? f.x : k ? -l - a : g.width - l + a;
              c.startYPos = h ? k ? this.yAxis.height - l + a : -l - a : f.y;
              e ? "hidden" === c.visibility && (c.show(), c.attr({
                opacity: 0
              }).animate({
                opacity: 1
              })) : c.attr({
                opacity: 1
              }).animate({
                opacity: 0
              }, void 0, c.hide);
              d.hasRendered && (b && c.attr({
                x: c.startXPos,
                y: c.startYPos
              }), c.placed = !0);
            }

            var t = [];

            a.compose = function (a) {
              if (-1 === t.indexOf(a)) {
                var c = a.prototype;
                t.push(a);
                c.alignDataLabel = f;
                c.drawDataLabels = v;
                c.justifyDataLabel = w;
                c.setDataLabelStartPos = z;
              }
            };
          })(f || (f = {}));

          "";
          return f;
        });
        M(a, "Series/Column/ColumnDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = w.series,
              z = C.merge,
              x = C.pick,
              J;

          (function (u) {
            function n(a, c, e, l, f) {
              var g = this.chart.inverted,
                  m = a.series,
                  k = a.dlBox || a.shapeArgs,
                  n = x(a.below, a.plotY > x(this.translatedThreshold, m.yAxis.len)),
                  u = x(e.inside, !!this.options.stacking);
              k && (l = z(k), 0 > l.y && (l.height += l.y, l.y = 0), k = l.y + l.height - m.yAxis.len, 0 < k && k < l.height && (l.height -= k), g && (l = {
                x: m.yAxis.len - l.y - l.height,
                y: m.xAxis.len - l.x - l.width,
                width: l.height,
                height: l.width
              }), u || (g ? (l.x += n ? 0 : l.width, l.width = 0) : (l.y += n ? l.height : 0, l.height = 0)));
              e.align = x(e.align, !g || u ? "center" : n ? "right" : "left");
              e.verticalAlign = x(e.verticalAlign, g || u ? "middle" : n ? "top" : "bottom");
              r.prototype.alignDataLabel.call(this, a, c, e, l, f);
              e.inside && a.contrastColor && c.css({
                color: a.contrastColor
              });
            }

            var m = [];

            u.compose = function (g) {
              a.compose(r);
              -1 === m.indexOf(g) && (m.push(g), g.prototype.alignDataLabel = n);
            };
          })(J || (J = {}));

          return J;
        });
        M(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = this && this.__extends || function () {
            var _a16 = function a(r, n) {
              _a16 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, g) {
                a.__proto__ = g;
              } || function (a, g) {
                for (var c in g) {
                  g.hasOwnProperty(c) && (a[c] = g[c]);
                }
              };

              return _a16(r, n);
            };

            return function (r, n) {
              function m() {
                this.constructor = r;
              }

              _a16(r, n);

              r.prototype = null === n ? Object.create(n) : (m.prototype = n.prototype, new m());
            };
          }(),
              z = C.extend,
              x = C.merge;

          C = function (w) {
            function u() {
              var a = null !== w && w.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(u, w);
            u.defaultOptions = x(a.defaultOptions, {});
            return u;
          }(a);

          z(C.prototype, {
            inverted: !0
          });
          w.registerSeriesType("bar", C);
          "";
          return C;
        });
        M(a, "Series/Scatter/ScatterSeries.js", [a["Series/Column/ColumnSeries.js"], a["Series/Line/LineSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E) {
          var r = this && this.__extends || function () {
            var _a17 = function a(m, g) {
              _a17 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, e) {
                a.__proto__ = e;
              } || function (a, e) {
                for (var c in e) {
                  e.hasOwnProperty(c) && (a[c] = e[c]);
                }
              };

              return _a17(m, g);
            };

            return function (m, g) {
              function c() {
                this.constructor = m;
              }

              _a17(m, g);

              m.prototype = null === g ? Object.create(g) : (c.prototype = g.prototype, new c());
            };
          }(),
              x = E.addEvent,
              J = E.extend,
              u = E.merge;

          E = function (a) {
            function m() {
              var g = null !== a && a.apply(this, arguments) || this;
              g.data = void 0;
              g.options = void 0;
              g.points = void 0;
              return g;
            }

            r(m, a);

            m.prototype.applyJitter = function () {
              var a = this,
                  c = this.options.jitter,
                  e = this.points.length;
              c && this.points.forEach(function (g, f) {
                ["x", "y"].forEach(function (l, m) {
                  var k = "plot" + l.toUpperCase();

                  if (c[l] && !g.isNull) {
                    var n = a[l + "Axis"];
                    var r = c[l] * n.transA;

                    if (n && !n.isLog) {
                      var q = Math.max(0, g[k] - r);
                      n = Math.min(n.len, g[k] + r);
                      m = 1E4 * Math.sin(f + m * e);
                      g[k] = q + (n - q) * (m - Math.floor(m));
                      "x" === l && (g.clientX = g.plotX);
                    }
                  }
                });
              });
            };

            m.prototype.drawGraph = function () {
              this.options.lineWidth ? a.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };

            m.defaultOptions = u(w.defaultOptions, {
              lineWidth: 0,
              findNearestPointBy: "xy",
              jitter: {
                x: 0,
                y: 0
              },
              marker: {
                enabled: !0
              },
              tooltip: {
                headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
              }
            });
            return m;
          }(w);

          J(E.prototype, {
            drawTracker: a.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
          });
          x(E, "afterTranslate", function () {
            this.applyJitter();
          });
          C.registerSeriesType("scatter", E);
          "";
          return E;
        });
        M(a, "Mixins/CenteredSeries.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = C.isNumber,
              z = C.pick,
              x = C.relativeLength,
              J = a.deg2rad;
          return a.CenteredSeriesMixin = {
            getCenter: function getCenter() {
              var a = this.options,
                  n = this.chart,
                  m = 2 * (a.slicedOffset || 0),
                  g = n.plotWidth - 2 * m,
                  c = n.plotHeight - 2 * m,
                  e = a.center,
                  l = Math.min(g, c),
                  f = a.size,
                  r = a.innerSize || 0;
              "string" === typeof f && (f = parseFloat(f));
              "string" === typeof r && (r = parseFloat(r));
              a = [z(e[0], "50%"), z(e[1], "50%"), z(f && 0 > f ? void 0 : a.size, "100%"), z(r && 0 > r ? void 0 : a.innerSize || 0, "0%")];
              !n.angular || this instanceof w || (a[3] = 0);

              for (e = 0; 4 > e; ++e) {
                f = a[e], n = 2 > e || 2 === e && /%$/.test(f), a[e] = x(f, [g, c, l, a[2]][e]) + (n ? m : 0);
              }

              a[3] > a[2] && (a[3] = a[2]);
              return a;
            },
            getStartAndEndRadians: function getStartAndEndRadians(a, n) {
              a = r(a) ? a : 0;
              n = r(n) && n > a && 360 > n - a ? n : a + 360;
              return {
                start: J * (a + -90),
                end: J * (n + -90)
              };
            }
          };
        });
        M(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, w, C) {
          var r = this && this.__extends || function () {
            var _a18 = function a(c, e) {
              _a18 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (a[e] = c[e]);
                }
              };

              return _a18(c, e);
            };

            return function (c, e) {
              function g() {
                this.constructor = c;
              }

              _a18(c, e);

              c.prototype = null === e ? Object.create(e) : (g.prototype = e.prototype, new g());
            };
          }(),
              z = a.setAnimation,
              x = C.addEvent,
              J = C.defined;

          a = C.extend;
          var u = C.isNumber,
              n = C.pick,
              m = C.relativeLength;

          w = function (a) {
            function c() {
              var c = null !== a && a.apply(this, arguments) || this;
              c.labelDistance = void 0;
              c.options = void 0;
              c.series = void 0;
              return c;
            }

            r(c, a);

            c.prototype.getConnectorPath = function () {
              var a = this.labelPosition,
                  c = this.series.options.dataLabels,
                  f = this.connectorShapes,
                  g = c.connectorShape;
              f[g] && (g = f[g]);
              return g.call(this, {
                x: a["final"].x,
                y: a["final"].y,
                alignment: a.alignment
              }, a.connectorPosition, c);
            };

            c.prototype.getTranslate = function () {
              return this.sliced ? this.slicedTranslation : {
                translateX: 0,
                translateY: 0
              };
            };

            c.prototype.haloPath = function (a) {
              var c = this.shapeArgs;
              return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
                innerR: c.r - 1,
                start: c.start,
                end: c.end
              });
            };

            c.prototype.init = function () {
              var c = this;
              a.prototype.init.apply(this, arguments);
              this.name = n(this.name, "Slice");

              var g = function g(a) {
                c.slice("select" === a.type);
              };

              x(this, "select", g);
              x(this, "unselect", g);
              return this;
            };

            c.prototype.isValid = function () {
              return u(this.y) && 0 <= this.y;
            };

            c.prototype.setVisible = function (a, c) {
              var e = this,
                  g = this.series,
                  l = g.chart,
                  k = g.options.ignoreHiddenPoint;
              c = n(c, k);
              a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, g.options.data[g.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (c) {
                if (e[c]) e[c][a ? "show" : "hide"](a);
              }), this.legendItem && l.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), k && (g.isDirty = !0), c && l.redraw());
            };

            c.prototype.slice = function (a, c, f) {
              var e = this.series;
              z(f, e.chart);
              n(c, !0);
              this.sliced = this.options.sliced = J(a) ? a : !this.sliced;
              e.options.data[e.data.indexOf(this)] = this.options;
              this.graphic && this.graphic.animate(this.getTranslate());
              this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };

            return c;
          }(w);

          a(w.prototype, {
            connectorShapes: {
              fixedOffset: function fixedOffset(a, c, e) {
                var g = c.breakAt;
                c = c.touchingSliceAt;
                return [["M", a.x, a.y], e.softConnector ? ["C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * g.x - c.x, 2 * g.y - c.y, g.x, g.y] : ["L", g.x, g.y], ["L", c.x, c.y]];
              },
              straight: function straight(a, c) {
                c = c.touchingSliceAt;
                return [["M", a.x, a.y], ["L", c.x, c.y]];
              },
              crookedLine: function crookedLine(a, c, e) {
                c = c.touchingSliceAt;
                var g = this.series,
                    f = g.center[0],
                    n = g.chart.plotWidth,
                    r = g.chart.plotLeft;
                g = a.alignment;
                var k = this.shapeArgs.r;
                e = m(e.crookDistance, 1);
                n = "left" === g ? f + k + (n + r - f - k) * (1 - e) : r + (f - k) * e;
                e = ["L", n, a.y];
                f = !0;
                if ("left" === g ? n > a.x || n < c.x : n < a.x || n > c.x) f = !1;
                a = [["M", a.x, a.y]];
                f && a.push(e);
                a.push(["L", c.x, c.y]);
                return a;
              }
            }
          });
          return w;
        });
        M(a, "Series/Pie/PieSeries.js", [a["Mixins/CenteredSeries.js"], a["Series/Column/ColumnSeries.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Color/Palette.js"], a["Series/Pie/PiePoint.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x, J, u, n, m) {
          var g = this && this.__extends || function () {
            var _a19 = function a(c, e) {
              _a19 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, c) {
                a.__proto__ = c;
              } || function (a, c) {
                for (var e in c) {
                  c.hasOwnProperty(e) && (a[e] = c[e]);
                }
              };

              return _a19(c, e);
            };

            return function (c, e) {
              function f() {
                this.constructor = c;
              }

              _a19(c, e);

              c.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
            };
          }(),
              c = a.getStartAndEndRadians;

          C = C.noop;
          var e = m.clamp,
              l = m.extend,
              f = m.fireEvent,
              r = m.merge,
              q = m.pick,
              k = m.relativeLength;

          m = function (a) {
            function l() {
              var c = null !== a && a.apply(this, arguments) || this;
              c.center = void 0;
              c.data = void 0;
              c.maxLabelDistance = void 0;
              c.options = void 0;
              c.points = void 0;
              return c;
            }

            g(l, a);

            l.prototype.animate = function (a) {
              var c = this,
                  e = c.points,
                  f = c.startAngleRad;
              a || e.forEach(function (a) {
                var b = a.graphic,
                    d = a.shapeArgs;
                b && d && (b.attr({
                  r: q(a.startR, c.center && c.center[3] / 2),
                  start: f,
                  end: f
                }), b.animate({
                  r: d.r,
                  start: d.start,
                  end: d.end
                }, c.options.animation));
              });
            };

            l.prototype.drawEmpty = function () {
              var a = this.startAngleRad,
                  c = this.endAngleRad,
                  e = this.options;

              if (0 === this.total && this.center) {
                var f = this.center[0];
                var d = this.center[1];
                this.graph || (this.graph = this.chart.renderer.arc(f, d, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
                this.graph.attr({
                  d: n.arc(f, d, this.center[2] / 2, 0, {
                    start: a,
                    end: c,
                    innerR: this.center[3] / 2
                  })
                });
                this.chart.styledMode || this.graph.attr({
                  "stroke-width": e.borderWidth,
                  fill: e.fillColor || "none",
                  stroke: e.color || z.neutralColor20
                });
              } else this.graph && (this.graph = this.graph.destroy());
            };

            l.prototype.drawPoints = function () {
              var a = this.chart.renderer;
              this.points.forEach(function (c) {
                c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
                c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
              });
            };

            l.prototype.generatePoints = function () {
              a.prototype.generatePoints.call(this);
              this.updateTotals();
            };

            l.prototype.getX = function (a, c, f) {
              var h = this.center,
                  d = this.radii ? this.radii[f.index] || 0 : h[2] / 2;
              a = Math.asin(e((a - h[1]) / (d + f.labelDistance), -1, 1));
              return h[0] + (c ? -1 : 1) * Math.cos(a) * (d + f.labelDistance) + (0 < f.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
            };

            l.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            l.prototype.redrawPoints = function () {
              var a = this,
                  c = a.chart,
                  e = c.renderer,
                  f = a.options.shadow,
                  d,
                  b,
                  g,
                  k;
              this.drawEmpty();
              !f || a.shadowGroup || c.styledMode || (a.shadowGroup = e.g("shadow").attr({
                zIndex: -1
              }).add(a.group));
              a.points.forEach(function (h) {
                var l = {};
                b = h.graphic;

                if (!h.isNull && b) {
                  var m = void 0;
                  k = h.shapeArgs;
                  d = h.getTranslate();
                  c.styledMode || (m = h.shadowGroup, f && !m && (m = h.shadowGroup = e.g("shadow").add(a.shadowGroup)), m && m.attr(d), g = a.pointAttribs(h, h.selected && "select"));
                  h.delayedRendering ? (b.setRadialReference(a.center).attr(k).attr(d), c.styledMode || b.attr(g).attr({
                    "stroke-linejoin": "round"
                  }).shadow(f, m), h.delayedRendering = !1) : (b.setRadialReference(a.center), c.styledMode || r(!0, l, g), r(!0, l, k, d), b.animate(l));
                  b.attr({
                    visibility: h.visible ? "inherit" : "hidden"
                  });
                  b.addClass(h.getClassName(), !0);
                } else b && (h.graphic = b.destroy());
              });
            };

            l.prototype.sortByAngle = function (a, c) {
              a.sort(function (a, e) {
                return "undefined" !== typeof a.angle && (e.angle - a.angle) * c;
              });
            };

            l.prototype.translate = function (a) {
              this.generatePoints();
              var e = this.options,
                  g = e.slicedOffset,
                  h = g + (e.borderWidth || 0),
                  d = c(e.startAngle, e.endAngle),
                  b = this.startAngleRad = d.start;
              d = (this.endAngleRad = d.end) - b;
              var l = this.points,
                  m = e.dataLabels.distance;
              e = e.ignoreHiddenPoint;
              var n = l.length,
                  r,
                  v = 0;
              a || (this.center = a = this.getCenter());

              for (r = 0; r < n; r++) {
                var u = l[r];
                var x = b + v * d;
                !u.isValid() || e && !u.visible || (v += u.percentage / 100);
                var w = b + v * d;
                var B = {
                  x: a[0],
                  y: a[1],
                  r: a[2] / 2,
                  innerR: a[3] / 2,
                  start: Math.round(1E3 * x) / 1E3,
                  end: Math.round(1E3 * w) / 1E3
                };
                u.shapeType = "arc";
                u.shapeArgs = B;
                u.labelDistance = q(u.options.dataLabels && u.options.dataLabels.distance, m);
                u.labelDistance = k(u.labelDistance, B.r);
                this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, u.labelDistance);
                w = (w + x) / 2;
                w > 1.5 * Math.PI ? w -= 2 * Math.PI : w < -Math.PI / 2 && (w += 2 * Math.PI);
                u.slicedTranslation = {
                  translateX: Math.round(Math.cos(w) * g),
                  translateY: Math.round(Math.sin(w) * g)
                };
                B = Math.cos(w) * a[2] / 2;
                var z = Math.sin(w) * a[2] / 2;
                u.tooltipPos = [a[0] + .7 * B, a[1] + .7 * z];
                u.half = w < -Math.PI / 2 || w > Math.PI / 2 ? 1 : 0;
                u.angle = w;
                x = Math.min(h, u.labelDistance / 5);
                u.labelPosition = {
                  natural: {
                    x: a[0] + B + Math.cos(w) * u.labelDistance,
                    y: a[1] + z + Math.sin(w) * u.labelDistance
                  },
                  "final": {},
                  alignment: 0 > u.labelDistance ? "center" : u.half ? "right" : "left",
                  connectorPosition: {
                    breakAt: {
                      x: a[0] + B + Math.cos(w) * x,
                      y: a[1] + z + Math.sin(w) * x
                    },
                    touchingSliceAt: {
                      x: a[0] + B,
                      y: a[1] + z
                    }
                  }
                };
              }

              f(this, "afterTranslate");
            };

            l.prototype.updateTotals = function () {
              var a = this.points,
                  c = a.length,
                  e = this.options.ignoreHiddenPoint,
                  f,
                  d = 0;

              for (f = 0; f < c; f++) {
                var b = a[f];
                !b.isValid() || e && !b.visible || (d += b.y);
              }

              this.total = d;

              for (f = 0; f < c; f++) {
                b = a[f], b.percentage = 0 < d && (b.visible || !e) ? b.y / d * 100 : 0, b.total = d;
              }
            };

            l.defaultOptions = r(J.defaultOptions, {
              center: [null, null],
              clip: !1,
              colorByPoint: !0,
              dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0
              },
              fillColor: void 0,
              ignoreHiddenPoint: !0,
              inactiveOtherPoints: !0,
              legendType: "point",
              marker: null,
              size: null,
              showInLegend: !1,
              slicedOffset: 10,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0
              },
              borderColor: z.backgroundColor,
              borderWidth: 1,
              lineWidth: void 0,
              states: {
                hover: {
                  brightness: .1
                }
              }
            });
            return l;
          }(J);

          l(m.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: E.drawRectangle,
            drawTracker: w.prototype.drawTracker,
            getCenter: a.getCenter,
            getSymbol: C,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: w.prototype.pointAttribs,
            pointClass: x,
            requireSorting: !1,
            searchPoint: C,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          u.registerSeriesType("pie", m);
          "";
          return m;
        });
        M(a, "Series/Pie/PieDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, w, C, E, z, x) {
          var r = w.noop,
              u = E.distribute,
              n = z.series,
              m = x.arrayMax,
              g = x.clamp,
              c = x.defined,
              e = x.merge,
              l = x.pick,
              f = x.relativeLength,
              v;

          (function (q) {
            function k() {
              var a = this,
                  f = a.data,
                  d = a.chart,
                  b = a.options.dataLabels || {},
                  g = b.connectorPadding,
                  k = d.plotWidth,
                  r = d.plotHeight,
                  q = d.plotLeft,
                  v = Math.round(d.chartWidth / 3),
                  w = a.center,
                  x = w[2] / 2,
                  B = w[1],
                  z = [[], []],
                  D = [0, 0, 0, 0],
                  E = a.dataLabelPositioners,
                  I,
                  J,
                  M,
                  O,
                  Z,
                  A,
                  U,
                  N,
                  W,
                  X,
                  Y,
                  T;
              a.visible && (b.enabled || a._hasPointLabels) && (f.forEach(function (a) {
                a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
                  width: "auto"
                }).css({
                  width: "auto",
                  textOverflow: "clip"
                }), a.dataLabel.shortened = !1);
              }), n.prototype.drawDataLabels.apply(a), f.forEach(function (a) {
                a.dataLabel && (a.visible ? (z[a.half].push(a), a.dataLabel._pos = null, !c(b.style.width) && !c(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > v && (a.dataLabel.css({
                  width: Math.round(.7 * v) + "px"
                }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
              }), z.forEach(function (e, f) {
                var h = e.length,
                    m = [],
                    n;

                if (h) {
                  a.sortByAngle(e, f - .5);

                  if (0 < a.maxLabelDistance) {
                    var p = Math.max(0, B - x - a.maxLabelDistance);
                    var t = Math.min(B + x + a.maxLabelDistance, d.plotHeight);
                    e.forEach(function (a) {
                      0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, B - x - a.labelDistance), a.bottom = Math.min(B + x + a.labelDistance, d.plotHeight), n = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                        target: a.labelPosition.natural.y - a.top + n / 2,
                        size: n,
                        rank: a.y
                      }, m.push(a.distributeBox));
                    });
                    p = t + n - p;
                    u(m, p, p / 5);
                  }

                  for (Y = 0; Y < h; Y++) {
                    I = e[Y];
                    A = I.labelPosition;
                    O = I.dataLabel;
                    X = !1 === I.visible ? "hidden" : "inherit";
                    W = p = A.natural.y;
                    m && c(I.distributeBox) && ("undefined" === typeof I.distributeBox.pos ? X = "hidden" : (U = I.distributeBox.size, W = E.radialDistributionY(I)));
                    delete I.positionIndex;
                    if (b.justify) N = E.justify(I, x, w);else switch (b.alignTo) {
                      case "connectors":
                        N = E.alignToConnectors(e, f, k, q);
                        break;

                      case "plotEdges":
                        N = E.alignToPlotEdges(O, f, k, q);
                        break;

                      default:
                        N = E.radialDistributionX(a, I, W, p);
                    }
                    O._attr = {
                      visibility: X,
                      align: A.alignment
                    };
                    T = I.options.dataLabels || {};
                    O._pos = {
                      x: N + l(T.x, b.x) + ({
                        left: g,
                        right: -g
                      }[A.alignment] || 0),
                      y: W + l(T.y, b.y) - 10
                    };
                    A["final"].x = N;
                    A["final"].y = W;
                    l(b.crop, !0) && (Z = O.getBBox().width, p = null, N - Z < g && 1 === f ? (p = Math.round(Z - N + g), D[3] = Math.max(p, D[3])) : N + Z > k - g && 0 === f && (p = Math.round(N + Z - k + g), D[1] = Math.max(p, D[1])), 0 > W - U / 2 ? D[0] = Math.max(Math.round(-W + U / 2), D[0]) : W + U / 2 > r && (D[2] = Math.max(Math.round(W + U / 2 - r), D[2])), O.sideOverflow = p);
                  }
                }
              }), 0 === m(D) || this.verifyDataLabelOverflow(D)) && (this.placeDataLabels(), this.points.forEach(function (c) {
                T = e(b, c.options.dataLabels);

                if (J = l(T.connectorWidth, 1)) {
                  var f;
                  M = c.connector;

                  if ((O = c.dataLabel) && O._pos && c.visible && 0 < c.labelDistance) {
                    X = O._attr.visibility;
                    if (f = !M) c.connector = M = d.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + c.colorIndex + (c.className ? " " + c.className : "")).add(a.dataLabelsGroup), d.styledMode || M.attr({
                      "stroke-width": J,
                      stroke: T.connectorColor || c.color || C.neutralColor60
                    });
                    M[f ? "attr" : "animate"]({
                      d: c.getConnectorPath()
                    });
                    M.attr("visibility", X);
                  } else M && (c.connector = M.destroy());
                }
              }));
            }

            function v() {
              this.points.forEach(function (a) {
                var c = a.dataLabel,
                    d;
                c && a.visible && ((d = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
                  width: c._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](d), c.moved = !0) : c && c.attr({
                  y: -9999
                }));
                delete a.distributeBox;
              }, this);
            }

            function w(a) {
              var c = this.center,
                  d = this.options,
                  b = d.center,
                  e = d.minSize || 80,
                  k = null !== d.size;

              if (!k) {
                if (null !== b[0]) var l = Math.max(c[2] - Math.max(a[1], a[3]), e);else l = Math.max(c[2] - a[1] - a[3], e), c[0] += (a[3] - a[1]) / 2;
                null !== b[1] ? l = g(l, e, c[2] - Math.max(a[0], a[2])) : (l = g(l, e, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
                l < c[2] ? (c[2] = l, c[3] = Math.min(f(d.innerSize || 0, l), l), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : k = !0;
              }

              return k;
            }

            var x = [],
                z = {
              radialDistributionY: function radialDistributionY(a) {
                return a.top + a.distributeBox.pos;
              },
              radialDistributionX: function radialDistributionX(a, c, d, b) {
                return a.getX(d < c.top + 2 || d > c.bottom - 2 ? b : d, c.half, c);
              },
              justify: function justify(a, c, d) {
                return d[0] + (a.half ? -1 : 1) * (c + a.labelDistance);
              },
              alignToPlotEdges: function alignToPlotEdges(a, c, d, b) {
                a = a.getBBox().width;
                return c ? a + b : d - a - b;
              },
              alignToConnectors: function alignToConnectors(a, c, d, b) {
                var e = 0,
                    f;
                a.forEach(function (a) {
                  f = a.dataLabel.getBBox().width;
                  f > e && (e = f);
                });
                return c ? e + b : d - e - b;
              }
            };

            q.compose = function (c) {
              a.compose(n);
              -1 === x.indexOf(c) && (x.push(c), c = c.prototype, c.dataLabelPositioners = z, c.alignDataLabel = r, c.drawDataLabels = k, c.placeDataLabels = v, c.verifyDataLabelOverflow = w);
            };
          })(v || (v = {}));

          return v;
        });
        M(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function (a, w) {
          function r(a, g) {
            var c = !1;

            if (a) {
              var e = a.newOpacity;
              a.oldOpacity !== e && (a.alignAttr && a.placed ? (a[e ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), c = !0, a.alignAttr.opacity = e, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, function () {
                g.styledMode || a.css({
                  pointerEvents: e ? "auto" : "none"
                });
              }), z(g, "afterHideOverlappingLabel")) : a.attr({
                opacity: e
              }));
              a.isOld = !0;
            }

            return c;
          }

          var E = w.addEvent,
              z = w.fireEvent,
              x = w.isArray,
              J = w.isNumber,
              u = w.objectEach,
              n = w.pick;
          E(a, "render", function () {
            var a = this,
                g = [];
            (this.labelCollectors || []).forEach(function (a) {
              g = g.concat(a());
            });
            (this.yAxis || []).forEach(function (a) {
              a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && u(a.stacking.stacks, function (a) {
                u(a, function (a) {
                  a.label && "hidden" !== a.label.visibility && g.push(a.label);
                });
              });
            });
            (this.series || []).forEach(function (c) {
              var e = c.options.dataLabels;
              c.visible && (!1 !== e.enabled || c._hasPointLabels) && (e = function e(c) {
                return c.forEach(function (c) {
                  c.visible && (x(c.dataLabels) ? c.dataLabels : c.dataLabel ? [c.dataLabel] : []).forEach(function (e) {
                    var f = e.options;
                    e.labelrank = n(f.labelrank, c.labelrank, c.shapeArgs && c.shapeArgs.height);
                    f.allowOverlap ? (e.oldOpacity = e.opacity, e.newOpacity = 1, r(e, a)) : g.push(e);
                  });
                });
              }, e(c.nodes || []), e(c.points));
            });
            this.hideOverlappingLabels(g);
          });

          a.prototype.hideOverlappingLabels = function (a) {
            var g = this,
                c = a.length,
                e = g.renderer,
                l,
                f,
                m,
                n = !1;

            var k = function k(a) {
              var c,
                  f = a.box ? 0 : a.padding || 0,
                  g = c = 0,
                  d;

              if (a && (!a.alignAttr || a.placed)) {
                var b = a.alignAttr || {
                  x: a.attr("x"),
                  y: a.attr("y")
                };
                var k = a.parentGroup;
                a.width || (c = a.getBBox(), a.width = c.width, a.height = c.height, c = e.fontMetrics(null, a.element).h);
                var l = a.width - 2 * f;
                (d = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[a.alignValue]) ? g = +d * l : J(a.x) && Math.round(a.x) !== a.translateX && (g = a.x - a.translateX);
                return {
                  x: b.x + (k.translateX || 0) + f - (g || 0),
                  y: b.y + (k.translateY || 0) + f - c,
                  width: a.width - 2 * f,
                  height: a.height - 2 * f
                };
              }
            };

            for (f = 0; f < c; f++) {
              if (l = a[f]) l.oldOpacity = l.opacity, l.newOpacity = 1, l.absoluteBox = k(l);
            }

            a.sort(function (a, c) {
              return (c.labelrank || 0) - (a.labelrank || 0);
            });

            for (f = 0; f < c; f++) {
              var u = (k = a[f]) && k.absoluteBox;

              for (l = f + 1; l < c; ++l) {
                var w = (m = a[l]) && m.absoluteBox;
                !u || !w || k === m || 0 === k.newOpacity || 0 === m.newOpacity || w.x >= u.x + u.width || w.x + w.width <= u.x || w.y >= u.y + u.height || w.y + w.height <= u.y || ((k.labelrank < m.labelrank ? k : m).newOpacity = 0);
              }
            }

            a.forEach(function (a) {
              r(a, g) && (n = !0);
            });
            n && z(g, "afterHideAllOverlappingLabels");
          };
        });
        M(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.extend,
              C = a.find,
              E = a.isArray,
              z = a.isObject,
              x = a.merge,
              J = a.objectEach,
              u = a.pick,
              n = a.splat,
              m = a.uniqueKey,
              g;

          (function (a) {
            var c = [];

            a.compose = function (a) {
              -1 === c.indexOf(a) && (c.push(a), r(a.prototype, g.prototype));
              return a;
            };

            var g = function () {
              function a() {}

              a.prototype.currentOptions = function (a) {
                function c(a, f, g, k) {
                  var h;
                  J(a, function (a, b) {
                    if (!k && -1 < e.collectionsWithUpdate.indexOf(b) && f[b]) for (a = n(a), g[b] = [], h = 0; h < Math.max(a.length, f[b].length); h++) {
                      f[b][h] && (void 0 === a[h] ? g[b][h] = f[b][h] : (g[b][h] = {}, c(a[h], f[b][h], g[b][h], k + 1)));
                    } else z(a) ? (g[b] = E(a) ? [] : {}, c(a, f[b] || {}, g[b], k + 1)) : g[b] = "undefined" === typeof f[b] ? null : f[b];
                  });
                }

                var e = this,
                    f = {};
                c(a, this.options, f, 0);
                return f;
              };

              a.prototype.matchResponsiveRule = function (a, c) {
                var e = a.condition;
                (e.callback || function () {
                  return this.chartWidth <= u(e.maxWidth, Number.MAX_VALUE) && this.chartHeight <= u(e.maxHeight, Number.MAX_VALUE) && this.chartWidth >= u(e.minWidth, 0) && this.chartHeight >= u(e.minHeight, 0);
                }).call(this) && c.push(a._id);
              };

              a.prototype.setResponsive = function (a, c) {
                var e = this,
                    f = this.options.responsive,
                    g = this.currentResponsive,
                    l = [];
                !c && f && f.rules && f.rules.forEach(function (a) {
                  "undefined" === typeof a._id && (a._id = m());
                  e.matchResponsiveRule(a, l);
                }, this);
                c = x.apply(void 0, l.map(function (a) {
                  return C((f || {}).rules || [], function (c) {
                    return c._id === a;
                  });
                }).map(function (a) {
                  return a && a.chartOptions;
                }));
                c.isResponsiveOptions = !0;
                l = l.toString() || void 0;
                l !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a, !0), l ? (g = this.currentOptions(c), g.isResponsiveOptions = !0, this.currentResponsive = {
                  ruleIds: l,
                  mergedOptions: c,
                  undoOptions: g
                }, this.update(c, a, !0)) : this.currentResponsive = void 0);
              };

              return a;
            }();
          })(g || (g = {}));

          "";
          "";
          return g;
        });
        M(a, "masters/highcharts.src.js", [a["Core/Globals.js"], a["Core/Utilities.js"], a["Core/DefaultOptions.js"], a["Core/Animation/Fx.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/FormatUtilities.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Renderer/HTML/HTMLElement.js"], a["Core/Renderer/HTML/HTMLRenderer.js"], a["Core/Axis/Axis.js"], a["Core/Axis/DateTimeAxis.js"], a["Core/Axis/LogarithmicAxis.js"], a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], a["Core/Axis/Tick.js"], a["Core/Tooltip.js"], a["Core/Series/Point.js"], a["Core/Pointer.js"], a["Core/MSPointer.js"], a["Core/Legend/Legend.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Series/Column/ColumnSeries.js"], a["Series/Column/ColumnDataLabel.js"], a["Series/Pie/PieSeries.js"], a["Series/Pie/PieDataLabel.js"], a["Core/Series/DataLabel.js"], a["Core/Responsive.js"], a["Core/Color/Color.js"], a["Core/Time.js"]], function (a, w, C, E, z, x, J, u, n, m, g, c, e, l, f, v, q, k, I, D, B, M, t, h, d, b, p, G, y, L, F, P, S) {
          a.animate = z.animate;
          a.animObject = z.animObject;
          a.getDeferredAnimation = z.getDeferredAnimation;
          a.setAnimation = z.setAnimation;
          a.stop = z.stop;
          a.timers = E.timers;
          a.AST = x;
          a.Axis = e;
          a.Chart = t;
          a.chart = t.chart;
          a.Fx = E;
          a.Legend = M;
          a.PlotLineOrBand = v;
          a.Point = I;
          a.Pointer = B.isRequired() ? B : D;
          a.Series = h;
          a.SVGElement = n;
          a.SVGRenderer = m;
          a.Tick = q;
          a.Time = S;
          a.Tooltip = k;
          a.Color = P;
          a.color = P.parse;
          c.compose(m);
          g.compose(n);
          a.defaultOptions = C.defaultOptions;
          a.getOptions = C.getOptions;
          a.time = C.defaultTime;
          a.setOptions = C.setOptions;
          a.dateFormat = J.dateFormat;
          a.format = J.format;
          a.numberFormat = J.numberFormat;
          a.addEvent = w.addEvent;
          a.arrayMax = w.arrayMax;
          a.arrayMin = w.arrayMin;
          a.attr = w.attr;
          a.clearTimeout = w.clearTimeout;
          a.correctFloat = w.correctFloat;
          a.createElement = w.createElement;
          a.css = w.css;
          a.defined = w.defined;
          a.destroyObjectProperties = w.destroyObjectProperties;
          a.discardElement = w.discardElement;
          a.distribute = u.distribute;
          a.erase = w.erase;
          a.error = w.error;
          a.extend = w.extend;
          a.extendClass = w.extendClass;
          a.find = w.find;
          a.fireEvent = w.fireEvent;
          a.getMagnitude = w.getMagnitude;
          a.getStyle = w.getStyle;
          a.inArray = w.inArray;
          a.isArray = w.isArray;
          a.isClass = w.isClass;
          a.isDOMElement = w.isDOMElement;
          a.isFunction = w.isFunction;
          a.isNumber = w.isNumber;
          a.isObject = w.isObject;
          a.isString = w.isString;
          a.keys = w.keys;
          a.merge = w.merge;
          a.normalizeTickInterval = w.normalizeTickInterval;
          a.objectEach = w.objectEach;
          a.offset = w.offset;
          a.pad = w.pad;
          a.pick = w.pick;
          a.pInt = w.pInt;
          a.relativeLength = w.relativeLength;
          a.removeEvent = w.removeEvent;
          a.seriesType = d.seriesType;
          a.splat = w.splat;
          a.stableSort = w.stableSort;
          a.syncTimeout = w.syncTimeout;
          a.timeUnits = w.timeUnits;
          a.uniqueKey = w.uniqueKey;
          a.useSerialIds = w.useSerialIds;
          a.wrap = w.wrap;
          p.compose(b);
          L.compose(h);
          l.compose(e);
          f.compose(e);
          y.compose(G);
          v.compose(e);
          F.compose(t);
          return a;
        });
        a["masters/highcharts.src.js"]._modules = a;
        return a["masters/highcharts.src.js"];
      }); //# sourceMappingURL=highcharts.js.map

      /***/

    },

    /***/
    "ZivX":
    /*!*****************************************************!*\
      !*** ./node_modules/highcharts/highcharts-gantt.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function ZivX(module, exports, __webpack_require__) {
      "use strict";

      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*
      Highcharts Gantt JS v9.2.2 (2021-08-24)
      (c) 2017-2021 Lars Cabrera, Torstein Honsi, Jon Arild Nygard & Oystein Moseng
      License: www.highcharts.com/license
      */


      (function (X, M) {
        true && module.exports ? (M["default"] = M, module.exports = X.document ? M(X) : M) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return M(X);
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
      })("undefined" !== typeof window ? window : this, function (X) {
        function M(g, P, C, y) {
          g.hasOwnProperty(P) || (g[P] = y.apply(null, C));
        }

        var g = {};
        M(g, "Core/Globals.js", [], function () {
          var g = "undefined" !== typeof X ? X : "undefined" !== typeof window ? window : {},
              P;

          (function (e) {
            e.SVG_NS = "http://www.w3.org/2000/svg";
            e.product = "Highcharts";
            e.version = "9.2.2";
            e.win = g;
            e.doc = e.win.document;
            e.svg = e.doc && e.doc.createElementNS && !!e.doc.createElementNS(e.SVG_NS, "svg").createSVGRect;
            e.userAgent = e.win.navigator && e.win.navigator.userAgent || "";
            e.isChrome = -1 !== e.userAgent.indexOf("Chrome");
            e.isFirefox = -1 !== e.userAgent.indexOf("Firefox");
            e.isMS = /(edge|msie|trident)/i.test(e.userAgent) && !e.win.opera;
            e.isSafari = !e.isChrome && -1 !== e.userAgent.indexOf("Safari");
            e.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(e.userAgent);
            e.isWebKit = -1 !== e.userAgent.indexOf("AppleWebKit");
            e.deg2rad = 2 * Math.PI / 360;
            e.hasBidiBug = e.isFirefox && 4 > parseInt(e.userAgent.split("Firefox/")[1], 10);
            e.hasTouch = !!e.win.TouchEvent;
            e.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];

            e.noop = function () {};

            e.supportsPassiveEvents = function () {
              var g = !1;

              if (!e.isMS) {
                var P = Object.defineProperty({}, "passive", {
                  get: function get() {
                    g = !0;
                  }
                });
                e.win.addEventListener && e.win.removeEventListener && (e.win.addEventListener("testPassive", e.noop, P), e.win.removeEventListener("testPassive", e.noop, P));
              }

              return g;
            }();

            e.charts = [];
            e.dateFormats = {};
            e.seriesTypes = {};
            e.symbolSizes = {};
            e.chartCount = 0;
          })(P || (P = {}));

          "";
          return P;
        });
        M(g, "Core/Utilities.js", [g["Core/Globals.js"]], function (e) {
          function g(b, c, u, f) {
            var n = c ? "Highcharts error" : "Highcharts warning";
            32 === b && (b = n + ": Deprecated member");
            var I = m(b),
                O = I ? n + " #" + b + ": www.highcharts.com/errors/" + b + "/" : b.toString();

            if ("undefined" !== typeof f) {
              var k = "";
              I && (O += "?");
              J(f, function (q, F) {
                k += "\n - " + F + ": " + q;
                I && (O += encodeURI(F) + "=" + encodeURI(q));
              });
              O += k;
            }

            t(e, "displayError", {
              chart: u,
              code: b,
              message: O,
              params: f
            }, function () {
              if (c) throw Error(O);
              A.console && -1 === g.messages.indexOf(O) && console.warn(O);
            });
            g.messages.push(O);
          }

          function C(b, c) {
            var n = {};
            J(b, function (I, u) {
              if (G(b[u], !0) && !b.nodeType && c[u]) I = C(b[u], c[u]), Object.keys(I).length && (n[u] = I);else if (G(b[u]) || b[u] !== c[u]) n[u] = b[u];
            });
            return n;
          }

          function y(b, c) {
            return parseInt(b, c || 10);
          }

          function E(b) {
            return "string" === typeof b;
          }

          function v(b) {
            b = Object.prototype.toString.call(b);
            return "[object Array]" === b || "[object Array Iterator]" === b;
          }

          function G(b, c) {
            return !!b && "object" === typeof b && (!c || !v(b));
          }

          function x(b) {
            return G(b) && "number" === typeof b.nodeType;
          }

          function r(b) {
            var c = b && b.constructor;
            return !(!G(b, !0) || x(b) || !c || !c.name || "Object" === c.name);
          }

          function m(b) {
            return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
          }

          function d(b) {
            return "undefined" !== typeof b && null !== b;
          }

          function a(b, c, u) {
            var n;
            E(c) ? d(u) ? b.setAttribute(c, u) : b && b.getAttribute && ((n = b.getAttribute(c)) || "class" !== c || (n = b.getAttribute(c + "Name"))) : J(c, function (c, n) {
              b.setAttribute(n, c);
            });
            return n;
          }

          function p(b, c) {
            var n;
            b || (b = {});

            for (n in c) {
              b[n] = c[n];
            }

            return b;
          }

          function B() {
            for (var b = arguments, c = b.length, u = 0; u < c; u++) {
              var f = b[u];
              if ("undefined" !== typeof f && null !== f) return f;
            }
          }

          function l(b, c) {
            e.isMS && !e.svg && c && "undefined" !== typeof c.opacity && (c.filter = "alpha(opacity=" + 100 * c.opacity + ")");
            p(b.style, c);
          }

          function h(b, c, u, f, w) {
            b = z.createElement(b);
            c && p(b, c);
            w && l(b, {
              padding: "0",
              border: "none",
              margin: "0"
            });
            u && l(b, u);
            f && f.appendChild(b);
            return b;
          }

          function f(b, c) {
            return parseFloat(b.toPrecision(c || 14));
          }

          function k(b, c, u) {
            var n = e.getStyle || k;
            if ("width" === c) return c = Math.min(b.offsetWidth, b.scrollWidth), u = b.getBoundingClientRect && b.getBoundingClientRect().width, u < c && u >= c - 1 && (c = Math.floor(u)), Math.max(0, c - (n(b, "padding-left", !0) || 0) - (n(b, "padding-right", !0) || 0));
            if ("height" === c) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (n(b, "padding-top", !0) || 0) - (n(b, "padding-bottom", !0) || 0));
            A.getComputedStyle || g(27, !0);

            if (b = A.getComputedStyle(b, void 0)) {
              var I = b.getPropertyValue(c);
              B(u, "opacity" !== c) && (I = y(I));
            }

            return I;
          }

          function J(b, c, u) {
            for (var n in b) {
              Object.hasOwnProperty.call(b, n) && c.call(u || b[n], b[n], n, b);
            }
          }

          function K(b, c, u) {
            function n(c, q) {
              var F = b.removeEventListener || e.removeEventListenerPolyfill;
              F && F.call(b, c, q, !1);
            }

            function I(u) {
              var q;

              if (b.nodeName) {
                if (c) {
                  var F = {};
                  F[c] = !0;
                } else F = u;

                J(F, function (b, F) {
                  if (u[F]) for (q = u[F].length; q--;) {
                    n(F, u[F][q].fn);
                  }
                });
              }
            }

            var f = "function" === typeof b && b.prototype || b;

            if (Object.hasOwnProperty.call(f, "hcEvents")) {
              var O = f.hcEvents;
              c ? (f = O[c] || [], u ? (O[c] = f.filter(function (b) {
                return u !== b.fn;
              }), n(c, u)) : (I(O), O[c] = [])) : (I(O), delete f.hcEvents);
            }
          }

          function t(b, c, u, f) {
            u = u || {};

            if (z.createEvent && (b.dispatchEvent || b.fireEvent && b !== e)) {
              var n = z.createEvent("Events");
              n.initEvent(c, !0, !0);
              u = p(n, u);
              b.dispatchEvent ? b.dispatchEvent(u) : b.fireEvent(c, u);
            } else if (b.hcEvents) {
              u.target || p(u, {
                preventDefault: function preventDefault() {
                  u.defaultPrevented = !0;
                },
                target: b,
                type: c
              });
              n = [];

              for (var I = b, O = !1; I.hcEvents;) {
                Object.hasOwnProperty.call(I, "hcEvents") && I.hcEvents[c] && (n.length && (O = !0), n.unshift.apply(n, I.hcEvents[c])), I = Object.getPrototypeOf(I);
              }

              O && n.sort(function (b, q) {
                return b.order - q.order;
              });
              n.forEach(function (c) {
                !1 === c.fn.call(b, u) && u.preventDefault();
              });
            }

            f && !u.defaultPrevented && f.call(b, u);
          }

          var Q = e.charts,
              z = e.doc,
              A = e.win;
          (g || (g = {})).messages = [];
          var c;

          Math.easeInOutSine = function (b) {
            return -.5 * (Math.cos(Math.PI * b) - 1);
          };

          var b = Array.prototype.find ? function (b, c) {
            return b.find(c);
          } : function (b, c) {
            var n,
                I = b.length;

            for (n = 0; n < I; n++) {
              if (c(b[n], n)) return b[n];
            }
          };
          J({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function (b, c) {
            e[c] = function (n) {
              var u;
              g(32, !1, void 0, (u = {}, u["Highcharts." + c] = "use Array." + b, u));
              return Array.prototype[b].apply(n, [].slice.call(arguments, 1));
            };
          });

          var D,
              L = function () {
            var b = Math.random().toString(36).substring(2, 9) + "-",
                c = 0;
            return function () {
              return "highcharts-" + (D ? "" : b) + c++;
            };
          }();

          A.jQuery && (A.jQuery.fn.highcharts = function () {
            var b = [].slice.call(arguments);
            if (this[0]) return b[0] ? (new e[E(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : Q[a(this[0], "data-highcharts-chart")];
          });
          b = {
            addEvent: function addEvent(b, c, u, f) {
              void 0 === f && (f = {});
              var n = "function" === typeof b && b.prototype || b;
              Object.hasOwnProperty.call(n, "hcEvents") || (n.hcEvents = {});
              n = n.hcEvents;
              e.Point && b instanceof e.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
              var I = b.addEventListener || e.addEventListenerPolyfill;
              I && I.call(b, c, u, e.supportsPassiveEvents ? {
                passive: void 0 === f.passive ? -1 !== c.indexOf("touch") : f.passive,
                capture: !1
              } : !1);
              n[c] || (n[c] = []);
              n[c].push({
                fn: u,
                order: "number" === typeof f.order ? f.order : Infinity
              });
              n[c].sort(function (b, c) {
                return b.order - c.order;
              });
              return function () {
                K(b, c, u);
              };
            },
            arrayMax: function arrayMax(b) {
              for (var c = b.length, u = b[0]; c--;) {
                b[c] > u && (u = b[c]);
              }

              return u;
            },
            arrayMin: function arrayMin(b) {
              for (var c = b.length, u = b[0]; c--;) {
                b[c] < u && (u = b[c]);
              }

              return u;
            },
            attr: a,
            clamp: function clamp(b, c, u) {
              return b > c ? b < u ? b : u : c;
            },
            cleanRecursively: C,
            clearTimeout: function (_clearTimeout3) {
              function clearTimeout(_x3) {
                return _clearTimeout3.apply(this, arguments);
              }

              clearTimeout.toString = function () {
                return _clearTimeout3.toString();
              };

              return clearTimeout;
            }(function (b) {
              d(b) && clearTimeout(b);
            }),
            correctFloat: f,
            createElement: h,
            css: l,
            defined: d,
            destroyObjectProperties: function destroyObjectProperties(b, c) {
              J(b, function (n, f) {
                n && n !== c && n.destroy && n.destroy();
                delete b[f];
              });
            },
            discardElement: function discardElement(b) {
              c || (c = h("div"));
              b && c.appendChild(b);
              c.innerHTML = "";
            },
            erase: function erase(b, c) {
              for (var n = b.length; n--;) {
                if (b[n] === c) {
                  b.splice(n, 1);
                  break;
                }
              }
            },
            error: g,
            extend: p,
            extendClass: function extendClass(b, c) {
              var n = function n() {};

              n.prototype = new b();
              p(n.prototype, c);
              return n;
            },
            find: b,
            fireEvent: t,
            getMagnitude: function getMagnitude(b) {
              return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
            },
            getNestedProperty: function getNestedProperty(b, c) {
              for (b = b.split("."); b.length && d(c);) {
                var n = b.shift();
                if ("undefined" === typeof n || "__proto__" === n) return;
                c = c[n];
                if (!d(c) || "function" === typeof c || "number" === typeof c.nodeType || c === A) return;
              }

              return c;
            },
            getStyle: k,
            inArray: function inArray(b, c, u) {
              g(32, !1, void 0, {
                "Highcharts.inArray": "use Array.indexOf"
              });
              return c.indexOf(b, u);
            },
            isArray: v,
            isClass: r,
            isDOMElement: x,
            isFunction: function isFunction(b) {
              return "function" === typeof b;
            },
            isNumber: m,
            isObject: G,
            isString: E,
            keys: function keys(b) {
              g(32, !1, void 0, {
                "Highcharts.keys": "use Object.keys"
              });
              return Object.keys(b);
            },
            merge: function merge() {
              var b,
                  c = arguments,
                  u = {},
                  f = function f(b, c) {
                "object" !== typeof b && (b = {});
                J(c, function (n, q) {
                  "__proto__" !== q && "constructor" !== q && (!G(n, !0) || r(n) || x(n) ? b[q] = c[q] : b[q] = f(b[q] || {}, n));
                });
                return b;
              };

              !0 === c[0] && (u = c[1], c = Array.prototype.slice.call(c, 2));
              var w = c.length;

              for (b = 0; b < w; b++) {
                u = f(u, c[b]);
              }

              return u;
            },
            normalizeTickInterval: function normalizeTickInterval(b, c, u, k, w) {
              var n = b;
              u = B(u, 1);
              var O = b / u;
              c || (c = w ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === k && (1 === u ? c = c.filter(function (b) {
                return 0 === b % 1;
              }) : .1 >= u && (c = [1 / u])));

              for (k = 0; k < c.length && !(n = c[k], w && n * u >= b || !w && O <= (c[k] + (c[k + 1] || c[k])) / 2); k++) {
                ;
              }

              return n = f(n * u, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: J,
            offset: function offset(b) {
              var c = z.documentElement;
              b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
              };
              return {
                top: b.top + (A.pageYOffset || c.scrollTop) - (c.clientTop || 0),
                left: b.left + (A.pageXOffset || c.scrollLeft) - (c.clientLeft || 0),
                width: b.width,
                height: b.height
              };
            },
            pad: function pad(b, c, u) {
              return Array((c || 2) + 1 - String(b).replace("-", "").length).join(u || "0") + b;
            },
            pick: B,
            pInt: y,
            relativeLength: function relativeLength(b, c, u) {
              return /%$/.test(b) ? c * parseFloat(b) / 100 + (u || 0) : parseFloat(b);
            },
            removeEvent: K,
            splat: function splat(b) {
              return v(b) ? b : [b];
            },
            stableSort: function stableSort(b, c) {
              var n = b.length,
                  f,
                  w;

              for (w = 0; w < n; w++) {
                b[w].safeI = w;
              }

              b.sort(function (b, n) {
                f = c(b, n);
                return 0 === f ? b.safeI - n.safeI : f;
              });

              for (w = 0; w < n; w++) {
                delete b[w].safeI;
              }
            },
            syncTimeout: function syncTimeout(b, c, u) {
              if (0 < c) return setTimeout(b, c, u);
              b.call(0, u);
              return -1;
            },
            timeUnits: {
              millisecond: 1,
              second: 1E3,
              minute: 6E4,
              hour: 36E5,
              day: 864E5,
              week: 6048E5,
              month: 24192E5,
              year: 314496E5
            },
            uniqueKey: L,
            useSerialIds: function useSerialIds(b) {
              return D = B(b, D);
            },
            wrap: function wrap(b, c, u) {
              var n = b[c];

              b[c] = function () {
                var b = Array.prototype.slice.call(arguments),
                    c = arguments,
                    O = this;

                O.proceed = function () {
                  n.apply(O, arguments.length ? arguments : c);
                };

                b.unshift(n);
                b = u.apply(this, b);
                O.proceed = null;
                return b;
              };
            }
          };
          "";
          return b;
        });
        M(g, "Core/Color/Palette.js", [], function () {
          return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            backgroundColor: "#ffffff",
            neutralColor100: "#000000",
            neutralColor80: "#333333",
            neutralColor60: "#666666",
            neutralColor40: "#999999",
            neutralColor20: "#cccccc",
            neutralColor10: "#e6e6e6",
            neutralColor5: "#f2f2f2",
            neutralColor3: "#f7f7f7",
            highlightColor100: "#003399",
            highlightColor80: "#335cad",
            highlightColor60: "#6685c2",
            highlightColor20: "#ccd6eb",
            highlightColor10: "#e6ebf5",
            positiveColor: "#06b535",
            negativeColor: "#f21313"
          };
        });
        M(g, "Core/Chart/ChartDefaults.js", [g["Core/Color/Palette.js"]], function (e) {
          return {
            panning: {
              enabled: !1,
              type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: e.highlightColor80,
            backgroundColor: e.backgroundColor,
            plotBorderColor: e.neutralColor20
          };
        });
        M(g, "Core/Color/Color.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g) {
          var P = g.isNumber,
              y = g.merge,
              E = g.pInt;

          g = function () {
            function g(G) {
              this.rgba = [NaN, NaN, NaN, NaN];
              this.input = G;
              var x = e.Color;
              if (x && x !== g) return new x(G);
              if (!(this instanceof g)) return new g(G);
              this.init(G);
            }

            g.parse = function (e) {
              return e ? new g(e) : g.None;
            };

            g.prototype.init = function (e) {
              var x;
              if ("object" === typeof e && "undefined" !== typeof e.stops) this.stops = e.stops.map(function (a) {
                return new g(a[1]);
              });else if ("string" === typeof e) {
                this.input = e = g.names[e.toLowerCase()] || e;

                if ("#" === e.charAt(0)) {
                  var r = e.length;
                  var m = parseInt(e.substr(1), 16);
                  7 === r ? x = [(m & 16711680) >> 16, (m & 65280) >> 8, m & 255, 1] : 4 === r && (x = [(m & 3840) >> 4 | (m & 3840) >> 8, (m & 240) >> 4 | m & 240, (m & 15) << 4 | m & 15, 1]);
                }

                if (!x) for (m = g.parsers.length; m-- && !x;) {
                  var d = g.parsers[m];
                  (r = d.regex.exec(e)) && (x = d.parse(r));
                }
              }
              x && (this.rgba = x);
            };

            g.prototype.get = function (e) {
              var x = this.input,
                  r = this.rgba;

              if ("object" === typeof x && "undefined" !== typeof this.stops) {
                var m = y(x);
                m.stops = [].slice.call(m.stops);
                this.stops.forEach(function (d, a) {
                  m.stops[a] = [m.stops[a][0], d.get(e)];
                });
                return m;
              }

              return r && P(r[0]) ? "rgb" === e || !e && 1 === r[3] ? "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")" : "a" === e ? "" + r[3] : "rgba(" + r.join(",") + ")" : x;
            };

            g.prototype.brighten = function (e) {
              var x = this.rgba;
              if (this.stops) this.stops.forEach(function (m) {
                m.brighten(e);
              });else if (P(e) && 0 !== e) for (var r = 0; 3 > r; r++) {
                x[r] += E(255 * e), 0 > x[r] && (x[r] = 0), 255 < x[r] && (x[r] = 255);
              }
              return this;
            };

            g.prototype.setOpacity = function (e) {
              this.rgba[3] = e;
              return this;
            };

            g.prototype.tweenTo = function (e, x) {
              var r = this.rgba,
                  m = e.rgba;
              if (!P(r[0]) || !P(m[0])) return e.input || "none";
              e = 1 !== m[3] || 1 !== r[3];
              return (e ? "rgba(" : "rgb(") + Math.round(m[0] + (r[0] - m[0]) * (1 - x)) + "," + Math.round(m[1] + (r[1] - m[1]) * (1 - x)) + "," + Math.round(m[2] + (r[2] - m[2]) * (1 - x)) + (e ? "," + (m[3] + (r[3] - m[3]) * (1 - x)) : "") + ")";
            };

            g.names = {
              white: "#ffffff",
              black: "#000000"
            };
            g.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(e) {
                return [E(e[1]), E(e[2]), E(e[3]), parseFloat(e[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(e) {
                return [E(e[1]), E(e[2]), E(e[3]), 1];
              }
            }];
            g.None = new g("");
            return g;
          }();

          "";
          return g;
        });
        M(g, "Core/Time.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g) {
          var P = e.win,
              y = g.defined,
              E = g.error,
              v = g.extend,
              G = g.isObject,
              x = g.merge,
              r = g.objectEach,
              m = g.pad,
              d = g.pick,
              a = g.splat,
              p = g.timeUnits,
              B = e.isSafari && P.Intl && P.Intl.DateTimeFormat.prototype.formatRange,
              l = e.isSafari && P.Intl && !P.Intl.DateTimeFormat.prototype.formatRange;

          g = function () {
            function h(f) {
              this.options = {};
              this.variableTimezone = this.useUTC = !1;
              this.Date = P.Date;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.update(f);
            }

            h.prototype.get = function (f, k) {
              if (this.variableTimezone || this.timezoneOffset) {
                var h = k.getTime(),
                    a = h - this.getTimezoneOffset(k);
                k.setTime(a);
                f = k["getUTC" + f]();
                k.setTime(h);
                return f;
              }

              return this.useUTC ? k["getUTC" + f]() : k["get" + f]();
            };

            h.prototype.set = function (f, k, h) {
              if (this.variableTimezone || this.timezoneOffset) {
                if ("Milliseconds" === f || "Seconds" === f || "Minutes" === f && 0 === this.getTimezoneOffset(k) % 36E5) return k["setUTC" + f](h);
                var a = this.getTimezoneOffset(k);
                a = k.getTime() - a;
                k.setTime(a);
                k["setUTC" + f](h);
                f = this.getTimezoneOffset(k);
                a = k.getTime() + f;
                return k.setTime(a);
              }

              return this.useUTC || B && "FullYear" === f ? k["setUTC" + f](h) : k["set" + f](h);
            };

            h.prototype.update = function (f) {
              var k = d(f && f.useUTC, !0);
              this.options = f = x(!0, this.options || {}, f);
              this.Date = f.Date || P.Date || Date;
              this.timezoneOffset = (this.useUTC = k) && f.timezoneOffset;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.variableTimezone = k && !(!f.getTimezoneOffset && !f.timezone);
            };

            h.prototype.makeTime = function (f, k, h, a, t, p) {
              if (this.useUTC) {
                var z = this.Date.UTC.apply(0, arguments);
                var A = this.getTimezoneOffset(z);
                z += A;
                var c = this.getTimezoneOffset(z);
                A !== c ? z += c - A : A - 36E5 !== this.getTimezoneOffset(z - 36E5) || l || (z -= 36E5);
              } else z = new this.Date(f, k, d(h, 1), d(a, 0), d(t, 0), d(p, 0)).getTime();

              return z;
            };

            h.prototype.timezoneOffsetFunction = function () {
              var f = this,
                  k = this.options,
                  h = k.moment || P.moment;
              if (!this.useUTC) return function (f) {
                return 6E4 * new Date(f.toString()).getTimezoneOffset();
              };

              if (k.timezone) {
                if (h) return function (f) {
                  return 6E4 * -h.tz(f, k.timezone).utcOffset();
                };
                E(25);
              }

              return this.useUTC && k.getTimezoneOffset ? function (f) {
                return 6E4 * k.getTimezoneOffset(f.valueOf());
              } : function () {
                return 6E4 * (f.timezoneOffset || 0);
              };
            };

            h.prototype.dateFormat = function (f, k, h) {
              if (!y(k) || isNaN(k)) return e.defaultOptions.lang && e.defaultOptions.lang.invalidDate || "";
              f = d(f, "%Y-%m-%d %H:%M:%S");
              var a = this,
                  t = new this.Date(k),
                  p = this.get("Hours", t),
                  z = this.get("Day", t),
                  A = this.get("Date", t),
                  c = this.get("Month", t),
                  b = this.get("FullYear", t),
                  D = e.defaultOptions.lang,
                  l = D && D.weekdays,
                  I = D && D.shortWeekdays;
              t = v({
                a: I ? I[z] : l[z].substr(0, 3),
                A: l[z],
                d: m(A),
                e: m(A, 2, " "),
                w: z,
                b: D.shortMonths[c],
                B: D.months[c],
                m: m(c + 1),
                o: c + 1,
                y: b.toString().substr(2, 2),
                Y: b,
                H: m(p),
                k: p,
                I: m(p % 12 || 12),
                l: p % 12 || 12,
                M: m(this.get("Minutes", t)),
                p: 12 > p ? "AM" : "PM",
                P: 12 > p ? "am" : "pm",
                S: m(t.getSeconds()),
                L: m(Math.floor(k % 1E3), 3)
              }, e.dateFormats);
              r(t, function (b, c) {
                for (; -1 !== f.indexOf("%" + c);) {
                  f = f.replace("%" + c, "function" === typeof b ? b.call(a, k) : b);
                }
              });
              return h ? f.substr(0, 1).toUpperCase() + f.substr(1) : f;
            };

            h.prototype.resolveDTLFormat = function (f) {
              return G(f, !0) ? f : (f = a(f), {
                main: f[0],
                from: f[1],
                to: f[2]
              });
            };

            h.prototype.getTimeTicks = function (f, k, h, a) {
              var t = this,
                  l = [],
                  z = {},
                  A = new t.Date(k),
                  c = f.unitRange,
                  b = f.count || 1,
                  D;
              a = d(a, 1);

              if (y(k)) {
                t.set("Milliseconds", A, c >= p.second ? 0 : b * Math.floor(t.get("Milliseconds", A) / b));
                c >= p.second && t.set("Seconds", A, c >= p.minute ? 0 : b * Math.floor(t.get("Seconds", A) / b));
                c >= p.minute && t.set("Minutes", A, c >= p.hour ? 0 : b * Math.floor(t.get("Minutes", A) / b));
                c >= p.hour && t.set("Hours", A, c >= p.day ? 0 : b * Math.floor(t.get("Hours", A) / b));
                c >= p.day && t.set("Date", A, c >= p.month ? 1 : Math.max(1, b * Math.floor(t.get("Date", A) / b)));

                if (c >= p.month) {
                  t.set("Month", A, c >= p.year ? 0 : b * Math.floor(t.get("Month", A) / b));
                  var L = t.get("FullYear", A);
                }

                c >= p.year && t.set("FullYear", A, L - L % b);
                c === p.week && (L = t.get("Day", A), t.set("Date", A, t.get("Date", A) - L + a + (L < a ? -7 : 0)));
                L = t.get("FullYear", A);
                a = t.get("Month", A);
                var I = t.get("Date", A),
                    n = t.get("Hours", A);
                k = A.getTime();
                !t.variableTimezone && t.useUTC || !y(h) || (D = h - k > 4 * p.month || t.getTimezoneOffset(k) !== t.getTimezoneOffset(h));
                k = A.getTime();

                for (A = 1; k < h;) {
                  l.push(k), k = c === p.year ? t.makeTime(L + A * b, 0) : c === p.month ? t.makeTime(L, a + A * b) : !D || c !== p.day && c !== p.week ? D && c === p.hour && 1 < b ? t.makeTime(L, a, I, n + A * b) : k + c * b : t.makeTime(L, a, I + A * b * (c === p.day ? 1 : 7)), A++;
                }

                l.push(k);
                c <= p.hour && 1E4 > l.length && l.forEach(function (b) {
                  0 === b % 18E5 && "000000000" === t.dateFormat("%H%M%S%L", b) && (z[b] = "day");
                });
              }

              l.info = v(f, {
                higherRanks: z,
                totalRange: c * b
              });
              return l;
            };

            h.prototype.getDateFormat = function (f, k, h, a) {
              var t = this.dateFormat("%m-%d %H:%M:%S.%L", k),
                  l = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
              },
                  z = "millisecond";

              for (A in p) {
                if (f === p.week && +this.dateFormat("%w", k) === h && "00:00:00.000" === t.substr(6)) {
                  var A = "week";
                  break;
                }

                if (p[A] > f) {
                  A = z;
                  break;
                }

                if (l[A] && t.substr(l[A]) !== "01-01 00:00:00.000".substr(l[A])) break;
                "week" !== A && (z = A);
              }

              if (A) var c = this.resolveDTLFormat(a[A]).main;
              return c;
            };

            return h;
          }();

          "";
          return g;
        });
        M(g, "Core/DefaultOptions.js", [g["Core/Chart/ChartDefaults.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Color/Palette.js"], g["Core/Time.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v) {
          g = g.parse;
          var G = v.merge,
              x = {
            colors: y.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
              loading: "Loading...",
              months: "January February March April May June July August September October November December".split(" "),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
              weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
              decimalPoint: ".",
              numericSymbols: "kMGTPE".split(""),
              resetZoom: "Reset zoom",
              resetZoomTitle: "Reset zoom level 1:1",
              thousandsSep: " "
            },
            global: {},
            time: {
              Date: void 0,
              getTimezoneOffset: void 0,
              timezone: void 0,
              timezoneOffset: 0,
              useUTC: !0
            },
            chart: e,
            title: {
              text: "Chart title",
              align: "center",
              margin: 15,
              widthAdjust: -44
            },
            subtitle: {
              text: "",
              align: "center",
              widthAdjust: -44
            },
            caption: {
              margin: 15,
              text: "",
              align: "left",
              verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
              style: {
                position: "absolute",
                color: y.neutralColor80
              }
            },
            legend: {
              enabled: !0,
              align: "center",
              alignColumns: !0,
              className: "highcharts-no-tooltip",
              layout: "horizontal",
              labelFormatter: function labelFormatter() {
                return this.name;
              },
              borderColor: y.neutralColor40,
              borderRadius: 0,
              navigation: {
                activeColor: y.highlightColor100,
                inactiveColor: y.neutralColor20
              },
              itemStyle: {
                color: y.neutralColor80,
                cursor: "pointer",
                fontSize: "12px",
                fontWeight: "bold",
                textOverflow: "ellipsis"
              },
              itemHoverStyle: {
                color: y.neutralColor100
              },
              itemHiddenStyle: {
                color: y.neutralColor20
              },
              shadow: !1,
              itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
              },
              squareSymbol: !0,
              symbolPadding: 5,
              verticalAlign: "bottom",
              x: 0,
              y: 0,
              title: {
                style: {
                  fontWeight: "bold"
                }
              }
            },
            loading: {
              labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
              },
              style: {
                position: "absolute",
                backgroundColor: y.backgroundColor,
                opacity: .5,
                textAlign: "center"
              }
            },
            tooltip: {
              enabled: !0,
              animation: C.svg,
              borderRadius: 3,
              dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
              },
              footerFormat: "",
              headerShape: "callout",
              hideDelay: 500,
              padding: 8,
              shape: "callout",
              shared: !1,
              snap: C.isTouchDevice ? 25 : 10,
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
              backgroundColor: g(y.neutralColor3).setOpacity(.85).get(),
              borderWidth: 1,
              shadow: !0,
              stickOnContact: !1,
              style: {
                color: y.neutralColor80,
                cursor: "default",
                fontSize: "12px",
                whiteSpace: "nowrap"
              },
              useHTML: !1
            },
            credits: {
              enabled: !0,
              href: "https://www.highcharts.com?credits",
              position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
              },
              style: {
                cursor: "pointer",
                color: y.neutralColor40,
                fontSize: "9px"
              },
              text: "Highcharts.com"
            }
          };
          x.chart.styledMode = !1;
          "";
          var r = new E(G(x.global, x.time));
          e = {
            defaultOptions: x,
            defaultTime: r,
            getOptions: function getOptions() {
              return x;
            },
            setOptions: function setOptions(m) {
              G(!0, x, m);
              if (m.time || m.global) C.time ? C.time.update(G(x.global, x.time, m.global, m.time)) : C.time = r;
              return x;
            }
          };
          "";
          return e;
        });
        M(g, "Core/Animation/Fx.js", [g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var P = e.parse,
              E = g.win,
              v = C.isNumber,
              G = C.objectEach;
          return function () {
            function e(r, m, d) {
              this.pos = NaN;
              this.options = m;
              this.elem = r;
              this.prop = d;
            }

            e.prototype.dSetter = function () {
              var r = this.paths,
                  m = r && r[0];
              r = r && r[1];
              var d = this.now || 0,
                  a = [];
              if (1 !== d && m && r) {
                if (m.length === r.length && 1 > d) for (var p = 0; p < r.length; p++) {
                  for (var B = m[p], l = r[p], h = [], f = 0; f < l.length; f++) {
                    var k = B[f],
                        J = l[f];
                    v(k) && v(J) && ("A" !== l[0] || 4 !== f && 5 !== f) ? h[f] = k + d * (J - k) : h[f] = J;
                  }

                  a.push(h);
                } else a = r;
              } else a = this.toD || [];
              this.elem.attr("d", a, void 0, !0);
            };

            e.prototype.update = function () {
              var r = this.elem,
                  m = this.prop,
                  d = this.now,
                  a = this.options.step;
              if (this[m + "Setter"]) this[m + "Setter"]();else r.attr ? r.element && r.attr(m, d, null, !0) : r.style[m] = d + this.unit;
              a && a.call(r, d, this);
            };

            e.prototype.run = function (r, m, d) {
              var a = this,
                  p = a.options,
                  B = function B(f) {
                return B.stopped ? !1 : a.step(f);
              },
                  l = E.requestAnimationFrame || function (f) {
                setTimeout(f, 13);
              },
                  h = function h() {
                for (var f = 0; f < e.timers.length; f++) {
                  e.timers[f]() || e.timers.splice(f--, 1);
                }

                e.timers.length && l(h);
              };

              r !== m || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = r, this.end = m, this.unit = d, this.now = this.start, this.pos = 0, B.elem = this.elem, B.prop = this.prop, B() && 1 === e.timers.push(B) && l(h)) : (delete p.curAnim[this.prop], p.complete && 0 === Object.keys(p.curAnim).length && p.complete.call(this.elem));
            };

            e.prototype.step = function (r) {
              var m = +new Date(),
                  d = this.options,
                  a = this.elem,
                  p = d.complete,
                  B = d.duration,
                  l = d.curAnim;
              if (a.attr && !a.element) r = !1;else if (r || m >= B + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                var h = l[this.prop] = !0;
                G(l, function (f) {
                  !0 !== f && (h = !1);
                });
                h && p && p.call(a);
                r = !1;
              } else this.pos = d.easing((m - this.startTime) / B), this.now = this.start + (this.end - this.start) * this.pos, this.update(), r = !0;
              return r;
            };

            e.prototype.initPath = function (r, m, d) {
              function a(f, k) {
                for (; f.length < K;) {
                  var a = f[0],
                      A = k[K - f.length];
                  A && "M" === a[0] && (f[0] = "C" === A[0] ? ["C", a[1], a[2], a[1], a[2], a[1], a[2]] : ["L", a[1], a[2]]);
                  f.unshift(a);
                  h && (a = f.pop(), f.push(f[f.length - 1], a));
                }
              }

              function p(k, a) {
                for (; k.length < K;) {
                  if (a = k[Math.floor(k.length / f) - 1].slice(), "C" === a[0] && (a[1] = a[5], a[2] = a[6]), h) {
                    var t = k[Math.floor(k.length / f)].slice();
                    k.splice(k.length / 2, 0, a, t);
                  } else k.push(a);
                }
              }

              var B = r.startX,
                  l = r.endX;
              d = d.slice();
              var h = r.isArea,
                  f = h ? 2 : 1;
              m = m && m.slice();
              if (!m) return [d, d];

              if (B && l && l.length) {
                for (r = 0; r < B.length; r++) {
                  if (B[r] === l[0]) {
                    var k = r;
                    break;
                  } else if (B[0] === l[l.length - B.length + r]) {
                    k = r;
                    var J = !0;
                    break;
                  } else if (B[B.length - 1] === l[l.length - B.length + r]) {
                    k = B.length - r;
                    break;
                  }
                }

                "undefined" === typeof k && (m = []);
              }

              if (m.length && v(k)) {
                var K = d.length + k * f;
                J ? (a(m, d), p(d, m)) : (a(d, m), p(m, d));
              }

              return [m, d];
            };

            e.prototype.fillSetter = function () {
              e.prototype.strokeSetter.apply(this, arguments);
            };

            e.prototype.strokeSetter = function () {
              this.elem.attr(this.prop, P(this.start).tweenTo(P(this.end), this.pos), null, !0);
            };

            e.timers = [];
            return e;
          }();
        });
        M(g, "Core/Animation/AnimationUtilities.js", [g["Core/Animation/Fx.js"], g["Core/Utilities.js"]], function (e, g) {
          function P(a) {
            return r(a) ? m({
              duration: 500,
              defer: 0
            }, a) : {
              duration: a ? 500 : 0,
              defer: 0
            };
          }

          function y(a, d) {
            for (var p = e.timers.length; p--;) {
              e.timers[p].elem !== a || d && d !== e.timers[p].prop || (e.timers[p].stopped = !0);
            }
          }

          var E = g.defined,
              v = g.getStyle,
              G = g.isArray,
              x = g.isNumber,
              r = g.isObject,
              m = g.merge,
              d = g.objectEach,
              a = g.pick;
          return {
            animate: function animate(a, B, l) {
              var h,
                  f = "",
                  k,
                  p;

              if (!r(l)) {
                var K = arguments;
                l = {
                  duration: K[2],
                  easing: K[3],
                  complete: K[4]
                };
              }

              x(l.duration) || (l.duration = 400);
              l.easing = "function" === typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine;
              l.curAnim = m(B);
              d(B, function (t, d) {
                y(a, d);
                p = new e(a, l, d);
                k = void 0;
                "d" === d && G(B.d) ? (p.paths = p.initPath(a, a.pathArray, B.d), p.toD = B.d, h = 0, k = 1) : a.attr ? h = a.attr(d) : (h = parseFloat(v(a, d)) || 0, "opacity" !== d && (f = "px"));
                k || (k = t);
                "string" === typeof k && k.match("px") && (k = k.replace(/px/g, ""));
                p.run(h, k, f);
              });
            },
            animObject: P,
            getDeferredAnimation: function getDeferredAnimation(a, d, l) {
              var h = P(d),
                  f = 0,
                  k = 0;
              (l ? [l] : a.series).forEach(function (a) {
                a = P(a.options.animation);
                f = d && E(d.defer) ? h.defer : Math.max(f, a.duration + a.defer);
                k = Math.min(h.duration, a.duration);
              });
              a.renderer.forExport && (f = 0);
              return {
                defer: Math.max(0, f - k),
                duration: Math.min(f, k)
              };
            },
            setAnimation: function setAnimation(p, d) {
              d.renderer.globalAnimation = a(p, d.options.chart.animation, !0);
            },
            stop: y
          };
        });
        M(g, "Core/Renderer/HTML/AST.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g) {
          var P = e.SVG_NS,
              y = g.attr,
              E = g.createElement,
              v = g.discardElement,
              G = g.error,
              x = g.isString,
              r = g.objectEach,
              m = g.splat;

          try {
            var d = !!new DOMParser().parseFromString("", "text/html");
          } catch (a) {
            d = !1;
          }

          g = function () {
            function a(a) {
              this.nodes = "string" === typeof a ? this.parseMarkup(a) : a;
            }

            a.filterUserAttributes = function (d) {
              r(d, function (p, l) {
                var h = !0;
                -1 === a.allowedAttributes.indexOf(l) && (h = !1);
                -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(l) && (h = x(p) && a.allowedReferences.some(function (f) {
                  return 0 === p.indexOf(f);
                }));
                h || (G("Highcharts warning: Invalid attribute '" + l + "' in config"), delete d[l]);
              });
              return d;
            };

            a.setElementHTML = function (d, m) {
              d.innerHTML = "";
              m && new a(m).addToDOM(d);
            };

            a.prototype.addToDOM = function (d) {
              function p(d, h) {
                var f;
                m(d).forEach(function (k) {
                  var d = k.tagName,
                      l = k.textContent ? e.doc.createTextNode(k.textContent) : void 0;
                  if (d) if ("#text" === d) var t = l;else if (-1 !== a.allowedTags.indexOf(d)) {
                    d = e.doc.createElementNS("svg" === d ? P : h.namespaceURI || P, d);
                    var m = k.attributes || {};
                    r(k, function (f, a) {
                      "tagName" !== a && "attributes" !== a && "children" !== a && "textContent" !== a && (m[a] = f);
                    });
                    y(d, a.filterUserAttributes(m));
                    l && d.appendChild(l);
                    p(k.children || [], d);
                    t = d;
                  } else G("Highcharts warning: Invalid tagName '" + d + "' in config");
                  t && h.appendChild(t);
                  f = t;
                });
                return f;
              }

              return p(this.nodes, d);
            };

            a.prototype.parseMarkup = function (a) {
              var p = [];
              a = a.trim();
              if (d) a = new DOMParser().parseFromString(a, "text/html");else {
                var l = E("div");
                l.innerHTML = a;
                a = {
                  body: l
                };
              }

              var h = function h(a, k) {
                var f = a.nodeName.toLowerCase(),
                    d = {
                  tagName: f
                };
                "#text" === f && (d.textContent = a.textContent || "");

                if (f = a.attributes) {
                  var t = {};
                  [].forEach.call(f, function (a) {
                    t[a.name] = a.value;
                  });
                  d.attributes = t;
                }

                if (a.childNodes.length) {
                  var l = [];
                  [].forEach.call(a.childNodes, function (a) {
                    h(a, l);
                  });
                  l.length && (d.children = l);
                }

                k.push(d);
              };

              [].forEach.call(a.body.childNodes, function (a) {
                return h(a, p);
              });
              l && v(l);
              return p;
            };

            a.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            a.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            a.allowedTags = "a b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            return a;
          }();

          "";
          return g;
        });
        M(g, "Core/FormatUtilities.js", [g["Core/DefaultOptions.js"], g["Core/Utilities.js"]], function (e, g) {
          function P(m, d, a, p) {
            m = +m || 0;
            d = +d;
            var B = y.lang,
                l = (m.toString().split(".")[1] || "").split("e")[0].length,
                h = m.toString().split("e"),
                f = d;
            if (-1 === d) d = Math.min(l, 20);else if (!G(d)) d = 2;else if (d && h[1] && 0 > h[1]) {
              var k = d + +h[1];
              0 <= k ? (h[0] = (+h[0]).toExponential(k).split("e")[0], d = k) : (h[0] = h[0].split(".")[0] || 0, m = 20 > d ? (h[0] * Math.pow(10, h[1])).toFixed(d) : 0, h[1] = 0);
            }
            k = (Math.abs(h[1] ? h[0] : m) + Math.pow(10, -Math.max(d, l) - 1)).toFixed(d);
            l = String(r(k));
            var J = 3 < l.length ? l.length % 3 : 0;
            a = x(a, B.decimalPoint);
            p = x(p, B.thousandsSep);
            m = (0 > m ? "-" : "") + (J ? l.substr(0, J) + p : "");
            m = 0 > +h[1] && !f ? "0" : m + l.substr(J).replace(/(\d{3})(?=\d)/g, "$1" + p);
            d && (m += a + k.slice(-d));
            h[1] && 0 !== +m && (m += "e" + h[1]);
            return m;
          }

          var y = e.defaultOptions,
              E = e.defaultTime,
              v = g.getNestedProperty,
              G = g.isNumber,
              x = g.pick,
              r = g.pInt;
          return {
            dateFormat: function dateFormat(m, d, a) {
              return E.dateFormat(m, d, a);
            },
            format: function format(m, d, a) {
              var p = "{",
                  B = !1,
                  l = /f$/,
                  h = /\.([0-9])/,
                  f = y.lang,
                  k = a && a.time || E;
              a = a && a.numberFormatter || P;

              for (var J = []; m;) {
                var K = m.indexOf(p);
                if (-1 === K) break;
                var t = m.slice(0, K);

                if (B) {
                  t = t.split(":");
                  p = v(t.shift() || "", d);
                  if (t.length && "number" === typeof p) if (t = t.join(":"), l.test(t)) {
                    var r = parseInt((t.match(h) || ["", "-1"])[1], 10);
                    null !== p && (p = a(p, r, f.decimalPoint, -1 < t.indexOf(",") ? f.thousandsSep : ""));
                  } else p = k.dateFormat(t, p);
                  J.push(p);
                } else J.push(t);

                m = m.slice(K + 1);
                p = (B = !B) ? "}" : "{";
              }

              J.push(m);
              return J.join("");
            },
            numberFormat: P
          };
        });
        M(g, "Core/Renderer/RendererUtilities.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.clamp,
              C = e.pick,
              y = e.stableSort,
              E;

          (function (e) {
            function v(e, r, m) {
              var d = e,
                  a = d.reducedLen || r,
                  p = function p(a, f) {
                return (f.rank || 0) - (a.rank || 0);
              },
                  B = function B(a, f) {
                return a.target - f.target;
              },
                  l,
                  h = !0,
                  f = [],
                  k = 0;

              for (l = e.length; l--;) {
                k += e[l].size;
              }

              if (k > a) {
                y(e, p);

                for (k = l = 0; k <= a;) {
                  k += e[l].size, l++;
                }

                f = e.splice(l - 1, e.length);
              }

              y(e, B);

              for (e = e.map(function (a) {
                return {
                  size: a.size,
                  targets: [a.target],
                  align: C(a.align, .5)
                };
              }); h;) {
                for (l = e.length; l--;) {
                  a = e[l], p = (Math.min.apply(0, a.targets) + Math.max.apply(0, a.targets)) / 2, a.pos = g(p - a.size * a.align, 0, r - a.size);
                }

                l = e.length;

                for (h = !1; l--;) {
                  0 < l && e[l - 1].pos + e[l - 1].size > e[l].pos && (e[l - 1].size += e[l].size, e[l - 1].targets = e[l - 1].targets.concat(e[l].targets), e[l - 1].align = .5, e[l - 1].pos + e[l - 1].size > r && (e[l - 1].pos = r - e[l - 1].size), e.splice(l, 1), h = !0);
                }
              }

              d.push.apply(d, f);
              l = 0;
              e.some(function (a) {
                var f = 0;
                return (a.targets || []).some(function () {
                  d[l].pos = a.pos + f;
                  if ("undefined" !== typeof m && Math.abs(d[l].pos - d[l].target) > m) return d.slice(0, l + 1).forEach(function (a) {
                    return delete a.pos;
                  }), d.reducedLen = (d.reducedLen || r) - .1 * r, d.reducedLen > .1 * r && v(d, r, m), !0;
                  f += d[l].size;
                  l++;
                  return !1;
                });
              });
              y(d, B);
              return d;
            }

            e.distribute = v;
          })(E || (E = {}));

          return E;
        });
        M(g, "Core/Renderer/SVG/SVGElement.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Renderer/HTML/AST.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Color/Palette.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v) {
          var G = e.animate,
              x = e.animObject,
              r = e.stop,
              m = y.deg2rad,
              d = y.doc,
              a = y.noop,
              p = y.svg,
              B = y.SVG_NS,
              l = y.win,
              h = v.addEvent,
              f = v.attr,
              k = v.createElement,
              J = v.css,
              K = v.defined,
              t = v.erase,
              Q = v.extend,
              z = v.fireEvent,
              A = v.isArray,
              c = v.isFunction,
              b = v.isNumber,
              D = v.isString,
              L = v.merge,
              I = v.objectEach,
              n = v.pick,
              u = v.pInt,
              N = v.syncTimeout,
              w = v.uniqueKey;

          e = function () {
            function H() {
              this.element = void 0;
              this.onEvents = {};
              this.opacity = 1;
              this.renderer = void 0;
              this.SVG_NS = B;
              this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }

            H.prototype._defaultGetter = function (b) {
              b = n(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
              /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
              return b;
            };

            H.prototype._defaultSetter = function (b, c, q) {
              q.setAttribute(c, b);
            };

            H.prototype.add = function (b) {
              var c = this.renderer,
                  q = this.element;
              b && (this.parentGroup = b);
              this.parentInverted = b && b.inverted;
              "undefined" !== typeof this.textStr && "text" === this.element.nodeName && c.buildText(this);
              this.added = !0;
              if (!b || b.handleZ || this.zIndex) var F = this.zIndexSetter();
              F || (b ? b.element : c.box).appendChild(q);
              if (this.onAdd) this.onAdd();
              return this;
            };

            H.prototype.addClass = function (b, c) {
              var q = c ? "" : this.attr("class") || "";
              b = (b || "").split(/ /g).reduce(function (b, c) {
                -1 === q.indexOf(c) && b.push(c);
                return b;
              }, q ? [q] : []).join(" ");
              b !== q && this.attr("class", b);
              return this;
            };

            H.prototype.afterSetters = function () {
              this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };

            H.prototype.align = function (b, c, q) {
              var F = {},
                  a = this.renderer,
                  f = a.alignedObjects,
                  u,
                  k,
                  O;

              if (b) {
                if (this.alignOptions = b, this.alignByTranslate = c, !q || D(q)) this.alignTo = u = q || "renderer", t(f, this), f.push(this), q = void 0;
              } else b = this.alignOptions, c = this.alignByTranslate, u = this.alignTo;

              q = n(q, a[u], "scrollablePlotBox" === u ? a.plotBox : void 0, a);
              u = b.align;
              var h = b.verticalAlign;
              a = (q.x || 0) + (b.x || 0);
              f = (q.y || 0) + (b.y || 0);
              "right" === u ? k = 1 : "center" === u && (k = 2);
              k && (a += (q.width - (b.width || 0)) / k);
              F[c ? "translateX" : "x"] = Math.round(a);
              "bottom" === h ? O = 1 : "middle" === h && (O = 2);
              O && (f += (q.height - (b.height || 0)) / O);
              F[c ? "translateY" : "y"] = Math.round(f);
              this[this.placed ? "animate" : "attr"](F);
              this.placed = !0;
              this.alignAttr = F;
              return this;
            };

            H.prototype.alignSetter = function (b) {
              var c = {
                left: "start",
                center: "middle",
                right: "end"
              };
              c[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", c[b]));
            };

            H.prototype.animate = function (b, c, q) {
              var F = this,
                  a = x(n(c, this.renderer.globalAnimation, !0));
              c = a.defer;
              n(d.hidden, d.msHidden, d.webkitHidden, !1) && (a.duration = 0);
              0 !== a.duration ? (q && (a.complete = q), N(function () {
                F.element && G(F, b, a);
              }, c)) : (this.attr(b, void 0, q), I(b, function (b, c) {
                a.step && a.step.call(this, b, {
                  prop: c,
                  pos: 1,
                  elem: this
                });
              }, this));
              return this;
            };

            H.prototype.applyTextOutline = function (b) {
              var c = this.element;
              -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));
              var q = b.split(" ");
              b = q[q.length - 1];

              if ((q = q[0]) && "none" !== q && y.svg) {
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                q = q.replace(/(^[\d\.]+)(.*?)$/g, function (b, c, q) {
                  return 2 * Number(c) + q;
                });
                this.removeTextOutline();
                var F = d.createElementNS(B, "tspan");
                f(F, {
                  "class": "highcharts-text-outline",
                  fill: b,
                  stroke: b,
                  "stroke-width": q,
                  "stroke-linejoin": "round"
                });
                [].forEach.call(c.childNodes, function (b) {
                  var c = b.cloneNode(!0);
                  c.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
                    return c.removeAttribute(b);
                  });
                  F.appendChild(c);
                });
                var a = d.createElementNS(B, "tspan");
                a.textContent = "\u200B";
                ["x", "y"].forEach(function (b) {
                  var q = c.getAttribute(b);
                  q && a.setAttribute(b, q);
                });
                F.appendChild(a);
                c.insertBefore(F, c.firstChild);
              }
            };

            H.prototype.attr = function (b, c, q, F) {
              var a = this.element,
                  n = this.symbolCustomAttribs,
                  f,
                  u = this,
                  k,
                  h;

              if ("string" === typeof b && "undefined" !== typeof c) {
                var w = b;
                b = {};
                b[w] = c;
              }

              "string" === typeof b ? u = (this[b + "Getter"] || this._defaultGetter).call(this, b, a) : (I(b, function (c, q) {
                k = !1;
                F || r(this, q);
                this.symbolName && -1 !== n.indexOf(q) && (f || (this.symbolAttr(b), f = !0), k = !0);
                !this.rotation || "x" !== q && "y" !== q || (this.doTransform = !0);
                k || (h = this[q + "Setter"] || this._defaultSetter, h.call(this, c, q, a), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(q) && this.updateShadows(q, c, h));
              }, this), this.afterSetters());
              q && q.call(this);
              return u;
            };

            H.prototype.clip = function (b) {
              return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
            };

            H.prototype.crisp = function (b, c) {
              c = c || b.strokeWidth || 0;
              var q = Math.round(c) % 2 / 2;
              b.x = Math.floor(b.x || this.x || 0) + q;
              b.y = Math.floor(b.y || this.y || 0) + q;
              b.width = Math.floor((b.width || this.width || 0) - 2 * q);
              b.height = Math.floor((b.height || this.height || 0) - 2 * q);
              K(b.strokeWidth) && (b.strokeWidth = c);
              return b;
            };

            H.prototype.complexColor = function (b, c, q) {
              var F = this.renderer,
                  a,
                  n,
                  f,
                  u,
                  k,
                  h,
                  D,
                  d,
                  t,
                  O,
                  l = [],
                  p;
              z(this.renderer, "complexColor", {
                args: arguments
              }, function () {
                b.radialGradient ? n = "radialGradient" : b.linearGradient && (n = "linearGradient");

                if (n) {
                  f = b[n];
                  k = F.gradients;
                  h = b.stops;
                  t = q.radialReference;
                  A(f) && (b[n] = f = {
                    x1: f[0],
                    y1: f[1],
                    x2: f[2],
                    y2: f[3],
                    gradientUnits: "userSpaceOnUse"
                  });
                  "radialGradient" === n && t && !K(f.gradientUnits) && (u = f, f = L(f, F.getRadialAttr(t, u), {
                    gradientUnits: "userSpaceOnUse"
                  }));
                  I(f, function (b, c) {
                    "id" !== c && l.push(c, b);
                  });
                  I(h, function (b) {
                    l.push(b);
                  });
                  l = l.join(",");
                  if (k[l]) O = k[l].attr("id");else {
                    f.id = O = w();
                    var S = k[l] = F.createElement(n).attr(f).add(F.defs);
                    S.radAttr = u;
                    S.stops = [];
                    h.forEach(function (b) {
                      0 === b[1].indexOf("rgba") ? (a = C.parse(b[1]), D = a.get("rgb"), d = a.get("a")) : (D = b[1], d = 1);
                      b = F.createElement("stop").attr({
                        offset: b[0],
                        "stop-color": D,
                        "stop-opacity": d
                      }).add(S);
                      S.stops.push(b);
                    });
                  }
                  p = "url(" + F.url + "#" + O + ")";
                  q.setAttribute(c, p);
                  q.gradient = l;

                  b.toString = function () {
                    return p;
                  };
                }
              });
            };

            H.prototype.css = function (b) {
              var c = this.styles,
                  q = {},
                  F = this.element,
                  a = ["textOutline", "textOverflow", "width"],
                  n = "",
                  k = !c;
              b && b.color && (b.fill = b.color);
              c && I(b, function (b, F) {
                c && c[F] !== b && (q[F] = b, k = !0);
              });

              if (k) {
                c && (b = Q(c, q));
                if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === F.nodeName.toLowerCase() && b.width) var h = this.textWidth = u(b.width);
                this.styles = b;
                h && !p && this.renderer.forExport && delete b.width;

                if (F.namespaceURI === this.SVG_NS) {
                  var w = function w(b, c) {
                    return "-" + c.toLowerCase();
                  };

                  I(b, function (b, c) {
                    -1 === a.indexOf(c) && (n += c.replace(/([A-Z])/g, w) + ":" + b + ";");
                  });
                  n && f(F, "style", n);
                } else J(F, b);

                this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
              }

              return this;
            };

            H.prototype.dashstyleSetter = function (b) {
              var c = this["stroke-width"];
              "inherit" === c && (c = 1);

              if (b = b && b.toLowerCase()) {
                var q = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

                for (b = q.length; b--;) {
                  q[b] = "" + u(q[b]) * n(c, NaN);
                }

                b = q.join(",").replace(/NaN/g, "none");
                this.element.setAttribute("stroke-dasharray", b);
              }
            };

            H.prototype.destroy = function () {
              var b = this,
                  c = b.element || {},
                  q = b.renderer,
                  F = c.ownerSVGElement,
                  a = q.isSVG && "SPAN" === c.nodeName && b.parentGroup || void 0;
              c.onclick = c.onmouseout = c.onmouseover = c.onmousemove = c.point = null;
              r(b);

              if (b.clipPath && F) {
                var n = b.clipPath;
                [].forEach.call(F.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
                  -1 < b.getAttribute("clip-path").indexOf(n.element.id) && b.removeAttribute("clip-path");
                });
                b.clipPath = n.destroy();
              }

              if (b.stops) {
                for (F = 0; F < b.stops.length; F++) {
                  b.stops[F].destroy();
                }

                b.stops.length = 0;
                b.stops = void 0;
              }

              b.safeRemoveChild(c);

              for (q.styledMode || b.destroyShadows(); a && a.div && 0 === a.div.childNodes.length;) {
                c = a.parentGroup, b.safeRemoveChild(a.div), delete a.div, a = c;
              }

              b.alignTo && t(q.alignedObjects, b);
              I(b, function (c, q) {
                b[q] && b[q].parentGroup === b && b[q].destroy && b[q].destroy();
                delete b[q];
              });
            };

            H.prototype.destroyShadows = function () {
              (this.shadows || []).forEach(function (b) {
                this.safeRemoveChild(b);
              }, this);
              this.shadows = void 0;
            };

            H.prototype.destroyTextPath = function (b, c) {
              var q = b.getElementsByTagName("text")[0];

              if (q) {
                if (q.removeAttribute("dx"), q.removeAttribute("dy"), c.element.setAttribute("id", ""), this.textPathWrapper && q.getElementsByTagName("textPath").length) {
                  for (b = this.textPathWrapper.element.childNodes; b.length;) {
                    q.appendChild(b[0]);
                  }

                  q.removeChild(this.textPathWrapper.element);
                }
              } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");

              this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };

            H.prototype.dSetter = function (b, c, q) {
              A(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, c, q) {
                return c && c.join ? (q ? b + " " : "") + c.join(" ") : (c || "").toString();
              }, ""));
              /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
              this[c] !== b && (q.setAttribute(c, b), this[c] = b);
            };

            H.prototype.fadeOut = function (b) {
              var c = this;
              c.animate({
                opacity: 0
              }, {
                duration: n(b, 150),
                complete: function complete() {
                  c.attr({
                    y: -9999
                  }).hide();
                }
              });
            };

            H.prototype.fillSetter = function (b, c, q) {
              "string" === typeof b ? q.setAttribute(c, b) : b && this.complexColor(b, c, q);
            };

            H.prototype.getBBox = function (b, a) {
              var q = this.renderer,
                  F = this.element,
                  f = this.styles,
                  u = this.textStr,
                  k = q.cache,
                  h = q.cacheKeys,
                  w = F.namespaceURI === this.SVG_NS;
              a = n(a, this.rotation, 0);
              var A = q.styledMode ? F && H.prototype.getStyle.call(F, "font-size") : f && f.fontSize,
                  D;

              if (K(u)) {
                var d = u.toString();
                -1 === d.indexOf("<") && (d = d.replace(/[0-9]/g, "0"));
                d += ["", a, A, this.textWidth, f && f.textOverflow, f && f.fontWeight].join();
              }

              d && !b && (D = k[d]);

              if (!D) {
                if (w || q.forExport) {
                  try {
                    var t = this.fakeTS && function (b) {
                      var c = F.querySelector(".highcharts-text-outline");
                      c && J(c, {
                        display: b
                      });
                    };

                    c(t) && t("none");
                    D = F.getBBox ? Q({}, F.getBBox()) : {
                      width: F.offsetWidth,
                      height: F.offsetHeight
                    };
                    c(t) && t("");
                  } catch (W) {
                    "";
                  }

                  if (!D || 0 > D.width) D = {
                    width: 0,
                    height: 0
                  };
                } else D = this.htmlGetBBox();

                q.isSVG && (b = D.width, q = D.height, w && (D.height = q = {
                  "11px,17": 14,
                  "13px,20": 16
                }[f && f.fontSize + "," + Math.round(q)] || q), a && (f = a * m, D.width = Math.abs(q * Math.sin(f)) + Math.abs(b * Math.cos(f)), D.height = Math.abs(q * Math.cos(f)) + Math.abs(b * Math.sin(f))));

                if (d && ("" === u || 0 < D.height)) {
                  for (; 250 < h.length;) {
                    delete k[h.shift()];
                  }

                  k[d] || h.push(d);
                  k[d] = D;
                }
              }

              return D;
            };

            H.prototype.getStyle = function (b) {
              return l.getComputedStyle(this.element || this, "").getPropertyValue(b);
            };

            H.prototype.hasClass = function (b) {
              return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
            };

            H.prototype.hide = function (b) {
              b ? this.attr({
                y: -9999
              }) : this.attr({
                visibility: "hidden"
              });
              return this;
            };

            H.prototype.htmlGetBBox = function () {
              return {
                height: 0,
                width: 0,
                x: 0,
                y: 0
              };
            };

            H.prototype.init = function (b, c) {
              this.element = "span" === c ? k(c) : d.createElementNS(this.SVG_NS, c);
              this.renderer = b;
              z(this, "afterInit");
            };

            H.prototype.invert = function (b) {
              this.inverted = b;
              this.updateTransform();
              return this;
            };

            H.prototype.on = function (b, c) {
              var q = this.onEvents;
              if (q[b]) q[b]();
              q[b] = h(this.element, b, c);
              return this;
            };

            H.prototype.opacitySetter = function (b, c, q) {
              this.opacity = b = Number(Number(b).toFixed(3));
              q.setAttribute(c, b);
            };

            H.prototype.removeClass = function (b) {
              return this.attr("class", ("" + this.attr("class")).replace(D(b) ? new RegExp("(^| )" + b + "( |$)") : b, " ").replace(/ +/g, " ").trim());
            };

            H.prototype.removeTextOutline = function () {
              var b = this.element.querySelector("tspan.highcharts-text-outline");
              b && this.safeRemoveChild(b);
            };

            H.prototype.safeRemoveChild = function (b) {
              var c = b.parentNode;
              c && c.removeChild(b);
            };

            H.prototype.setRadialReference = function (b) {
              var c = this.element.gradient && this.renderer.gradients[this.element.gradient];
              this.element.radialReference = b;
              c && c.radAttr && c.animate(this.renderer.getRadialAttr(b, c.radAttr));
              return this;
            };

            H.prototype.setTextPath = function (c, n) {
              var q = this.element,
                  F = this.text ? this.text.element : q,
                  f = {
                textAnchor: "text-anchor"
              },
                  u = !1,
                  k = this.textPathWrapper,
                  h = !k;
              n = L(!0, {
                enabled: !0,
                attributes: {
                  dy: -5,
                  startOffset: "50%",
                  textAnchor: "middle"
                }
              }, n);
              var D = g.filterUserAttributes(n.attributes);

              if (c && n && n.enabled) {
                k && null === k.element.parentNode ? (h = !0, k = k.destroy()) : k && this.removeTextOutline.call(k.parentGroup);
                this.options && this.options.padding && (D.dx = -this.options.padding);
                k || (this.textPathWrapper = k = this.renderer.createElement("textPath"), u = !0);
                var d = k.element;
                (n = c.element.getAttribute("id")) || c.element.setAttribute("id", n = w());
                if (h) for (F.setAttribute("y", 0), b(D.dx) && F.setAttribute("x", -D.dx), c = [].slice.call(F.childNodes), h = 0; h < c.length; h++) {
                  var A = c[h];
                  A.nodeType !== Node.TEXT_NODE && "tspan" !== A.nodeName || d.appendChild(A);
                }
                u && k && k.add({
                  element: F
                });
                d.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + n);
                K(D.dy) && (d.parentNode.setAttribute("dy", D.dy), delete D.dy);
                K(D.dx) && (d.parentNode.setAttribute("dx", D.dx), delete D.dx);
                I(D, function (b, c) {
                  d.setAttribute(f[c] || c, b);
                });
                q.removeAttribute("transform");
                this.removeTextOutline.call(k);
                this.text && !this.renderer.styledMode && this.attr({
                  fill: "none",
                  "stroke-width": 0
                });
                this.applyTextOutline = this.updateTransform = a;
              } else k && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(q, c), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

              return this;
            };

            H.prototype.shadow = function (b, c, q) {
              var F = [],
                  a = this.element,
                  n = this.oldShadowOptions,
                  k = {
                color: E.neutralColor100,
                offsetX: this.parentInverted ? -1 : 1,
                offsetY: this.parentInverted ? -1 : 1,
                opacity: .15,
                width: 3
              },
                  u = !1,
                  h;
              !0 === b ? h = k : "object" === typeof b && (h = Q(k, b));
              h && (h && n && I(h, function (b, c) {
                b !== n[c] && (u = !0);
              }), u && this.destroyShadows(), this.oldShadowOptions = h);
              if (!h) this.destroyShadows();else if (!this.shadows) {
                var D = h.opacity / h.width;
                var w = this.parentInverted ? "translate(" + h.offsetY + ", " + h.offsetX + ")" : "translate(" + h.offsetX + ", " + h.offsetY + ")";

                for (k = 1; k <= h.width; k++) {
                  var d = a.cloneNode(!1);
                  var A = 2 * h.width + 1 - 2 * k;
                  f(d, {
                    stroke: b.color || E.neutralColor100,
                    "stroke-opacity": D * k,
                    "stroke-width": A,
                    transform: w,
                    fill: "none"
                  });
                  d.setAttribute("class", (d.getAttribute("class") || "") + " highcharts-shadow");
                  q && (f(d, "height", Math.max(f(d, "height") - A, 0)), d.cutHeight = A);
                  c ? c.element.appendChild(d) : a.parentNode && a.parentNode.insertBefore(d, a);
                  F.push(d);
                }

                this.shadows = F;
              }
              return this;
            };

            H.prototype.show = function (b) {
              return this.attr({
                visibility: b ? "inherit" : "visible"
              });
            };

            H.prototype.strokeSetter = function (b, c, q) {
              this[c] = b;
              this.stroke && this["stroke-width"] ? (H.prototype.fillSetter.call(this, this.stroke, "stroke", q), q.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === c && 0 === b && this.hasStroke ? (q.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (q.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
            };

            H.prototype.strokeWidth = function () {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              var b = this.getStyle("stroke-width"),
                  c = 0;
              if (b.indexOf("px") === b.length - 2) c = u(b);else if ("" !== b) {
                var q = d.createElementNS(B, "rect");
                f(q, {
                  width: b,
                  "stroke-width": 0
                });
                this.element.parentNode.appendChild(q);
                c = q.getBBox().width;
                q.parentNode.removeChild(q);
              }
              return c;
            };

            H.prototype.symbolAttr = function (b) {
              var c = this;
              "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (q) {
                c[q] = n(b[q], c[q]);
              });
              c.attr({
                d: c.renderer.symbols[c.symbolName](c.x, c.y, c.width, c.height, c)
              });
            };

            H.prototype.textSetter = function (b) {
              b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
            };

            H.prototype.titleSetter = function (b) {
              var c = this.element,
                  q = c.getElementsByTagName("title")[0] || d.createElementNS(this.SVG_NS, "title");
              c.insertBefore ? c.insertBefore(q, c.firstChild) : c.appendChild(q);
              q.textContent = String(n(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };

            H.prototype.toFront = function () {
              var b = this.element;
              b.parentNode.appendChild(b);
              return this;
            };

            H.prototype.translate = function (b, c) {
              return this.attr({
                translateX: b,
                translateY: c
              });
            };

            H.prototype.updateShadows = function (b, c, q) {
              var F = this.shadows;
              if (F) for (var a = F.length; a--;) {
                q.call(F[a], "height" === b ? Math.max(c - (F[a].cutHeight || 0), 0) : "d" === b ? this.d : c, b, F[a]);
              }
            };

            H.prototype.updateTransform = function () {
              var b = this.scaleX,
                  c = this.scaleY,
                  q = this.inverted,
                  F = this.rotation,
                  a = this.matrix,
                  f = this.element,
                  k = this.translateX || 0,
                  u = this.translateY || 0;
              q && (k += this.width, u += this.height);
              k = ["translate(" + k + "," + u + ")"];
              K(a) && k.push("matrix(" + a.join(",") + ")");
              q ? k.push("rotate(90) scale(-1,1)") : F && k.push("rotate(" + F + " " + n(this.rotationOriginX, f.getAttribute("x"), 0) + " " + n(this.rotationOriginY, f.getAttribute("y") || 0) + ")");
              (K(b) || K(c)) && k.push("scale(" + n(b, 1) + " " + n(c, 1) + ")");
              k.length && f.setAttribute("transform", k.join(" "));
            };

            H.prototype.visibilitySetter = function (b, c, q) {
              "inherit" === b ? q.removeAttribute(c) : this[c] !== b && q.setAttribute(c, b);
              this[c] = b;
            };

            H.prototype.xGetter = function (b) {
              "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
              return this._defaultGetter(b);
            };

            H.prototype.zIndexSetter = function (b, c) {
              var q = this.renderer,
                  F = this.parentGroup,
                  a = (F || q).element || q.box,
                  n = this.element;
              q = a === q.box;
              var f = !1;
              var k = this.added;
              var h;
              K(b) ? (n.setAttribute("data-z-index", b), b = +b, this[c] === b && (k = !1)) : K(this[c]) && n.removeAttribute("data-z-index");
              this[c] = b;

              if (k) {
                (b = this.zIndex) && F && (F.handleZ = !0);
                c = a.childNodes;

                for (h = c.length - 1; 0 <= h && !f; h--) {
                  F = c[h];
                  k = F.getAttribute("data-z-index");
                  var D = !K(k);
                  if (F !== n) if (0 > b && D && !q && !h) a.insertBefore(n, c[h]), f = !0;else if (u(k) <= b || D && (!K(b) || 0 <= b)) a.insertBefore(n, c[h + 1] || null), f = !0;
                }

                f || (a.insertBefore(n, c[q ? 3 : 0] || null), f = !0);
              }

              return f;
            };

            return H;
          }();

          e.prototype["stroke-widthSetter"] = e.prototype.strokeSetter;
          e.prototype.yGetter = e.prototype.xGetter;

          e.prototype.matrixSetter = e.prototype.rotationOriginXSetter = e.prototype.rotationOriginYSetter = e.prototype.rotationSetter = e.prototype.scaleXSetter = e.prototype.scaleYSetter = e.prototype.translateXSetter = e.prototype.translateYSetter = e.prototype.verticalAlignSetter = function (b, c) {
            this[c] = b;
            this.doTransform = !0;
          };

          "";
          return e;
        });
        M(g, "Core/Renderer/RendererRegistry.js", [g["Core/Globals.js"]], function (e) {
          var g;

          (function (g) {
            g.rendererTypes = {};
            var P;

            g.getRendererType = function (e) {
              void 0 === e && (e = P);
              return g.rendererTypes[e] || g.rendererTypes[P];
            };

            g.registerRendererType = function (y, v, G) {
              g.rendererTypes[y] = v;
              if (!P || G) P = y, e.Renderer = v;
            };
          })(g || (g = {}));

          return g;
        });
        M(g, "Core/Renderer/SVG/SVGLabel.js", [g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (e, g) {
          var P = this && this.__extends || function () {
            var _m = function m(d, a) {
              _m = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var l in d) {
                  d.hasOwnProperty(l) && (a[l] = d[l]);
                }
              };

              return _m(d, a);
            };

            return function (d, a) {
              function p() {
                this.constructor = d;
              }

              _m(d, a);

              d.prototype = null === a ? Object.create(a) : (p.prototype = a.prototype, new p());
            };
          }(),
              y = g.defined,
              E = g.extend,
              v = g.isNumber,
              G = g.merge,
              x = g.pick,
              r = g.removeEvent;

          return function (m) {
            function d(a, p, B, l, h, f, k, r, K, t) {
              var J = m.call(this) || this;
              J.paddingLeftSetter = J.paddingSetter;
              J.paddingRightSetter = J.paddingSetter;
              J.init(a, "g");
              J.textStr = p;
              J.x = B;
              J.y = l;
              J.anchorX = f;
              J.anchorY = k;
              J.baseline = K;
              J.className = t;
              J.addClass("button" === t ? "highcharts-no-tooltip" : "highcharts-label");
              t && J.addClass("highcharts-" + t);
              J.text = a.text(void 0, 0, 0, r).attr({
                zIndex: 1
              });
              var z;
              "string" === typeof h && ((z = /^url\((.*?)\)$/.test(h)) || J.renderer.symbols[h]) && (J.symbolKey = h);
              J.bBox = d.emptyBBox;
              J.padding = 3;
              J.baselineOffset = 0;
              J.needsBox = a.styledMode || z;
              J.deferredAttr = {};
              J.alignFactor = 0;
              return J;
            }

            P(d, m);

            d.prototype.alignSetter = function (a) {
              a = {
                left: 0,
                center: .5,
                right: 1
              }[a];
              a !== this.alignFactor && (this.alignFactor = a, this.bBox && v(this.xSetting) && this.attr({
                x: this.xSetting
              }));
            };

            d.prototype.anchorXSetter = function (a, d) {
              this.anchorX = a;
              this.boxAttr(d, Math.round(a) - this.getCrispAdjust() - this.xSetting);
            };

            d.prototype.anchorYSetter = function (a, d) {
              this.anchorY = a;
              this.boxAttr(d, a - this.ySetting);
            };

            d.prototype.boxAttr = function (a, d) {
              this.box ? this.box.attr(a, d) : this.deferredAttr[a] = d;
            };

            d.prototype.css = function (a) {
              if (a) {
                var p = {};
                a = G(a);
                d.textProps.forEach(function (d) {
                  "undefined" !== typeof a[d] && (p[d] = a[d], delete a[d]);
                });
                this.text.css(p);
                var m = ("width" in p);
                "fontSize" in p || "fontWeight" in p ? this.updateTextPadding() : m && this.updateBoxSize();
              }

              return e.prototype.css.call(this, a);
            };

            d.prototype.destroy = function () {
              r(this.element, "mouseenter");
              r(this.element, "mouseleave");
              this.text && this.text.destroy();
              this.box && (this.box = this.box.destroy());
              e.prototype.destroy.call(this);
            };

            d.prototype.fillSetter = function (a, d) {
              a && (this.needsBox = !0);
              this.fill = a;
              this.boxAttr(d, a);
            };

            d.prototype.getBBox = function () {
              this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
              var a = this.padding,
                  d = x(this.paddingLeft, a);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - d,
                y: this.bBox.y - a
              };
            };

            d.prototype.getCrispAdjust = function () {
              return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };

            d.prototype.heightSetter = function (a) {
              this.heightSetting = a;
            };

            d.prototype.onAdd = function () {
              var a = this.textStr;
              this.text.add(this);
              this.attr({
                text: y(a) ? a : "",
                x: this.x,
                y: this.y
              });
              this.box && y(this.anchorX) && this.attr({
                anchorX: this.anchorX,
                anchorY: this.anchorY
              });
            };

            d.prototype.paddingSetter = function (a, d) {
              v(a) ? a !== this[d] && (this[d] = a, this.updateTextPadding()) : this[d] = void 0;
            };

            d.prototype.rSetter = function (a, d) {
              this.boxAttr(d, a);
            };

            d.prototype.shadow = function (a) {
              a && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(a));
              return this;
            };

            d.prototype.strokeSetter = function (a, d) {
              this.stroke = a;
              this.boxAttr(d, a);
            };

            d.prototype["stroke-widthSetter"] = function (a, d) {
              a && (this.needsBox = !0);
              this["stroke-width"] = a;
              this.boxAttr(d, a);
            };

            d.prototype["text-alignSetter"] = function (a) {
              this.textAlign = a;
            };

            d.prototype.textSetter = function (a) {
              "undefined" !== typeof a && this.text.attr({
                text: a
              });
              this.updateTextPadding();
            };

            d.prototype.updateBoxSize = function () {
              var a = this.text.element.style,
                  p = {},
                  m = this.padding,
                  l = this.bBox = v(this.widthSetting) && v(this.heightSetting) && !this.textAlign || !y(this.text.textStr) ? d.emptyBBox : this.text.getBBox();
              this.width = this.getPaddedWidth();
              this.height = (this.heightSetting || l.height || 0) + 2 * m;
              a = this.renderer.fontMetrics(a && a.fontSize, this.text);
              this.baselineOffset = m + Math.min((this.text.firstLineMetrics || a).b, l.height || Infinity);
              this.heightSetting && (this.baselineOffset += (this.heightSetting - a.h) / 2);
              this.needsBox && (this.box || (m = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), m.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), m.add(this)), m = this.getCrispAdjust(), p.x = m, p.y = (this.baseline ? -this.baselineOffset : 0) + m, p.width = Math.round(this.width), p.height = Math.round(this.height), this.box.attr(E(p, this.deferredAttr)), this.deferredAttr = {});
            };

            d.prototype.updateTextPadding = function () {
              var a = this.text;
              this.updateBoxSize();
              var d = this.baseline ? 0 : this.baselineOffset,
                  m = x(this.paddingLeft, this.padding);
              y(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (m += {
                center: .5,
                right: 1
              }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (m !== a.x || d !== a.y) a.attr("x", m), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), "undefined" !== typeof d && a.attr("y", d);
              a.x = m;
              a.y = d;
            };

            d.prototype.widthSetter = function (a) {
              this.widthSetting = v(a) ? a : void 0;
            };

            d.prototype.getPaddedWidth = function () {
              var a = this.padding,
                  d = x(this.paddingLeft, a);
              a = x(this.paddingRight, a);
              return (this.widthSetting || this.bBox.width || 0) + d + a;
            };

            d.prototype.xSetter = function (a) {
              this.x = a;
              this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
              this.xSetting = Math.round(a);
              this.attr("translateX", this.xSetting);
            };

            d.prototype.ySetter = function (a) {
              this.ySetting = this.y = Math.round(a);
              this.attr("translateY", this.ySetting);
            };

            d.emptyBBox = {
              width: 0,
              height: 0,
              x: 0,
              y: 0
            };
            d.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return d;
          }(e);
        });
        M(g, "Core/Renderer/SVG/Symbols.js", [g["Core/Utilities.js"]], function (e) {
          function g(e, r, m, d, a) {
            var p = [];

            if (a) {
              var B = a.start || 0,
                  l = G(a.r, m);
              m = G(a.r, d || m);
              var h = (a.end || 0) - .001;
              d = a.innerR;
              var f = G(a.open, .001 > Math.abs((a.end || 0) - B - 2 * Math.PI)),
                  k = Math.cos(B),
                  J = Math.sin(B),
                  K = Math.cos(h),
                  t = Math.sin(h);
              B = G(a.longArc, .001 > h - B - Math.PI ? 0 : 1);
              p.push(["M", e + l * k, r + m * J], ["A", l, m, 0, B, G(a.clockwise, 1), e + l * K, r + m * t]);
              E(d) && p.push(f ? ["M", e + d * K, r + d * t] : ["L", e + d * K, r + d * t], ["A", d, d, 0, B, E(a.clockwise) ? 1 - a.clockwise : 0, e + d * k, r + d * J]);
              f || p.push(["Z"]);
            }

            return p;
          }

          function C(e, r, m, d, a) {
            return a && a.r ? y(e, r, m, d, a) : [["M", e, r], ["L", e + m, r], ["L", e + m, r + d], ["L", e, r + d], ["Z"]];
          }

          function y(e, r, m, d, a) {
            a = a && a.r || 0;
            return [["M", e + a, r], ["L", e + m - a, r], ["C", e + m, r, e + m, r, e + m, r + a], ["L", e + m, r + d - a], ["C", e + m, r + d, e + m, r + d, e + m - a, r + d], ["L", e + a, r + d], ["C", e, r + d, e, r + d, e, r + d - a], ["L", e, r + a], ["C", e, r, e, r, e + a, r]];
          }

          var E = e.defined,
              v = e.isNumber,
              G = e.pick;
          return {
            arc: g,
            callout: function callout(e, r, m, d, a) {
              var p = Math.min(a && a.r || 0, m, d),
                  B = p + 6,
                  l = a && a.anchorX;
              a = a && a.anchorY || 0;
              var h = y(e, r, m, d, {
                r: p
              });
              if (!v(l)) return h;
              e + l >= m ? a > r + B && a < r + d - B ? h.splice(3, 1, ["L", e + m, a - 6], ["L", e + m + 6, a], ["L", e + m, a + 6], ["L", e + m, r + d - p]) : h.splice(3, 1, ["L", e + m, d / 2], ["L", l, a], ["L", e + m, d / 2], ["L", e + m, r + d - p]) : 0 >= e + l ? a > r + B && a < r + d - B ? h.splice(7, 1, ["L", e, a + 6], ["L", e - 6, a], ["L", e, a - 6], ["L", e, r + p]) : h.splice(7, 1, ["L", e, d / 2], ["L", l, a], ["L", e, d / 2], ["L", e, r + p]) : a && a > d && l > e + B && l < e + m - B ? h.splice(5, 1, ["L", l + 6, r + d], ["L", l, r + d + 6], ["L", l - 6, r + d], ["L", e + p, r + d]) : a && 0 > a && l > e + B && l < e + m - B && h.splice(1, 1, ["L", l - 6, r], ["L", l, r - 6], ["L", l + 6, r], ["L", m - p, r]);
              return h;
            },
            circle: function circle(e, r, m, d) {
              return g(e + m / 2, r + d / 2, m / 2, d / 2, {
                start: .5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1
              });
            },
            diamond: function diamond(e, r, m, d) {
              return [["M", e + m / 2, r], ["L", e + m, r + d / 2], ["L", e + m / 2, r + d], ["L", e, r + d / 2], ["Z"]];
            },
            rect: C,
            roundedRect: y,
            square: C,
            triangle: function triangle(e, r, m, d) {
              return [["M", e + m / 2, r], ["L", e + m, r + d], ["L", e, r + d], ["Z"]];
            },
            "triangle-down": function triangleDown(e, r, m, d) {
              return [["M", e, r], ["L", e + m, r], ["L", e + m / 2, r + d], ["Z"]];
            }
          };
        });
        M(g, "Core/Renderer/SVG/TextBuilder.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var P = g.doc,
              E = g.SVG_NS,
              v = C.attr,
              G = C.isString,
              x = C.objectEach,
              r = C.pick;
          return function () {
            function m(d) {
              var a = d.styles;
              this.renderer = d.renderer;
              this.svgElement = d;
              this.width = d.textWidth;
              this.textLineHeight = a && a.lineHeight;
              this.textOutline = a && a.textOutline;
              this.ellipsis = !(!a || "ellipsis" !== a.textOverflow);
              this.noWrap = !(!a || "nowrap" !== a.whiteSpace);
              this.fontSize = a && a.fontSize;
            }

            m.prototype.buildSVG = function () {
              var d = this.svgElement,
                  a = d.element,
                  p = d.renderer,
                  m = r(d.textStr, "").toString(),
                  l = -1 !== m.indexOf("<"),
                  h = a.childNodes;
              p = this.width && !d.added && p.box;
              var f = /<br.*?>/g,
                  k = [m, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();

              if (k !== d.textCache) {
                d.textCache = k;
                delete d.actualWidth;

                for (k = h.length; k--;) {
                  a.removeChild(h[k]);
                }

                l || this.ellipsis || this.width || -1 !== m.indexOf(" ") && (!this.noWrap || f.test(m)) ? "" !== m && (p && p.appendChild(a), m = new e(m), this.modifyTree(m.nodes), m.addToDOM(d.element), this.modifyDOM(), this.ellipsis && -1 !== (a.textContent || "").indexOf("\u2026") && d.attr("title", this.unescapeEntities(d.textStr || "", ["&lt;", "&gt;"])), p && p.removeChild(a)) : a.appendChild(P.createTextNode(this.unescapeEntities(m)));
                G(this.textOutline) && d.applyTextOutline && d.applyTextOutline(this.textOutline);
              }
            };

            m.prototype.modifyDOM = function () {
              var d = this,
                  a = this.svgElement,
                  p = v(a.element, "x");
              a.firstLineMetrics = void 0;

              for (var m; m = a.element.firstChild;) {
                if (/^[\s\u200B]*$/.test(m.textContent || " ")) a.element.removeChild(m);else break;
              }

              [].forEach.call(a.element.querySelectorAll("tspan.highcharts-br"), function (f, h) {
                f.nextSibling && f.previousSibling && (0 === h && 1 === f.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(void 0, f.previousSibling)), v(f, {
                  dy: d.getLineHeight(f.nextSibling),
                  x: p
                }));
              });
              var l = this.width || 0;

              if (l) {
                var h = function h(f, _h) {
                  var k = f.textContent || "",
                      t = k.replace(/([^\^])-/g, "$1- ").split(" "),
                      m = !d.noWrap && (1 < t.length || 1 < a.element.childNodes.length),
                      z = d.getLineHeight(_h),
                      A = 0,
                      c = a.actualWidth;
                  if (d.ellipsis) k && d.truncate(f, k, void 0, 0, Math.max(0, l - parseInt(d.fontSize || 12, 10)), function (b, c) {
                    return b.substring(0, c) + "\u2026";
                  });else if (m) {
                    k = [];

                    for (m = []; _h.firstChild && _h.firstChild !== f;) {
                      m.push(_h.firstChild), _h.removeChild(_h.firstChild);
                    }

                    for (; t.length;) {
                      t.length && !d.noWrap && 0 < A && (k.push(f.textContent || ""), f.textContent = t.join(" ").replace(/- /g, "-")), d.truncate(f, void 0, t, 0 === A ? c || 0 : 0, l, function (b, c) {
                        return t.slice(0, c).join(" ").replace(/- /g, "-");
                      }), c = a.actualWidth, A++;
                    }

                    m.forEach(function (b) {
                      _h.insertBefore(b, f);
                    });
                    k.forEach(function (b) {
                      _h.insertBefore(P.createTextNode(b), f);

                      b = P.createElementNS(E, "tspan");
                      b.textContent = "\u200B";
                      v(b, {
                        dy: z,
                        x: p
                      });

                      _h.insertBefore(b, f);
                    });
                  }
                },
                    f = function f(k) {
                  [].slice.call(k.childNodes).forEach(function (d) {
                    d.nodeType === Node.TEXT_NODE ? h(d, k) : (-1 !== d.className.baseVal.indexOf("highcharts-br") && (a.actualWidth = 0), f(d));
                  });
                };

                f(a.element);
              }
            };

            m.prototype.getLineHeight = function (d) {
              var a;
              d = d.nodeType === Node.TEXT_NODE ? d.parentElement : d;
              this.renderer.styledMode || (a = d && /(px|em)$/.test(d.style.fontSize) ? d.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
              return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a, d || this.svgElement.element).h;
            };

            m.prototype.modifyTree = function (d) {
              var a = this,
                  p = function p(m, l) {
                var h = m.tagName,
                    f = a.renderer.styledMode,
                    k = m.attributes || {};
                if ("b" === h || "strong" === h) f ? k["class"] = "highcharts-strong" : k.style = "font-weight:bold;" + (k.style || "");else if ("i" === h || "em" === h) f ? k["class"] = "highcharts-emphasized" : k.style = "font-style:italic;" + (k.style || "");
                G(k.style) && (k.style = k.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
                "br" === h && (k["class"] = "highcharts-br", m.textContent = "\u200B", (l = d[l + 1]) && l.textContent && (l.textContent = l.textContent.replace(/^ +/gm, "")));
                "#text" !== h && "a" !== h && (m.tagName = "tspan");
                m.attributes = k;
                m.children && m.children.filter(function (a) {
                  return "#text" !== a.tagName;
                }).forEach(p);
              };

              d.forEach(p);
            };

            m.prototype.truncate = function (d, a, p, m, l, h) {
              var f = this.svgElement,
                  k = f.renderer,
                  e = f.rotation,
                  r = [],
                  t = p ? 1 : 0,
                  g = (a || p || "").length,
                  z = g,
                  A,
                  c = function c(b, _c14) {
                _c14 = _c14 || b;
                var D = d.parentNode;
                if (D && "undefined" === typeof r[_c14]) if (D.getSubStringLength) try {
                  r[_c14] = m + D.getSubStringLength(0, p ? _c14 + 1 : _c14);
                } catch (n) {
                  "";
                } else k.getSpanWidth && (d.textContent = h(a || p, b), r[_c14] = m + k.getSpanWidth(f, d));
                return r[_c14];
              };

              f.rotation = 0;
              var b = c(d.textContent.length);

              if (m + b > l) {
                for (; t <= g;) {
                  z = Math.ceil((t + g) / 2), p && (A = h(p, z)), b = c(z, A && A.length - 1), t === g ? t = g + 1 : b > l ? g = z - 1 : t = z;
                }

                0 === g ? d.textContent = "" : a && g === a.length - 1 || (d.textContent = A || h(a || p, z));
              }

              p && p.splice(0, z);
              f.actualWidth = b;
              f.rotation = e;
            };

            m.prototype.unescapeEntities = function (d, a) {
              x(this.renderer.escapes, function (p, m) {
                a && -1 !== a.indexOf(p) || (d = d.toString().replace(new RegExp(p, "g"), m));
              });
              return d;
            };

            return m;
          }();
        });
        M(g, "Core/Renderer/SVG/SVGRenderer.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Color/Palette.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGLabel.js"], g["Core/Renderer/SVG/Symbols.js"], g["Core/Renderer/SVG/TextBuilder.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G, x, r, m) {
          var d = C.charts,
              a = C.deg2rad,
              p = C.doc,
              B = C.isFirefox,
              l = C.isMS,
              h = C.isWebKit,
              f = C.noop,
              k = C.SVG_NS,
              J = C.symbolSizes,
              K = C.win,
              t = m.addEvent,
              Q = m.attr,
              z = m.createElement,
              A = m.css,
              c = m.defined,
              b = m.destroyObjectProperties,
              D = m.extend,
              L = m.isArray,
              I = m.isNumber,
              n = m.isObject,
              u = m.isString,
              N = m.merge,
              w = m.pick,
              H = m.pInt,
              O = m.uniqueKey,
              R;

          C = function () {
            function q(b, c, q, a, f, n, k) {
              this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
              this.init(b, c, q, a, f, n, k);
            }

            q.prototype.init = function (b, c, q, a, f, n, k) {
              var F = this.createElement("svg").attr({
                version: "1.1",
                "class": "highcharts-root"
              }),
                  h = F.element;
              k || F.css(this.getStyle(a));
              b.appendChild(h);
              Q(b, "dir", "ltr");
              -1 === b.innerHTML.indexOf("xmlns") && Q(h, "xmlns", this.SVG_NS);
              this.isSVG = !0;
              this.box = h;
              this.boxWrapper = F;
              this.alignedObjects = [];
              this.url = this.getReferenceURL();
              this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 9.2.2"));
              this.defs = this.createElement("defs").add();
              this.allowHTML = n;
              this.forExport = f;
              this.styledMode = k;
              this.gradients = {};
              this.cache = {};
              this.cacheKeys = [];
              this.imgCount = 0;
              this.setSize(c, q, !1);
              var u;
              B && b.getBoundingClientRect && (c = function c() {
                A(b, {
                  left: 0,
                  top: 0
                });
                u = b.getBoundingClientRect();
                A(b, {
                  left: Math.ceil(u.left) - u.left + "px",
                  top: Math.ceil(u.top) - u.top + "px"
                });
              }, c(), this.unSubPixelFix = t(K, "resize", c));
            };

            q.prototype.definition = function (b) {
              return new e([b]).addToDOM(this.defs.element);
            };

            q.prototype.getReferenceURL = function () {
              if ((B || h) && p.getElementsByTagName("base").length) {
                if (!c(R)) {
                  var b = O();
                  b = new e([{
                    tagName: "svg",
                    attributes: {
                      width: 8,
                      height: 8
                    },
                    children: [{
                      tagName: "defs",
                      children: [{
                        tagName: "clipPath",
                        attributes: {
                          id: b
                        },
                        children: [{
                          tagName: "rect",
                          attributes: {
                            width: 4,
                            height: 4
                          }
                        }]
                      }]
                    }, {
                      tagName: "rect",
                      attributes: {
                        id: "hitme",
                        width: 8,
                        height: 8,
                        "clip-path": "url(#" + b + ")",
                        fill: "rgba(0,0,0,0.001)"
                      }
                    }]
                  }]).addToDOM(p.body);
                  A(b, {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    zIndex: 9E5
                  });
                  var q = p.elementFromPoint(6, 6);
                  R = "hitme" === (q && q.id);
                  p.body.removeChild(b);
                }

                if (R) return K.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
              }

              return "";
            };

            q.prototype.getStyle = function (b) {
              return this.style = D({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
              }, b);
            };

            q.prototype.setStyle = function (b) {
              this.boxWrapper.css(this.getStyle(b));
            };

            q.prototype.isHidden = function () {
              return !this.boxWrapper.getBBox().width;
            };

            q.prototype.destroy = function () {
              var c = this.defs;
              this.box = null;
              this.boxWrapper = this.boxWrapper.destroy();
              b(this.gradients || {});
              this.gradients = null;
              c && (this.defs = c.destroy());
              this.unSubPixelFix && this.unSubPixelFix();
              return this.alignedObjects = null;
            };

            q.prototype.createElement = function (b) {
              var c = new this.Element();
              c.init(this, b);
              return c;
            };

            q.prototype.getRadialAttr = function (b, c) {
              return {
                cx: b[0] - b[2] / 2 + (c.cx || 0) * b[2],
                cy: b[1] - b[2] / 2 + (c.cy || 0) * b[2],
                r: (c.r || 0) * b[2]
              };
            };

            q.prototype.buildText = function (b) {
              new r(b).buildSVG();
            };

            q.prototype.getContrast = function (b) {
              b = g.parse(b).rgba;
              b[0] *= 1;
              b[1] *= 1.2;
              b[2] *= .5;
              return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
            };

            q.prototype.button = function (b, c, q, a, f, n, k, h, u, d) {
              var F = this.label(b, c, q, u, void 0, void 0, d, void 0, "button"),
                  w = this.styledMode,
                  A = 0,
                  z = f ? N(f) : {};
              b = z && z.style || {};
              z = e.filterUserAttributes(z);
              F.attr(N({
                padding: 8,
                r: 2
              }, z));

              if (!w) {
                z = N({
                  fill: y.neutralColor3,
                  stroke: y.neutralColor20,
                  "stroke-width": 1,
                  style: {
                    color: y.neutralColor80,
                    cursor: "pointer",
                    fontWeight: "normal"
                  }
                }, {
                  style: b
                }, z);
                var S = z.style;
                delete z.style;
                n = N(z, {
                  fill: y.neutralColor10
                }, e.filterUserAttributes(n || {}));
                var I = n.style;
                delete n.style;
                k = N(z, {
                  fill: y.highlightColor10,
                  style: {
                    color: y.neutralColor100,
                    fontWeight: "bold"
                  }
                }, e.filterUserAttributes(k || {}));
                var p = k.style;
                delete k.style;
                h = N(z, {
                  style: {
                    color: y.neutralColor20
                  }
                }, e.filterUserAttributes(h || {}));
                var H = h.style;
                delete h.style;
              }

              t(F.element, l ? "mouseover" : "mouseenter", function () {
                3 !== A && F.setState(1);
              });
              t(F.element, l ? "mouseout" : "mouseleave", function () {
                3 !== A && F.setState(A);
              });

              F.setState = function (b) {
                1 !== b && (F.state = A = b);
                F.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
                w || F.attr([z, n, k, h][b || 0]).css([S, I, p, H][b || 0]);
              };

              w || F.attr(z).css(D({
                cursor: "default"
              }, S));
              return F.on("touchstart", function (b) {
                return b.stopPropagation();
              }).on("click", function (b) {
                3 !== A && a.call(F, b);
              });
            };

            q.prototype.crispLine = function (b, q, a) {
              void 0 === a && (a = "round");
              var F = b[0],
                  f = b[1];
              c(F[1]) && F[1] === f[1] && (F[1] = f[1] = Math[a](F[1]) - q % 2 / 2);
              c(F[2]) && F[2] === f[2] && (F[2] = f[2] = Math[a](F[2]) + q % 2 / 2);
              return b;
            };

            q.prototype.path = function (b) {
              var c = this.styledMode ? {} : {
                fill: "none"
              };
              L(b) ? c.d = b : n(b) && D(c, b);
              return this.createElement("path").attr(c);
            };

            q.prototype.circle = function (b, c, q) {
              b = n(b) ? b : "undefined" === typeof b ? {} : {
                x: b,
                y: c,
                r: q
              };
              c = this.createElement("circle");

              c.xSetter = c.ySetter = function (b, c, q) {
                q.setAttribute("c" + c, b);
              };

              return c.attr(b);
            };

            q.prototype.arc = function (b, c, q, a, f, k) {
              n(b) ? (a = b, c = a.y, q = a.r, b = a.x) : a = {
                innerR: a,
                start: f,
                end: k
              };
              b = this.symbol("arc", b, c, q, q, a);
              b.r = q;
              return b;
            };

            q.prototype.rect = function (b, c, q, a, f, k) {
              f = n(b) ? b.r : f;
              var F = this.createElement("rect");
              b = n(b) ? b : "undefined" === typeof b ? {} : {
                x: b,
                y: c,
                width: Math.max(q, 0),
                height: Math.max(a, 0)
              };
              this.styledMode || ("undefined" !== typeof k && (b["stroke-width"] = k, b = F.crisp(b)), b.fill = "none");
              f && (b.r = f);

              F.rSetter = function (b, c, q) {
                F.r = b;
                Q(q, {
                  rx: b,
                  ry: b
                });
              };

              F.rGetter = function () {
                return F.r || 0;
              };

              return F.attr(b);
            };

            q.prototype.setSize = function (b, c, q) {
              this.width = b;
              this.height = c;
              this.boxWrapper.animate({
                width: b,
                height: c
              }, {
                step: function step() {
                  this.attr({
                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                  });
                },
                duration: w(q, !0) ? void 0 : 0
              });
              this.alignElements();
            };

            q.prototype.g = function (b) {
              var c = this.createElement("g");
              return b ? c.attr({
                "class": "highcharts-" + b
              }) : c;
            };

            q.prototype.image = function (b, c, q, a, f, n) {
              var F = {
                preserveAspectRatio: "none"
              },
                  k = function k(b, c) {
                b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", c) : b.setAttribute("hc-svg-href", c);
              };

              1 < arguments.length && D(F, {
                x: c,
                y: q,
                width: a,
                height: f
              });
              var h = this.createElement("image").attr(F);

              F = function F(c) {
                k(h.element, b);
                n.call(h, c);
              };

              if (n) {
                k(h.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
                var u = new K.Image();
                t(u, "load", F);
                u.src = b;
                u.complete && F({});
              } else k(h.element, b);

              return h;
            };

            q.prototype.symbol = function (b, q, a, f, n, k) {
              var F = this,
                  h = /^url\((.*?)\)$/,
                  u = h.test(b),
                  t = !u && (this.symbols[b] ? b : "circle"),
                  l = t && this.symbols[t],
                  I;

              if (l) {
                "number" === typeof q && (I = l.call(this.symbols, Math.round(q || 0), Math.round(a || 0), f || 0, n || 0, k));
                var S = this.path(I);
                F.styledMode || S.attr("fill", "none");
                D(S, {
                  symbolName: t || void 0,
                  x: q,
                  y: a,
                  width: f,
                  height: n
                });
                k && D(S, k);
              } else if (u) {
                var H = b.match(h)[1];
                var L = S = this.image(H);
                L.imgwidth = w(J[H] && J[H].width, k && k.width);
                L.imgheight = w(J[H] && J[H].height, k && k.height);

                var m = function m(b) {
                  return b.attr({
                    width: b.width,
                    height: b.height
                  });
                };

                ["width", "height"].forEach(function (b) {
                  L[b + "Setter"] = function (b, q) {
                    var F = this["img" + q];
                    this[q] = b;
                    c(F) && (k && "within" === k.backgroundSize && this.width && this.height && (F = Math.round(F * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(q, F), this.alignByTranslate || (b = ((this[q] || 0) - F) / 2, this.attr("width" === q ? {
                      translateX: b
                    } : {
                      translateY: b
                    })));
                  };
                });
                c(q) && L.attr({
                  x: q,
                  y: a
                });
                L.isImg = !0;
                c(L.imgwidth) && c(L.imgheight) ? m(L) : (L.attr({
                  width: 0,
                  height: 0
                }), z("img", {
                  onload: function onload() {
                    var b = d[F.chartIndex];
                    0 === this.width && (A(this, {
                      position: "absolute",
                      top: "-999em"
                    }), p.body.appendChild(this));
                    J[H] = {
                      width: this.width,
                      height: this.height
                    };
                    L.imgwidth = this.width;
                    L.imgheight = this.height;
                    L.element && m(L);
                    this.parentNode && this.parentNode.removeChild(this);
                    F.imgCount--;
                    if (!F.imgCount && b && !b.hasLoaded) b.onload();
                  },
                  src: H
                }), this.imgCount++);
              }

              return S;
            };

            q.prototype.clipRect = function (b, c, q, a) {
              var F = O() + "-",
                  f = this.createElement("clipPath").attr({
                id: F
              }).add(this.defs);
              b = this.rect(b, c, q, a, 0).add(f);
              b.id = F;
              b.clipPath = f;
              b.count = 0;
              return b;
            };

            q.prototype.text = function (b, q, a, f) {
              var F = {};
              if (f && (this.allowHTML || !this.forExport)) return this.html(b, q, a);
              F.x = Math.round(q || 0);
              a && (F.y = Math.round(a));
              c(b) && (F.text = b);
              b = this.createElement("text").attr(F);
              if (!f || this.forExport && !this.allowHTML) b.xSetter = function (b, c, q) {
                for (var a = q.getElementsByTagName("tspan"), F = q.getAttribute(c), f = 0, n; f < a.length; f++) {
                  n = a[f], n.getAttribute(c) === F && n.setAttribute(c, b);
                }

                q.setAttribute(c, b);
              };
              return b;
            };

            q.prototype.fontMetrics = function (b, c) {
              b = !this.styledMode && /px/.test(b) || !K.getComputedStyle ? b || c && c.style && c.style.fontSize || this.style && this.style.fontSize : c && v.prototype.getStyle.call(c, "font-size");
              b = /px/.test(b) ? H(b) : 12;
              c = 24 > b ? b + 3 : Math.round(1.2 * b);
              return {
                h: c,
                b: Math.round(.8 * c),
                f: b
              };
            };

            q.prototype.rotCorr = function (b, c, q) {
              var F = b;
              c && q && (F = Math.max(F * Math.cos(c * a), 4));
              return {
                x: -b / 3 * Math.sin(c * a),
                y: F
              };
            };

            q.prototype.pathToSegments = function (b) {
              for (var c = [], q = [], a = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
              }, F = 0; F < b.length; F++) {
                u(q[0]) && I(b[F]) && q.length === a[q[0].toUpperCase()] && b.splice(F, 0, q[0].replace("M", "L").replace("m", "l")), "string" === typeof b[F] && (q.length && c.push(q.slice(0)), q.length = 0), q.push(b[F]);
              }

              c.push(q.slice(0));
              return c;
            };

            q.prototype.label = function (b, c, q, a, f, n, k, h, u) {
              return new G(this, b, c, q, a, f, n, k, h, u);
            };

            q.prototype.alignElements = function () {
              this.alignedObjects.forEach(function (b) {
                return b.align();
              });
            };

            return q;
          }();

          D(C.prototype, {
            Element: v,
            SVG_NS: k,
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            symbols: x,
            draw: f
          });
          E.registerRendererType("svg", C, !0);
          "";
          return C;
        });
        M(g, "Core/Renderer/HTML/HTMLElement.js", [g["Core/Globals.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var P = this && this.__extends || function () {
            var _a20 = function a(d, h) {
              _a20 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, k) {
                a.__proto__ = k;
              } || function (a, k) {
                for (var f in k) {
                  k.hasOwnProperty(f) && (a[f] = k[f]);
                }
              };

              return _a20(d, h);
            };

            return function (d, h) {
              function f() {
                this.constructor = d;
              }

              _a20(d, h);

              d.prototype = null === h ? Object.create(h) : (f.prototype = h.prototype, new f());
            };
          }(),
              E = e.isFirefox,
              v = e.isMS,
              G = e.isWebKit,
              x = e.win,
              r = C.css,
              m = C.defined,
              d = C.extend,
              a = C.pick,
              p = C.pInt;

          return function (e) {
            function l() {
              return null !== e && e.apply(this, arguments) || this;
            }

            P(l, e);

            l.compose = function (a) {
              if (-1 === l.composedClasses.indexOf(a)) {
                l.composedClasses.push(a);
                var f = l.prototype,
                    k = a.prototype;
                k.getSpanCorrection = f.getSpanCorrection;
                k.htmlCss = f.htmlCss;
                k.htmlGetBBox = f.htmlGetBBox;
                k.htmlUpdateTransform = f.htmlUpdateTransform;
                k.setSpanRotation = f.setSpanRotation;
              }

              return a;
            };

            l.prototype.getSpanCorrection = function (a, f, k) {
              this.xCorr = -a * k;
              this.yCorr = -f;
            };

            l.prototype.htmlCss = function (h) {
              var f = "SPAN" === this.element.tagName && h && "width" in h,
                  k = a(f && h.width, void 0);

              if (f) {
                delete h.width;
                this.textWidth = k;
                var l = !0;
              }

              h && "ellipsis" === h.textOverflow && (h.whiteSpace = "nowrap", h.overflow = "hidden");
              this.styles = d(this.styles, h);
              r(this.element, h);
              l && this.htmlUpdateTransform();
              return this;
            };

            l.prototype.htmlGetBBox = function () {
              var a = this.element;
              return {
                x: a.offsetLeft,
                y: a.offsetTop,
                width: a.offsetWidth,
                height: a.offsetHeight
              };
            };

            l.prototype.htmlUpdateTransform = function () {
              if (this.added) {
                var a = this.renderer,
                    f = this.element,
                    k = this.translateX || 0,
                    d = this.translateY || 0,
                    l = this.x || 0,
                    t = this.y || 0,
                    e = this.textAlign || "left",
                    z = {
                  left: 0,
                  center: .5,
                  right: 1
                }[e],
                    A = this.styles;
                A = A && A.whiteSpace;
                r(f, {
                  marginLeft: k,
                  marginTop: d
                });
                !a.styledMode && this.shadows && this.shadows.forEach(function (b) {
                  r(b, {
                    marginLeft: k + 1,
                    marginTop: d + 1
                  });
                });
                this.inverted && [].forEach.call(f.childNodes, function (b) {
                  a.invertChild(b, f);
                });

                if ("SPAN" === f.tagName) {
                  var c = this.rotation,
                      b = this.textWidth && p(this.textWidth),
                      D = [c, e, f.innerHTML, this.textWidth, this.textAlign].join(),
                      L = void 0;
                  (L = b !== this.oldTextWidth) && !(L = b > this.oldTextWidth) && ((L = this.textPxLength) || (r(f, {
                    width: "",
                    whiteSpace: A || "nowrap"
                  }), L = f.offsetWidth), L = L > b);
                  L && (/[ \-]/.test(f.textContent || f.innerText) || "ellipsis" === f.style.textOverflow) ? (r(f, {
                    width: b + "px",
                    display: "block",
                    whiteSpace: A || "normal"
                  }), this.oldTextWidth = b, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
                  D !== this.cTT && (L = a.fontMetrics(f.style.fontSize, f).b, !m(c) || c === (this.oldRotation || 0) && e === this.oldAlign || this.setSpanRotation(c, z, L), this.getSpanCorrection(!m(c) && this.textPxLength || f.offsetWidth, L, z, c, e));
                  r(f, {
                    left: l + (this.xCorr || 0) + "px",
                    top: t + (this.yCorr || 0) + "px"
                  });
                  this.cTT = D;
                  this.oldRotation = c;
                  this.oldAlign = e;
                }
              } else this.alignOnAdd = !0;
            };

            l.prototype.setSpanRotation = function (a, f, k) {
              var h = {},
                  d = v && !/Edge/.test(x.navigator.userAgent) ? "-ms-transform" : G ? "-webkit-transform" : E ? "MozTransform" : x.opera ? "-o-transform" : void 0;
              d && (h[d] = h.transform = "rotate(" + a + "deg)", h[d + (E ? "Origin" : "-origin")] = h.transformOrigin = 100 * f + "% " + k + "px", r(this.element, h));
            };

            l.composedClasses = [];
            return l;
          }(g);
        });
        M(g, "Core/Renderer/HTML/HTMLRenderer.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var P = this && this.__extends || function () {
            var _m2 = function m(d, a) {
              _m2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var l in d) {
                  d.hasOwnProperty(l) && (a[l] = d[l]);
                }
              };

              return _m2(d, a);
            };

            return function (d, a) {
              function p() {
                this.constructor = d;
              }

              _m2(d, a);

              d.prototype = null === a ? Object.create(a) : (p.prototype = a.prototype, new p());
            };
          }(),
              v = y.attr,
              G = y.createElement,
              x = y.extend,
              r = y.pick;

          return function (m) {
            function d() {
              return null !== m && m.apply(this, arguments) || this;
            }

            P(d, m);

            d.compose = function (a) {
              -1 === d.composedClasses.indexOf(a) && (d.composedClasses.push(a), a.prototype.html = d.prototype.html);
              return a;
            };

            d.prototype.html = function (a, d, m) {
              var l = this.createElement("span"),
                  h = l.element,
                  f = l.renderer,
                  k = f.isSVG,
                  p = function p(a, f) {
                ["opacity", "visibility"].forEach(function (k) {
                  a[k + "Setter"] = function (d, h, c) {
                    var b = a.div ? a.div.style : f;
                    g.prototype[k + "Setter"].call(this, d, h, c);
                    b && (b[h] = d);
                  };
                });
                a.addedSetters = !0;
              };

              l.textSetter = function (a) {
                a !== this.textStr && (delete this.bBox, delete this.oldTextWidth, e.setElementHTML(this.element, r(a, "")), this.textStr = a, l.doTransform = !0);
              };

              k && p(l, l.element.style);

              l.xSetter = l.ySetter = l.alignSetter = l.rotationSetter = function (a, f) {
                "align" === f ? l.alignValue = l.textAlign = a : l[f] = a;
                l.doTransform = !0;
              };

              l.afterSetters = function () {
                this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
              };

              l.attr({
                text: a,
                x: Math.round(d),
                y: Math.round(m)
              }).css({
                position: "absolute"
              });
              f.styledMode || l.css({
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
              });
              h.style.whiteSpace = "nowrap";
              l.css = l.htmlCss;
              k && (l.add = function (a) {
                var k = f.box.parentNode,
                    d = [];

                if (this.parentGroup = a) {
                  var z = a.div;

                  if (!z) {
                    for (; a;) {
                      d.push(a), a = a.parentGroup;
                    }

                    d.reverse().forEach(function (a) {
                      function c(b, c) {
                        a[c] = b;
                        "translateX" === c ? h.left = b + "px" : h.top = b + "px";
                        a.doTransform = !0;
                      }

                      var b = v(a.element, "class"),
                          f = a.styles || {};
                      z = a.div = a.div || G("div", b ? {
                        className: b
                      } : void 0, {
                        position: "absolute",
                        left: (a.translateX || 0) + "px",
                        top: (a.translateY || 0) + "px",
                        display: a.display,
                        opacity: a.opacity,
                        cursor: f.cursor,
                        pointerEvents: f.pointerEvents,
                        visibility: a.visibility
                      }, z || k);
                      var h = z.style;
                      x(a, {
                        classSetter: function (b) {
                          return function (c) {
                            this.element.setAttribute("class", c);
                            b.className = c;
                          };
                        }(z),
                        on: function on() {
                          d[0].div && l.on.apply({
                            element: d[0].div,
                            onEvents: a.onEvents
                          }, arguments);
                          return a;
                        },
                        translateXSetter: c,
                        translateYSetter: c
                      });
                      a.addedSetters || p(a);
                    });
                  }
                } else z = k;

                z.appendChild(h);
                l.added = !0;
                l.alignOnAdd && l.htmlUpdateTransform();
                return l;
              });
              return l;
            };

            d.composedClasses = [];
            return d;
          }(C);
        });
        M(g, "Core/Axis/AxisDefaults.js", [g["Core/Color/Palette.js"]], function (e) {
          var g;

          (function (g) {
            g.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: !1
                },
                second: {
                  main: "%H:%M:%S",
                  range: !1
                },
                minute: {
                  main: "%H:%M",
                  range: !1
                },
                hour: {
                  main: "%H:%M",
                  range: !1
                },
                day: {
                  main: "%e. %b"
                },
                week: {
                  main: "%e. %b"
                },
                month: {
                  main: "%b '%y"
                },
                year: {
                  main: "%Y"
                }
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: void 0,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                x: 0,
                zIndex: 7,
                style: {
                  color: e.neutralColor60,
                  cursor: "default",
                  fontSize: "11px"
                }
              },
              maxPadding: .01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minPadding: .01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                  color: e.neutralColor60
                }
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: e.neutralColor5,
              minorGridLineWidth: 1,
              minorTickColor: e.neutralColor40,
              lineColor: e.highlightColor20,
              lineWidth: 1,
              gridLineColor: e.neutralColor10,
              gridLineWidth: void 0,
              tickColor: e.highlightColor20
            };
            g.defaultYAxisOptions = {
              reversedStacks: !0,
              endOnTick: !0,
              maxPadding: .05,
              minPadding: .05,
              tickPixelInterval: 72,
              showLastLabel: !0,
              labels: {
                x: -8
              },
              startOnTick: !0,
              title: {
                rotation: 270,
                text: "Values"
              },
              stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function formatter() {
                  var e = this.axis.chart.numberFormatter;
                  return e(this.total, -1);
                },
                style: {
                  color: e.neutralColor100,
                  fontSize: "11px",
                  fontWeight: "bold",
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
            };
            g.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            g.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            g.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            g.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(g || (g = {}));

          return g;
        });
        M(g, "Core/Foundation.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.addEvent,
              C = e.isFunction,
              y = e.objectEach,
              E = e.removeEvent;
          return {
            registerEventOptions: function registerEventOptions(e, G) {
              e.eventOptions = e.eventOptions || {};
              y(G.events, function (x, r) {
                e.eventOptions[r] !== x && (e.eventOptions[r] && (E(e, r, e.eventOptions[r]), delete e.eventOptions[r]), C(x) && (e.eventOptions[r] = x, g(e, r, x)));
              });
            }
          };
        });
        M(g, "Core/Axis/Tick.js", [g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var P = g.deg2rad,
              E = C.clamp,
              v = C.correctFloat,
              G = C.defined,
              x = C.destroyObjectProperties,
              r = C.extend,
              m = C.fireEvent,
              d = C.isNumber,
              a = C.merge,
              p = C.objectEach,
              B = C.pick;

          g = function () {
            function l(a, f, k, d, l) {
              this.isNewLabel = this.isNew = !0;
              this.axis = a;
              this.pos = f;
              this.type = k || "";
              this.parameters = l || {};
              this.tickmarkOffset = this.parameters.tickmarkOffset;
              this.options = this.parameters.options;
              m(this, "init");
              k || d || this.addLabel();
            }

            l.prototype.addLabel = function () {
              var a = this,
                  f = a.axis,
                  k = f.options,
                  l = f.chart,
                  p = f.categories,
                  t = f.logarithmic,
                  g = f.names,
                  z = a.pos,
                  A = B(a.options && a.options.labels, k.labels),
                  c = f.tickPositions,
                  b = z === c[0],
                  D = z === c[c.length - 1],
                  L = (!A.step || 1 === A.step) && 1 === f.tickInterval;
              c = c.info;
              var I = a.label,
                  n;
              p = this.parameters.category || (p ? B(p[z], g[z], z) : z);
              t && d(p) && (p = v(t.lin2log(p)));
              if (f.dateTime) if (c) {
                var u = l.time.resolveDTLFormat(k.dateTimeLabelFormats[!k.grid && c.higherRanks[z] || c.unitName]);
                var N = u.main;
              } else d(p) && (N = f.dateTime.getXDateFormat(p, k.dateTimeLabelFormats || {}));
              a.isFirst = b;
              a.isLast = D;
              var w = {
                axis: f,
                chart: l,
                dateTimeLabelFormat: N,
                isFirst: b,
                isLast: D,
                pos: z,
                tick: a,
                tickPositionInfo: c,
                value: p
              };
              m(this, "labelFormat", w);

              var H = function H(b) {
                return A.formatter ? A.formatter.call(b, b) : A.format ? (b.text = f.defaultLabelFormatter.call(b), e.format(A.format, b, l)) : f.defaultLabelFormatter.call(b, b);
              };

              k = H.call(w, w);
              var O = u && u.list;
              a.shortenLabel = O ? function () {
                for (n = 0; n < O.length; n++) {
                  if (r(w, {
                    dateTimeLabelFormat: O[n]
                  }), I.attr({
                    text: H.call(w, w)
                  }), I.getBBox().width < f.getSlotWidth(a) - 2 * A.padding) return;
                }

                I.attr({
                  text: ""
                });
              } : void 0;
              L && f._addedPlotLB && a.moveLabel(k, A);
              G(I) || a.movedLabel ? I && I.textStr !== k && !L && (!I.textWidth || A.style.width || I.styles.width || I.css({
                width: null
              }), I.attr({
                text: k
              }), I.textPxLength = I.getBBox().width) : (a.label = I = a.createLabel({
                x: 0,
                y: 0
              }, k, A), a.rotation = 0);
            };

            l.prototype.createLabel = function (d, f, k) {
              var h = this.axis,
                  l = h.chart;
              if (d = G(f) && k.enabled ? l.renderer.text(f, d.x, d.y, k.useHTML).add(h.labelGroup) : null) l.styledMode || d.css(a(k.style)), d.textPxLength = d.getBBox().width;
              return d;
            };

            l.prototype.destroy = function () {
              x(this, this.axis);
            };

            l.prototype.getPosition = function (a, f, k, d) {
              var h = this.axis,
                  t = h.chart,
                  l = d && t.oldChartHeight || t.chartHeight;
              a = {
                x: a ? v(h.translate(f + k, null, null, d) + h.transB) : h.left + h.offset + (h.opposite ? (d && t.oldChartWidth || t.chartWidth) - h.right - h.left : 0),
                y: a ? l - h.bottom + h.offset - (h.opposite ? h.height : 0) : v(l - h.translate(f + k, null, null, d) - h.transB)
              };
              a.y = E(a.y, -1E5, 1E5);
              m(this, "afterGetPosition", {
                pos: a
              });
              return a;
            };

            l.prototype.getLabelPosition = function (a, f, k, d, l, t, p, z) {
              var h = this.axis,
                  c = h.transA,
                  b = h.isLinked && h.linkedParent ? h.linkedParent.reversed : h.reversed,
                  D = h.staggerLines,
                  L = h.tickRotCorr || {
                x: 0,
                y: 0
              },
                  I = d || h.reserveSpaceDefault ? 0 : -h.labelOffset * ("center" === h.labelAlign ? .5 : 1),
                  n = {},
                  u = l.y;
              G(u) || (u = 0 === h.side ? k.rotation ? -8 : -k.getBBox().height : 2 === h.side ? L.y + 8 : Math.cos(k.rotation * P) * (L.y - k.getBBox(!1, 0).height / 2));
              a = a + l.x + I + L.x - (t && d ? t * c * (b ? -1 : 1) : 0);
              f = f + u - (t && !d ? t * c * (b ? 1 : -1) : 0);
              D && (k = p / (z || 1) % D, h.opposite && (k = D - k - 1), f += h.labelOffset / D * k);
              n.x = a;
              n.y = Math.round(f);
              m(this, "afterGetLabelPosition", {
                pos: n,
                tickmarkOffset: t,
                index: p
              });
              return n;
            };

            l.prototype.getLabelSize = function () {
              return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };

            l.prototype.getMarkPath = function (a, f, k, d, l, t) {
              return t.crispLine([["M", a, f], ["L", a + (l ? 0 : -k), f + (l ? k : 0)]], d);
            };

            l.prototype.handleOverflow = function (a) {
              var f = this.axis,
                  d = f.options.labels,
                  h = a.x,
                  l = f.chart.chartWidth,
                  t = f.chart.spacing,
                  p = B(f.labelLeft, Math.min(f.pos, t[3]));
              t = B(f.labelRight, Math.max(f.isRadial ? 0 : f.pos + f.len, l - t[1]));
              var z = this.label,
                  A = this.rotation,
                  c = {
                left: 0,
                center: .5,
                right: 1
              }[f.labelAlign || z.attr("align")],
                  b = z.getBBox().width,
                  D = f.getSlotWidth(this),
                  L = {},
                  I = D,
                  n = 1,
                  u;
              if (A || "justify" !== d.overflow) 0 > A && h - c * b < p ? u = Math.round(h / Math.cos(A * P) - p) : 0 < A && h + c * b > t && (u = Math.round((l - h) / Math.cos(A * P)));else if (l = h + (1 - c) * b, h - c * b < p ? I = a.x + I * (1 - c) - p : l > t && (I = t - a.x + I * c, n = -1), I = Math.min(D, I), I < D && "center" === f.labelAlign && (a.x += n * (D - I - c * (D - Math.min(b, I)))), b > I || f.autoRotation && (z.styles || {}).width) u = I;
              u && (this.shortenLabel ? this.shortenLabel() : (L.width = Math.floor(u) + "px", (d.style || {}).textOverflow || (L.textOverflow = "ellipsis"), z.css(L)));
            };

            l.prototype.moveLabel = function (a, f) {
              var d = this,
                  h = d.label,
                  l = d.axis,
                  t = l.reversed,
                  m = !1;
              h && h.textStr === a ? (d.movedLabel = h, m = !0, delete d.label) : p(l.ticks, function (f) {
                m || f.isNew || f === d || !f.label || f.label.textStr !== a || (d.movedLabel = f.label, m = !0, f.labelPos = d.movedLabel.xy, delete f.label);
              });

              if (!m && (d.labelPos || h)) {
                var z = d.labelPos || h.xy;
                h = l.horiz ? t ? 0 : l.width + l.left : z.x;
                l = l.horiz ? z.y : t ? l.width + l.left : 0;
                d.movedLabel = d.createLabel({
                  x: h,
                  y: l
                }, a, f);
                d.movedLabel && d.movedLabel.attr({
                  opacity: 0
                });
              }
            };

            l.prototype.render = function (a, f, d) {
              var k = this.axis,
                  h = k.horiz,
                  l = this.pos,
                  p = B(this.tickmarkOffset, k.tickmarkOffset);
              l = this.getPosition(h, l, p, f);
              p = l.x;
              var z = l.y;
              k = h && p === k.pos + k.len || !h && z === k.pos ? -1 : 1;
              h = B(d, this.label && this.label.newOpacity, 1);
              d = B(d, 1);
              this.isActive = !0;
              this.renderGridLine(f, d, k);
              this.renderMark(l, d, k);
              this.renderLabel(l, f, h, a);
              this.isNew = !1;
              m(this, "afterRender");
            };

            l.prototype.renderGridLine = function (a, f, d) {
              var k = this.axis,
                  h = k.options,
                  l = {},
                  p = this.pos,
                  z = this.type,
                  A = B(this.tickmarkOffset, k.tickmarkOffset),
                  c = k.chart.renderer,
                  b = this.gridLine,
                  D = h.gridLineWidth,
                  L = h.gridLineColor,
                  I = h.gridLineDashStyle;
              "minor" === this.type && (D = h.minorGridLineWidth, L = h.minorGridLineColor, I = h.minorGridLineDashStyle);
              b || (k.chart.styledMode || (l.stroke = L, l["stroke-width"] = D || 0, l.dashstyle = I), z || (l.zIndex = 1), a && (f = 0), this.gridLine = b = c.path().attr(l).addClass("highcharts-" + (z ? z + "-" : "") + "grid-line").add(k.gridGroup));
              if (b && (d = k.getPlotLinePath({
                value: p + A,
                lineWidth: b.strokeWidth() * d,
                force: "pass",
                old: a
              }))) b[a || this.isNew ? "attr" : "animate"]({
                d: d,
                opacity: f
              });
            };

            l.prototype.renderMark = function (a, f, d) {
              var k = this.axis,
                  h = k.options,
                  l = k.chart.renderer,
                  p = this.type,
                  z = k.tickSize(p ? p + "Tick" : "tick"),
                  A = a.x;
              a = a.y;
              var c = B(h["minor" !== p ? "tickWidth" : "minorTickWidth"], !p && k.isXAxis ? 1 : 0);
              h = h["minor" !== p ? "tickColor" : "minorTickColor"];
              var b = this.mark,
                  D = !b;
              z && (k.opposite && (z[0] = -z[0]), b || (this.mark = b = l.path().addClass("highcharts-" + (p ? p + "-" : "") + "tick").add(k.axisGroup), k.chart.styledMode || b.attr({
                stroke: h,
                "stroke-width": c
              })), b[D ? "attr" : "animate"]({
                d: this.getMarkPath(A, a, z[0], b.strokeWidth() * d, k.horiz, l),
                opacity: f
              }));
            };

            l.prototype.renderLabel = function (a, f, k, l) {
              var h = this.axis,
                  t = h.horiz,
                  p = h.options,
                  z = this.label,
                  A = p.labels,
                  c = A.step;
              h = B(this.tickmarkOffset, h.tickmarkOffset);
              var b = a.x;
              a = a.y;
              var D = !0;
              z && d(b) && (z.xy = a = this.getLabelPosition(b, a, z, t, A, h, l, c), this.isFirst && !this.isLast && !p.showFirstLabel || this.isLast && !this.isFirst && !p.showLastLabel ? D = !1 : !t || A.step || A.rotation || f || 0 === k || this.handleOverflow(a), c && l % c && (D = !1), D && d(a.y) ? (a.opacity = k, z[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (z.attr("y", -9999), this.isNewLabel = !0));
            };

            l.prototype.replaceMovedLabel = function () {
              var a = this.label,
                  f = this.axis,
                  d = f.reversed;

              if (a && !this.isNew) {
                var l = f.horiz ? d ? f.left : f.width + f.left : a.xy.x;
                d = f.horiz ? a.xy.y : d ? f.width + f.top : f.top;
                a.animate({
                  x: l,
                  y: d,
                  opacity: 0
                }, void 0, a.destroy);
                delete this.label;
              }

              f.isDirty = !0;
              this.label = this.movedLabel;
              delete this.movedLabel;
            };

            return l;
          }();

          "";
          return g;
        });
        M(g, "Core/Axis/Axis.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/AxisDefaults.js"], g["Core/Color/Color.js"], g["Core/Color/Palette.js"], g["Core/DefaultOptions.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Axis/Tick.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G, x, r) {
          var m = e.animObject,
              d = E.defaultOptions,
              a = v.registerEventOptions,
              p = G.deg2rad,
              B = r.arrayMax,
              l = r.arrayMin,
              h = r.clamp,
              f = r.correctFloat,
              k = r.defined,
              J = r.destroyObjectProperties,
              K = r.erase,
              t = r.error,
              Q = r.extend,
              z = r.fireEvent,
              A = r.getMagnitude,
              c = r.isArray,
              b = r.isNumber,
              D = r.isString,
              L = r.merge,
              I = r.normalizeTickInterval,
              n = r.objectEach,
              u = r.pick,
              N = r.relativeLength,
              w = r.removeEvent,
              H = r.splat,
              O = r.syncTimeout;

          e = function () {
            function e(b, c) {
              this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
              this.init(b, c);
            }

            e.prototype.init = function (c, f) {
              var q = f.isX;
              this.chart = c;
              this.horiz = c.inverted && !this.isZAxis ? !q : q;
              this.isXAxis = q;
              this.coll = this.coll || (q ? "xAxis" : "yAxis");
              z(this, "init", {
                userOptions: f
              });
              this.opposite = u(f.opposite, this.opposite);
              this.side = u(f.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
              this.setOptions(f);
              var F = this.options,
                  d = F.labels,
                  n = F.type;
              this.userOptions = f;
              this.minPixelPadding = 0;
              this.reversed = u(F.reversed, this.reversed);
              this.visible = F.visible;
              this.zoomEnabled = F.zoomEnabled;
              this.hasNames = "category" === n || !0 === F.categories;
              this.categories = F.categories || this.hasNames;
              this.names || (this.names = [], this.names.keys = {});
              this.plotLinesAndBandsGroups = {};
              this.positiveValuesOnly = !!this.logarithmic;
              this.isLinked = k(F.linkedTo);
              this.ticks = {};
              this.labelEdge = [];
              this.minorTicks = {};
              this.plotLinesAndBands = [];
              this.alternateBands = {};
              this.len = 0;
              this.minRange = this.userMinRange = F.minRange || F.maxZoom;
              this.range = F.range;
              this.offset = F.offset || 0;
              this.min = this.max = null;
              f = u(F.crosshair, H(c.options.tooltip.crosshairs)[q ? 0 : 1]);
              this.crosshair = !0 === f ? {} : f;
              -1 === c.axes.indexOf(this) && (q ? c.axes.splice(c.xAxis.length, 0, this) : c.axes.push(this), c[this.coll].push(this));
              this.series = this.series || [];
              c.inverted && !this.isZAxis && q && "undefined" === typeof this.reversed && (this.reversed = !0);
              this.labelRotation = b(d.rotation) ? d.rotation : void 0;
              a(this, F);
              z(this, "afterInit");
            };

            e.prototype.setOptions = function (b) {
              this.options = L(g.defaultXAxisOptions, "yAxis" === this.coll && g.defaultYAxisOptions, [g.defaultTopAxisOptions, g.defaultRightAxisOptions, g.defaultBottomAxisOptions, g.defaultLeftAxisOptions][this.side], L(d[this.coll], b));
              z(this, "afterSetOptions", {
                userOptions: b
              });
            };

            e.prototype.defaultLabelFormatter = function (c) {
              var q = this.axis;
              c = this.chart.numberFormatter;
              var a = b(this.value) ? this.value : NaN,
                  f = q.chart.time,
                  n = this.dateTimeLabelFormat,
                  k = d.lang,
                  u = k.numericSymbols;
              k = k.numericSymbolMagnitude || 1E3;
              var h = q.logarithmic ? Math.abs(a) : q.tickInterval,
                  w = u && u.length;
              if (q.categories) var l = "" + this.value;else if (n) l = f.dateFormat(n, a);else if (w && 1E3 <= h) for (; w-- && "undefined" === typeof l;) {
                q = Math.pow(k, w + 1), h >= q && 0 === 10 * a % q && null !== u[w] && 0 !== a && (l = c(a / q, -1) + u[w]);
              }
              "undefined" === typeof l && (l = 1E4 <= Math.abs(a) ? c(a, -1) : c(a, -1, void 0, ""));
              return l;
            };

            e.prototype.getSeriesExtremes = function () {
              var c = this,
                  a = c.chart,
                  f;
              z(this, "getSeriesExtremes", null, function () {
                c.hasVisibleSeries = !1;
                c.dataMin = c.dataMax = c.threshold = null;
                c.softThreshold = !c.isXAxis;
                c.stacking && c.stacking.buildStacks();
                c.series.forEach(function (q) {
                  if (q.visible || !a.options.chart.ignoreHiddenSeries) {
                    var F = q.options,
                        d = F.threshold;
                    c.hasVisibleSeries = !0;
                    c.positiveValuesOnly && 0 >= d && (d = null);

                    if (c.isXAxis) {
                      if (F = q.xData, F.length) {
                        F = c.logarithmic ? F.filter(c.validatePositiveValue) : F;
                        f = q.getXExtremes(F);
                        var n = f.min;
                        var h = f.max;
                        b(n) || n instanceof Date || (F = F.filter(b), f = q.getXExtremes(F), n = f.min, h = f.max);
                        F.length && (c.dataMin = Math.min(u(c.dataMin, n), n), c.dataMax = Math.max(u(c.dataMax, h), h));
                      }
                    } else if (q = q.applyExtremes(), b(q.dataMin) && (n = q.dataMin, c.dataMin = Math.min(u(c.dataMin, n), n)), b(q.dataMax) && (h = q.dataMax, c.dataMax = Math.max(u(c.dataMax, h), h)), k(d) && (c.threshold = d), !F.softThreshold || c.positiveValuesOnly) c.softThreshold = !1;
                  }
                });
              });
              z(this, "afterGetSeriesExtremes");
            };

            e.prototype.translate = function (c, a, f, d, n, k) {
              var q = this.linkedParent || this,
                  F = d && q.old ? q.old.min : q.min,
                  h = q.minPixelPadding;
              n = (q.isOrdinal || q.brokenAxis && q.brokenAxis.hasBreaks || q.logarithmic && n) && q.lin2val;
              var u = 1,
                  w = 0;
              d = d && q.old ? q.old.transA : q.transA;
              d || (d = q.transA);
              f && (u *= -1, w = q.len);
              q.reversed && (u *= -1, w -= u * (q.sector || q.len));
              a ? (c = (c * u + w - h) / d + F, n && (c = q.lin2val(c))) : (n && (c = q.val2lin(c)), c = b(F) ? u * (c - F) * d + w + u * h + (b(k) ? d * k : 0) : void 0);
              return c;
            };

            e.prototype.toPixels = function (b, c) {
              return this.translate(b, !1, !this.horiz, null, !0) + (c ? 0 : this.pos);
            };

            e.prototype.toValue = function (b, c) {
              return this.translate(b - (c ? 0 : this.pos), !0, !this.horiz, null, !0);
            };

            e.prototype.getPlotLinePath = function (c) {
              function a(b, c, a) {
                if ("pass" !== e && b < c || b > a) e ? b = h(b, c, a) : N = !0;
                return b;
              }

              var q = this,
                  f = q.chart,
                  d = q.left,
                  n = q.top,
                  k = c.old,
                  w = c.value,
                  l = c.lineWidth,
                  D = k && f.oldChartHeight || f.chartHeight,
                  t = k && f.oldChartWidth || f.chartWidth,
                  A = q.transB,
                  p = c.translatedValue,
                  e = c.force,
                  I,
                  H,
                  L,
                  m,
                  N;
              c = {
                value: w,
                lineWidth: l,
                old: k,
                force: e,
                acrossPanes: c.acrossPanes,
                translatedValue: p
              };
              z(this, "getPlotLinePath", c, function (c) {
                p = u(p, q.translate(w, null, null, k));
                p = h(p, -1E5, 1E5);
                I = L = Math.round(p + A);
                H = m = Math.round(D - p - A);
                b(p) ? q.horiz ? (H = n, m = D - q.bottom, I = L = a(I, d, d + q.width)) : (I = d, L = t - q.right, H = m = a(H, n, n + q.height)) : (N = !0, e = !1);
                c.path = N && !e ? null : f.renderer.crispLine([["M", I, H], ["L", L, m]], l || 1);
              });
              return c.path;
            };

            e.prototype.getLinearTickPositions = function (b, c, a) {
              var q = f(Math.floor(c / b) * b);
              a = f(Math.ceil(a / b) * b);
              var d = [],
                  F;
              f(q + b) === q && (F = 20);
              if (this.single) return [c];

              for (c = q; c <= a;) {
                d.push(c);
                c = f(c + b, F);
                if (c === n) break;
                var n = c;
              }

              return d;
            };

            e.prototype.getMinorTickInterval = function () {
              var b = this.options;
              return !0 === b.minorTicks ? u(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
            };

            e.prototype.getMinorTickPositions = function () {
              var b = this.options,
                  c = this.tickPositions,
                  a = this.minorTickInterval,
                  f = this.pointRangePadding || 0,
                  d = this.min - f;
              f = this.max + f;
              var n = f - d,
                  k = [];

              if (n && n / a < this.len / 3) {
                var h = this.logarithmic;
                if (h) this.paddedTicks.forEach(function (b, c, q) {
                  c && k.push.apply(k, h.getLogTickPositions(a, q[c - 1], q[c], !0));
                });else if (this.dateTime && "auto" === this.getMinorTickInterval()) k = k.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(a), d, f, b.startOfWeek));else for (b = d + (c[0] - d) % a; b <= f && b !== k[0]; b += a) {
                  k.push(b);
                }
              }

              0 !== k.length && this.trimTicks(k);
              return k;
            };

            e.prototype.adjustForMinRange = function () {
              var b = this.options,
                  c = this.logarithmic,
                  a = this.min,
                  f = this.max,
                  d = 0,
                  n,
                  h,
                  w,
                  D;
              this.isXAxis && "undefined" === typeof this.minRange && !c && (k(b.min) || k(b.max) ? this.minRange = null : (this.series.forEach(function (b) {
                w = b.xData;
                D = b.xIncrement ? 1 : w.length - 1;
                if (1 < w.length) for (n = D; 0 < n; n--) {
                  if (h = w[n] - w[n - 1], !d || h < d) d = h;
                }
              }), this.minRange = Math.min(5 * d, this.dataMax - this.dataMin)));

              if (f - a < this.minRange) {
                var t = this.dataMax - this.dataMin >= this.minRange;
                var A = this.minRange;
                var p = (A - f + a) / 2;
                p = [a - p, u(b.min, a - p)];
                t && (p[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                a = B(p);
                f = [a + A, u(b.max, a + A)];
                t && (f[2] = c ? c.log2lin(this.dataMax) : this.dataMax);
                f = l(f);
                f - a < A && (p[0] = f - A, p[1] = u(b.min, f - A), a = B(p));
              }

              this.min = a;
              this.max = f;
            };

            e.prototype.getClosest = function () {
              var b;
              this.categories ? b = 1 : this.series.forEach(function (c) {
                var a = c.closestPointRange,
                    q = c.visible || !c.chart.options.chart.ignoreHiddenSeries;
                !c.noSharedTooltip && k(a) && q && (b = k(b) ? Math.min(b, a) : a);
              });
              return b;
            };

            e.prototype.nameToX = function (b) {
              var a = c(this.categories),
                  q = a ? this.categories : this.names,
                  f = b.options.x;
              b.series.requireSorting = !1;
              k(f) || (f = this.options.uniqueNames ? a ? q.indexOf(b.name) : u(q.keys[b.name], -1) : b.series.autoIncrement());

              if (-1 === f) {
                if (!a) var d = q.length;
              } else d = f;

              "undefined" !== typeof d && (this.names[d] = b.name, this.names.keys[b.name] = d);
              return d;
            };

            e.prototype.updateNames = function () {
              var b = this,
                  c = this.names;
              0 < c.length && (Object.keys(c.keys).forEach(function (b) {
                delete c.keys[b];
              }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (c) {
                c.xIncrement = null;
                if (!c.points || c.isDirtyData) b.max = Math.max(b.max, c.xData.length - 1), c.processData(), c.generatePoints();
                c.data.forEach(function (a, q) {
                  if (a && a.options && "undefined" !== typeof a.name) {
                    var f = b.nameToX(a);
                    "undefined" !== typeof f && f !== a.x && (a.x = f, c.xData[q] = f);
                  }
                });
              }));
            };

            e.prototype.setAxisTranslation = function () {
              var b = this,
                  c = b.max - b.min,
                  a = b.linkedParent,
                  f = !!b.categories,
                  d = b.isXAxis,
                  n = b.axisPointRange || 0,
                  k = 0,
                  h = 0,
                  w = b.transA;

              if (d || f || n) {
                var l = b.getClosest();
                a ? (k = a.minPointOffset, h = a.pointRangePadding) : b.series.forEach(function (c) {
                  var a = f ? 1 : d ? u(c.options.pointRange, l, 0) : b.axisPointRange || 0,
                      q = c.options.pointPlacement;
                  n = Math.max(n, a);
                  if (!b.single || f) c = c.is("xrange") ? !d : d, k = Math.max(k, c && D(q) ? 0 : a / 2), h = Math.max(h, c && "on" === q ? 0 : a);
                });
                a = b.ordinal && b.ordinal.slope && l ? b.ordinal.slope / l : 1;
                b.minPointOffset = k *= a;
                b.pointRangePadding = h *= a;
                b.pointRange = Math.min(n, b.single && f ? 1 : c);
                d && (b.closestPointRange = l);
              }

              b.translationSlope = b.transA = w = b.staticScale || b.len / (c + h || 1);
              b.transB = b.horiz ? b.left : b.bottom;
              b.minPixelPadding = w * k;
              z(this, "afterSetAxisTranslation");
            };

            e.prototype.minFromRange = function () {
              return this.max - this.range;
            };

            e.prototype.setTickInterval = function (c) {
              var a = this,
                  q = a.chart,
                  d = a.logarithmic,
                  n = a.options,
                  h = a.isXAxis,
                  w = a.isLinked,
                  l = n.tickPixelInterval,
                  D = a.categories,
                  p = a.softThreshold,
                  e = n.maxPadding,
                  H = n.minPadding,
                  L = n.tickInterval,
                  m = b(a.threshold) ? a.threshold : null;
              a.dateTime || D || w || this.getTickAmount();
              var N = u(a.userMin, n.min);
              var g = u(a.userMax, n.max);

              if (w) {
                a.linkedParent = q[a.coll][n.linkedTo];
                var r = a.linkedParent.getExtremes();
                a.min = u(r.min, r.dataMin);
                a.max = u(r.max, r.dataMax);
                n.type !== a.linkedParent.options.type && t(11, 1, q);
              } else {
                if (p && k(m)) if (a.dataMin >= m) r = m, H = 0;else if (a.dataMax <= m) {
                  var O = m;
                  e = 0;
                }
                a.min = u(N, r, a.dataMin);
                a.max = u(g, O, a.dataMax);
              }

              d && (a.positiveValuesOnly && !c && 0 >= Math.min(a.min, u(a.dataMin, a.min)) && t(10, 1, q), a.min = f(d.log2lin(a.min), 16), a.max = f(d.log2lin(a.max), 16));
              a.range && k(a.max) && (a.userMin = a.min = N = Math.max(a.dataMin, a.minFromRange()), a.userMax = g = a.max, a.range = null);
              z(a, "foundExtremes");
              a.beforePadding && a.beforePadding();
              a.adjustForMinRange();
              !(D || a.axisPointRange || a.stacking && a.stacking.usePercentage || w) && k(a.min) && k(a.max) && (q = a.max - a.min) && (!k(N) && H && (a.min -= q * H), !k(g) && e && (a.max += q * e));
              b(a.userMin) || (b(n.softMin) && n.softMin < a.min && (a.min = N = n.softMin), b(n.floor) && (a.min = Math.max(a.min, n.floor)));
              b(a.userMax) || (b(n.softMax) && n.softMax > a.max && (a.max = g = n.softMax), b(n.ceiling) && (a.max = Math.min(a.max, n.ceiling)));
              p && k(a.dataMin) && (m = m || 0, !k(N) && a.min < m && a.dataMin >= m ? a.min = a.options.minRange ? Math.min(m, a.max - a.minRange) : m : !k(g) && a.max > m && a.dataMax <= m && (a.max = a.options.minRange ? Math.max(m, a.min + a.minRange) : m));
              b(a.min) && b(a.max) && !this.chart.polar && a.min > a.max && (k(a.options.min) ? a.max = a.min : k(a.options.max) && (a.min = a.max));
              a.tickInterval = a.min === a.max || "undefined" === typeof a.min || "undefined" === typeof a.max ? 1 : w && a.linkedParent && !L && l === a.linkedParent.options.tickPixelInterval ? L = a.linkedParent.tickInterval : u(L, this.tickAmount ? (a.max - a.min) / Math.max(this.tickAmount - 1, 1) : void 0, D ? 1 : (a.max - a.min) * l / Math.max(a.len, l));
              h && !c && (a.series.forEach(function (b) {
                b.forceCrop = b.forceCropping && b.forceCropping();
                b.processData(a.min !== (a.old && a.old.min) || a.max !== (a.old && a.old.max));
              }), z(this, "postProcessData"));
              a.setAxisTranslation();
              z(this, "initialAxisTranslation");
              a.pointRange && !L && (a.tickInterval = Math.max(a.pointRange, a.tickInterval));
              c = u(n.minTickInterval, a.dateTime && !a.series.some(function (b) {
                return b.noSharedTooltip;
              }) ? a.closestPointRange : 0);
              !L && a.tickInterval < c && (a.tickInterval = c);
              a.dateTime || a.logarithmic || L || (a.tickInterval = I(a.tickInterval, void 0, A(a.tickInterval), u(n.allowDecimals, .5 > a.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
              this.tickAmount || (a.tickInterval = a.unsquish());
              this.setTickPositions();
            };

            e.prototype.setTickPositions = function () {
              var b = this.options,
                  c = b.tickPositions,
                  a = this.getMinorTickInterval(),
                  f = this.hasVerticalPanning(),
                  n = "colorAxis" === this.coll,
                  d = (n || !f) && b.startOnTick;
              f = (n || !f) && b.endOnTick;
              n = b.tickPositioner;
              this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
              this.minorTickInterval = "auto" === a && this.tickInterval ? this.tickInterval / 5 : a;
              this.single = this.min === this.max && k(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
              this.tickPositions = a = c && c.slice();
              !a && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? a = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (a = [this.min, this.max], t(19, !1, this.chart)), a.length > this.len && (a = [a[0], a.pop()], a[0] === a[1] && (a.length = 1)), this.tickPositions = a, n && (n = n.apply(this, [this.min, this.max]))) && (this.tickPositions = a = n);
              this.paddedTicks = a.slice(0);
              this.trimTicks(a, d, f);
              this.isLinked || (this.single && 2 > a.length && !this.categories && !this.series.some(function (b) {
                return b.is("heatmap") && "between" === b.options.pointPlacement;
              }) && (this.min -= .5, this.max += .5), c || n || this.adjustTickAmount());
              z(this, "afterSetTickPositions");
            };

            e.prototype.trimTicks = function (b, c, a) {
              var q = b[0],
                  f = b[b.length - 1],
                  n = !this.isOrdinal && this.minPointOffset || 0;
              z(this, "trimTicks");

              if (!this.isLinked) {
                if (c && -Infinity !== q) this.min = q;else for (; this.min - n > b[0];) {
                  b.shift();
                }
                if (a) this.max = f;else for (; this.max + n < b[b.length - 1];) {
                  b.pop();
                }
                0 === b.length && k(q) && !this.options.tickPositions && b.push((f + q) / 2);
              }
            };

            e.prototype.alignToOthers = function () {
              var b = {},
                  c = this.options,
                  a;
              !1 !== this.chart.options.chart.alignTicks && c.alignTicks && !1 !== c.startOnTick && !1 !== c.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (c) {
                var q = c.options;
                q = [c.horiz ? q.left : q.top, q.width, q.height, q.pane].join();
                c.series.length && (b[q] ? a = !0 : b[q] = 1);
              });
              return a;
            };

            e.prototype.getTickAmount = function () {
              var b = this.options,
                  c = b.tickPixelInterval,
                  a = b.tickAmount;
              !k(b.tickInterval) && !a && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (a = 2);
              !a && this.alignToOthers() && (a = Math.ceil(this.len / c) + 1);
              4 > a && (this.finalTickAmt = a, a = 5);
              this.tickAmount = a;
            };

            e.prototype.adjustTickAmount = function () {
              var c = this.options,
                  a = this.tickInterval,
                  n = this.tickPositions,
                  d = this.tickAmount,
                  h = this.finalTickAmt,
                  w = n && n.length,
                  l = u(this.threshold, this.softThreshold ? 0 : null);

              if (this.hasData() && b(this.min) && b(this.max)) {
                if (w < d) {
                  for (; n.length < d;) {
                    n.length % 2 || this.min === l ? n.push(f(n[n.length - 1] + a)) : n.unshift(f(n[0] - a));
                  }

                  this.transA *= (w - 1) / (d - 1);
                  this.min = c.startOnTick ? n[0] : Math.min(this.min, n[0]);
                  this.max = c.endOnTick ? n[n.length - 1] : Math.max(this.max, n[n.length - 1]);
                } else w > d && (this.tickInterval *= 2, this.setTickPositions());

                if (k(h)) {
                  for (a = c = n.length; a--;) {
                    (3 === h && 1 === a % 2 || 2 >= h && 0 < a && a < c - 1) && n.splice(a, 1);
                  }

                  this.finalTickAmt = void 0;
                }
              }
            };

            e.prototype.setScale = function () {
              var b = !1,
                  c = !1;
              this.series.forEach(function (a) {
                b = b || a.isDirtyData || a.isDirty;
                c = c || a.xAxis && a.xAxis.isDirty || !1;
              });
              this.setAxisSize();
              var a = this.len !== (this.old && this.old.len);
              a || b || c || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = a || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
              b && this.panningState && (this.panningState.isDirty = !0);
              z(this, "afterSetScale");
            };

            e.prototype.setExtremes = function (b, c, a, f, n) {
              var q = this,
                  d = q.chart;
              a = u(a, !0);
              q.series.forEach(function (b) {
                delete b.kdTree;
              });
              n = Q(n, {
                min: b,
                max: c
              });
              z(q, "setExtremes", n, function () {
                q.userMin = b;
                q.userMax = c;
                q.eventArgs = n;
                a && d.redraw(f);
              });
            };

            e.prototype.zoom = function (b, c) {
              var a = this,
                  q = this.dataMin,
                  f = this.dataMax,
                  n = this.options,
                  d = Math.min(q, u(n.min, q)),
                  h = Math.max(f, u(n.max, f));
              b = {
                newMin: b,
                newMax: c
              };
              z(this, "zoom", b, function (b) {
                var c = b.newMin,
                    n = b.newMax;
                if (c !== a.min || n !== a.max) a.allowZoomOutside || (k(q) && (c < d && (c = d), c > h && (c = h)), k(f) && (n < d && (n = d), n > h && (n = h))), a.displayBtn = "undefined" !== typeof c || "undefined" !== typeof n, a.setExtremes(c, n, !1, void 0, {
                  trigger: "zoom"
                });
                b.zoomed = !0;
              });
              return b.zoomed;
            };

            e.prototype.setAxisSize = function () {
              var b = this.chart,
                  c = this.options,
                  a = c.offsets || [0, 0, 0, 0],
                  f = this.horiz,
                  n = this.width = Math.round(N(u(c.width, b.plotWidth - a[3] + a[1]), b.plotWidth)),
                  d = this.height = Math.round(N(u(c.height, b.plotHeight - a[0] + a[2]), b.plotHeight)),
                  k = this.top = Math.round(N(u(c.top, b.plotTop + a[0]), b.plotHeight, b.plotTop));
              c = this.left = Math.round(N(u(c.left, b.plotLeft + a[3]), b.plotWidth, b.plotLeft));
              this.bottom = b.chartHeight - d - k;
              this.right = b.chartWidth - n - c;
              this.len = Math.max(f ? n : d, 0);
              this.pos = f ? c : k;
            };

            e.prototype.getExtremes = function () {
              var b = this.logarithmic;
              return {
                min: b ? f(b.lin2log(this.min)) : this.min,
                max: b ? f(b.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
              };
            };

            e.prototype.getThreshold = function (b) {
              var c = this.logarithmic,
                  a = c ? c.lin2log(this.min) : this.min;
              c = c ? c.lin2log(this.max) : this.max;
              null === b || -Infinity === b ? b = a : Infinity === b ? b = c : a > b ? b = a : c < b && (b = c);
              return this.translate(b, 0, 1, 0, 1);
            };

            e.prototype.autoLabelAlign = function (b) {
              var c = (u(b, 0) - 90 * this.side + 720) % 360;
              b = {
                align: "center"
              };
              z(this, "autoLabelAlign", b, function (b) {
                15 < c && 165 > c ? b.align = "right" : 195 < c && 345 > c && (b.align = "left");
              });
              return b.align;
            };

            e.prototype.tickSize = function (b) {
              var c = this.options,
                  a = u(c["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
                  f = c["tick" === b ? "tickLength" : "minorTickLength"];

              if (a && f) {
                "inside" === c[b + "Position"] && (f = -f);
                var n = [f, a];
              }

              b = {
                tickSize: n
              };
              z(this, "afterTickSize", b);
              return b.tickSize;
            };

            e.prototype.labelMetrics = function () {
              var b = this.tickPositions && this.tickPositions[0] || 0;
              return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
            };

            e.prototype.unsquish = function () {
              var c = this.options.labels,
                  a = this.horiz,
                  n = this.tickInterval,
                  d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / n),
                  k = c.rotation,
                  h = this.labelMetrics(),
                  w = Math.max(this.max - this.min, 0),
                  l = function l(b) {
                var c = b / (d || 1);
                c = 1 < c ? Math.ceil(c) : 1;
                c * n > w && Infinity !== b && Infinity !== d && w && (c = Math.ceil(w / n));
                return f(c * n);
              },
                  D = n,
                  A,
                  t,
                  z = Number.MAX_VALUE;

              if (a) {
                if (!c.staggerLines && !c.step) if (b(k)) var e = [k];else d < c.autoRotationLimit && (e = c.autoRotation);
                e && e.forEach(function (b) {
                  if (b === k || b && -90 <= b && 90 >= b) {
                    t = l(Math.abs(h.h / Math.sin(p * b)));
                    var c = t + Math.abs(b / 360);
                    c < z && (z = c, A = b, D = t);
                  }
                });
              } else c.step || (D = l(h.h));

              this.autoRotation = e;
              this.labelRotation = u(A, b(k) ? k : 0);
              return D;
            };

            e.prototype.getSlotWidth = function (c) {
              var a = this.chart,
                  f = this.horiz,
                  n = this.options.labels,
                  d = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                  q = a.margin[3];
              if (c && b(c.slotWidth)) return c.slotWidth;
              if (f && 2 > n.step) return n.rotation ? 0 : (this.staggerLines || 1) * this.len / d;

              if (!f) {
                c = n.style.width;
                if (void 0 !== c) return parseInt(String(c), 10);
                if (q) return q - a.spacing[3];
              }

              return .33 * a.chartWidth;
            };

            e.prototype.renderUnsquish = function () {
              var b = this.chart,
                  c = b.renderer,
                  a = this.tickPositions,
                  f = this.ticks,
                  n = this.options.labels,
                  d = n.style,
                  k = this.horiz,
                  h = this.getSlotWidth(),
                  u = Math.max(1, Math.round(h - 2 * n.padding)),
                  w = {},
                  l = this.labelMetrics(),
                  A = d.textOverflow,
                  t = 0;
              D(n.rotation) || (w.rotation = n.rotation || 0);
              a.forEach(function (b) {
                b = f[b];
                b.movedLabel && b.replaceMovedLabel();
                b && b.label && b.label.textPxLength > t && (t = b.label.textPxLength);
              });
              this.maxLabelLength = t;
              if (this.autoRotation) t > u && t > l.h ? w.rotation = this.labelRotation : this.labelRotation = 0;else if (h) {
                var p = u;

                if (!A) {
                  var e = "clip";

                  for (u = a.length; !k && u--;) {
                    var z = a[u];
                    if (z = f[z].label) z.styles && "ellipsis" === z.styles.textOverflow ? z.css({
                      textOverflow: "clip"
                    }) : z.textPxLength > h && z.css({
                      width: h + "px"
                    }), z.getBBox().height > this.len / a.length - (l.h - l.f) && (z.specificTextOverflow = "ellipsis");
                  }
                }
              }
              w.rotation && (p = t > .5 * b.chartHeight ? .33 * b.chartHeight : t, A || (e = "ellipsis"));
              if (this.labelAlign = n.align || this.autoLabelAlign(this.labelRotation)) w.align = this.labelAlign;
              a.forEach(function (b) {
                var c = (b = f[b]) && b.label,
                    a = d.width,
                    n = {};
                c && (c.attr(w), b.shortenLabel ? b.shortenLabel() : p && !a && "nowrap" !== d.whiteSpace && (p < c.textPxLength || "SPAN" === c.element.tagName) ? (n.width = p + "px", A || (n.textOverflow = c.specificTextOverflow || e), c.css(n)) : c.styles && c.styles.width && !n.width && !a && c.css({
                  width: null
                }), delete c.specificTextOverflow, b.rotation = w.rotation);
              }, this);
              this.tickRotCorr = c.rotCorr(l.b, this.labelRotation || 0, 0 !== this.side);
            };

            e.prototype.hasData = function () {
              return this.series.some(function (b) {
                return b.hasData();
              }) || this.options.showEmpty && k(this.min) && k(this.max);
            };

            e.prototype.addTitle = function (b) {
              var c = this.chart.renderer,
                  a = this.horiz,
                  n = this.opposite,
                  f = this.options.title,
                  d = this.chart.styledMode,
                  q;
              this.axisTitle || ((q = f.textAlign) || (q = (a ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: n ? "right" : "left",
                middle: "center",
                high: n ? "left" : "right"
              })[f.align]), this.axisTitle = c.text(f.text || "", 0, 0, f.useHTML).attr({
                zIndex: 7,
                rotation: f.rotation,
                align: q
              }).addClass("highcharts-axis-title"), d || this.axisTitle.css(L(f.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
              d || f.style.width || this.isRadial || this.axisTitle.css({
                width: this.len + "px"
              });
              this.axisTitle[b ? "show" : "hide"](b);
            };

            e.prototype.generateTick = function (b) {
              var c = this.ticks;
              c[b] ? c[b].addLabel() : c[b] = new x(this, b);
            };

            e.prototype.getOffset = function () {
              var b = this,
                  c = this,
                  a = c.chart,
                  f = a.renderer,
                  d = c.options,
                  h = c.tickPositions,
                  w = c.ticks,
                  l = c.horiz,
                  D = c.side,
                  t = a.inverted && !c.isZAxis ? [1, 0, 3, 2][D] : D,
                  A = c.hasData(),
                  p = d.title,
                  e = d.labels,
                  I = a.axisOffset;
              a = a.clipOffset;
              var H = [-1, 1, 1, -1][D],
                  m = d.className,
                  L = c.axisParent,
                  N,
                  g = 0,
                  r = 0,
                  O = 0;
              c.showAxis = N = A || d.showEmpty;
              c.staggerLines = c.horiz && e.staggerLines || void 0;

              if (!c.axisGroup) {
                var B = function B(c, a, n) {
                  return f.g(c).attr({
                    zIndex: n
                  }).addClass("highcharts-" + b.coll.toLowerCase() + a + " " + (b.isRadial ? "highcharts-radial-axis" + a + " " : "") + (m || "")).add(L);
                };

                c.gridGroup = B("grid", "-grid", d.gridZIndex);
                c.axisGroup = B("axis", "", d.zIndex);
                c.labelGroup = B("axis-labels", "-labels", e.zIndex);
              }

              A || c.isLinked ? (h.forEach(function (b) {
                c.generateTick(b);
              }), c.renderUnsquish(), c.reserveSpaceDefault = 0 === D || 2 === D || {
                1: "left",
                3: "right"
              }[D] === c.labelAlign, u(e.reserveSpace, "center" === c.labelAlign ? !0 : null, c.reserveSpaceDefault) && h.forEach(function (b) {
                O = Math.max(w[b].getLabelSize(), O);
              }), c.staggerLines && (O *= c.staggerLines), c.labelOffset = O * (c.opposite ? -1 : 1)) : n(w, function (b, c) {
                b.destroy();
                delete w[c];
              });

              if (p && p.text && !1 !== p.enabled && (c.addTitle(N), N && !1 !== p.reserveSpace)) {
                c.titleOffset = g = c.axisTitle.getBBox()[l ? "height" : "width"];
                var R = p.offset;
                r = k(R) ? 0 : u(p.margin, l ? 5 : 10);
              }

              c.renderLine();
              c.offset = H * u(d.offset, I[D] ? I[D] + (d.margin || 0) : 0);
              c.tickRotCorr = c.tickRotCorr || {
                x: 0,
                y: 0
              };
              p = 0 === D ? -c.labelMetrics().h : 2 === D ? c.tickRotCorr.y : 0;
              A = Math.abs(O) + r;
              O && (A = A - p + H * (l ? u(e.y, c.tickRotCorr.y + 8 * H) : e.x));
              c.axisTitleMargin = u(R, A);
              c.getMaxLabelDimensions && (c.maxLabelDimensions = c.getMaxLabelDimensions(w, h));
              l = this.tickSize("tick");
              I[D] = Math.max(I[D], (c.axisTitleMargin || 0) + g + H * c.offset, A, h && h.length && l ? l[0] + H * c.offset : 0);
              d = d.offset ? 0 : 2 * Math.floor(c.axisLine.strokeWidth() / 2);
              a[t] = Math.max(a[t], d);
              z(this, "afterGetOffset");
            };

            e.prototype.getLinePath = function (b) {
              var c = this.chart,
                  a = this.opposite,
                  f = this.offset,
                  n = this.horiz,
                  d = this.left + (a ? this.width : 0) + f;
              f = c.chartHeight - this.bottom - (a ? this.height : 0) + f;
              a && (b *= -1);
              return c.renderer.crispLine([["M", n ? this.left : d, n ? f : this.top], ["L", n ? c.chartWidth - this.right : d, n ? f : c.chartHeight - this.bottom]], b);
            };

            e.prototype.renderLine = function () {
              this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              }));
            };

            e.prototype.getTitlePosition = function () {
              var b = this.horiz,
                  c = this.left,
                  a = this.top,
                  f = this.len,
                  n = this.options.title,
                  d = b ? c : a,
                  k = this.opposite,
                  h = this.offset,
                  u = n.x,
                  w = n.y,
                  l = this.axisTitle,
                  D = this.chart.renderer.fontMetrics(n.style.fontSize, l);
              l = Math.max(l.getBBox(null, 0).height - D.h - 1, 0);
              f = {
                low: d + (b ? 0 : f),
                middle: d + f / 2,
                high: d + (b ? f : 0)
              }[n.align];
              c = (b ? a + this.height : c) + (b ? 1 : -1) * (k ? -1 : 1) * this.axisTitleMargin + [-l, l, D.f, -l][this.side];
              b = {
                x: b ? f + u : c + (k ? this.width : 0) + h + u,
                y: b ? c + w - (k ? this.height : 0) + h : f + w
              };
              z(this, "afterGetTitlePosition", {
                titlePosition: b
              });
              return b;
            };

            e.prototype.renderMinorTick = function (b, c) {
              var a = this.minorTicks;
              a[b] || (a[b] = new x(this, b, "minor"));
              c && a[b].isNew && a[b].render(null, !0);
              a[b].render(null, !1, 1);
            };

            e.prototype.renderTick = function (b, c, a) {
              var f = this.ticks;
              if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) f[b] || (f[b] = new x(this, b)), a && f[b].isNew && f[b].render(c, !0, -1), f[b].render(c);
            };

            e.prototype.render = function () {
              var c = this,
                  a = c.chart,
                  f = c.logarithmic,
                  d = c.options,
                  k = c.isLinked,
                  h = c.tickPositions,
                  u = c.axisTitle,
                  w = c.ticks,
                  l = c.minorTicks,
                  D = c.alternateBands,
                  A = d.stackLabels,
                  t = d.alternateGridColor,
                  p = c.tickmarkOffset,
                  e = c.axisLine,
                  I = c.showAxis,
                  H = m(a.renderer.globalAnimation),
                  L,
                  N;
              c.labelEdge.length = 0;
              c.overlap = !1;
              [w, l, D].forEach(function (b) {
                n(b, function (b) {
                  b.isActive = !1;
                });
              });

              if (c.hasData() || k) {
                var g = c.chart.hasRendered && c.old && b(c.old.min);
                c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function (b) {
                  c.renderMinorTick(b, g);
                });
                h.length && (h.forEach(function (b, a) {
                  c.renderTick(b, a, g);
                }), p && (0 === c.min || c.single) && (w[-1] || (w[-1] = new x(c, -1, null, !0)), w[-1].render(-1)));
                t && h.forEach(function (b, n) {
                  N = "undefined" !== typeof h[n + 1] ? h[n + 1] + p : c.max - p;
                  0 === n % 2 && b < c.max && N <= c.max + (a.polar ? -p : p) && (D[b] || (D[b] = new G.PlotLineOrBand(c)), L = b + p, D[b].options = {
                    from: f ? f.lin2log(L) : L,
                    to: f ? f.lin2log(N) : N,
                    color: t,
                    className: "highcharts-alternate-grid"
                  }, D[b].render(), D[b].isActive = !0);
                });
                c._addedPlotLB || (c._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (b) {
                  c.addPlotBandOrLine(b);
                }));
              }

              [w, l, D].forEach(function (b) {
                var c = [],
                    f = H.duration;
                n(b, function (b, a) {
                  b.isActive || (b.render(a, !1, 0), b.isActive = !1, c.push(a));
                });
                O(function () {
                  for (var a = c.length; a--;) {
                    b[c[a]] && !b[c[a]].isActive && (b[c[a]].destroy(), delete b[c[a]]);
                  }
                }, b !== D && a.hasRendered && f ? f : 0);
              });
              e && (e[e.isPlaced ? "animate" : "attr"]({
                d: this.getLinePath(e.strokeWidth())
              }), e.isPlaced = !0, e[I ? "show" : "hide"](I));
              u && I && (d = c.getTitlePosition(), b(d.y) ? (u[u.isNew ? "attr" : "animate"](d), u.isNew = !1) : (u.attr("y", -9999), u.isNew = !0));
              A && A.enabled && c.stacking && c.stacking.renderStackTotals();
              c.old = {
                len: c.len,
                max: c.max,
                min: c.min,
                transA: c.transA,
                userMax: c.userMax,
                userMin: c.userMin
              };
              c.isDirty = !1;
              z(this, "afterRender");
            };

            e.prototype.redraw = function () {
              this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
                b.render();
              }));
              this.series.forEach(function (b) {
                b.isDirty = !0;
              });
            };

            e.prototype.getKeepProps = function () {
              return this.keepProps || e.keepProps;
            };

            e.prototype.destroy = function (b) {
              var c = this,
                  a = c.plotLinesAndBands,
                  f = this.eventOptions;
              z(this, "destroy", {
                keepEvents: b
              });
              b || w(c);
              [c.ticks, c.minorTicks, c.alternateBands].forEach(function (b) {
                J(b);
              });
              if (a) for (b = a.length; b--;) {
                a[b].destroy();
              }
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
                c[b] && (c[b] = c[b].destroy());
              });

              for (var d in c.plotLinesAndBandsGroups) {
                c.plotLinesAndBandsGroups[d] = c.plotLinesAndBandsGroups[d].destroy();
              }

              n(c, function (b, a) {
                -1 === c.getKeepProps().indexOf(a) && delete c[a];
              });
              this.eventOptions = f;
            };

            e.prototype.drawCrosshair = function (b, c) {
              var a = this.crosshair,
                  f = u(a && a.snap, !0),
                  n = this.chart,
                  d,
                  h = this.cross;
              z(this, "drawCrosshair", {
                e: b,
                point: c
              });
              b || (b = this.cross && this.cross.e);

              if (a && !1 !== (k(c) || !f)) {
                f ? k(c) && (d = u("colorAxis" !== this.coll ? c.crosshairPos : null, this.isXAxis ? c.plotX : this.len - c.plotY)) : d = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);

                if (k(d)) {
                  var q = {
                    value: c && (this.isXAxis ? c.x : u(c.stackY, c.y)),
                    translatedValue: d
                  };
                  n.polar && Q(q, {
                    isCrosshair: !0,
                    chartX: b && b.chartX,
                    chartY: b && b.chartY,
                    point: c
                  });
                  q = this.getPlotLinePath(q) || null;
                }

                if (!k(q)) {
                  this.hideCrosshair();
                  return;
                }

                f = this.categories && !this.isRadial;
                h || (this.cross = h = n.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (f ? "category " : "thin ") + (a.className || "")).attr({
                  zIndex: u(a.zIndex, 2)
                }).add(), n.styledMode || (h.attr({
                  stroke: a.color || (f ? C.parse(y.highlightColor20).setOpacity(.25).get() : y.neutralColor20),
                  "stroke-width": u(a.width, 1)
                }).css({
                  "pointer-events": "none"
                }), a.dashStyle && h.attr({
                  dashstyle: a.dashStyle
                })));
                h.show().attr({
                  d: q
                });
                f && !a.width && h.attr({
                  "stroke-width": this.transA
                });
                this.cross.e = b;
              } else this.hideCrosshair();

              z(this, "afterDrawCrosshair", {
                e: b,
                point: c
              });
            };

            e.prototype.hideCrosshair = function () {
              this.cross && this.cross.hide();
              z(this, "afterHideCrosshair");
            };

            e.prototype.hasVerticalPanning = function () {
              var b = this.chart.options.chart.panning;
              return !!(b && b.enabled && /y/.test(b.type));
            };

            e.prototype.validatePositiveValue = function (c) {
              return b(c) && 0 < c;
            };

            e.prototype.update = function (b, c) {
              var a = this.chart;
              b = L(this.userOptions, b);
              this.destroy(!0);
              this.init(a, b);
              a.isDirtyBox = !0;
              u(c, !0) && a.redraw();
            };

            e.prototype.remove = function (b) {
              for (var c = this.chart, a = this.coll, f = this.series, n = f.length; n--;) {
                f[n] && f[n].remove(!1);
              }

              K(c.axes, this);
              K(c[a], this);
              c[a].forEach(function (b, c) {
                b.options.index = b.userOptions.index = c;
              });
              this.destroy();
              c.isDirtyBox = !0;
              u(b, !0) && c.redraw();
            };

            e.prototype.setTitle = function (b, c) {
              this.update({
                title: b
              }, c);
            };

            e.prototype.setCategories = function (b, c) {
              this.update({
                categories: b
              }, c);
            };

            e.defaultOptions = g.defaultXAxisOptions;
            e.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return e;
          }();

          "";
          return e;
        });
        M(g, "Core/Axis/DateTimeAxis.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.addEvent,
              C = e.getMagnitude,
              y = e.normalizeTickInterval,
              E = e.timeUnits,
              v;

          (function (e) {
            function x() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }

            function r(a) {
              "datetime" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new d(this));
            }

            var m = [];

            e.compose = function (a) {
              -1 === m.indexOf(a) && (m.push(a), a.keepProps.push("dateTime"), a.prototype.getTimeTicks = x, g(a, "init", r));
              return a;
            };

            var d = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.normalizeTimeTickInterval = function (a, d) {
                var l = d || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                d = l[l.length - 1];
                var h = E[d[0]],
                    f = d[1],
                    k;

                for (k = 0; k < l.length && !(d = l[k], h = E[d[0]], f = d[1], l[k + 1] && a <= (h * f[f.length - 1] + E[l[k + 1][0]]) / 2); k++) {
                  ;
                }

                h === E.year && a < 5 * h && (f = [1, 2, 5]);
                a = y(a / h, f, "year" === d[0] ? Math.max(C(a / h), 1) : 1);
                return {
                  unitRange: h,
                  count: a,
                  unitName: d[0]
                };
              };

              a.prototype.getXDateFormat = function (a, d) {
                var l = this.axis;
                return l.closestPointRange ? l.chart.time.getDateFormat(l.closestPointRange, a, l.options.startOfWeek, d) || d.year : d.day;
              };

              return a;
            }();

            e.Additions = d;
          })(v || (v = {}));

          return v;
        });
        M(g, "Core/Axis/LogarithmicAxis.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.addEvent,
              C = e.getMagnitude,
              y = e.normalizeTickInterval,
              E = e.pick,
              v;

          (function (e) {
            function x(a) {
              var e = this.logarithmic;
              "logarithmic" !== a.userOptions.type ? this.logarithmic = void 0 : e || (this.logarithmic = new d(this));
            }

            function r() {
              var a = this.logarithmic;
              a && (this.lin2val = function (d) {
                return a.lin2log(d);
              }, this.val2lin = function (d) {
                return a.log2lin(d);
              });
            }

            var m = [];

            e.compose = function (a) {
              -1 === m.indexOf(a) && (m.push(a), a.keepProps.push("logarithmic"), g(a, "init", x), g(a, "afterInit", r));
              return a;
            };

            var d = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.getLogTickPositions = function (a, d, l, h) {
                var f = this.axis,
                    k = f.len,
                    e = f.options,
                    p = [];
                h || (this.minorAutoInterval = void 0);
                if (.5 <= a) a = Math.round(a), p = f.getLinearTickPositions(a, d, l);else if (.08 <= a) {
                  var t = Math.floor(d),
                      m,
                      z = e = void 0;

                  for (k = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; t < l + 1 && !z; t++) {
                    var A = k.length;

                    for (m = 0; m < A && !z; m++) {
                      var c = this.log2lin(this.lin2log(t) * k[m]);
                      c > d && (!h || e <= l) && "undefined" !== typeof e && p.push(e);
                      e > l && (z = !0);
                      e = c;
                    }
                  }
                } else d = this.lin2log(d), l = this.lin2log(l), a = h ? f.getMinorTickInterval() : e.tickInterval, a = E("auto" === a ? null : a, this.minorAutoInterval, e.tickPixelInterval / (h ? 5 : 1) * (l - d) / ((h ? k / f.tickPositions.length : k) || 1)), a = y(a, void 0, C(a)), p = f.getLinearTickPositions(a, d, l).map(this.log2lin), h || (this.minorAutoInterval = a / 5);
                h || (f.tickInterval = a);
                return p;
              };

              a.prototype.lin2log = function (a) {
                return Math.pow(10, a);
              };

              a.prototype.log2lin = function (a) {
                return Math.log(a) / Math.LN10;
              };

              return a;
            }();

            e.Additions = d;
          })(v || (v = {}));

          return v;
        });
        M(g, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.erase,
              C = e.extend,
              y = e.isNumber,
              E;

          (function (e) {
            var v = [],
                x;

            e.compose = function (e, d) {
              x || (x = e);
              -1 === v.indexOf(d) && (v.push(d), C(d.prototype, r.prototype));
              return d;
            };

            var r = function () {
              function e() {}

              e.prototype.getPlotBandPath = function (d, a, e) {
                void 0 === e && (e = this.options);
                var p = this.getPlotLinePath({
                  value: a,
                  force: !0,
                  acrossPanes: e.acrossPanes
                }),
                    l = [],
                    h = this.horiz;
                a = !y(this.min) || !y(this.max) || d < this.min && a < this.min || d > this.max && a > this.max;
                d = this.getPlotLinePath({
                  value: d,
                  force: !0,
                  acrossPanes: e.acrossPanes
                });
                e = 1;

                if (d && p) {
                  if (a) {
                    var f = d.toString() === p.toString();
                    e = 0;
                  }

                  for (a = 0; a < d.length; a += 2) {
                    var k = d[a],
                        m = d[a + 1],
                        g = p[a],
                        t = p[a + 1];
                    "M" !== k[0] && "L" !== k[0] || "M" !== m[0] && "L" !== m[0] || "M" !== g[0] && "L" !== g[0] || "M" !== t[0] && "L" !== t[0] || (h && g[1] === k[1] ? (g[1] += e, t[1] += e) : h || g[2] !== k[2] || (g[2] += e, t[2] += e), l.push(["M", k[1], k[2]], ["L", m[1], m[2]], ["L", t[1], t[2]], ["L", g[1], g[2]], ["Z"]));
                    l.isFlat = f;
                  }
                }

                return l;
              };

              e.prototype.addPlotBand = function (d) {
                return this.addPlotBandOrLine(d, "plotBands");
              };

              e.prototype.addPlotLine = function (d) {
                return this.addPlotBandOrLine(d, "plotLines");
              };

              e.prototype.addPlotBandOrLine = function (d, a) {
                var e = this,
                    m = this.userOptions,
                    l = new x(this, d);
                this.visible && (l = l.render());

                if (l) {
                  this._addedPlotLB || (this._addedPlotLB = !0, (m.plotLines || []).concat(m.plotBands || []).forEach(function (a) {
                    e.addPlotBandOrLine(a);
                  }));

                  if (a) {
                    var h = m[a] || [];
                    h.push(d);
                    m[a] = h;
                  }

                  this.plotLinesAndBands.push(l);
                }

                return l;
              };

              e.prototype.removePlotBandOrLine = function (d) {
                var a = this.plotLinesAndBands,
                    e = this.options,
                    m = this.userOptions;

                if (a) {
                  for (var l = a.length; l--;) {
                    a[l].id === d && a[l].destroy();
                  }

                  [e.plotLines || [], m.plotLines || [], e.plotBands || [], m.plotBands || []].forEach(function (a) {
                    for (l = a.length; l--;) {
                      (a[l] || {}).id === d && g(a, a[l]);
                    }
                  });
                }
              };

              e.prototype.removePlotBand = function (d) {
                this.removePlotBandOrLine(d);
              };

              e.prototype.removePlotLine = function (d) {
                this.removePlotBandOrLine(d);
              };

              return e;
            }();
          })(E || (E = {}));

          return E;
        });
        M(g, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [g["Core/Color/Palette.js"], g["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var P = C.arrayMax,
              E = C.arrayMin,
              v = C.defined,
              G = C.destroyObjectProperties,
              x = C.erase,
              r = C.fireEvent,
              m = C.merge,
              d = C.objectEach,
              a = C.pick;

          C = function () {
            function p(a, d) {
              this.axis = a;
              d && (this.options = d, this.id = d.id);
            }

            p.compose = function (a) {
              return g.compose(p, a);
            };

            p.prototype.render = function () {
              r(this, "render");
              var p = this,
                  l = p.axis,
                  h = l.horiz,
                  f = l.logarithmic,
                  k = p.options,
                  g = k.color,
                  K = a(k.zIndex, 0),
                  t = k.events,
                  Q = {},
                  z = l.chart.renderer,
                  A = k.label,
                  c = p.label,
                  b = k.to,
                  D = k.from,
                  L = k.value,
                  I = p.svgElem,
                  n = [],
                  u = v(D) && v(b);
              n = v(L);
              var N = !I,
                  w = {
                "class": "highcharts-plot-" + (u ? "band " : "line ") + (k.className || "")
              },
                  H = u ? "bands" : "lines";
              f && (D = f.log2lin(D), b = f.log2lin(b), L = f.log2lin(L));
              l.chart.styledMode || (n ? (w.stroke = g || e.neutralColor40, w["stroke-width"] = a(k.width, 1), k.dashStyle && (w.dashstyle = k.dashStyle)) : u && (w.fill = g || e.highlightColor10, k.borderWidth && (w.stroke = k.borderColor, w["stroke-width"] = k.borderWidth)));
              Q.zIndex = K;
              H += "-" + K;
              (f = l.plotLinesAndBandsGroups[H]) || (l.plotLinesAndBandsGroups[H] = f = z.g("plot-" + H).attr(Q).add());
              N && (p.svgElem = I = z.path().attr(w).add(f));
              if (n) n = l.getPlotLinePath({
                value: L,
                lineWidth: I.strokeWidth(),
                acrossPanes: k.acrossPanes
              });else if (u) n = l.getPlotBandPath(D, b, k);else return;
              !p.eventsAdded && t && (d(t, function (b, c) {
                I.on(c, function (b) {
                  t[c].apply(p, [b]);
                });
              }), p.eventsAdded = !0);
              (N || !I.d) && n && n.length ? I.attr({
                d: n
              }) : I && (n ? (I.show(!0), I.animate({
                d: n
              })) : I.d && (I.hide(), c && (p.label = c = c.destroy())));
              A && (v(A.text) || v(A.formatter)) && n && n.length && 0 < l.width && 0 < l.height && !n.isFlat ? (A = m({
                align: h && u && "center",
                x: h ? !u && 4 : 10,
                verticalAlign: !h && u && "middle",
                y: h ? u ? 16 : 10 : u ? 6 : -4,
                rotation: h && !u && 90
              }, A), this.renderLabel(A, n, u, K)) : c && c.hide();
              return p;
            };

            p.prototype.renderLabel = function (a, d, h, f) {
              var k = this.axis,
                  l = k.chart.renderer,
                  e = this.label;
              e || (this.label = e = l.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
                align: a.textAlign || a.align,
                rotation: a.rotation,
                "class": "highcharts-plot-" + (h ? "band" : "line") + "-label " + (a.className || ""),
                zIndex: f
              }).add(), k.chart.styledMode || e.css(m({
                textOverflow: "ellipsis"
              }, a.style)));
              f = d.xBounds || [d[0][1], d[1][1], h ? d[2][1] : d[0][1]];
              d = d.yBounds || [d[0][2], d[1][2], h ? d[2][2] : d[0][2]];
              h = E(f);
              l = E(d);
              e.align(a, !1, {
                x: h,
                y: l,
                width: P(f) - h,
                height: P(d) - l
              });
              e.alignValue && "left" !== e.alignValue || e.css({
                width: (90 === e.rotation ? k.height - (e.alignAttr.y - k.top) : k.width - (e.alignAttr.x - k.left)) + "px"
              });
              e.show(!0);
            };

            p.prototype.getLabelText = function (a) {
              return v(a.formatter) ? a.formatter.call(this) : a.text;
            };

            p.prototype.destroy = function () {
              x(this.axis.plotLinesAndBands, this);
              delete this.axis;
              G(this);
            };

            return p;
          }();

          "";
          "";
          return C;
        });
        M(g, "Core/Tooltip.js", [g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Color/Palette.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v) {
          var G = e.format,
              x = g.doc,
              r = y.distribute,
              m = v.addEvent,
              d = v.clamp,
              a = v.css,
              p = v.defined,
              B = v.discardElement,
              l = v.extend,
              h = v.fireEvent,
              f = v.isArray,
              k = v.isNumber,
              J = v.isString,
              K = v.merge,
              t = v.pick,
              Q = v.splat,
              z = v.syncTimeout;

          e = function () {
            function e(c, b) {
              this.container = void 0;
              this.crosshairs = [];
              this.distance = 0;
              this.isHidden = !0;
              this.isSticky = !1;
              this.now = {};
              this.options = {};
              this.outside = !1;
              this.chart = c;
              this.init(c, b);
            }

            e.prototype.applyFilter = function () {
              var c = this.chart;
              c.renderer.definition({
                tagName: "filter",
                attributes: {
                  id: "drop-shadow-" + c.index,
                  opacity: .5
                },
                children: [{
                  tagName: "feGaussianBlur",
                  attributes: {
                    "in": "SourceAlpha",
                    stdDeviation: 1
                  }
                }, {
                  tagName: "feOffset",
                  attributes: {
                    dx: 1,
                    dy: 1
                  }
                }, {
                  tagName: "feComponentTransfer",
                  children: [{
                    tagName: "feFuncA",
                    attributes: {
                      type: "linear",
                      slope: .3
                    }
                  }]
                }, {
                  tagName: "feMerge",
                  children: [{
                    tagName: "feMergeNode"
                  }, {
                    tagName: "feMergeNode",
                    attributes: {
                      "in": "SourceGraphic"
                    }
                  }]
                }]
              });
            };

            e.prototype.bodyFormatter = function (c) {
              return c.map(function (b) {
                var c = b.series.tooltipOptions;
                return (c[(b.point.formatPrefix || "point") + "Formatter"] || b.point.tooltipFormatter).call(b.point, c[(b.point.formatPrefix || "point") + "Format"] || "");
              });
            };

            e.prototype.cleanSplit = function (c) {
              this.chart.series.forEach(function (b) {
                var a = b && b.tt;
                a && (!a.isActive || c ? b.tt = a.destroy() : a.isActive = !1);
              });
            };

            e.prototype.defaultFormatter = function (c) {
              var b = this.points || Q(this);
              var a = [c.tooltipFooterHeaderFormatter(b[0])];
              a = a.concat(c.bodyFormatter(b));
              a.push(c.tooltipFooterHeaderFormatter(b[0], !0));
              return a;
            };

            e.prototype.destroy = function () {
              this.label && (this.label = this.label.destroy());
              this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
              this.renderer && (this.renderer = this.renderer.destroy(), B(this.container));
              v.clearTimeout(this.hideTimer);
              v.clearTimeout(this.tooltipTimeout);
            };

            e.prototype.getAnchor = function (c, b) {
              var a = this.chart,
                  f = a.pointer,
                  d = a.inverted,
                  n = a.plotTop,
                  k = a.plotLeft,
                  h,
                  w,
                  e = 0,
                  l = 0;
              c = Q(c);
              this.followPointer && b ? ("undefined" === typeof b.chartX && (b = f.normalize(b)), f = [b.chartX - k, b.chartY - n]) : c[0].tooltipPos ? f = c[0].tooltipPos : (c.forEach(function (b) {
                h = b.series.yAxis;
                w = b.series.xAxis;
                e += b.plotX || 0;
                l += b.plotLow ? (b.plotLow + (b.plotHigh || 0)) / 2 : b.plotY || 0;
                w && h && (d ? (e += n + a.plotHeight - w.len - w.pos, l += k + a.plotWidth - h.len - h.pos) : (e += w.pos - k, l += h.pos - n));
              }), e /= c.length, l /= c.length, f = [d ? a.plotWidth - l : e, d ? a.plotHeight - e : l], this.shared && 1 < c.length && b && (d ? f[0] = b.chartX - k : f[1] = b.chartY - n));
              return f.map(Math.round);
            };

            e.prototype.getLabel = function () {
              var c = this,
                  b = this.chart.styledMode,
                  f = this.options,
                  d = "tooltip" + (p(f.className) ? " " + f.className : ""),
                  k = f.style.pointerEvents || (!this.followPointer && f.stickOnContact ? "auto" : "none"),
                  n = function n() {
                c.inContact = !0;
              },
                  h = function h(b) {
                var a = c.chart.hoverSeries;
                c.inContact = c.shouldStickOnContact() && c.chart.pointer.inClass(b.relatedTarget, "highcharts-tooltip");
                if (!c.inContact && a && a.onMouseOut) a.onMouseOut();
              },
                  e,
                  w = this.chart.renderer;

              if (!this.label) {
                if (this.outside) {
                  var l = this.chart.options.chart.style,
                      t = E.getRendererType();
                  this.container = e = g.doc.createElement("div");
                  e.className = "highcharts-tooltip-container";
                  a(e, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: k,
                    zIndex: Math.max(this.options.style.zIndex || 0, (l && l.zIndex || 0) + 3)
                  });
                  m(e, "mouseenter", n);
                  m(e, "mouseleave", h);
                  g.doc.body.appendChild(e);
                  this.renderer = w = new t(e, 0, 0, l, void 0, void 0, w.styledMode);
                }

                this.split ? this.label = w.g(d) : (this.label = w.label("", 0, 0, f.shape, void 0, void 0, f.useHTML, void 0, d).attr({
                  padding: f.padding,
                  r: f.borderRadius
                }), b || this.label.attr({
                  fill: f.backgroundColor,
                  "stroke-width": f.borderWidth
                }).css(f.style).css({
                  pointerEvents: k
                }).shadow(f.shadow));
                b && f.shadow && (this.applyFilter(), this.label.attr({
                  filter: "url(#drop-shadow-" + this.chart.index + ")"
                }));

                if (c.outside && !c.split) {
                  var A = this.label,
                      q = A.xSetter,
                      z = A.ySetter;

                  A.xSetter = function (b) {
                    q.call(A, c.distance);
                    e.style.left = b + "px";
                  };

                  A.ySetter = function (b) {
                    z.call(A, c.distance);
                    e.style.top = b + "px";
                  };
                }

                this.label.on("mouseenter", n).on("mouseleave", h).attr({
                  zIndex: 8
                }).add();
              }

              return this.label;
            };

            e.prototype.getPosition = function (c, b, a) {
              var f = this.chart,
                  d = this.distance,
                  n = {},
                  k = f.inverted && a.h || 0,
                  h = this.outside,
                  w = h ? x.documentElement.clientWidth - 2 * d : f.chartWidth,
                  e = h ? Math.max(x.body.scrollHeight, x.documentElement.scrollHeight, x.body.offsetHeight, x.documentElement.offsetHeight, x.documentElement.clientHeight) : f.chartHeight,
                  l = f.pointer.getChartPosition(),
                  D = function D(n) {
                var k = "x" === n;
                return [n, k ? w : e, k ? c : b].concat(h ? [k ? c * l.scaleX : b * l.scaleY, k ? l.left - d + (a.plotX + f.plotLeft) * l.scaleX : l.top - d + (a.plotY + f.plotTop) * l.scaleY, 0, k ? w : e] : [k ? c : b, k ? a.plotX + f.plotLeft : a.plotY + f.plotTop, k ? f.plotLeft : f.plotTop, k ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);
              },
                  q = D("y"),
                  A = D("x"),
                  z,
                  p = !this.followPointer && t(a.ttBelow, !f.inverted === !!a.negative),
                  m = function m(b, c, a, f, u, q, e) {
                var w = h ? "y" === b ? d * l.scaleY : d * l.scaleX : d,
                    D = (a - f) / 2,
                    t = f < u - d,
                    A = u + d + f < c,
                    z = u - w - a + D;
                u = u + w - D;
                if (p && A) n[b] = u;else if (!p && t) n[b] = z;else if (t) n[b] = Math.min(e - f, 0 > z - k ? z : z - k);else if (A) n[b] = Math.max(q, u + k + a > c ? u : u + k);else return !1;
              },
                  g = function g(b, c, a, f, k) {
                var h;
                k < d || k > c - d ? h = !1 : n[b] = k < a / 2 ? 1 : k > c - f / 2 ? c - f - 2 : k - a / 2;
                return h;
              },
                  r = function r(b) {
                var c = q;
                q = A;
                A = c;
                z = b;
              },
                  B = function B() {
                !1 !== m.apply(0, q) ? !1 !== g.apply(0, A) || z || (r(!0), B()) : z ? n.x = n.y = 0 : (r(!0), B());
              };

              (f.inverted || 1 < this.len) && r();
              B();
              return n;
            };

            e.prototype.hide = function (c) {
              var b = this;
              v.clearTimeout(this.hideTimer);
              c = t(c, this.options.hideDelay);
              this.isHidden || (this.hideTimer = z(function () {
                b.getLabel().fadeOut(c ? void 0 : c);
                b.isHidden = !0;
              }, c));
            };

            e.prototype.init = function (c, b) {
              this.chart = c;
              this.options = b;
              this.crosshairs = [];
              this.now = {
                x: 0,
                y: 0
              };
              this.isHidden = !0;
              this.split = b.split && !c.inverted && !c.polar;
              this.shared = b.shared || this.split;
              this.outside = t(b.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));
            };

            e.prototype.shouldStickOnContact = function () {
              return !(this.followPointer || !this.options.stickOnContact);
            };

            e.prototype.isStickyOnContact = function () {
              return !(!this.shouldStickOnContact() || !this.inContact);
            };

            e.prototype.move = function (c, b, a, f) {
              var d = this,
                  n = d.now,
                  k = !1 !== d.options.animation && !d.isHidden && (1 < Math.abs(c - n.x) || 1 < Math.abs(b - n.y)),
                  h = d.followPointer || 1 < d.len;
              l(n, {
                x: k ? (2 * n.x + c) / 3 : c,
                y: k ? (n.y + b) / 2 : b,
                anchorX: h ? void 0 : k ? (2 * n.anchorX + a) / 3 : a,
                anchorY: h ? void 0 : k ? (n.anchorY + f) / 2 : f
              });
              d.getLabel().attr(n);
              d.drawTracker();
              k && (v.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                d && d.move(c, b, a, f);
              }, 32));
            };

            e.prototype.refresh = function (c, b) {
              var a = this.chart,
                  d = this.options,
                  k = Q(c),
                  n = k[0],
                  u = [],
                  e = d.formatter || this.defaultFormatter,
                  w = this.shared,
                  l = a.styledMode,
                  A = {};

              if (d.enabled) {
                v.clearTimeout(this.hideTimer);
                this.followPointer = !this.split && n.series.tooltipOptions.followPointer;
                var z = this.getAnchor(c, b),
                    q = z[0],
                    p = z[1];
                !w || !f(c) && c.series && c.series.noSharedTooltip ? A = n.getLabelConfig() : (a.pointer.applyInactiveState(k), k.forEach(function (b) {
                  b.setState("hover");
                  u.push(b.getLabelConfig());
                }), A = {
                  x: n.category,
                  y: n.y
                }, A.points = u);
                this.len = u.length;
                c = e.call(A, this);
                e = n.series;
                this.distance = t(e.tooltipOptions.distance, 16);
                if (!1 === c) this.hide();else {
                  if (this.split) this.renderSplit(c, k);else if (k = q, w = p, b && a.pointer.isDirectTouch && (k = b.chartX - a.plotLeft, w = b.chartY - a.plotTop), a.polar || !1 === e.options.clip || e.shouldShowTooltip(k, w)) b = this.getLabel(), d.style.width && !l || b.css({
                    width: this.chart.spacingBox.width + "px"
                  }), b.attr({
                    text: c && c.join ? c.join("") : c
                  }), b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + t(n.colorIndex, e.colorIndex)), l || b.attr({
                    stroke: d.borderColor || n.color || e.color || C.neutralColor60
                  }), this.updatePosition({
                    plotX: q,
                    plotY: p,
                    negative: n.negative,
                    ttBelow: n.ttBelow,
                    h: z[2] || 0
                  });else {
                    this.hide();
                    return;
                  }
                  this.isHidden && this.label && this.label.attr({
                    opacity: 1
                  }).show();
                  this.isHidden = !1;
                }
                h(this, "refresh");
              }
            };

            e.prototype.renderSplit = function (c, b) {
              function a(b, c, a, n, k) {
                void 0 === k && (k = !0);
                a ? (c = P ? 0 : ha, b = d(b - n / 2, V.left, V.right - n - (f.outside ? E : 0))) : (c -= y, b = k ? b - n - K : b + K, b = d(b, k ? b : V.left, V.right));
                return {
                  x: b,
                  y: c
                };
              }

              var f = this,
                  k = f.chart,
                  n = f.chart,
                  h = n.chartWidth,
                  e = n.chartHeight,
                  w = n.plotHeight,
                  A = n.plotLeft,
                  z = n.plotTop,
                  p = n.pointer,
                  q = n.scrollablePixelsY;
              q = void 0 === q ? 0 : q;
              var m = n.scrollablePixelsX,
                  g = n.scrollingContainer;
              g = void 0 === g ? {
                scrollLeft: 0,
                scrollTop: 0
              } : g;
              var B = g.scrollLeft;
              g = g.scrollTop;
              var Q = n.styledMode,
                  K = f.distance,
                  S = f.options,
                  Y = f.options.positioner,
                  V = f.outside && "number" !== typeof m ? x.documentElement.getBoundingClientRect() : {
                left: B,
                right: B + h,
                top: g,
                bottom: g + e
              },
                  v = f.getLabel(),
                  G = this.renderer || k.renderer,
                  P = !(!k.xAxis[0] || !k.xAxis[0].opposite);
              k = p.getChartPosition();
              var E = k.left;
              k = k.top;
              var y = z + g,
                  aa = 0,
                  ha = w - q;
              J(c) && (c = [!1, c]);
              c = c.slice(0, b.length + 1).reduce(function (c, n, k) {
                if (!1 !== n && "" !== n) {
                  k = b[k - 1] || {
                    isHeader: !0,
                    plotX: b[0].plotX,
                    plotY: w,
                    series: {}
                  };
                  var h = k.isHeader,
                      u = h ? f : k.series;
                  n = n.toString();
                  var e = u.tt,
                      q = k.isHeader;
                  var l = k.series;
                  var D = "highcharts-color-" + t(k.colorIndex, l.colorIndex, "none");
                  e || (e = {
                    padding: S.padding,
                    r: S.borderRadius
                  }, Q || (e.fill = S.backgroundColor, e["stroke-width"] = S.borderWidth), e = G.label("", 0, 0, S[q ? "headerShape" : "shape"], void 0, void 0, S.useHTML).addClass((q ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + D).attr(e).add(v));
                  e.isActive = !0;
                  e.attr({
                    text: n
                  });
                  Q || e.css(S.style).shadow(S.shadow).attr({
                    stroke: S.borderColor || k.color || l.color || C.neutralColor80
                  });
                  u = u.tt = e;
                  q = u.getBBox();
                  n = q.width + u.strokeWidth();
                  h && (aa = q.height, ha += aa, P && (y -= aa));
                  l = k.plotX;
                  l = void 0 === l ? 0 : l;
                  D = k.plotY;
                  D = void 0 === D ? 0 : D;
                  e = k.series;

                  if (k.isHeader) {
                    l = A + l;
                    var p = z + w / 2;
                  } else {
                    var m = e.xAxis,
                        H = e.yAxis;
                    l = m.pos + d(l, -K, m.len + K);
                    e.shouldShowTooltip(0, H.pos - z + D, {
                      ignoreX: !0
                    }) && (p = H.pos + D);
                  }

                  l = d(l, V.left - K, V.right + K);
                  "number" === typeof p ? (q = q.height + 1, D = Y ? Y.call(f, n, q, k) : a(l, p, h, n), c.push({
                    align: Y ? 0 : void 0,
                    anchorX: l,
                    anchorY: p,
                    boxWidth: n,
                    point: k,
                    rank: t(D.rank, h ? 1 : 0),
                    size: q,
                    target: D.y,
                    tt: u,
                    x: D.x
                  })) : u.isActive = !1;
                }

                return c;
              }, []);
              !Y && c.some(function (b) {
                var c = (f.outside ? E : 0) + b.anchorX;
                return c < V.left && c + b.boxWidth < V.right ? !0 : c < E - V.left + b.boxWidth && V.right - c > c;
              }) && (c = c.map(function (b) {
                var c = a(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
                return l(b, {
                  target: c.y,
                  x: c.x
                });
              }));
              f.cleanSplit();
              r(c, ha);
              var M = E,
                  ba = E;
              c.forEach(function (b) {
                var c = b.x,
                    a = b.boxWidth;
                b = b.isHeader;
                b || (f.outside && E + c < M && (M = E + c), !b && f.outside && M + a > ba && (ba = E + c));
              });
              c.forEach(function (b) {
                var c = b.x,
                    a = b.anchorX,
                    d = b.pos,
                    n = b.point.isHeader;
                d = {
                  visibility: "undefined" === typeof d ? "hidden" : "inherit",
                  x: c,
                  y: d + y,
                  anchorX: a,
                  anchorY: b.anchorY
                };

                if (f.outside && c < a) {
                  var k = E - M;
                  0 < k && (n || (d.x = c + k, d.anchorX = a + k), n && (d.x = (ba - M) / 2, d.anchorX = a + k));
                }

                b.tt.attr(d);
              });
              c = f.container;
              q = f.renderer;
              f.outside && c && q && (n = v.getBBox(), q.setSize(n.width + n.x, n.height + n.y, !1), c.style.left = M + "px", c.style.top = k + "px");
            };

            e.prototype.drawTracker = function () {
              if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
                var c = this.chart,
                    b = this.label,
                    a = this.shared ? c.hoverPoints : c.hoverPoint;

                if (b && a) {
                  var f = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                  a = this.getAnchor(a);
                  var d = b.getBBox();
                  a[0] += c.plotLeft - b.translateX;
                  a[1] += c.plotTop - b.translateY;
                  f.x = Math.min(0, a[0]);
                  f.y = Math.min(0, a[1]);
                  f.width = 0 > a[0] ? Math.max(Math.abs(a[0]), d.width - a[0]) : Math.max(Math.abs(a[0]), d.width);
                  f.height = 0 > a[1] ? Math.max(Math.abs(a[1]), d.height - Math.abs(a[1])) : Math.max(Math.abs(a[1]), d.height);
                  this.tracker ? this.tracker.attr(f) : (this.tracker = b.renderer.rect(f).addClass("highcharts-tracker").add(b), c.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                  }));
                }
              }
            };

            e.prototype.styledModeFormat = function (c) {
              return c.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };

            e.prototype.tooltipFooterHeaderFormatter = function (c, b) {
              var a = c.series,
                  f = a.tooltipOptions,
                  d = a.xAxis,
                  n = d && d.dateTime;
              d = {
                isFooter: b,
                labelConfig: c
              };
              var e = f.xDateFormat,
                  l = f[b ? "footerFormat" : "headerFormat"];
              h(this, "headerFormatter", d, function (b) {
                n && !e && k(c.key) && (e = n.getXDateFormat(c.key, f.dateTimeLabelFormats));
                n && e && (c.point && c.point.tooltipDateKeys || ["key"]).forEach(function (b) {
                  l = l.replace("{point." + b + "}", "{point." + b + ":" + e + "}");
                });
                a.chart.styledMode && (l = this.styledModeFormat(l));
                b.text = G(l, {
                  point: c,
                  series: a
                }, this.chart);
              });
              return d.text;
            };

            e.prototype.update = function (c) {
              this.destroy();
              K(!0, this.chart.options.tooltip.userOptions, c);
              this.init(this.chart, K(!0, this.options, c));
            };

            e.prototype.updatePosition = function (c) {
              var b = this.chart,
                  f = this.options,
                  d = b.pointer,
                  k = this.getLabel();
              d = d.getChartPosition();
              var n = (f.positioner || this.getPosition).call(this, k.width, k.height, c),
                  h = c.plotX + b.plotLeft;
              c = c.plotY + b.plotTop;

              if (this.outside) {
                f = f.borderWidth + 2 * this.distance;
                this.renderer.setSize(k.width + f, k.height + f, !1);
                if (1 !== d.scaleX || 1 !== d.scaleY) a(this.container, {
                  transform: "scale(" + d.scaleX + ", " + d.scaleY + ")"
                }), h *= d.scaleX, c *= d.scaleY;
                h += d.left - n.x;
                c += d.top - n.y;
              }

              this.move(Math.round(n.x), Math.round(n.y || 0), h, c);
            };

            return e;
          }();

          "";
          return e;
        });
        M(g, "Core/Series/Point.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Animation/AnimationUtilities.js"], g["Core/DefaultOptions.js"], g["Core/FormatUtilities.js"], g["Core/Utilities.js"]], function (e, g, C, y, E) {
          var v = g.animObject,
              G = C.defaultOptions,
              x = y.format,
              r = E.addEvent,
              m = E.defined,
              d = E.erase,
              a = E.extend,
              p = E.fireEvent,
              B = E.getNestedProperty,
              l = E.isArray,
              h = E.isFunction,
              f = E.isNumber,
              k = E.isObject,
              J = E.merge,
              K = E.objectEach,
              t = E.pick,
              Q = E.syncTimeout,
              z = E.removeEvent,
              A = E.uniqueKey;

          g = function () {
            function c() {
              this.colorIndex = this.category = void 0;
              this.formatPrefix = "point";
              this.id = void 0;
              this.isNull = !1;
              this.percentage = this.options = this.name = void 0;
              this.selected = !1;
              this.total = this.series = void 0;
              this.visible = !0;
              this.x = void 0;
            }

            c.prototype.animateBeforeDestroy = function () {
              var b = this,
                  c = {
                x: b.startXPos,
                opacity: 0
              },
                  f = b.getGraphicalProps();
              f.singular.forEach(function (a) {
                b[a] = b[a].animate("dataLabel" === a ? {
                  x: b[a].startXPos,
                  y: b[a].startYPos,
                  opacity: 0
                } : c);
              });
              f.plural.forEach(function (c) {
                b[c].forEach(function (c) {
                  c.element && c.animate(a({
                    x: b.startXPos
                  }, c.startYPos ? {
                    x: c.startXPos,
                    y: c.startYPos
                  } : {}));
                });
              });
            };

            c.prototype.applyOptions = function (b, d) {
              var k = this.series,
                  h = k.options.pointValKey || k.pointValKey;
              b = c.prototype.optionsToObject.call(this, b);
              a(this, b);
              this.options = this.options ? a(this.options, b) : b;
              b.group && delete this.group;
              b.dataLabels && delete this.dataLabels;
              h && (this.y = c.prototype.getNestedProperty.call(this, h));
              this.formatPrefix = (this.isNull = t(this.isValid && !this.isValid(), null === this.x || !f(this.y))) ? "null" : "point";
              this.selected && (this.state = "select");
              "name" in this && "undefined" === typeof d && k.xAxis && k.xAxis.hasNames && (this.x = k.xAxis.nameToX(this));
              "undefined" === typeof this.x && k ? this.x = "undefined" === typeof d ? k.autoIncrement() : d : f(b.x) && k.options.relativeXValue && (this.x = k.autoIncrement(b.x));
              return this;
            };

            c.prototype.destroy = function () {
              function b() {
                if (c.graphic || c.dataLabel || c.dataLabels) z(c), c.destroyElements();

                for (h in c) {
                  c[h] = null;
                }
              }

              var c = this,
                  a = c.series,
                  f = a.chart;
              a = a.options.dataSorting;
              var n = f.hoverPoints,
                  k = v(c.series.chart.renderer.globalAnimation),
                  h;
              c.legendItem && f.legend.destroyItem(c);
              n && (c.setState(), d(n, c), n.length || (f.hoverPoints = null));
              if (c === f.hoverPoint) c.onMouseOut();
              a && a.enabled ? (this.animateBeforeDestroy(), Q(b, k.duration)) : b();
              f.pointCount--;
            };

            c.prototype.destroyElements = function (b) {
              var c = this;
              b = c.getGraphicalProps(b);
              b.singular.forEach(function (b) {
                c[b] = c[b].destroy();
              });
              b.plural.forEach(function (b) {
                c[b].forEach(function (b) {
                  b.element && b.destroy();
                });
                delete c[b];
              });
            };

            c.prototype.firePointEvent = function (b, c, a) {
              var f = this,
                  d = this.series.options;
              (d.point.events[b] || f.options && f.options.events && f.options.events[b]) && f.importEvents();
              "click" === b && d.allowPointSelect && (a = function a(b) {
                f.select && f.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
              });
              p(f, b, c, a);
            };

            c.prototype.getClassName = function () {
              return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };

            c.prototype.getGraphicalProps = function (b) {
              var c = this,
                  a = [],
                  f = {
                singular: [],
                plural: []
              },
                  d;
              b = b || {
                graphic: 1,
                dataLabel: 1
              };
              b.graphic && a.push("graphic", "upperGraphic", "shadowGroup");
              b.dataLabel && a.push("dataLabel", "dataLabelUpper", "connector");

              for (d = a.length; d--;) {
                var k = a[d];
                c[k] && f.singular.push(k);
              }

              ["dataLabel", "connector"].forEach(function (a) {
                var d = a + "s";
                b[a] && c[d] && f.plural.push(d);
              });
              return f;
            };

            c.prototype.getLabelConfig = function () {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
              };
            };

            c.prototype.getNestedProperty = function (b) {
              if (b) return 0 === b.indexOf("custom.") ? B(b, this.options) : this[b];
            };

            c.prototype.getZone = function () {
              var b = this.series,
                  c = b.zones;
              b = b.zoneAxis || "y";
              var a,
                  f = 0;

              for (a = c[f]; this[b] >= a.value;) {
                a = c[++f];
              }

              this.nonZonedColor || (this.nonZonedColor = this.color);
              this.color = a && a.color && !this.options.color ? a.color : this.nonZonedColor;
              return a;
            };

            c.prototype.hasNewShapeType = function () {
              return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };

            c.prototype.init = function (b, c, a) {
              this.series = b;
              this.applyOptions(c, a);
              this.id = m(this.id) ? this.id : A();
              this.resolveColor();
              b.chart.pointCount++;
              p(this, "afterInit");
              return this;
            };

            c.prototype.optionsToObject = function (b) {
              var a = this.series,
                  d = a.options.keys,
                  k = d || a.pointArrayMap || ["y"],
                  n = k.length,
                  h = {},
                  e = 0,
                  w = 0;
              if (f(b) || null === b) h[k[0]] = b;else if (l(b)) for (!d && b.length > n && (a = typeof b[0], "string" === a ? h.name = b[0] : "number" === a && (h.x = b[0]), e++); w < n;) {
                d && "undefined" === typeof b[e] || (0 < k[w].indexOf(".") ? c.prototype.setNestedProperty(h, b[e], k[w]) : h[k[w]] = b[e]), e++, w++;
              } else "object" === typeof b && (h = b, b.dataLabels && (a._hasPointLabels = !0), b.marker && (a._hasPointMarkers = !0));
              return h;
            };

            c.prototype.resolveColor = function () {
              var b = this.series,
                  c = b.chart.styledMode;
              var a = b.chart.options.chart.colorCount;
              delete this.nonZonedColor;

              if (b.options.colorByPoint) {
                if (!c) {
                  a = b.options.colors || b.chart.options.colors;
                  var f = a[b.colorCounter];
                  a = a.length;
                }

                c = b.colorCounter;
                b.colorCounter++;
                b.colorCounter === a && (b.colorCounter = 0);
              } else c || (f = b.color), c = b.colorIndex;

              this.colorIndex = t(this.options.colorIndex, c);
              this.color = t(this.options.color, f);
            };

            c.prototype.setNestedProperty = function (b, c, a) {
              a.split(".").reduce(function (b, a, f, d) {
                b[a] = d.length - 1 === f ? c : k(b[a], !0) ? b[a] : {};
                return b[a];
              }, b);
              return b;
            };

            c.prototype.tooltipFormatter = function (b) {
              var c = this.series,
                  a = c.tooltipOptions,
                  f = t(a.valueDecimals, ""),
                  d = a.valuePrefix || "",
                  k = a.valueSuffix || "";
              c.chart.styledMode && (b = c.chart.tooltip.styledModeFormat(b));
              (c.pointArrayMap || ["y"]).forEach(function (c) {
                c = "{point." + c;
                if (d || k) b = b.replace(RegExp(c + "}", "g"), d + c + "}" + k);
                b = b.replace(RegExp(c + "}", "g"), c + ":,." + f + "f}");
              });
              return x(b, {
                point: this,
                series: this.series
              }, c.chart);
            };

            c.prototype.update = function (b, c, a, f) {
              function d() {
                h.applyOptions(b);
                var f = l && h.hasDummyGraphic;
                f = null === h.y ? !f : f;
                l && f && (h.graphic = l.destroy(), delete h.hasDummyGraphic);
                k(b, !0) && (l && l.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (h.graphic = l.destroy()), b && b.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));
                p = h.index;
                e.updateParallelArrays(h, p);
                z.data[p] = k(z.data[p], !0) || k(b, !0) ? h.options : t(b, z.data[p]);
                e.isDirty = e.isDirtyData = !0;
                !e.fixedBox && e.hasCartesianSeries && (A.isDirtyBox = !0);
                "point" === z.legendType && (A.isDirtyLegend = !0);
                c && A.redraw(a);
              }

              var h = this,
                  e = h.series,
                  l = h.graphic,
                  A = e.chart,
                  z = e.options,
                  p;
              c = t(c, !0);
              !1 === f ? d() : h.firePointEvent("update", {
                options: b
              }, d);
            };

            c.prototype.remove = function (b, c) {
              this.series.removePoint(this.series.data.indexOf(this), b, c);
            };

            c.prototype.select = function (b, c) {
              var a = this,
                  f = a.series,
                  d = f.chart;
              this.selectedStaging = b = t(b, !a.selected);
              a.firePointEvent(b ? "select" : "unselect", {
                accumulate: c
              }, function () {
                a.selected = a.options.selected = b;
                f.options.data[f.data.indexOf(a)] = a.options;
                a.setState(b && "select");
                c || d.getSelectedPoints().forEach(function (b) {
                  var c = b.series;
                  b.selected && b !== a && (b.selected = b.options.selected = !1, c.options.data[c.data.indexOf(b)] = b.options, b.setState(d.hoverPoints && c.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
                });
              });
              delete this.selectedStaging;
            };

            c.prototype.onMouseOver = function (b) {
              var c = this.series.chart,
                  a = c.pointer;
              b = b ? a.normalize(b) : a.getChartCoordinatesFromPoint(this, c.inverted);
              a.runPointActions(b, this);
            };

            c.prototype.onMouseOut = function () {
              var b = this.series.chart;
              this.firePointEvent("mouseOut");
              this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {
                b.setState();
              });
              b.hoverPoints = b.hoverPoint = null;
            };

            c.prototype.importEvents = function () {
              if (!this.hasImportedEvents) {
                var b = this,
                    c = J(b.series.options.point, b.options).events;
                b.events = c;
                K(c, function (c, a) {
                  h(c) && r(b, a, c);
                });
                this.hasImportedEvents = !0;
              }
            };

            c.prototype.setState = function (b, c) {
              var d = this.series,
                  k = this.state,
                  n = d.options.states[b || "normal"] || {},
                  h = G.plotOptions[d.type].marker && d.options.marker,
                  l = h && !1 === h.enabled,
                  w = h && h.states && h.states[b || "normal"] || {},
                  A = !1 === w.enabled,
                  z = this.marker || {},
                  m = d.chart,
                  q = h && d.markerAttribs,
                  D = d.halo,
                  g,
                  r = d.stateMarkerGraphic;
              b = b || "";

              if (!(b === this.state && !c || this.selected && "select" !== b || !1 === n.enabled || b && (A || l && !1 === w.enabled) || b && z.states && z.states[b] && !1 === z.states[b].enabled)) {
                this.state = b;
                q && (g = d.markerAttribs(this, b));

                if (this.graphic && !this.hasDummyGraphic) {
                  k && this.graphic.removeClass("highcharts-point-" + k);
                  b && this.graphic.addClass("highcharts-point-" + b);

                  if (!m.styledMode) {
                    var B = d.pointAttribs(this, b);
                    var Q = t(m.options.chart.animation, n.animation);
                    d.options.inactiveOtherPoints && f(B.opacity) && ((this.dataLabels || []).forEach(function (b) {
                      b && b.animate({
                        opacity: B.opacity
                      }, Q);
                    }), this.connector && this.connector.animate({
                      opacity: B.opacity
                    }, Q));
                    this.graphic.animate(B, Q);
                  }

                  g && this.graphic.animate(g, t(m.options.chart.animation, w.animation, h.animation));
                  r && r.hide();
                } else {
                  if (b && w) {
                    k = z.symbol || d.symbol;
                    r && r.currentSymbol !== k && (r = r.destroy());
                    if (g) if (r) r[c ? "animate" : "attr"]({
                      x: g.x,
                      y: g.y
                    });else k && (d.stateMarkerGraphic = r = m.renderer.symbol(k, g.x, g.y, g.width, g.height).add(d.markerGroup), r.currentSymbol = k);
                    !m.styledMode && r && r.attr(d.pointAttribs(this, b));
                  }

                  r && (r[b && this.isInside ? "show" : "hide"](), r.element.point = this, r.addClass(this.getClassName(), !0));
                }

                n = n.halo;
                g = (r = this.graphic || r) && r.visibility || "inherit";
                n && n.size && r && "hidden" !== g && !this.isCluster ? (D || (d.halo = D = m.renderer.path().add(r.parentGroup)), D.show()[c ? "animate" : "attr"]({
                  d: this.haloPath(n.size)
                }), D.attr({
                  "class": "highcharts-halo highcharts-color-" + t(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
                  visibility: g,
                  zIndex: -1
                }), D.point = this, m.styledMode || D.attr(a({
                  fill: this.color || d.color,
                  "fill-opacity": n.opacity
                }, e.filterUserAttributes(n.attributes || {})))) : D && D.point && D.point.haloPath && D.animate({
                  d: D.point.haloPath(0)
                }, null, D.hide);
                p(this, "afterSetState", {
                  state: b
                });
              }
            };

            c.prototype.haloPath = function (b) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - b, this.plotY - b, 2 * b, 2 * b);
            };

            return c;
          }();

          "";
          return g;
        });
        M(g, "Core/Pointer.js", [g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Color/Palette.js"], g["Core/Tooltip.js"], g["Core/Utilities.js"]], function (e, g, C, y, E) {
          var v = e.parse,
              G = g.charts,
              x = g.noop,
              r = E.addEvent,
              m = E.attr,
              d = E.css,
              a = E.defined,
              p = E.extend,
              B = E.find,
              l = E.fireEvent,
              h = E.isNumber,
              f = E.isObject,
              k = E.objectEach,
              J = E.offset,
              K = E.pick,
              t = E.splat;

          e = function () {
            function e(a, f) {
              this.lastValidTouch = {};
              this.pinchDown = [];
              this.runChartClick = !1;
              this.eventsToUnbind = [];
              this.chart = a;
              this.hasDragged = !1;
              this.options = f;
              this.init(a, f);
            }

            e.prototype.applyInactiveState = function (a) {
              var f = [],
                  c;
              (a || []).forEach(function (b) {
                c = b.series;
                f.push(c);
                c.linkedParent && f.push(c.linkedParent);
                c.linkedSeries && (f = f.concat(c.linkedSeries));
                c.navigatorSeries && f.push(c.navigatorSeries);
              });
              this.chart.series.forEach(function (b) {
                -1 === f.indexOf(b) ? b.setState("inactive", !0) : b.options.inactiveOtherPoints && b.setAllPointsToState("inactive");
              });
            };

            e.prototype.destroy = function () {
              var a = this;
              this.eventsToUnbind.forEach(function (a) {
                return a();
              });
              this.eventsToUnbind = [];
              g.chartCount || (e.unbindDocumentMouseUp && (e.unbindDocumentMouseUp = e.unbindDocumentMouseUp()), e.unbindDocumentTouchEnd && (e.unbindDocumentTouchEnd = e.unbindDocumentTouchEnd()));
              clearInterval(a.tooltipTimeout);
              k(a, function (f, c) {
                a[c] = void 0;
              });
            };

            e.prototype.drag = function (a) {
              var d = this.chart,
                  c = d.options.chart,
                  b = this.zoomHor,
                  k = this.zoomVert,
                  h = d.plotLeft,
                  e = d.plotTop,
                  n = d.plotWidth,
                  l = d.plotHeight,
                  t = this.mouseDownX || 0,
                  w = this.mouseDownY || 0,
                  z = f(c.panning) ? c.panning && c.panning.enabled : c.panning,
                  p = c.panKey && a[c.panKey + "Key"],
                  m = a.chartX,
                  q = a.chartY,
                  g = this.selectionMarker;
              if (!g || !g.touch) if (m < h ? m = h : m > h + n && (m = h + n), q < e ? q = e : q > e + l && (q = e + l), this.hasDragged = Math.sqrt(Math.pow(t - m, 2) + Math.pow(w - q, 2)), 10 < this.hasDragged) {
                var r = d.isInsidePlot(t - h, w - e, {
                  visiblePlotOnly: !0
                });
                d.hasCartesianSeries && (this.zoomX || this.zoomY) && r && !p && !g && (this.selectionMarker = g = d.renderer.rect(h, e, b ? 1 : n, k ? 1 : l, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add(), d.styledMode || g.attr({
                  fill: c.selectionMarkerFill || v(C.highlightColor80).setOpacity(.25).get()
                }));
                g && b && (b = m - t, g.attr({
                  width: Math.abs(b),
                  x: (0 < b ? 0 : b) + t
                }));
                g && k && (b = q - w, g.attr({
                  height: Math.abs(b),
                  y: (0 < b ? 0 : b) + w
                }));
                r && !g && z && d.pan(a, c.panning);
              }
            };

            e.prototype.dragStart = function (a) {
              var f = this.chart;
              f.mouseIsDown = a.type;
              f.cancelClick = !1;
              f.mouseDownX = this.mouseDownX = a.chartX;
              f.mouseDownY = this.mouseDownY = a.chartY;
            };

            e.prototype.drop = function (f) {
              var k = this,
                  c = this.chart,
                  b = this.hasPinched;

              if (this.selectionMarker) {
                var e = {
                  originalEvent: f,
                  xAxis: [],
                  yAxis: []
                },
                    t = this.selectionMarker,
                    z = t.attr ? t.attr("x") : t.x,
                    n = t.attr ? t.attr("y") : t.y,
                    u = t.attr ? t.attr("width") : t.width,
                    m = t.attr ? t.attr("height") : t.height,
                    w;
                if (this.hasDragged || b) c.axes.forEach(function (c) {
                  if (c.zoomEnabled && a(c.min) && (b || k[{
                    xAxis: "zoomX",
                    yAxis: "zoomY"
                  }[c.coll]]) && h(z) && h(n)) {
                    var d = c.horiz,
                        l = "touchend" === f.type ? c.minPixelPadding : 0,
                        q = c.toValue((d ? z : n) + l);
                    d = c.toValue((d ? z + u : n + m) - l);
                    e[c.coll].push({
                      axis: c,
                      min: Math.min(q, d),
                      max: Math.max(q, d)
                    });
                    w = !0;
                  }
                }), w && l(c, "selection", e, function (a) {
                  c.zoom(p(a, b ? {
                    animation: !1
                  } : null));
                });
                h(c.index) && (this.selectionMarker = this.selectionMarker.destroy());
                b && this.scaleGroups();
              }

              c && h(c.index) && (d(c.container, {
                cursor: c._cursor
              }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
            };

            e.prototype.findNearestKDPoint = function (a, d, c) {
              var b = this.chart,
                  k = b.hoverPoint;
              b = b.tooltip;
              if (k && b && b.isStickyOnContact()) return k;
              var h;
              a.forEach(function (b) {
                var a = !(b.noSharedTooltip && d) && 0 > b.options.findNearestPointBy.indexOf("y");
                b = b.searchPoint(c, a);

                if ((a = f(b, !0) && b.series) && !(a = !f(h, !0))) {
                  a = h.distX - b.distX;
                  var k = h.dist - b.dist,
                      e = (b.series.group && b.series.group.zIndex) - (h.series.group && h.series.group.zIndex);
                  a = 0 < (0 !== a && d ? a : 0 !== k ? k : 0 !== e ? e : h.series.index > b.series.index ? -1 : 1);
                }

                a && (h = b);
              });
              return h;
            };

            e.prototype.getChartCoordinatesFromPoint = function (a, f) {
              var c = a.series,
                  b = c.xAxis;
              c = c.yAxis;
              var d = a.shapeArgs;

              if (b && c) {
                var k = K(a.clientX, a.plotX),
                    e = a.plotY || 0;
                a.isNode && d && h(d.x) && h(d.y) && (k = d.x, e = d.y);
                return f ? {
                  chartX: c.len + c.pos - e,
                  chartY: b.len + b.pos - k
                } : {
                  chartX: k + b.pos,
                  chartY: e + c.pos
                };
              }

              if (d && d.x && d.y) return {
                chartX: d.x,
                chartY: d.y
              };
            };

            e.prototype.getChartPosition = function () {
              if (this.chartPosition) return this.chartPosition;
              var a = this.chart.container,
                  f = J(a);
              this.chartPosition = {
                left: f.left,
                top: f.top,
                scaleX: 1,
                scaleY: 1
              };
              var c = a.offsetWidth;
              a = a.offsetHeight;
              2 < c && 2 < a && (this.chartPosition.scaleX = f.width / c, this.chartPosition.scaleY = f.height / a);
              return this.chartPosition;
            };

            e.prototype.getCoordinates = function (a) {
              var f = {
                xAxis: [],
                yAxis: []
              };
              this.chart.axes.forEach(function (c) {
                f[c.isXAxis ? "xAxis" : "yAxis"].push({
                  axis: c,
                  value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
                });
              });
              return f;
            };

            e.prototype.getHoverData = function (a, d, c, b, k, h) {
              var e = [];
              b = !(!b || !a);
              var n = {
                chartX: h ? h.chartX : void 0,
                chartY: h ? h.chartY : void 0,
                shared: k
              };
              l(this, "beforeGetHoverData", n);
              var u = d && !d.stickyTracking ? [d] : c.filter(function (b) {
                return n.filter ? n.filter(b) : b.visible && !(!k && b.directTouch) && K(b.options.enableMouseTracking, !0) && b.stickyTracking;
              });
              var t = b || !h ? a : this.findNearestKDPoint(u, k, h);
              d = t && t.series;
              t && (k && !d.noSharedTooltip ? (u = c.filter(function (b) {
                return n.filter ? n.filter(b) : b.visible && !(!k && b.directTouch) && K(b.options.enableMouseTracking, !0) && !b.noSharedTooltip;
              }), u.forEach(function (b) {
                var c = B(b.points, function (b) {
                  return b.x === t.x && !b.isNull;
                });
                f(c) && (b.chart.isBoosting && (c = b.getPoint(c)), e.push(c));
              })) : e.push(t));
              n = {
                hoverPoint: t
              };
              l(this, "afterGetHoverData", n);
              return {
                hoverPoint: n.hoverPoint,
                hoverSeries: d,
                hoverPoints: e
              };
            };

            e.prototype.getPointFromEvent = function (a) {
              a = a.target;

              for (var f; a && !f;) {
                f = a.point, a = a.parentNode;
              }

              return f;
            };

            e.prototype.onTrackerMouseOut = function (a) {
              a = a.relatedTarget || a.toElement;
              var f = this.chart.hoverSeries;
              this.isDirectTouch = !1;
              if (!(!f || !a || f.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + f.index) && this.inClass(a, "highcharts-tracker"))) f.onMouseOut();
            };

            e.prototype.inClass = function (a, f) {
              for (var c; a;) {
                if (c = m(a, "class")) {
                  if (-1 !== c.indexOf(f)) return !0;
                  if (-1 !== c.indexOf("highcharts-container")) return !1;
                }

                a = a.parentNode;
              }
            };

            e.prototype.init = function (a, f) {
              this.options = f;
              this.chart = a;
              this.runChartClick = !(!f.chart.events || !f.chart.events.click);
              this.pinchDown = [];
              this.lastValidTouch = {};
              y && (a.tooltip = new y(a, f.tooltip), this.followTouchMove = K(f.tooltip.followTouchMove, !0));
              this.setDOMEvents();
            };

            e.prototype.normalize = function (a, f) {
              var c = a.touches,
                  b = c ? c.length ? c.item(0) : K(c.changedTouches, a.changedTouches)[0] : a;
              f || (f = this.getChartPosition());
              c = b.pageX - f.left;
              b = b.pageY - f.top;
              c /= f.scaleX;
              b /= f.scaleY;
              return p(a, {
                chartX: Math.round(c),
                chartY: Math.round(b)
              });
            };

            e.prototype.onContainerClick = function (a) {
              var f = this.chart,
                  c = f.hoverPoint;
              a = this.normalize(a);
              var b = f.plotLeft,
                  d = f.plotTop;
              f.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (l(c.series, "click", p(a, {
                point: c
              })), f.hoverPoint && c.firePointEvent("click", a)) : (p(a, this.getCoordinates(a)), f.isInsidePlot(a.chartX - b, a.chartY - d, {
                visiblePlotOnly: !0
              }) && l(f, "click", a)));
            };

            e.prototype.onContainerMouseDown = function (a) {
              var f = 1 === ((a.buttons || a.button) & 1);
              a = this.normalize(a);
              if (g.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
              if ("undefined" === typeof a.button || f) this.zoomOption(a), f && a.preventDefault && a.preventDefault(), this.dragStart(a);
            };

            e.prototype.onContainerMouseLeave = function (a) {
              var f = G[K(e.hoverChartIndex, -1)],
                  c = this.chart.tooltip;
              c && c.shouldStickOnContact() && this.inClass(a.relatedTarget, "highcharts-tooltip-container") || (a = this.normalize(a), f && (a.relatedTarget || a.toElement) && (f.pointer.reset(), f.pointer.chartPosition = void 0), c && !c.isHidden && this.reset());
            };

            e.prototype.onContainerMouseEnter = function (a) {
              delete this.chartPosition;
            };

            e.prototype.onContainerMouseMove = function (a) {
              var f = this.chart;
              a = this.normalize(a);
              this.setHoverChartIndex();
              a.preventDefault || (a.returnValue = !1);
              ("mousedown" === f.mouseIsDown || this.touchSelect(a)) && this.drag(a);
              f.openMenu || !this.inClass(a.target, "highcharts-tracker") && !f.isInsidePlot(a.chartX - f.plotLeft, a.chartY - f.plotTop, {
                visiblePlotOnly: !0
              }) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
            };

            e.prototype.onDocumentTouchEnd = function (a) {
              var f = G[K(e.hoverChartIndex, -1)];
              f && f.pointer.drop(a);
            };

            e.prototype.onContainerTouchMove = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
            };

            e.prototype.onContainerTouchStart = function (a) {
              if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
            };

            e.prototype.onDocumentMouseMove = function (a) {
              var f = this.chart,
                  c = this.chartPosition;
              a = this.normalize(a, c);
              var b = f.tooltip;
              !c || b && b.isStickyOnContact() || f.isInsidePlot(a.chartX - f.plotLeft, a.chartY - f.plotTop, {
                visiblePlotOnly: !0
              }) || this.inClass(a.target, "highcharts-tracker") || this.reset();
            };

            e.prototype.onDocumentMouseUp = function (a) {
              var f = G[K(e.hoverChartIndex, -1)];
              f && f.pointer.drop(a);
            };

            e.prototype.pinch = function (a) {
              var f = this,
                  c = f.chart,
                  b = f.pinchDown,
                  d = a.touches || [],
                  k = d.length,
                  h = f.lastValidTouch,
                  n = f.hasZoom,
                  e = {},
                  l = 1 === k && (f.inClass(a.target, "highcharts-tracker") && c.runTrackerClick || f.runChartClick),
                  w = {},
                  t = f.selectionMarker;
              1 < k ? f.initiated = !0 : 1 === k && this.followTouchMove && (f.initiated = !1);
              n && f.initiated && !l && !1 !== a.cancelable && a.preventDefault();
              [].map.call(d, function (b) {
                return f.normalize(b);
              });
              "touchstart" === a.type ? ([].forEach.call(d, function (c, a) {
                b[a] = {
                  chartX: c.chartX,
                  chartY: c.chartY
                };
              }), h.x = [b[0].chartX, b[1] && b[1].chartX], h.y = [b[0].chartY, b[1] && b[1].chartY], c.axes.forEach(function (b) {
                if (b.zoomEnabled) {
                  var a = c.bounds[b.horiz ? "h" : "v"],
                      f = b.minPixelPadding,
                      d = b.toPixels(Math.min(K(b.options.min, b.dataMin), b.dataMin)),
                      k = b.toPixels(Math.max(K(b.options.max, b.dataMax), b.dataMax)),
                      n = Math.max(d, k);
                  a.min = Math.min(b.pos, Math.min(d, k) - f);
                  a.max = Math.max(b.pos + b.len, n + f);
                }
              }), f.res = !0) : f.followTouchMove && 1 === k ? this.runPointActions(f.normalize(a)) : b.length && (t || (f.selectionMarker = t = p({
                destroy: x,
                touch: !0
              }, c.plotBox)), f.pinchTranslate(b, d, e, t, w, h), f.hasPinched = n, f.scaleGroups(e, w), f.res && (f.res = !1, this.reset(!1, 0)));
            };

            e.prototype.pinchTranslate = function (a, f, c, b, d, k) {
              this.zoomHor && this.pinchTranslateDirection(!0, a, f, c, b, d, k);
              this.zoomVert && this.pinchTranslateDirection(!1, a, f, c, b, d, k);
            };

            e.prototype.pinchTranslateDirection = function (a, f, c, b, d, k, h, n) {
              var e = this.chart,
                  l = a ? "x" : "y",
                  w = a ? "X" : "Y",
                  t = "chart" + w,
                  p = a ? "width" : "height",
                  m = e["plot" + (a ? "Left" : "Top")],
                  q = e.inverted,
                  g = e.bounds[a ? "h" : "v"],
                  D = 1 === f.length,
                  A = f[0][t],
                  z = !D && f[1][t];

              f = function f() {
                "number" === typeof L && 20 < Math.abs(A - z) && (I = n || Math.abs(B - L) / Math.abs(A - z));
                S = (m - B) / I + A;
                r = e["plot" + (a ? "Width" : "Height")] / I;
              };

              var r,
                  S,
                  I = n || 1,
                  B = c[0][t],
                  L = !D && c[1][t];
              f();
              c = S;

              if (c < g.min) {
                c = g.min;
                var J = !0;
              } else c + r > g.max && (c = g.max - r, J = !0);

              J ? (B -= .8 * (B - h[l][0]), "number" === typeof L && (L -= .8 * (L - h[l][1])), f()) : h[l] = [B, L];
              q || (k[l] = S - m, k[p] = r);
              k = q ? 1 / I : I;
              d[p] = r;
              d[l] = c;
              b[q ? a ? "scaleY" : "scaleX" : "scale" + w] = I;
              b["translate" + w] = k * m + (B - k * A);
            };

            e.prototype.reset = function (a, f) {
              var c = this.chart,
                  b = c.hoverSeries,
                  d = c.hoverPoint,
                  k = c.hoverPoints,
                  h = c.tooltip,
                  n = h && h.shared ? k : d;
              a && n && t(n).forEach(function (b) {
                b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
              });
              if (a) h && n && t(n).length && (h.refresh(n), h.shared && k ? k.forEach(function (b) {
                b.setState(b.state, !0);
                b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
              }) : d && (d.setState(d.state, !0), c.axes.forEach(function (b) {
                b.crosshair && d.series[b.coll] === b && b.drawCrosshair(null, d);
              })));else {
                if (d) d.onMouseOut();
                k && k.forEach(function (b) {
                  b.setState();
                });
                if (b) b.onMouseOut();
                h && h.hide(f);
                this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                c.axes.forEach(function (b) {
                  b.hideCrosshair();
                });
                this.hoverX = c.hoverPoints = c.hoverPoint = null;
              }
            };

            e.prototype.runPointActions = function (a, f) {
              var c = this.chart,
                  b = c.tooltip && c.tooltip.options.enabled ? c.tooltip : void 0,
                  d = b ? b.shared : !1,
                  k = f || c.hoverPoint,
                  h = k && k.series || c.hoverSeries;
              f = this.getHoverData(k, h, c.series, (!a || "touchmove" !== a.type) && (!!f || h && h.directTouch && this.isDirectTouch), d, a);
              k = f.hoverPoint;
              h = f.hoverSeries;
              var n = f.hoverPoints;
              f = h && h.tooltipOptions.followPointer && !h.tooltipOptions.split;
              d = d && h && !h.noSharedTooltip;

              if (k && (k !== c.hoverPoint || b && b.isHidden)) {
                (c.hoverPoints || []).forEach(function (b) {
                  -1 === n.indexOf(b) && b.setState();
                });
                if (c.hoverSeries !== h) h.onMouseOver();
                this.applyInactiveState(n);
                (n || []).forEach(function (b) {
                  b.setState("hover");
                });
                c.hoverPoint && c.hoverPoint.firePointEvent("mouseOut");
                if (!k.series) return;
                c.hoverPoints = n;
                c.hoverPoint = k;
                k.firePointEvent("mouseOver");
                b && b.refresh(d ? n : k, a);
              } else f && b && !b.isHidden && (k = b.getAnchor([{}], a), c.isInsidePlot(k[0], k[1], {
                visiblePlotOnly: !0
              }) && b.updatePosition({
                plotX: k[0],
                plotY: k[1]
              }));

              this.unDocMouseMove || (this.unDocMouseMove = r(c.container.ownerDocument, "mousemove", function (b) {
                var c = G[e.hoverChartIndex];
                if (c) c.pointer.onDocumentMouseMove(b);
              }), this.eventsToUnbind.push(this.unDocMouseMove));
              c.axes.forEach(function (b) {
                var f = K((b.crosshair || {}).snap, !0),
                    d;
                f && ((d = c.hoverPoint) && d.series[b.coll] === b || (d = B(n, function (c) {
                  return c.series[b.coll] === b;
                })));
                d || !f ? b.drawCrosshair(a, d) : b.hideCrosshair();
              });
            };

            e.prototype.scaleGroups = function (a, f) {
              var c = this.chart;
              c.series.forEach(function (b) {
                var d = a || b.getPlotBox();
                b.xAxis && b.xAxis.zoomEnabled && b.group && (b.group.attr(d), b.markerGroup && (b.markerGroup.attr(d), b.markerGroup.clip(f ? c.clipRect : null)), b.dataLabelsGroup && b.dataLabelsGroup.attr(d));
              });
              c.clipRect.attr(f || c.clipBox);
            };

            e.prototype.setDOMEvents = function () {
              var a = this,
                  f = this.chart.container,
                  c = f.ownerDocument;
              f.onmousedown = this.onContainerMouseDown.bind(this);
              f.onmousemove = this.onContainerMouseMove.bind(this);
              f.onclick = this.onContainerClick.bind(this);
              this.eventsToUnbind.push(r(f, "mouseenter", this.onContainerMouseEnter.bind(this)));
              this.eventsToUnbind.push(r(f, "mouseleave", this.onContainerMouseLeave.bind(this)));
              e.unbindDocumentMouseUp || (e.unbindDocumentMouseUp = r(c, "mouseup", this.onDocumentMouseUp.bind(this)));

              for (var b = this.chart.renderTo.parentElement; b && "BODY" !== b.tagName;) {
                this.eventsToUnbind.push(r(b, "scroll", function () {
                  delete a.chartPosition;
                })), b = b.parentElement;
              }

              g.hasTouch && (this.eventsToUnbind.push(r(f, "touchstart", this.onContainerTouchStart.bind(this), {
                passive: !1
              })), this.eventsToUnbind.push(r(f, "touchmove", this.onContainerTouchMove.bind(this), {
                passive: !1
              })), e.unbindDocumentTouchEnd || (e.unbindDocumentTouchEnd = r(c, "touchend", this.onDocumentTouchEnd.bind(this), {
                passive: !1
              })));
            };

            e.prototype.setHoverChartIndex = function () {
              var a = this.chart,
                  f = g.charts[K(e.hoverChartIndex, -1)];
              if (f && f !== a) f.pointer.onContainerMouseLeave({
                relatedTarget: !0
              });
              f && f.mouseIsDown || (e.hoverChartIndex = a.index);
            };

            e.prototype.touch = function (a, f) {
              var c = this.chart,
                  b;
              this.setHoverChartIndex();
              if (1 === a.touches.length) {
                if (a = this.normalize(a), (b = c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
                  visiblePlotOnly: !0
                })) && !c.openMenu) {
                  f && this.runPointActions(a);

                  if ("touchmove" === a.type) {
                    f = this.pinchDown;
                    var d = f[0] ? 4 <= Math.sqrt(Math.pow(f[0].chartX - a.chartX, 2) + Math.pow(f[0].chartY - a.chartY, 2)) : !1;
                  }

                  K(d, !0) && this.pinch(a);
                } else f && this.reset();
              } else 2 === a.touches.length && this.pinch(a);
            };

            e.prototype.touchSelect = function (a) {
              return !(!this.chart.options.chart.zoomBySingleTouch || !a.touches || 1 !== a.touches.length);
            };

            e.prototype.zoomOption = function (a) {
              var f = this.chart,
                  c = f.options.chart;
              f = f.inverted;
              var b = c.zoomType || "";
              /touch/.test(a.type) && (b = K(c.pinchType, b));
              this.zoomX = a = /x/.test(b);
              this.zoomY = c = /y/.test(b);
              this.zoomHor = a && !f || c && f;
              this.zoomVert = c && !f || a && f;
              this.hasZoom = a || c;
            };

            return e;
          }();

          "";
          return e;
        });
        M(g, "Core/MSPointer.js", [g["Core/Globals.js"], g["Core/Pointer.js"], g["Core/Utilities.js"]], function (e, g, C) {
          function P() {
            var a = [];

            a.item = function (a) {
              return this[a];
            };

            p(l, function (f) {
              a.push({
                pageX: f.pageX,
                pageY: f.pageY,
                target: f.target
              });
            });
            return a;
          }

          function E(a, d, h, e) {
            var f = G[g.hoverChartIndex || NaN];
            "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !f || (f = f.pointer, e(a), f[d]({
              type: h,
              target: a.currentTarget,
              preventDefault: r,
              touches: P()
            }));
          }

          var v = this && this.__extends || function () {
            var _a21 = function a(f, d) {
              _a21 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, f) {
                a.__proto__ = f;
              } || function (a, f) {
                for (var d in f) {
                  f.hasOwnProperty(d) && (a[d] = f[d]);
                }
              };

              return _a21(f, d);
            };

            return function (f, d) {
              function k() {
                this.constructor = f;
              }

              _a21(f, d);

              f.prototype = null === d ? Object.create(d) : (k.prototype = d.prototype, new k());
            };
          }(),
              G = e.charts,
              x = e.doc,
              r = e.noop,
              m = e.win,
              d = C.addEvent,
              a = C.css,
              p = C.objectEach,
              B = C.removeEvent,
              l = {},
              h = !!m.PointerEvent;

          return function (f) {
            function k() {
              return null !== f && f.apply(this, arguments) || this;
            }

            v(k, f);

            k.isRequired = function () {
              return !(e.hasTouch || !m.PointerEvent && !m.MSPointerEvent);
            };

            k.prototype.batchMSEvents = function (a) {
              a(this.chart.container, h ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              a(this.chart.container, h ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              a(x, h ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };

            k.prototype.destroy = function () {
              this.batchMSEvents(B);
              f.prototype.destroy.call(this);
            };

            k.prototype.init = function (d, k) {
              f.prototype.init.call(this, d, k);
              this.hasZoom && a(d.container, {
                "-ms-touch-action": "none",
                "touch-action": "none"
              });
            };

            k.prototype.onContainerPointerDown = function (a) {
              E(a, "onContainerTouchStart", "touchstart", function (a) {
                l[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY,
                  target: a.currentTarget
                };
              });
            };

            k.prototype.onContainerPointerMove = function (a) {
              E(a, "onContainerTouchMove", "touchmove", function (a) {
                l[a.pointerId] = {
                  pageX: a.pageX,
                  pageY: a.pageY
                };
                l[a.pointerId].target || (l[a.pointerId].target = a.currentTarget);
              });
            };

            k.prototype.onDocumentPointerUp = function (a) {
              E(a, "onDocumentTouchEnd", "touchend", function (a) {
                delete l[a.pointerId];
              });
            };

            k.prototype.setDOMEvents = function () {
              f.prototype.setDOMEvents.call(this);
              (this.hasZoom || this.followTouchMove) && this.batchMSEvents(d);
            };

            return k;
          }(g);
        });
        M(g, "Core/Legend/Legend.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Series/Point.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v) {
          var G = e.animObject,
              x = e.setAnimation,
              r = g.format;
          e = C.isFirefox;
          var m = C.marginNames;
          C = C.win;
          var d = E.distribute,
              a = v.addEvent,
              p = v.createElement,
              B = v.css,
              l = v.defined,
              h = v.discardElement,
              f = v.find,
              k = v.fireEvent,
              J = v.isNumber,
              K = v.merge,
              t = v.pick,
              Q = v.relativeLength,
              z = v.stableSort,
              A = v.syncTimeout;
          E = v.wrap;

          v = function () {
            function c(b, a) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = !1;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = {};
              this.padding = 0;
              this.pages = [];
              this.proximate = !1;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = b;
              this.init(b, a);
            }

            c.prototype.init = function (b, c) {
              this.chart = b;
              this.setOptions(c);
              c.enabled && (this.render(), a(this.chart, "endResize", function () {
                this.legend.positionCheckboxes();
              }), this.proximate ? this.unchartrender = a(this.chart, "render", function () {
                this.legend.proximatePositions();
                this.legend.positionItems();
              }) : this.unchartrender && this.unchartrender());
            };

            c.prototype.setOptions = function (b) {
              var a = t(b.padding, 8);
              this.options = b;
              this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = K(this.itemStyle, b.itemHiddenStyle));
              this.itemMarginTop = b.itemMarginTop || 0;
              this.itemMarginBottom = b.itemMarginBottom || 0;
              this.padding = a;
              this.initialItemY = a - 5;
              this.symbolWidth = t(b.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === b.layout && !this.chart.inverted;
              this.baseline = void 0;
            };

            c.prototype.update = function (b, a) {
              var c = this.chart;
              this.setOptions(K(!0, this.options, b));
              this.destroy();
              c.isDirtyLegend = c.isDirtyBox = !0;
              t(a, !0) && c.redraw();
              k(this, "afterUpdate");
            };

            c.prototype.colorizeItem = function (b, a) {
              b.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

              if (!this.chart.styledMode) {
                var c = this.options,
                    f = b.legendItem,
                    d = b.legendLine,
                    h = b.legendSymbol,
                    e = this.itemHiddenStyle.color;
                c = a ? c.itemStyle.color : e;
                var l = a ? b.color || e : e,
                    t = b.options && b.options.marker,
                    p = {
                  fill: l
                };
                f && f.css({
                  fill: c,
                  color: c
                });
                d && d.attr({
                  stroke: l
                });
                h && (t && h.isMarker && (p = b.pointAttribs(), a || (p.stroke = p.fill = e)), h.attr(p));
              }

              k(this, "afterColorizeItem", {
                item: b,
                visible: a
              });
            };

            c.prototype.positionItems = function () {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            };

            c.prototype.positionItem = function (b) {
              var a = this,
                  c = this.options,
                  f = c.symbolPadding,
                  d = !c.rtl,
                  h = b._legendItemPos;
              c = h[0];
              h = h[1];
              var e = b.checkbox,
                  w = b.legendGroup;
              w && w.element && (f = {
                translateX: d ? c : this.legendWidth - c - 2 * f - 4,
                translateY: h
              }, d = function d() {
                k(a, "afterPositionItem", {
                  item: b
                });
              }, l(w.translateY) ? w.animate(f, void 0, d) : (w.attr(f), d()));
              e && (e.x = c, e.y = h);
            };

            c.prototype.destroyItem = function (b) {
              var a = b.checkbox;
              ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
                b[a] && (b[a] = b[a].destroy());
              });
              a && h(b.checkbox);
            };

            c.prototype.destroy = function () {
              function b(b) {
                this[b] && (this[b] = this[b].destroy());
              }

              this.getAllItems().forEach(function (a) {
                ["legendItem", "legendGroup"].forEach(b, a);
              });
              "clipRect up down pager nav box title group".split(" ").forEach(b, this);
              this.display = null;
            };

            c.prototype.positionCheckboxes = function () {
              var b = this.group && this.group.alignAttr,
                  a = this.clipHeight || this.legendHeight,
                  c = this.titleHeight;

              if (b) {
                var f = b.translateY;
                this.allItems.forEach(function (d) {
                  var k = d.checkbox;

                  if (k) {
                    var h = f + c + k.y + (this.scrollOffset || 0) + 3;
                    B(k, {
                      left: b.translateX + d.checkboxOffset + k.x - 20 + "px",
                      top: h + "px",
                      display: this.proximate || h > f - 6 && h < f + a - 6 ? "" : "none"
                    });
                  }
                }, this);
              }
            };

            c.prototype.renderTitle = function () {
              var b = this.options,
                  a = this.padding,
                  c = b.title,
                  f = 0;
              c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, null, null, null, b.useHTML, null, "legend-title").attr({
                zIndex: 1
              }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({
                width: this.maxLegendWidth + "px"
              }), b = this.title.getBBox(), f = b.height, this.offsetWidth = b.width, this.contentGroup.attr({
                translateY: f
              }));
              this.titleHeight = f;
            };

            c.prototype.setText = function (b) {
              var a = this.options;
              b.legendItem.attr({
                text: a.labelFormat ? r(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)
              });
            };

            c.prototype.renderItem = function (b) {
              var a = this.chart,
                  c = a.renderer,
                  f = this.options,
                  d = this.symbolWidth,
                  k = f.symbolPadding || 0,
                  h = this.itemStyle,
                  e = this.itemHiddenStyle,
                  l = "horizontal" === f.layout ? t(f.itemDistance, 20) : 0,
                  p = !f.rtl,
                  m = !b.series,
                  q = !m && b.series.drawLegendSymbol ? b.series : b,
                  g = q.options,
                  r = this.createCheckboxForItem && g && g.showCheckbox,
                  A = f.useHTML,
                  z = b.options.className,
                  B = b.legendItem;
              g = d + k + l + (r ? 20 : 0);
              B || (b.legendGroup = c.g("legend-item").addClass("highcharts-" + q.type + "-series highcharts-color-" + b.colorIndex + (z ? " " + z : "") + (m ? " highcharts-series-" + b.index : "")).attr({
                zIndex: 1
              }).add(this.scrollGroup), b.legendItem = B = c.text("", p ? d + k : -k, this.baseline || 0, A), a.styledMode || B.css(K(b.visible ? h : e)), B.attr({
                align: p ? "left" : "right",
                zIndex: 2
              }).add(b.legendGroup), this.baseline || (this.fontMetrics = c.fontMetrics(a.styledMode ? 12 : h.fontSize, B), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, B.attr("y", this.baseline), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, f.squareSymbol && (this.symbolWidth = t(f.symbolWidth, Math.max(this.symbolHeight, 16)), g = this.symbolWidth + k + l + (r ? 20 : 0), p && B.attr("x", this.symbolWidth + k))), q.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, B, A));
              r && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
              this.colorizeItem(b, b.visible);
              !a.styledMode && h.width || B.css({
                width: (f.itemWidth || this.widthOption || a.spacingBox.width) - g + "px"
              });
              this.setText(b);
              a = B.getBBox();
              b.itemWidth = b.checkboxOffset = f.itemWidth || b.legendItemWidth || a.width + g;
              this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
              this.totalItemWidth += b.itemWidth;
              this.itemHeight = b.itemHeight = Math.round(b.legendItemHeight || a.height || this.symbolHeight);
            };

            c.prototype.layoutItem = function (b) {
              var a = this.options,
                  c = this.padding,
                  f = "horizontal" === a.layout,
                  d = b.itemHeight,
                  k = this.itemMarginBottom,
                  h = this.itemMarginTop,
                  e = f ? t(a.itemDistance, 20) : 0,
                  l = this.maxLegendWidth;
              a = a.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : b.itemWidth;
              f && this.itemX - c + a > l && (this.itemX = c, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + k), this.lastLineHeight = 0);
              this.lastItemY = h + this.itemY + k;
              this.lastLineHeight = Math.max(d, this.lastLineHeight);
              b._legendItemPos = [this.itemX, this.itemY];
              f ? this.itemX += a : (this.itemY += h + d + k, this.lastLineHeight = d);
              this.offsetWidth = this.widthOption || Math.max((f ? this.itemX - c - (b.checkbox ? 0 : e) : a) + c, this.offsetWidth);
            };

            c.prototype.getAllItems = function () {
              var b = [];
              this.chart.series.forEach(function (a) {
                var c = a && a.options;
                a && t(c.showInLegend, l(c.linkedTo) ? !1 : void 0, !0) && (b = b.concat(a.legendItems || ("point" === c.legendType ? a.data : a)));
              });
              k(this, "afterGetAllItems", {
                allItems: b
              });
              return b;
            };

            c.prototype.getAlignment = function () {
              var b = this.options;
              return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
            };

            c.prototype.adjustMargins = function (b, a) {
              var c = this.chart,
                  f = this.options,
                  d = this.getAlignment();
              d && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (k, h) {
                k.test(d) && !l(b[h]) && (c[m[h]] = Math.max(c[m[h]], c.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * f[h % 2 ? "x" : "y"] + t(f.margin, 12) + a[h] + (c.titleOffset[h] || 0)));
              });
            };

            c.prototype.proximatePositions = function () {
              var b = this.chart,
                  a = [],
                  c = "left" === this.options.align;
              this.allItems.forEach(function (d) {
                var k;
                var h = c;

                if (d.yAxis) {
                  d.xAxis.options.reversed && (h = !h);
                  d.points && (k = f(h ? d.points : d.points.slice(0).reverse(), function (b) {
                    return J(b.plotY);
                  }));
                  h = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;
                  var e = d.yAxis.top - b.plotTop;
                  d.visible ? (k = k ? k.plotY : d.yAxis.height, k += e - .3 * h) : k = e + d.yAxis.height;
                  a.push({
                    target: k,
                    size: h,
                    item: d
                  });
                }
              }, this);
              d(a, b.plotHeight).forEach(function (a) {
                a.item._legendItemPos && (a.item._legendItemPos[1] = b.plotTop - b.spacing[0] + a.pos);
              });
            };

            c.prototype.render = function () {
              var b = this.chart,
                  a = b.renderer,
                  c = this.options,
                  f = this.padding,
                  d = this.getAllItems(),
                  h = this.group,
                  e = this.box;
              this.itemX = f;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = Q(c.width, b.spacingBox.width - f);
              var l = b.spacingBox.width - 2 * f - c.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (l /= 2);
              this.maxLegendWidth = this.widthOption || l;
              h || (this.group = h = a.g("legend").addClass(c.className || "").attr({
                zIndex: 7
              }).add(), this.contentGroup = a.g().attr({
                zIndex: 1
              }).add(h), this.scrollGroup = a.g().add(this.contentGroup));
              this.renderTitle();
              z(d, function (b, a) {
                return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
              });
              c.reversed && d.reverse();
              this.allItems = d;
              this.display = l = !!d.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              d.forEach(this.renderItem, this);
              d.forEach(this.layoutItem, this);
              d = (this.widthOption || this.offsetWidth) + f;
              var t = this.lastItemY + this.lastLineHeight + this.titleHeight;
              t = this.handleOverflow(t);
              t += f;
              e || (this.box = e = a.rect().addClass("highcharts-legend-box").attr({
                r: c.borderRadius
              }).add(h), e.isNew = !0);
              b.styledMode || e.attr({
                stroke: c.borderColor,
                "stroke-width": c.borderWidth || 0,
                fill: c.backgroundColor || "none"
              }).shadow(c.shadow);
              0 < d && 0 < t && (e[e.isNew ? "attr" : "animate"](e.crisp.call({}, {
                x: 0,
                y: 0,
                width: d,
                height: t
              }, e.strokeWidth())), e.isNew = !1);
              e[l ? "show" : "hide"]();
              b.styledMode && "none" === h.getStyle("display") && (d = t = 0);
              this.legendWidth = d;
              this.legendHeight = t;
              l && this.align();
              this.proximate || this.positionItems();
              k(this, "afterRender");
            };

            c.prototype.align = function (b) {
              void 0 === b && (b = this.chart.spacingBox);
              var a = this.chart,
                  c = this.options,
                  f = b.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? f += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (f -= a.titleOffset[2]);
              f !== b.y && (b = K(b, {
                y: f
              }));
              this.group.align(K(c, {
                width: this.legendWidth,
                height: this.legendHeight,
                verticalAlign: this.proximate ? "top" : c.verticalAlign
              }), !0, b);
            };

            c.prototype.handleOverflow = function (b) {
              var a = this,
                  c = this.chart,
                  f = c.renderer,
                  d = this.options,
                  k = d.y,
                  h = "top" === d.verticalAlign,
                  e = this.padding,
                  l = d.maxHeight,
                  p = d.navigation,
                  m = t(p.animation, !0),
                  q = p.arrowSize || 12,
                  g = this.pages,
                  r = this.allItems,
                  A = function A(b) {
                "number" === typeof b ? V.attr({
                  height: b
                }) : V && (a.clipRect = V.destroy(), a.contentGroup.clip());
                a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + e + "px,9999px," + (e + b) + "px,0)" : "auto");
              },
                  z = function z(b) {
                a[b] = f.circle(0, 0, 1.3 * q).translate(q / 2, q / 2).add(J);
                c.styledMode || a[b].attr("fill", "rgba(0,0,0,0.0001)");
                return a[b];
              },
                  B,
                  S;

              k = c.spacingBox.height + (h ? -k : k) - e;
              var J = this.nav,
                  V = this.clipRect;
              "horizontal" !== d.layout || "middle" === d.verticalAlign || d.floating || (k /= 2);
              l && (k = Math.min(k, l));
              g.length = 0;
              b && 0 < k && b > k && !1 !== p.enabled ? (this.clipHeight = B = Math.max(k - 20 - this.titleHeight - e, 0), this.currentPage = t(this.currentPage, 1), this.fullHeight = b, r.forEach(function (b, a) {
                var c = b._legendItemPos[1],
                    f = Math.round(b.legendItem.getBBox().height),
                    d = g.length;
                if (!d || c - g[d - 1] > B && (S || c) !== g[d - 1]) g.push(S || c), d++;
                b.pageIx = d - 1;
                S && (r[a - 1].pageIx = d - 1);
                a === r.length - 1 && c + f - g[d - 1] > B && c !== S && (g.push(c), b.pageIx = d);
                c !== S && (S = c);
              }), V || (V = a.clipRect = f.clipRect(0, e, 9999, 0), a.contentGroup.clip(V)), A(B), J || (this.nav = J = f.g().attr({
                zIndex: 1
              }).add(this.group), this.up = f.symbol("triangle", 0, 0, q, q).add(J), z("upTracker").on("click", function () {
                a.scroll(-1, m);
              }), this.pager = f.text("", 15, 10).addClass("highcharts-legend-navigation"), c.styledMode || this.pager.css(p.style), this.pager.add(J), this.down = f.symbol("triangle-down", 0, 0, q, q).add(J), z("downTracker").on("click", function () {
                a.scroll(1, m);
              })), a.scroll(0), b = k) : J && (A(), this.nav = J.destroy(), this.scrollGroup.attr({
                translateY: 1
              }), this.clipHeight = 0);
              return b;
            };

            c.prototype.scroll = function (b, a) {
              var c = this,
                  f = this.chart,
                  d = this.pages,
                  h = d.length,
                  e = this.clipHeight,
                  l = this.options.navigation,
                  p = this.pager,
                  m = this.padding,
                  g = this.currentPage + b;
              g > h && (g = h);
              0 < g && ("undefined" !== typeof a && x(a, f), this.nav.attr({
                translateX: m,
                translateY: e + this.padding + 7 + this.titleHeight,
                visibility: "visible"
              }), [this.up, this.upTracker].forEach(function (b) {
                b.attr({
                  "class": 1 === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }), p.attr({
                text: g + "/" + h
              }), [this.down, this.downTracker].forEach(function (b) {
                b.attr({
                  x: 18 + this.pager.getBBox().width,
                  "class": g === h ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }, this), f.styledMode || (this.up.attr({
                fill: 1 === g ? l.inactiveColor : l.activeColor
              }), this.upTracker.css({
                cursor: 1 === g ? "default" : "pointer"
              }), this.down.attr({
                fill: g === h ? l.inactiveColor : l.activeColor
              }), this.downTracker.css({
                cursor: g === h ? "default" : "pointer"
              })), this.scrollOffset = -d[g - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: this.scrollOffset
              }), this.currentPage = g, this.positionCheckboxes(), b = G(t(a, f.renderer.globalAnimation, !0)), A(function () {
                k(c, "afterScroll", {
                  currentPage: g
                });
              }, b.duration));
            };

            c.prototype.setItemEvents = function (b, a, c) {
              var f = this,
                  d = f.chart.renderer.boxWrapper,
                  h = b instanceof y,
                  e = "highcharts-legend-" + (h ? "point" : "series") + "-active",
                  l = f.chart.styledMode,
                  t = function t(a) {
                f.allItems.forEach(function (c) {
                  b !== c && [c].concat(c.linkedSeries || []).forEach(function (b) {
                    b.setState(a, !h);
                  });
                });
              };

              (c ? [a, b.legendSymbol] : [b.legendGroup]).forEach(function (c) {
                if (c) c.on("mouseover", function () {
                  b.visible && t("inactive");
                  b.setState("hover");
                  b.visible && d.addClass(e);
                  l || a.css(f.options.itemHoverStyle);
                }).on("mouseout", function () {
                  f.chart.styledMode || a.css(K(b.visible ? f.itemStyle : f.itemHiddenStyle));
                  t("");
                  d.removeClass(e);
                  b.setState();
                }).on("click", function (a) {
                  var c = function c() {
                    b.setVisible && b.setVisible();
                    t(b.visible ? "inactive" : "");
                  };

                  d.removeClass(e);
                  a = {
                    browserEvent: a
                  };
                  b.firePointEvent ? b.firePointEvent("legendItemClick", a, c) : k(b, "legendItemClick", a, c);
                });
              });
            };

            c.prototype.createCheckboxForItem = function (b) {
              b.checkbox = p("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: b.selected,
                defaultChecked: b.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              a(b.checkbox, "click", function (a) {
                k(b.series || b, "checkboxClick", {
                  checked: a.target.checked,
                  item: b
                }, function () {
                  b.select();
                });
              });
            };

            return c;
          }();

          (/Trident\/7\.0/.test(C.navigator && C.navigator.userAgent) || e) && E(v.prototype, "positionItem", function (a, b) {
            var c = this,
                f = function f() {
              b._legendItemPos && a.call(c, b);
            };

            f();
            c.bubbleLegend || setTimeout(f);
          });
          "";
          return v;
        });
        M(g, "Core/Series/SeriesRegistry.js", [g["Core/Globals.js"], g["Core/DefaultOptions.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var E = g.defaultOptions,
              v = y.error,
              G = y.extendClass,
              x = y.merge,
              r;

          (function (m) {
            function d(a, d) {
              var e = E.plotOptions || {},
                  l = d.defaultOptions;
              d.prototype.pointClass || (d.prototype.pointClass = C);
              d.prototype.type = a;
              l && (e[a] = l);
              m.seriesTypes[a] = d;
            }

            m.seriesTypes = e.seriesTypes;

            m.getSeries = function (a, d) {
              void 0 === d && (d = {});
              var e = a.options.chart;
              e = d.type || e.type || e.defaultSeriesType || "";
              var l = m.seriesTypes[e];
              m || v(17, !0, a, {
                missingModuleFor: e
              });
              e = new l();
              "function" === typeof e.init && e.init(a, d);
              return e;
            };

            m.registerSeriesType = d;

            m.seriesType = function (a, e, g, l, h) {
              var f = E.plotOptions || {};
              e = e || "";
              f[a] = x(f[e], g);
              d(a, G(m.seriesTypes[e] || function () {}, l));
              m.seriesTypes[a].prototype.type = a;
              h && (m.seriesTypes[a].prototype.pointClass = G(C, h));
              return m.seriesTypes[a];
            };
          })(r || (r = {}));

          return r;
        });
        M(g, "Core/Chart/Chart.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/FormatUtilities.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Legend/Legend.js"], g["Core/MSPointer.js"], g["Core/DefaultOptions.js"], g["Core/Color/Palette.js"], g["Core/Pointer.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Time.js"], g["Core/Utilities.js"], g["Core/Renderer/HTML/AST.js"]], function (e, g, C, y, E, v, G, x, r, m, d, a, p, B, l, h) {
          var f = e.animate,
              k = e.animObject,
              J = e.setAnimation,
              K = C.numberFormat,
              t = y.registerEventOptions,
              Q = E.charts,
              z = E.doc,
              A = E.marginNames,
              c = E.svg,
              b = E.win,
              D = x.defaultOptions,
              L = x.defaultTime,
              I = a.seriesTypes,
              n = l.addEvent,
              u = l.attr,
              N = l.cleanRecursively,
              w = l.createElement,
              H = l.css,
              O = l.defined,
              R = l.discardElement,
              q = l.erase,
              F = l.error,
              P = l.extend,
              ca = l.find,
              T = l.fireEvent,
              da = l.getStyle,
              S = l.isArray,
              Y = l.isNumber,
              V = l.isObject,
              ea = l.isString,
              Z = l.merge,
              W = l.objectEach,
              U = l.pick,
              fa = l.pInt,
              aa = l.relativeLength,
              M = l.removeEvent,
              ia = l.splat,
              ba = l.syncTimeout,
              ja = l.uniqueKey;

          e = function () {
            function a(b, a, c) {
              this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
              this.sharedClips = {};
              this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
              this.getArgs(b, a, c);
            }

            a.chart = function (b, c, f) {
              return new a(b, c, f);
            };

            a.prototype.getArgs = function (b, a, c) {
              ea(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);
            };

            a.prototype.init = function (b, a) {
              var c = b.plotOptions || {};
              T(this, "init", {
                args: arguments
              }, function () {
                var f = Z(D, b),
                    d = f.chart;
                W(f.plotOptions, function (b, a) {
                  V(b) && (b.tooltip = c[a] && Z(c[a].tooltip) || void 0);
                });
                f.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
                this.userOptions = b;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                  h: {},
                  v: {}
                };
                this.labelCollectors = [];
                this.callback = a;
                this.isResizing = 0;
                this.options = f;
                this.axes = [];
                this.series = [];
                this.time = b.time && Object.keys(b.time).length ? new B(b.time) : E.time;
                this.numberFormatter = d.numberFormatter || K;
                this.styledMode = d.styledMode;
                this.hasCartesianSeries = d.showAxes;
                this.index = Q.length;
                Q.push(this);
                E.chartCount++;
                t(this, d);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                T(this, "afterInit");
                this.firstRender();
              });
            };

            a.prototype.initSeries = function (b) {
              var a = this.options.chart;
              a = b.type || a.type || a.defaultSeriesType;
              var c = I[a];
              c || F(17, !0, this, {
                missingModuleFor: a
              });
              a = new c();
              "function" === typeof a.init && a.init(this, b);
              return a;
            };

            a.prototype.setSeriesData = function () {
              this.getSeriesOrderByLinks().forEach(function (b) {
                b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
              });
            };

            a.prototype.getSeriesOrderByLinks = function () {
              return this.series.concat().sort(function (b, a) {
                return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
              });
            };

            a.prototype.orderSeries = function (b) {
              var a = this.series;
              b = b || 0;

              for (var c = a.length; b < c; ++b) {
                a[b] && (a[b].index = b, a[b].name = a[b].getName());
              }
            };

            a.prototype.isInsidePlot = function (b, a, c) {
              void 0 === c && (c = {});
              var f = this.inverted,
                  d = this.plotBox,
                  k = this.plotLeft,
                  h = this.plotTop,
                  e = this.scrollablePlotBox,
                  n = 0;
              var l = 0;
              c.visiblePlotOnly && this.scrollingContainer && (l = this.scrollingContainer, n = l.scrollLeft, l = l.scrollTop);
              var q = c.series;
              d = c.visiblePlotOnly && e || d;
              e = c.inverted ? a : b;
              a = c.inverted ? b : a;
              b = {
                x: e,
                y: a,
                isInsidePlot: !0
              };

              if (!c.ignoreX) {
                var t = q && (f ? q.yAxis : q.xAxis) || {
                  pos: k,
                  len: Infinity
                };
                e = c.paneCoordinates ? t.pos + e : k + e;
                e >= Math.max(n + k, t.pos) && e <= Math.min(n + k + d.width, t.pos + t.len) || (b.isInsidePlot = !1);
              }

              !c.ignoreY && b.isInsidePlot && (f = q && (f ? q.xAxis : q.yAxis) || {
                pos: h,
                len: Infinity
              }, c = c.paneCoordinates ? f.pos + a : h + a, c >= Math.max(l + h, f.pos) && c <= Math.min(l + h + d.height, f.pos + f.len) || (b.isInsidePlot = !1));
              T(this, "afterIsInsidePlot", b);
              return b.isInsidePlot;
            };

            a.prototype.redraw = function (b) {
              T(this, "beforeRedraw");
              var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                  c = this.series,
                  f = this.pointer,
                  d = this.legend,
                  k = this.userOptions.legend,
                  h = this.renderer,
                  e = h.isHidden(),
                  n = [],
                  l = this.isDirtyBox,
                  q = this.isDirtyLegend;
              this.setResponsive && this.setResponsive(!1);
              J(this.hasRendered ? b : !1, this);
              e && this.temporaryDisplay();
              this.layOutTitles();

              for (b = c.length; b--;) {
                var t = c[b];

                if (t.options.stacking || t.options.centerInCategory) {
                  var w = !0;

                  if (t.isDirty) {
                    var p = !0;
                    break;
                  }
                }
              }

              if (p) for (b = c.length; b--;) {
                t = c[b], t.options.stacking && (t.isDirty = !0);
              }
              c.forEach(function (b) {
                b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), q = !0) : k && (k.labelFormatter || k.labelFormat) && (q = !0));
                b.isDirtyData && T(b, "updatedData");
              });
              q && d && d.options.enabled && (d.render(), this.isDirtyLegend = !1);
              w && this.getStacks();
              a.forEach(function (b) {
                b.updateNames();
                b.setScale();
              });
              this.getMargins();
              a.forEach(function (b) {
                b.isDirty && (l = !0);
              });
              a.forEach(function (b) {
                var a = b.min + "," + b.max;
                b.extKey !== a && (b.extKey = a, n.push(function () {
                  T(b, "afterSetExtremes", P(b.eventArgs, b.getExtremes()));
                  delete b.eventArgs;
                }));
                (l || w) && b.redraw();
              });
              l && this.drawChartBox();
              T(this, "predraw");
              c.forEach(function (b) {
                (l || b.isDirty) && b.visible && b.redraw();
                b.isDirtyData = !1;
              });
              f && f.reset(!0);
              h.draw();
              T(this, "redraw");
              T(this, "render");
              e && this.temporaryDisplay(!0);
              n.forEach(function (b) {
                b.call();
              });
            };

            a.prototype.get = function (b) {
              function a(a) {
                return a.id === b || a.options && a.options.id === b;
              }

              for (var c = this.series, f = ca(this.axes, a) || ca(this.series, a), d = 0; !f && d < c.length; d++) {
                f = ca(c[d].points || [], a);
              }

              return f;
            };

            a.prototype.getAxes = function () {
              var b = this,
                  a = this.options,
                  c = a.xAxis = ia(a.xAxis || {});
              a = a.yAxis = ia(a.yAxis || {});
              T(this, "getAxes");
              c.forEach(function (b, a) {
                b.index = a;
                b.isX = !0;
              });
              a.forEach(function (b, a) {
                b.index = a;
              });
              c.concat(a).forEach(function (a) {
                new g(b, a);
              });
              T(this, "afterGetAxes");
            };

            a.prototype.getSelectedPoints = function () {
              return this.series.reduce(function (b, a) {
                a.getPointsCollection().forEach(function (a) {
                  U(a.selectedStaging, a.selected) && b.push(a);
                });
                return b;
              }, []);
            };

            a.prototype.getSelectedSeries = function () {
              return this.series.filter(function (b) {
                return b.selected;
              });
            };

            a.prototype.setTitle = function (b, a, c) {
              this.applyDescription("title", b);
              this.applyDescription("subtitle", a);
              this.applyDescription("caption", void 0);
              this.layOutTitles(c);
            };

            a.prototype.applyDescription = function (b, a) {
              var c = this,
                  f = "title" === b ? {
                color: r.neutralColor80,
                fontSize: this.options.isStock ? "16px" : "18px"
              } : {
                color: r.neutralColor60
              };
              f = this.options[b] = Z(!this.styledMode && {
                style: f
              }, this.options[b], a);
              var d = this[b];
              d && a && (this[b] = d = d.destroy());
              f && !d && (d = this.renderer.text(f.text, 0, 0, f.useHTML).attr({
                align: f.align,
                "class": "highcharts-" + b,
                zIndex: f.zIndex || 4
              }).add(), d.update = function (a) {
                c[{
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }[b]](a);
              }, this.styledMode || d.css(f.style), this[b] = d);
            };

            a.prototype.layOutTitles = function (b) {
              var a = [0, 0, 0],
                  c = this.renderer,
                  f = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (b) {
                var d = this[b],
                    k = this.options[b],
                    h = k.verticalAlign || "top";
                b = "title" === b ? "top" === h ? -3 : 0 : "top" === h ? a[0] + 2 : 0;
                var e;

                if (d) {
                  this.styledMode || (e = k.style && k.style.fontSize);
                  e = c.fontMetrics(e, d).b;
                  d.css({
                    width: (k.width || f.width + (k.widthAdjust || 0)) + "px"
                  });
                  var n = Math.round(d.getBBox(k.useHTML).height);
                  d.align(P({
                    y: "bottom" === h ? e : b + e,
                    height: n
                  }, k), !1, "spacingBox");
                  k.floating || ("top" === h ? a[0] = Math.ceil(a[0] + n) : "bottom" === h && (a[2] = Math.ceil(a[2] + n)));
                }
              }, this);
              a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
              a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
              var d = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
              this.titleOffset = a;
              T(this, "afterLayOutTitles");
              !this.isDirtyBox && d && (this.isDirtyBox = this.isDirtyLegend = d, this.hasRendered && U(b, !0) && this.isDirtyBox && this.redraw());
            };

            a.prototype.getChartSize = function () {
              var b = this.options.chart,
                  a = b.width;
              b = b.height;
              var c = this.renderTo;
              O(a) || (this.containerWidth = da(c, "width"));
              O(b) || (this.containerHeight = da(c, "height"));
              this.chartWidth = Math.max(0, a || this.containerWidth || 600);
              this.chartHeight = Math.max(0, aa(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };

            a.prototype.temporaryDisplay = function (b) {
              var a = this.renderTo;
              if (b) for (; a && a.style;) {
                a.hcOrigStyle && (H(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (z.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;
              } else for (; a && a.style;) {
                z.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, z.body.appendChild(a));
                if ("none" === da(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
                  display: a.style.display,
                  height: a.style.height,
                  overflow: a.style.overflow
                }, b = {
                  display: "block",
                  overflow: "hidden"
                }, a !== this.renderTo && (b.height = 0), H(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
                a = a.parentNode;
                if (a === z.body) break;
              }
            };

            a.prototype.setClassName = function (b) {
              this.container.className = "highcharts-container " + (b || "");
            };

            a.prototype.getContainer = function () {
              var b = this.options,
                  a = b.chart,
                  f = ja(),
                  k,
                  h = this.renderTo;
              h || (this.renderTo = h = a.renderTo);
              ea(h) && (this.renderTo = h = z.getElementById(h));
              h || F(13, !0, this);
              var e = fa(u(h, "data-highcharts-chart"));
              Y(e) && Q[e] && Q[e].hasRendered && Q[e].destroy();
              u(h, "data-highcharts-chart", this.index);
              h.innerHTML = "";
              a.skipClone || h.offsetWidth || this.temporaryDisplay();
              this.getChartSize();
              e = this.chartWidth;
              var n = this.chartHeight;
              H(h, {
                overflow: "hidden"
              });
              this.styledMode || (k = P({
                position: "relative",
                overflow: "hidden",
                width: e + "px",
                height: n + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                userSelect: "none",
                "touch-action": "manipulation",
                outline: "none"
              }, a.style || {}));
              this.container = f = w("div", {
                id: f
              }, k, h);
              this._cursor = f.style.cursor;
              this.renderer = new (a.renderer || !c ? d.getRendererType(a.renderer) : p)(f, e, n, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
              J(void 0, this);
              this.setClassName(a.className);
              if (this.styledMode) for (var l in b.defs) {
                this.renderer.definition(b.defs[l]);
              } else this.renderer.setStyle(a.style);
              this.renderer.chartIndex = this.index;
              T(this, "afterGetContainer");
            };

            a.prototype.getMargins = function (b) {
              var a = this.spacing,
                  c = this.margin,
                  f = this.titleOffset;
              this.resetMargins();
              f[0] && !O(c[0]) && (this.plotTop = Math.max(this.plotTop, f[0] + a[0]));
              f[2] && !O(c[2]) && (this.marginBottom = Math.max(this.marginBottom, f[2] + a[2]));
              this.legend && this.legend.display && this.legend.adjustMargins(c, a);
              T(this, "getMargins");
              b || this.getAxisMargins();
            };

            a.prototype.getAxisMargins = function () {
              var b = this,
                  a = b.axisOffset = [0, 0, 0, 0],
                  c = b.colorAxis,
                  f = b.margin,
                  d = function d(b) {
                b.forEach(function (b) {
                  b.visible && b.getOffset();
                });
              };

              b.hasCartesianSeries ? d(b.axes) : c && c.length && d(c);
              A.forEach(function (c, d) {
                O(f[d]) || (b[c] += a[d]);
              });
              b.setChartSize();
            };

            a.prototype.reflow = function (a) {
              var c = this,
                  f = c.options.chart,
                  d = c.renderTo,
                  k = O(f.width) && O(f.height),
                  h = f.width || da(d, "width");
              f = f.height || da(d, "height");
              d = a ? a.target : b;
              delete c.pointer.chartPosition;

              if (!k && !c.isPrinting && h && f && (d === b || d === z)) {
                if (h !== c.containerWidth || f !== c.containerHeight) l.clearTimeout(c.reflowTimeout), c.reflowTimeout = ba(function () {
                  c.container && c.setSize(void 0, void 0, !1);
                }, a ? 100 : 0);
                c.containerWidth = h;
                c.containerHeight = f;
              }
            };

            a.prototype.setReflow = function (a) {
              var c = this;
              !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = n(b, "resize", function (b) {
                c.options && c.reflow(b);
              }), n(this, "destroy", this.unbindReflow));
            };

            a.prototype.setSize = function (b, a, c) {
              var d = this,
                  h = d.renderer;
              d.isResizing += 1;
              J(c, d);
              c = h.globalAnimation;
              d.oldChartHeight = d.chartHeight;
              d.oldChartWidth = d.chartWidth;
              "undefined" !== typeof b && (d.options.chart.width = b);
              "undefined" !== typeof a && (d.options.chart.height = a);
              d.getChartSize();
              d.styledMode || (c ? f : H)(d.container, {
                width: d.chartWidth + "px",
                height: d.chartHeight + "px"
              }, c);
              d.setChartSize(!0);
              h.setSize(d.chartWidth, d.chartHeight, c);
              d.axes.forEach(function (b) {
                b.isDirty = !0;
                b.setScale();
              });
              d.isDirtyLegend = !0;
              d.isDirtyBox = !0;
              d.layOutTitles();
              d.getMargins();
              d.redraw(c);
              d.oldChartHeight = null;
              T(d, "resize");
              ba(function () {
                d && T(d, "endResize", null, function () {
                  --d.isResizing;
                });
              }, k(c).duration);
            };

            a.prototype.setChartSize = function (b) {
              var a = this.inverted,
                  c = this.renderer,
                  f = this.chartWidth,
                  d = this.chartHeight,
                  k = this.options.chart,
                  h = this.spacing,
                  e = this.clipOffset,
                  n,
                  l,
                  q,
                  t;
              this.plotLeft = n = Math.round(this.plotLeft);
              this.plotTop = l = Math.round(this.plotTop);
              this.plotWidth = q = Math.max(0, Math.round(f - n - this.marginRight));
              this.plotHeight = t = Math.max(0, Math.round(d - l - this.marginBottom));
              this.plotSizeX = a ? t : q;
              this.plotSizeY = a ? q : t;
              this.plotBorderWidth = k.plotBorderWidth || 0;
              this.spacingBox = c.spacingBox = {
                x: h[3],
                y: h[0],
                width: f - h[3] - h[1],
                height: d - h[0] - h[2]
              };
              this.plotBox = c.plotBox = {
                x: n,
                y: l,
                width: q,
                height: t
              };
              a = 2 * Math.floor(this.plotBorderWidth / 2);
              f = Math.ceil(Math.max(a, e[3]) / 2);
              d = Math.ceil(Math.max(a, e[0]) / 2);
              this.clipBox = {
                x: f,
                y: d,
                width: Math.floor(this.plotSizeX - Math.max(a, e[1]) / 2 - f),
                height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, e[2]) / 2 - d))
              };
              b || (this.axes.forEach(function (b) {
                b.setAxisSize();
                b.setAxisTranslation();
              }), c.alignElements());
              T(this, "afterSetChartSize", {
                skipAxes: b
              });
            };

            a.prototype.resetMargins = function () {
              T(this, "resetMargins");
              var b = this,
                  a = b.options.chart;
              ["margin", "spacing"].forEach(function (c) {
                var f = a[c],
                    d = V(f) ? f : [f, f, f, f];
                ["Top", "Right", "Bottom", "Left"].forEach(function (f, k) {
                  b[c][k] = U(a[c + f], d[k]);
                });
              });
              A.forEach(function (a, c) {
                b[a] = U(b.margin[c], b.spacing[c]);
              });
              b.axisOffset = [0, 0, 0, 0];
              b.clipOffset = [0, 0, 0, 0];
            };

            a.prototype.drawChartBox = function () {
              var b = this.options.chart,
                  a = this.renderer,
                  c = this.chartWidth,
                  f = this.chartHeight,
                  d = this.styledMode,
                  k = this.plotBGImage,
                  h = b.backgroundColor,
                  e = b.plotBackgroundColor,
                  n = b.plotBackgroundImage,
                  l = this.plotLeft,
                  q = this.plotTop,
                  t = this.plotWidth,
                  w = this.plotHeight,
                  p = this.plotBox,
                  m = this.clipRect,
                  g = this.clipBox,
                  u = this.chartBackground,
                  r = this.plotBackground,
                  H = this.plotBorder,
                  A,
                  z = "animate";
              u || (this.chartBackground = u = a.rect().addClass("highcharts-background").add(), z = "attr");
              if (d) var S = A = u.strokeWidth();else {
                S = b.borderWidth || 0;
                A = S + (b.shadow ? 8 : 0);
                h = {
                  fill: h || "none"
                };
                if (S || u["stroke-width"]) h.stroke = b.borderColor, h["stroke-width"] = S;
                u.attr(h).shadow(b.shadow);
              }
              u[z]({
                x: A / 2,
                y: A / 2,
                width: c - A - S % 2,
                height: f - A - S % 2,
                r: b.borderRadius
              });
              z = "animate";
              r || (z = "attr", this.plotBackground = r = a.rect().addClass("highcharts-plot-background").add());
              r[z](p);
              d || (r.attr({
                fill: e || "none"
              }).shadow(b.plotShadow), n && (k ? (n !== k.attr("href") && k.attr("href", n), k.animate(p)) : this.plotBGImage = a.image(n, l, q, t, w).add()));
              m ? m.animate({
                width: g.width,
                height: g.height
              }) : this.clipRect = a.clipRect(g);
              z = "animate";
              H || (z = "attr", this.plotBorder = H = a.rect().addClass("highcharts-plot-border").attr({
                zIndex: 1
              }).add());
              d || H.attr({
                stroke: b.plotBorderColor,
                "stroke-width": b.plotBorderWidth || 0,
                fill: "none"
              });
              H[z](H.crisp({
                x: l,
                y: q,
                width: t,
                height: w
              }, -H.strokeWidth()));
              this.isDirtyBox = !1;
              T(this, "afterDrawChartBox");
            };

            a.prototype.propFromSeries = function () {
              var b = this,
                  a = b.options.chart,
                  c = b.options.series,
                  f,
                  d,
                  k;
              ["inverted", "angular", "polar"].forEach(function (h) {
                d = I[a.type || a.defaultSeriesType];
                k = a[h] || d && d.prototype[h];

                for (f = c && c.length; !k && f--;) {
                  (d = I[c[f].type]) && d.prototype[h] && (k = !0);
                }

                b[h] = k;
              });
            };

            a.prototype.linkSeries = function () {
              var b = this,
                  a = b.series;
              a.forEach(function (b) {
                b.linkedSeries.length = 0;
              });
              a.forEach(function (a) {
                var c = a.options.linkedTo;
                ea(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = U(a.options.visible, c.options.visible, a.visible));
              });
              T(this, "afterLinkSeries");
            };

            a.prototype.renderSeries = function () {
              this.series.forEach(function (b) {
                b.translate();
                b.render();
              });
            };

            a.prototype.renderLabels = function () {
              var b = this,
                  a = b.options.labels;
              a.items && a.items.forEach(function (c) {
                var f = P(a.style, c.style),
                    d = fa(f.left) + b.plotLeft,
                    k = fa(f.top) + b.plotTop + 12;
                delete f.left;
                delete f.top;
                b.renderer.text(c.html, d, k).attr({
                  zIndex: 2
                }).css(f).add();
              });
            };

            a.prototype.render = function () {
              var b = this.axes,
                  a = this.colorAxis,
                  c = this.renderer,
                  f = this.options,
                  d = function d(b) {
                b.forEach(function (b) {
                  b.visible && b.render();
                });
              },
                  k = 0;

              this.setTitle();
              this.legend = new v(this, f.legend);
              this.getStacks && this.getStacks();
              this.getMargins(!0);
              this.setChartSize();
              f = this.plotWidth;
              b.some(function (b) {
                if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return k = 21, !0;
              });
              var h = this.plotHeight = Math.max(this.plotHeight - k, 0);
              b.forEach(function (b) {
                b.setScale();
              });
              this.getAxisMargins();
              var e = 1.1 < f / this.plotWidth,
                  n = 1.05 < h / this.plotHeight;
              if (e || n) b.forEach(function (b) {
                (b.horiz && e || !b.horiz && n) && b.setTickInterval(!0);
              }), this.getMargins();
              this.drawChartBox();
              this.hasCartesianSeries ? d(b) : a && a.length && d(a);
              this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
                zIndex: 3
              }).add());
              this.renderSeries();
              this.renderLabels();
              this.addCredits();
              this.setResponsive && this.setResponsive();
              this.hasRendered = !0;
            };

            a.prototype.addCredits = function (a) {
              var c = this,
                  f = Z(!0, this.options.credits, a);
              f.enabled && !this.credits && (this.credits = this.renderer.text(f.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                f.href && (b.location.href = f.href);
              }).attr({
                align: f.position.align,
                zIndex: 8
              }), c.styledMode || this.credits.css(f.style), this.credits.add().align(f.position), this.credits.update = function (b) {
                c.credits = c.credits.destroy();
                c.addCredits(b);
              });
            };

            a.prototype.destroy = function () {
              var b = this,
                  a = b.axes,
                  c = b.series,
                  f = b.container,
                  d = f && f.parentNode,
                  k;
              T(b, "destroy");
              b.renderer.forExport ? q(Q, b) : Q[b.index] = void 0;
              E.chartCount--;
              b.renderTo.removeAttribute("data-highcharts-chart");
              M(b);

              for (k = a.length; k--;) {
                a[k] = a[k].destroy();
              }

              this.scroller && this.scroller.destroy && this.scroller.destroy();

              for (k = c.length; k--;) {
                c[k] = c[k].destroy();
              }

              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
                var c = b[a];
                c && c.destroy && (b[a] = c.destroy());
              });
              f && (f.innerHTML = "", M(f), d && R(f));
              W(b, function (a, c) {
                delete b[c];
              });
            };

            a.prototype.firstRender = function () {
              var b = this,
                  a = b.options;

              if (!b.isReadyToRender || b.isReadyToRender()) {
                b.getContainer();
                b.resetMargins();
                b.setChartSize();
                b.propFromSeries();
                b.getAxes();
                (S(a.series) ? a.series : []).forEach(function (a) {
                  b.initSeries(a);
                });
                b.linkSeries();
                b.setSeriesData();
                T(b, "beforeRender");
                m && (G.isRequired() ? b.pointer = new G(b, a) : b.pointer = new m(b, a));
                b.render();
                b.pointer.getChartPosition();
                if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
                b.temporaryDisplay(!0);
              }
            };

            a.prototype.onload = function () {
              this.callbacks.concat([this.callback]).forEach(function (b) {
                b && "undefined" !== typeof this.index && b.apply(this, [this]);
              }, this);
              T(this, "load");
              T(this, "render");
              O(this.index) && this.setReflow(this.options.chart.reflow);
              this.hasLoaded = !0;
            };

            a.prototype.addSeries = function (b, a, c) {
              var f = this,
                  d;
              b && (a = U(a, !0), T(f, "addSeries", {
                options: b
              }, function () {
                d = f.initSeries(b);
                f.isDirtyLegend = !0;
                f.linkSeries();
                d.enabledDataSorting && d.setData(b.data, !1);
                T(f, "afterAddSeries", {
                  series: d
                });
                a && f.redraw(c);
              }));
              return d;
            };

            a.prototype.addAxis = function (b, a, c, f) {
              return this.createAxis(a ? "xAxis" : "yAxis", {
                axis: b,
                redraw: c,
                animation: f
              });
            };

            a.prototype.addColorAxis = function (b, a, c) {
              return this.createAxis("colorAxis", {
                axis: b,
                redraw: a,
                animation: c
              });
            };

            a.prototype.createAxis = function (b, a) {
              b = new g(this, Z(a.axis, {
                index: this[b].length,
                isX: "xAxis" === b
              }));
              U(a.redraw, !0) && this.redraw(a.animation);
              return b;
            };

            a.prototype.showLoading = function (b) {
              var a = this,
                  c = a.options,
                  d = c.loading,
                  k = function k() {
                e && H(e, {
                  left: a.plotLeft + "px",
                  top: a.plotTop + "px",
                  width: a.plotWidth + "px",
                  height: a.plotHeight + "px"
                });
              },
                  e = a.loadingDiv,
                  l = a.loadingSpan;

              e || (a.loadingDiv = e = w("div", {
                className: "highcharts-loading highcharts-loading-hidden"
              }, null, a.container));
              l || (a.loadingSpan = l = w("span", {
                className: "highcharts-loading-inner"
              }, null, e), n(a, "redraw", k));
              e.className = "highcharts-loading";
              h.setElementHTML(l, U(b, c.lang.loading, ""));
              a.styledMode || (H(e, P(d.style, {
                zIndex: 10
              })), H(l, d.labelStyle), a.loadingShown || (H(e, {
                opacity: 0,
                display: ""
              }), f(e, {
                opacity: d.style.opacity || .5
              }, {
                duration: d.showDuration || 0
              })));
              a.loadingShown = !0;
              k();
            };

            a.prototype.hideLoading = function () {
              var b = this.options,
                  a = this.loadingDiv;
              a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || f(a, {
                opacity: 0
              }, {
                duration: b.loading.hideDuration || 100,
                complete: function complete() {
                  H(a, {
                    display: "none"
                  });
                }
              }));
              this.loadingShown = !1;
            };

            a.prototype.update = function (b, a, c, f) {
              var d = this,
                  k = {
                credits: "addCredits",
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              },
                  h = b.isResponsiveOptions,
                  e = [],
                  n,
                  l;
              T(d, "update", {
                options: b
              });
              h || d.setResponsive(!1, !0);
              b = N(b, d.options);
              d.userOptions = Z(d.userOptions, b);
              var q = b.chart;

              if (q) {
                Z(!0, d.options.chart, q);
                "className" in q && d.setClassName(q.className);
                "reflow" in q && d.setReflow(q.reflow);

                if ("inverted" in q || "polar" in q || "type" in q) {
                  d.propFromSeries();
                  var w = !0;
                }

                "alignTicks" in q && (w = !0);
                "events" in q && t(this, q);
                W(q, function (b, a) {
                  -1 !== d.propsRequireUpdateSeries.indexOf("chart." + a) && (n = !0);
                  -1 !== d.propsRequireDirtyBox.indexOf(a) && (d.isDirtyBox = !0);
                  -1 !== d.propsRequireReflow.indexOf(a) && (h ? d.isDirtyBox = !0 : l = !0);
                });
                !d.styledMode && q.style && d.renderer.setStyle(d.options.chart.style || {});
              }

              !d.styledMode && b.colors && (this.options.colors = b.colors);
              b.time && (this.time === L && (this.time = new B(b.time)), Z(!0, d.options.time, b.time));
              W(b, function (a, c) {
                if (d[c] && "function" === typeof d[c].update) d[c].update(a, !1);else if ("function" === typeof d[k[c]]) d[k[c]](a);else "colors" !== c && -1 === d.collectionsWithUpdate.indexOf(c) && Z(!0, d.options[c], b[c]);
                "chart" !== c && -1 !== d.propsRequireUpdateSeries.indexOf(c) && (n = !0);
              });
              this.collectionsWithUpdate.forEach(function (a) {
                if (b[a]) {
                  var f = [];
                  d[a].forEach(function (b, a) {
                    b.options.isInternal || f.push(U(b.options.index, a));
                  });
                  ia(b[a]).forEach(function (b, k) {
                    var h = O(b.id),
                        e;
                    h && (e = d.get(b.id));
                    !e && d[a] && (e = d[a][f ? f[k] : k]) && h && O(e.options.id) && (e = void 0);
                    e && e.coll === a && (e.update(b, !1), c && (e.touched = !0));
                    !e && c && d.collectionsWithInit[a] && (d.collectionsWithInit[a][0].apply(d, [b].concat(d.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
                  });
                  c && d[a].forEach(function (b) {
                    b.touched || b.options.isInternal ? delete b.touched : e.push(b);
                  });
                }
              });
              e.forEach(function (b) {
                b.chart && b.remove && b.remove(!1);
              });
              w && d.axes.forEach(function (b) {
                b.update({}, !1);
              });
              n && d.getSeriesOrderByLinks().forEach(function (b) {
                b.chart && b.update({}, !1);
              }, this);
              w = q && q.width;
              q = q && (ea(q.height) ? aa(q.height, w || d.chartWidth) : q.height);
              l || Y(w) && w !== d.chartWidth || Y(q) && q !== d.chartHeight ? d.setSize(w, q, f) : U(a, !0) && d.redraw(f);
              T(d, "afterUpdate", {
                options: b,
                redraw: a,
                animation: f
              });
            };

            a.prototype.setSubtitle = function (b, a) {
              this.applyDescription("subtitle", b);
              this.layOutTitles(a);
            };

            a.prototype.setCaption = function (b, a) {
              this.applyDescription("caption", b);
              this.layOutTitles(a);
            };

            a.prototype.showResetZoom = function () {
              function b() {
                a.zoomOut();
              }

              var a = this,
                  c = D.lang,
                  f = a.options.chart.resetZoomButton,
                  d = f.theme,
                  k = d.states,
                  h = "chart" === f.relativeTo || "spacingBox" === f.relativeTo ? null : "scrollablePlotBox";
              T(this, "beforeShowResetZoom", null, function () {
                a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, d, k && k.hover).attr({
                  align: f.position.align,
                  title: c.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(f.position, !1, h);
              });
              T(this, "afterShowResetZoom");
            };

            a.prototype.zoomOut = function () {
              T(this, "selection", {
                resetSelection: !0
              }, this.zoom);
            };

            a.prototype.zoom = function (b) {
              var a = this,
                  c = a.pointer,
                  f = a.inverted ? c.mouseDownX : c.mouseDownY,
                  d = !1,
                  k;
              !b || b.resetSelection ? (a.axes.forEach(function (b) {
                k = b.zoom();
              }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
                var h = b.axis,
                    e = a.inverted ? h.left : h.top,
                    n = a.inverted ? e + h.width : e + h.height,
                    l = h.isXAxis,
                    q = !1;
                if (!l && f >= e && f <= n || l || !O(f)) q = !0;
                c[l ? "zoomX" : "zoomY"] && q && (k = h.zoom(b.min, b.max), h.displayBtn && (d = !0));
              });
              var h = a.resetZoomButton;
              d && !h ? a.showResetZoom() : !d && V(h) && (a.resetZoomButton = h.destroy());
              k && a.redraw(U(a.options.chart.animation, b && b.animation, 100 > a.pointCount));
            };

            a.prototype.pan = function (b, a) {
              var c = this,
                  f = c.hoverPoints;
              a = "object" === typeof a ? a : {
                enabled: a,
                type: "x"
              };
              var d = c.options.chart,
                  k = c.options.mapNavigation && c.options.mapNavigation.enabled;
              d && d.panning && (d.panning = a);
              var h = a.type,
                  e;
              T(this, "pan", {
                originalEvent: b
              }, function () {
                f && f.forEach(function (b) {
                  b.setState();
                });
                var a = c.xAxis;
                "xy" === h ? a = a.concat(c.yAxis) : "y" === h && (a = c.yAxis);
                var d = {};
                a.forEach(function (a) {
                  if (a.options.panningEnabled && !a.options.isInternal) {
                    var f = a.horiz,
                        n = b[f ? "chartX" : "chartY"];
                    f = f ? "mouseDownX" : "mouseDownY";
                    var l = c[f],
                        q = a.minPointOffset || 0,
                        t = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,
                        w = a.getExtremes(),
                        p = a.toValue(l - n, !0) + q * t,
                        m = a.toValue(l + a.len - n, !0) - (q * t || a.isXAxis && a.pointRangePadding || 0),
                        g = m < p;
                    t = a.hasVerticalPanning();
                    l = g ? m : p;
                    p = g ? p : m;
                    var u = a.panningState;
                    !t || a.isXAxis || u && !u.isDirty || a.series.forEach(function (b) {
                      var a = b.getProcessedData(!0);
                      a = b.getExtremes(a.yData, !0);
                      u || (u = {
                        startMin: Number.MAX_VALUE,
                        startMax: -Number.MAX_VALUE
                      });
                      Y(a.dataMin) && Y(a.dataMax) && (u.startMin = Math.min(U(b.options.threshold, Infinity), a.dataMin, u.startMin), u.startMax = Math.max(U(b.options.threshold, -Infinity), a.dataMax, u.startMax));
                    });
                    t = Math.min(U(u && u.startMin, w.dataMin), q ? w.min : a.toValue(a.toPixels(w.min) - a.minPixelPadding));
                    m = Math.max(U(u && u.startMax, w.dataMax), q ? w.max : a.toValue(a.toPixels(w.max) + a.minPixelPadding));
                    a.panningState = u;
                    a.isOrdinal || (q = t - l, 0 < q && (p += q, l = t), q = p - m, 0 < q && (p = m, l -= q), a.series.length && l !== w.min && p !== w.max && l >= t && p <= m && (a.setExtremes(l, p, !1, !1, {
                      trigger: "pan"
                    }), c.resetZoomButton || k || l === t || p === m || !h.match("y") || (c.showResetZoom(), a.displayBtn = !1), e = !0), d[f] = n);
                  }
                });
                W(d, function (b, a) {
                  c[a] = b;
                });
                e && c.redraw(!1);
                H(c.container, {
                  cursor: "move"
                });
              });
            };

            return a;
          }();

          P(e.prototype, {
            callbacks: [],
            collectionsWithInit: {
              xAxis: [e.prototype.addAxis, [!0]],
              yAxis: [e.prototype.addAxis, [!1]],
              series: [e.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
          });
          "";
          return e;
        });
        M(g, "Core/Legend/LegendSymbol.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.merge,
              C = e.pick,
              y;

          (function (e) {
            e.drawLineMarker = function (e) {
              var v = this.options,
                  x = e.symbolWidth,
                  r = e.symbolHeight,
                  m = r / 2,
                  d = this.chart.renderer,
                  a = this.legendGroup;
              e = e.baseline - Math.round(.3 * e.fontMetrics.b);
              var p = {},
                  B = v.marker;
              this.chart.styledMode || (p = {
                "stroke-width": v.lineWidth || 0
              }, v.dashStyle && (p.dashstyle = v.dashStyle));
              this.legendLine = d.path([["M", 0, e], ["L", x, e]]).addClass("highcharts-graph").attr(p).add(a);
              B && !1 !== B.enabled && x && (v = Math.min(C(B.radius, m), m), 0 === this.symbol.indexOf("url") && (B = g(B, {
                width: r,
                height: r
              }), v = 0), this.legendSymbol = x = d.symbol(this.symbol, x / 2 - v, e - v, 2 * v, 2 * v, B).addClass("highcharts-point").add(a), x.isMarker = !0);
            };

            e.drawRectangle = function (e, g) {
              var x = e.symbolHeight,
                  r = e.options.squareSymbol;
              g.legendSymbol = this.chart.renderer.rect(r ? (e.symbolWidth - x) / 2 : 0, e.baseline - x + 1, r ? x : e.symbolWidth, x, C(e.options.symbolRadius, x / 2)).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(g.legendGroup);
            };
          })(y || (y = {}));

          return y;
        });
        M(g, "Core/Series/SeriesDefaults.js", [g["Core/Color/Palette.js"]], function (e) {
          return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
              duration: 1E3
            },
            events: {},
            marker: {
              enabledThreshold: 2,
              lineColor: e.backgroundColor,
              lineWidth: 0,
              radius: 4,
              states: {
                normal: {
                  animation: !0
                },
                hover: {
                  animation: {
                    duration: 50
                  },
                  enabled: !0,
                  radiusPlus: 2,
                  lineWidthPlus: 1
                },
                select: {
                  fillColor: e.neutralColor20,
                  lineColor: e.neutralColor100,
                  lineWidth: 2
                }
              }
            },
            point: {
              events: {}
            },
            dataLabels: {
              animation: {},
              align: "center",
              defer: !0,
              formatter: function formatter() {
                var e = this.series.chart.numberFormatter;
                return "number" !== typeof this.y ? "" : e(this.y, -1);
              },
              padding: 5,
              style: {
                fontSize: "11px",
                fontWeight: "bold",
                color: "contrast",
                textOutline: "1px contrast"
              },
              verticalAlign: "bottom",
              x: 0,
              y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                lineWidthPlus: 1,
                marker: {},
                halo: {
                  size: 10,
                  opacity: .25
                }
              },
              select: {
                animation: {
                  duration: 0
                }
              },
              inactive: {
                animation: {
                  duration: 50
                },
                opacity: .2
              }
            },
            stickyTracking: !0,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
          };
        });
        M(g, "Core/Series/Series.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/DefaultOptions.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Color/Palette.js"], g["Core/Series/Point.js"], g["Core/Series/SeriesDefaults.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G, x, r, m, d) {
          var a = e.animObject,
              p = e.setAnimation,
              B = g.defaultOptions,
              l = C.registerEventOptions,
              h = y.hasTouch,
              f = y.svg,
              k = y.win,
              J = r.seriesTypes,
              K = d.addEvent,
              t = d.arrayMax,
              Q = d.arrayMin,
              z = d.clamp,
              A = d.cleanRecursively,
              c = d.correctFloat,
              b = d.defined,
              D = d.erase,
              L = d.error,
              I = d.extend,
              n = d.find,
              u = d.fireEvent,
              N = d.getNestedProperty,
              w = d.isArray,
              H = d.isNumber,
              O = d.isString,
              R = d.merge,
              q = d.objectEach,
              F = d.pick,
              P = d.removeEvent,
              ca = d.splat,
              T = d.syncTimeout;

          e = function () {
            function e() {
              this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }

            e.prototype.init = function (b, a) {
              u(this, "init", {
                options: a
              });
              var c = this,
                  f = b.series;
              this.eventsToUnbind = [];
              c.chart = b;
              c.options = c.setOptions(a);
              a = c.options;
              c.linkedSeries = [];
              c.bindAxes();
              I(c, {
                name: a.name,
                state: "",
                visible: !1 !== a.visible,
                selected: !0 === a.selected
              });
              l(this, a);
              var d = a.events;
              if (d && d.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;
              c.getColor();
              c.getSymbol();
              c.parallelArrays.forEach(function (b) {
                c[b + "Data"] || (c[b + "Data"] = []);
              });
              c.isCartesian && (b.hasCartesianSeries = !0);
              var e;
              f.length && (e = f[f.length - 1]);
              c._i = F(e && e._i, -1) + 1;
              c.opacity = c.options.opacity;
              b.orderSeries(this.insert(f));
              a.dataSorting && a.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(a.data, !1);
              u(this, "afterInit");
            };

            e.prototype.is = function (b) {
              return J[b] && this instanceof J[b];
            };

            e.prototype.insert = function (b) {
              var a = this.options.index,
                  c;

              if (H(a)) {
                for (c = b.length; c--;) {
                  if (a >= F(b[c].options.index, b[c]._i)) {
                    b.splice(c + 1, 0, this);
                    break;
                  }
                }

                -1 === c && b.unshift(this);
                c += 1;
              } else b.push(this);

              return F(c, b.length - 1);
            };

            e.prototype.bindAxes = function () {
              var b = this,
                  a = b.options,
                  c = b.chart,
                  f;
              u(this, "bindAxes", null, function () {
                (b.axisTypes || []).forEach(function (d) {
                  var e = 0;
                  c[d].forEach(function (c) {
                    f = c.options;
                    if (a[d] === e && !f.isInternal || "undefined" !== typeof a[d] && a[d] === f.id || "undefined" === typeof a[d] && 0 === f.index) b.insert(c.series), b[d] = c, c.isDirty = !0;
                    f.isInternal || e++;
                  });
                  b[d] || b.optionalAxis === d || L(18, !0, c);
                });
              });
              u(this, "afterBindAxes");
            };

            e.prototype.updateParallelArrays = function (b, a) {
              var c = b.series,
                  f = arguments,
                  d = H(a) ? function (f) {
                var d = "y" === f && c.toYData ? c.toYData(b) : b[f];
                c[f + "Data"][a] = d;
              } : function (b) {
                Array.prototype[a].apply(c[b + "Data"], Array.prototype.slice.call(f, 2));
              };
              c.parallelArrays.forEach(d);
            };

            e.prototype.hasData = function () {
              return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };

            e.prototype.autoIncrement = function (b) {
              var a = this.options,
                  c = a.pointIntervalUnit,
                  f = a.relativeXValue,
                  d = this.chart.time,
                  e = this.xIncrement,
                  k;
              e = F(e, a.pointStart, 0);
              this.pointInterval = k = F(this.pointInterval, a.pointInterval, 1);
              f && H(b) && (k *= b);
              c && (a = new d.Date(e), "day" === c ? d.set("Date", a, d.get("Date", a) + k) : "month" === c ? d.set("Month", a, d.get("Month", a) + k) : "year" === c && d.set("FullYear", a, d.get("FullYear", a) + k), k = a.getTime() - e);
              if (f && H(b)) return e + k;
              this.xIncrement = e + k;
              return e;
            };

            e.prototype.setDataSortingOptions = function () {
              var a = this.options;
              I(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1
              });
              b(a.pointRange) || (a.pointRange = 1);
            };

            e.prototype.setOptions = function (a) {
              var c = this.chart,
                  f = c.options,
                  d = f.plotOptions,
                  e = c.userOptions || {};
              a = R(a);
              c = c.styledMode;
              var k = {
                plotOptions: d,
                userOptions: a
              };
              u(this, "setOptions", k);
              var h = k.plotOptions[this.type],
                  n = e.plotOptions || {};
              this.userOptions = k.userOptions;
              e = R(h, d.series, e.plotOptions && e.plotOptions[this.type], a);
              this.tooltipOptions = R(B.tooltip, B.plotOptions.series && B.plotOptions.series.tooltip, B.plotOptions[this.type].tooltip, f.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);
              this.stickyTracking = F(a.stickyTracking, n[this.type] && n[this.type].stickyTracking, n.series && n.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);
              null === h.marker && delete e.marker;
              this.zoneAxis = e.zoneAxis;
              d = this.zones = (e.zones || []).slice();
              !e.negativeColor && !e.negativeFillColor || e.zones || (f = {
                value: e[this.zoneAxis + "Threshold"] || e.threshold || 0,
                className: "highcharts-negative"
              }, c || (f.color = e.negativeColor, f.fillColor = e.negativeFillColor), d.push(f));
              d.length && b(d[d.length - 1].value) && d.push(c ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
              u(this, "afterSetOptions", {
                options: e
              });
              return e;
            };

            e.prototype.getName = function () {
              return F(this.options.name, "Series " + (this.index + 1));
            };

            e.prototype.getCyclic = function (a, c, f) {
              var d = this.chart,
                  e = this.userOptions,
                  k = a + "Index",
                  h = a + "Counter",
                  n = f ? f.length : F(d.options.chart[a + "Count"], d[a + "Count"]);

              if (!c) {
                var l = F(e[k], e["_" + k]);
                b(l) || (d.series.length || (d[h] = 0), e["_" + k] = l = d[h] % n, d[h] += 1);
                f && (c = f[l]);
              }

              "undefined" !== typeof l && (this[k] = l);
              this[a] = c;
            };

            e.prototype.getColor = function () {
              this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = v.neutralColor20 : this.getCyclic("color", this.options.color || B.plotOptions[this.type].color, this.chart.options.colors);
            };

            e.prototype.getPointsCollection = function () {
              return (this.hasGroupedData ? this.points : this.data) || [];
            };

            e.prototype.getSymbol = function () {
              this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };

            e.prototype.findPointIndex = function (b, a) {
              var c = b.id,
                  f = b.x,
                  d = this.points,
                  e = this.options.dataSorting,
                  k,
                  h;
              if (c) e = this.chart.get(c), e instanceof G && (k = e);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (k = function k(a) {
                return !a.touched && a.index === b.index;
              }, e && e.matchByName ? k = function k(a) {
                return !a.touched && a.name === b.name;
              } : this.options.relativeXValue && (k = function k(a) {
                return !a.touched && a.options.x === b.x;
              }), k = n(d, k), !k) return;

              if (k) {
                var l = k && k.index;
                "undefined" !== typeof l && (h = !0);
              }

              "undefined" === typeof l && H(f) && (l = this.xData.indexOf(f, a));
              -1 !== l && "undefined" !== typeof l && this.cropped && (l = l >= this.cropStart ? l - this.cropStart : l);
              !h && H(l) && d[l] && d[l].touched && (l = void 0);
              return l;
            };

            e.prototype.updateData = function (a, c) {
              var f = this.options,
                  d = f.dataSorting,
                  e = this.points,
                  k = [],
                  h = this.requireSorting,
                  n = a.length === e.length,
                  l,
                  q,
                  w,
                  p = !0;
              this.xIncrement = null;
              a.forEach(function (a, c) {
                var q = b(a) && this.pointClass.prototype.optionsToObject.call({
                  series: this
                }, a) || {},
                    t = q.x;

                if (q.id || H(t)) {
                  if (q = this.findPointIndex(q, w), -1 === q || "undefined" === typeof q ? k.push(a) : e[q] && a !== f.data[q] ? (e[q].update(a, !1, null, !1), e[q].touched = !0, h && (w = q + 1)) : e[q] && (e[q].touched = !0), !n || c !== q || d && d.enabled || this.hasDerivedData) l = !0;
                } else k.push(a);
              }, this);
              if (l) for (a = e.length; a--;) {
                (q = e[a]) && !q.touched && q.remove && q.remove(!1, c);
              } else !n || d && d.enabled ? p = !1 : (a.forEach(function (b, a) {
                b !== e[a].y && e[a].update && e[a].update(b, !1, null, !1);
              }), k.length = 0);
              e.forEach(function (b) {
                b && (b.touched = !1);
              });
              if (!p) return !1;
              k.forEach(function (b) {
                this.addPoint(b, !1, null, null, !1);
              }, this);
              null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = t(this.xData), this.autoIncrement());
              return !0;
            };

            e.prototype.setData = function (b, a, c, f) {
              var d = this,
                  e = d.points,
                  k = e && e.length || 0,
                  h = d.options,
                  n = d.chart,
                  l = h.dataSorting,
                  q = d.xAxis,
                  t = h.turboThreshold,
                  p = this.xData,
                  m = this.yData,
                  g = d.pointArrayMap;
              g = g && g.length;
              var u = h.keys,
                  r,
                  A = 0,
                  z = 1,
                  D = null;
              b = b || [];
              var N = b.length;
              a = F(a, !0);
              l && l.enabled && (b = this.sortData(b));
              !1 !== f && N && k && !d.cropped && !d.hasGroupedData && d.visible && !d.isSeriesBoosting && (r = this.updateData(b, c));

              if (!r) {
                d.xIncrement = null;
                d.colorCounter = 0;
                this.parallelArrays.forEach(function (b) {
                  d[b + "Data"].length = 0;
                });
                if (t && N > t) {
                  if (D = d.getFirstValidPoint(b), H(D)) for (c = 0; c < N; c++) {
                    p[c] = this.autoIncrement(), m[c] = b[c];
                  } else if (w(D)) {
                    if (g) for (c = 0; c < N; c++) {
                      f = b[c], p[c] = f[0], m[c] = f.slice(1, g + 1);
                    } else for (u && (A = u.indexOf("x"), z = u.indexOf("y"), A = 0 <= A ? A : 0, z = 0 <= z ? z : 1), c = 0; c < N; c++) {
                      f = b[c], p[c] = f[A], m[c] = f[z];
                    }
                  } else L(12, !1, n);
                } else for (c = 0; c < N; c++) {
                  "undefined" !== typeof b[c] && (f = {
                    series: d
                  }, d.pointClass.prototype.applyOptions.apply(f, [b[c]]), d.updateParallelArrays(f, c));
                }
                m && O(m[0]) && L(14, !0, n);
                d.data = [];
                d.options.data = d.userOptions.data = b;

                for (c = k; c--;) {
                  e[c] && e[c].destroy && e[c].destroy();
                }

                q && (q.minRange = q.userMinRange);
                d.isDirty = n.isDirtyBox = !0;
                d.isDirtyData = !!e;
                c = !1;
              }

              "point" === h.legendType && (this.processData(), this.generatePoints());
              a && n.redraw(c);
            };

            e.prototype.sortData = function (a) {
              var c = this,
                  f = c.options.dataSorting.sortKey || "y",
                  d = function d(a, c) {
                return b(c) && a.pointClass.prototype.optionsToObject.call({
                  series: a
                }, c) || {};
              };

              a.forEach(function (b, f) {
                a[f] = d(c, b);
                a[f].index = f;
              }, this);
              a.concat().sort(function (b, a) {
                b = N(f, b);
                a = N(f, a);
                return a < b ? -1 : a > b ? 1 : 0;
              }).forEach(function (b, a) {
                b.x = a;
              }, this);
              c.linkedSeries && c.linkedSeries.forEach(function (b) {
                var c = b.options,
                    f = c.data;
                c.dataSorting && c.dataSorting.enabled || !f || (f.forEach(function (c, e) {
                  f[e] = d(b, c);
                  a[e] && (f[e].x = a[e].x, f[e].index = e);
                }), b.setData(f, !1));
              });
              return a;
            };

            e.prototype.getProcessedData = function (b) {
              var a = this.xAxis,
                  c = this.options,
                  f = c.cropThreshold,
                  d = b || this.getExtremesFromAll || c.getExtremesFromAll,
                  e = this.isCartesian;
              b = a && a.val2lin;
              c = !(!a || !a.logarithmic);
              var k = 0,
                  h = this.xData,
                  n = this.yData,
                  l = this.requireSorting;
              var q = !1;
              var t = h.length;

              if (a) {
                q = a.getExtremes();
                var w = q.min;
                var p = q.max;
                q = a.categories && !a.names.length;
              }

              if (e && this.sorted && !d && (!f || t > f || this.forceCrop)) if (h[t - 1] < w || h[0] > p) h = [], n = [];else if (this.yData && (h[0] < w || h[t - 1] > p)) {
                var m = this.cropData(this.xData, this.yData, w, p);
                h = m.xData;
                n = m.yData;
                k = m.start;
                m = !0;
              }

              for (f = h.length || 1; --f;) {
                if (a = c ? b(h[f]) - b(h[f - 1]) : h[f] - h[f - 1], 0 < a && ("undefined" === typeof g || a < g)) var g = a;else 0 > a && l && !q && (L(15, !1, this.chart), l = !1);
              }

              return {
                xData: h,
                yData: n,
                cropped: m,
                cropStart: k,
                closestPointRange: g
              };
            };

            e.prototype.processData = function (b) {
              var a = this.xAxis;
              if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;
              b = this.getProcessedData();
              this.cropped = b.cropped;
              this.cropStart = b.cropStart;
              this.processedXData = b.xData;
              this.processedYData = b.yData;
              this.closestPointRange = this.basePointRange = b.closestPointRange;
            };

            e.prototype.cropData = function (b, a, c, f, d) {
              var e = b.length,
                  k,
                  h = 0,
                  n = e;
              d = F(d, this.cropShoulder);

              for (k = 0; k < e; k++) {
                if (b[k] >= c) {
                  h = Math.max(0, k - d);
                  break;
                }
              }

              for (c = k; c < e; c++) {
                if (b[c] > f) {
                  n = c + d;
                  break;
                }
              }

              return {
                xData: b.slice(h, n),
                yData: a.slice(h, n),
                start: h,
                end: n
              };
            };

            e.prototype.generatePoints = function () {
              var b = this.options,
                  a = b.data,
                  c = this.processedXData,
                  f = this.processedYData,
                  d = this.pointClass,
                  e = c.length,
                  k = this.cropStart || 0,
                  h = this.hasGroupedData,
                  n = b.keys,
                  l = [];
              b = b.dataGrouping && b.dataGrouping.groupAll ? k : 0;
              var q,
                  t,
                  w = this.data;

              if (!w && !h) {
                var p = [];
                p.length = a.length;
                w = this.data = p;
              }

              n && h && (this.options.keys = !1);

              for (t = 0; t < e; t++) {
                p = k + t;

                if (h) {
                  var m = new d().init(this, [c[t]].concat(ca(f[t])));
                  m.dataGroup = this.groupMap[b + t];
                  m.dataGroup.options && (m.options = m.dataGroup.options, I(m, m.dataGroup.options), delete m.dataLabels);
                } else (m = w[p]) || "undefined" === typeof a[p] || (w[p] = m = new d().init(this, a[p], c[t]));

                m && (m.index = h ? b + t : p, l[t] = m);
              }

              this.options.keys = n;
              if (w && (e !== (q = w.length) || h)) for (t = 0; t < q; t++) {
                t !== k || h || (t += e), w[t] && (w[t].destroyElements(), w[t].plotX = void 0);
              }
              this.data = w;
              this.points = l;
              u(this, "afterGeneratePoints");
            };

            e.prototype.getXExtremes = function (b) {
              return {
                min: Q(b),
                max: t(b)
              };
            };

            e.prototype.getExtremes = function (b, a) {
              var c = this.xAxis,
                  f = this.yAxis,
                  d = this.processedXData || this.xData,
                  e = [],
                  k = this.requireSorting ? this.cropShoulder : 0;
              f = f ? f.positiveValuesOnly : !1;
              var h,
                  n = 0,
                  l = 0,
                  q = 0;
              b = b || this.stackedYData || this.processedYData || [];
              var p = b.length;

              if (c) {
                var m = c.getExtremes();
                n = m.min;
                l = m.max;
              }

              for (h = 0; h < p; h++) {
                var g = d[h];
                m = b[h];
                var r = (H(m) || w(m)) && (m.length || 0 < m || !f);
                g = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (d[h + k] || g) >= n && (d[h - k] || g) <= l;
                if (r && g) if (r = m.length) for (; r--;) {
                  H(m[r]) && (e[q++] = m[r]);
                } else e[q++] = m;
              }

              b = {
                dataMin: Q(e),
                dataMax: t(e)
              };
              u(this, "afterGetExtremes", {
                dataExtremes: b
              });
              return b;
            };

            e.prototype.applyExtremes = function () {
              var b = this.getExtremes();
              this.dataMin = b.dataMin;
              this.dataMax = b.dataMax;
              return b;
            };

            e.prototype.getFirstValidPoint = function (b) {
              for (var a = b.length, c = 0, f = null; null === f && c < a;) {
                f = b[c], c++;
              }

              return f;
            };

            e.prototype.translate = function () {
              this.processedXData || this.processData();
              this.generatePoints();
              var a = this.options,
                  f = a.stacking,
                  d = this.xAxis,
                  e = d.categories,
                  k = this.enabledDataSorting,
                  h = this.yAxis,
                  n = this.points,
                  l = n.length,
                  q = !!this.modifyValue,
                  t = this.pointPlacementToXValue(),
                  p = !!t,
                  m = a.threshold,
                  g = a.startFromThreshold ? m : 0,
                  r = this.zoneAxis || "y",
                  A,
                  D,
                  N = Number.MAX_VALUE;

              for (A = 0; A < l; A++) {
                var B = n[A],
                    O = B.x,
                    J = void 0,
                    I = void 0,
                    R = B.y,
                    Q = B.low,
                    K = f && h.stacking && h.stacking.stacks[(this.negStacks && R < (g ? 0 : m) ? "-" : "") + this.stackKey];
                if (h.positiveValuesOnly && !h.validatePositiveValue(R) || d.positiveValuesOnly && !d.validatePositiveValue(O)) B.isNull = !0;
                B.plotX = D = c(z(d.translate(O, 0, 0, 0, 1, t, "flags" === this.type), -1E5, 1E5));

                if (f && this.visible && K && K[O]) {
                  var x = this.getStackIndicator(x, O, this.index);
                  B.isNull || (J = K[O], I = J.points[x.key]);
                }

                w(I) && (Q = I[0], R = I[1], Q === g && x.key === K[O].base && (Q = F(H(m) && m, h.min)), h.positiveValuesOnly && 0 >= Q && (Q = null), B.total = B.stackTotal = J.total, B.percentage = J.total && B.y / J.total * 100, B.stackY = R, this.irregularWidths || J.setOffset(this.pointXOffset || 0, this.barW || 0));
                B.yBottom = b(Q) ? z(h.translate(Q, 0, 1, 0, 1), -1E5, 1E5) : null;
                q && (R = this.modifyValue(R, B));
                B.plotY = void 0;
                H(R) && (J = h.translate(R, !1, !0, !1, !0), "undefined" !== typeof J && (B.plotY = z(J, -1E5, 1E5)));
                B.isInside = this.isPointInside(B);
                B.clientX = p ? c(d.translate(O, 0, 0, 0, 1, t)) : D;
                B.negative = B[r] < (a[r + "Threshold"] || m || 0);
                B.category = e && "undefined" !== typeof e[B.x] ? e[B.x] : B.x;

                if (!B.isNull && !1 !== B.visible) {
                  "undefined" !== typeof L && (N = Math.min(N, Math.abs(D - L)));
                  var L = D;
                }

                B.zone = this.zones.length && B.getZone();
                !B.graphic && this.group && k && (B.isNew = !0);
              }

              this.closestPointRangePx = N;
              u(this, "afterTranslate");
            };

            e.prototype.getValidPoints = function (b, a, c) {
              var f = this.chart;
              return (b || this.points || []).filter(function (b) {
                return a && !f.isInsidePlot(b.plotX, b.plotY, {
                  inverted: f.inverted
                }) ? !1 : !1 !== b.visible && (c || !b.isNull);
              });
            };

            e.prototype.getClipBox = function (b, a) {
              var c = this.options,
                  f = this.chart,
                  d = f.inverted,
                  e = this.xAxis,
                  k = e && this.yAxis,
                  h = f.options.chart.scrollablePlotArea || {};
              b && !1 === c.clip && k ? b = d ? {
                y: -f.chartWidth + k.len + k.pos,
                height: f.chartWidth,
                width: f.chartHeight,
                x: -f.chartHeight + e.len + e.pos
              } : {
                y: -k.pos,
                height: f.chartHeight,
                width: f.chartWidth,
                x: -e.pos
              } : (b = this.clipBox || f.clipBox, a && (b.width = f.plotSizeX, b.x = (f.scrollablePixelsX || 0) * (h.scrollPositionX || 0)));
              return a ? {
                width: b.width,
                x: b.x
              } : b;
            };

            e.prototype.getSharedClipKey = function (b) {
              if (this.sharedClipKey) return this.sharedClipKey;
              var a = [b && b.duration, b && b.easing, b && b.defer, this.getClipBox(b).height, this.options.xAxis, this.options.yAxis].join();
              if (!1 !== this.options.clip || b) this.sharedClipKey = a;
              return a;
            };

            e.prototype.setClip = function (b) {
              var a = this.chart,
                  c = this.options,
                  f = a.renderer,
                  d = a.inverted,
                  e = this.clipBox,
                  k = this.getClipBox(b),
                  h = this.getSharedClipKey(b),
                  n = a.sharedClips[h],
                  l = a.sharedClips[h + "m"];
              b && (k.width = 0, d && (k.x = a.plotHeight + (!1 !== c.clip ? 0 : a.plotTop)));
              n ? a.hasLoaded || n.attr(k) : (b && (a.sharedClips[h + "m"] = l = f.clipRect(d ? (a.plotSizeX || 0) + 99 : -99, d ? -a.plotLeft : -a.plotTop, 99, d ? a.chartWidth : a.chartHeight)), a.sharedClips[h] = n = f.clipRect(k), n.count = {
                length: 0
              });
              b && !n.count[this.index] && (n.count[this.index] = !0, n.count.length += 1);
              if (!1 !== c.clip || b) this.group.clip(b || e ? n : a.clipRect), this.markerGroup.clip(l);
              b || (n.count[this.index] && (delete n.count[this.index], --n.count.length), 0 === n.count.length && (e || (a.sharedClips[h] = n.destroy()), l && (a.sharedClips[h + "m"] = l.destroy())));
            };

            e.prototype.animate = function (b) {
              var c = this.chart,
                  f = a(this.options.animation),
                  d = this.sharedClipKey;
              if (b) this.setClip(f);else if (d) {
                b = c.sharedClips[d];
                d = c.sharedClips[d + "m"];
                var e = this.getClipBox(f, !0);
                b && b.animate(e, f);
                d && d.animate({
                  width: e.width + 99,
                  x: e.x - (c.inverted ? 0 : 99)
                }, f);
              }
            };

            e.prototype.afterAnimate = function () {
              this.setClip();
              u(this, "afterAnimate");
              this.finishedAnimating = !0;
            };

            e.prototype.drawPoints = function () {
              var b = this.points,
                  a = this.chart,
                  c = this.options.marker,
                  f = this[this.specialGroup] || this.markerGroup,
                  d = this.xAxis,
                  e = F(c.enabled, !d || d.isRadial ? !0 : null, this.closestPointRangePx >= c.enabledThreshold * c.radius),
                  k,
                  h;
              if (!1 !== c.enabled || this._hasPointMarkers) for (k = 0; k < b.length; k++) {
                var n = b[k];
                var l = (h = n.graphic) ? "animate" : "attr";
                var q = n.marker || {};
                var t = !!n.marker;

                if ((e && "undefined" === typeof q.enabled || q.enabled) && !n.isNull && !1 !== n.visible) {
                  var w = F(q.symbol, this.symbol, "rect");
                  var p = this.markerAttribs(n, n.selected && "select");
                  this.enabledDataSorting && (n.startXPos = d.reversed ? -(p.width || 0) : d.width);
                  var m = !1 !== n.isInside;
                  h ? h[m ? "show" : "hide"](m).animate(p) : m && (0 < (p.width || 0) || n.hasImage) && (n.graphic = h = a.renderer.symbol(w, p.x, p.y, p.width, p.height, t ? q : c).add(f), this.enabledDataSorting && a.hasRendered && (h.attr({
                    x: n.startXPos
                  }), l = "animate"));
                  h && "animate" === l && h[m ? "show" : "hide"](m).animate(p);
                  if (h && !a.styledMode) h[l](this.pointAttribs(n, n.selected && "select"));
                  h && h.addClass(n.getClassName(), !0);
                } else h && (n.graphic = h.destroy());
              }
            };

            e.prototype.markerAttribs = function (b, a) {
              var c = this.options,
                  f = c.marker,
                  d = b.marker || {},
                  e = d.symbol || f.symbol,
                  k = F(d.radius, f.radius);
              a && (f = f.states[a], a = d.states && d.states[a], k = F(a && a.radius, f && f.radius, k + (f && f.radiusPlus || 0)));
              b.hasImage = e && 0 === e.indexOf("url");
              b.hasImage && (k = 0);
              b = {
                x: c.crisp ? Math.floor(b.plotX - k) : b.plotX - k,
                y: b.plotY - k
              };
              k && (b.width = b.height = 2 * k);
              return b;
            };

            e.prototype.pointAttribs = function (b, a) {
              var c = this.options.marker,
                  f = b && b.options,
                  d = f && f.marker || {},
                  e = f && f.color,
                  k = b && b.color,
                  h = b && b.zone && b.zone.color,
                  n = this.color;
              b = F(d.lineWidth, c.lineWidth);
              f = 1;
              n = e || h || k || n;
              e = d.fillColor || c.fillColor || n;
              k = d.lineColor || c.lineColor || n;
              a = a || "normal";
              c = c.states[a];
              a = d.states && d.states[a] || {};
              b = F(a.lineWidth, c.lineWidth, b + F(a.lineWidthPlus, c.lineWidthPlus, 0));
              e = a.fillColor || c.fillColor || e;
              k = a.lineColor || c.lineColor || k;
              f = F(a.opacity, c.opacity, f);
              return {
                stroke: k,
                "stroke-width": b,
                fill: e,
                opacity: f
              };
            };

            e.prototype.destroy = function (b) {
              var a = this,
                  c = a.chart,
                  f = /AppleWebKit\/533/.test(k.navigator.userAgent),
                  e = a.data || [],
                  h,
                  n,
                  l,
                  t;
              u(a, "destroy");
              this.removeEvents(b);
              (a.axisTypes || []).forEach(function (b) {
                (t = a[b]) && t.series && (D(t.series, a), t.isDirty = t.forceRedraw = !0);
              });
              a.legendItem && a.chart.legend.destroyItem(a);

              for (n = e.length; n--;) {
                (l = e[n]) && l.destroy && l.destroy();
              }

              a.clips && a.clips.forEach(function (b) {
                return b.destroy();
              });
              d.clearTimeout(a.animationTimeout);
              q(a, function (b, a) {
                b instanceof m && !b.survive && (h = f && "group" === a ? "hide" : "destroy", b[h]());
              });
              c.hoverSeries === a && (c.hoverSeries = void 0);
              D(c.series, a);
              c.orderSeries();
              q(a, function (c, f) {
                b && "hcEvents" === f || delete a[f];
              });
            };

            e.prototype.applyZones = function () {
              var b = this,
                  a = this.chart,
                  c = a.renderer,
                  f = this.zones,
                  d = this.clips || [],
                  e = this.graph,
                  k = this.area,
                  h = Math.max(a.chartWidth, a.chartHeight),
                  n = this[(this.zoneAxis || "y") + "Axis"],
                  l = a.inverted,
                  q,
                  t,
                  w,
                  p,
                  m,
                  g,
                  u,
                  r,
                  H = !1;

              if (f.length && (e || k) && n && "undefined" !== typeof n.min) {
                var A = n.reversed;
                var D = n.horiz;
                e && !this.showLine && e.hide();
                k && k.hide();
                var B = n.getExtremes();
                f.forEach(function (f, N) {
                  q = A ? D ? a.plotWidth : 0 : D ? 0 : n.toPixels(B.min) || 0;
                  q = z(F(t, q), 0, h);
                  t = z(Math.round(n.toPixels(F(f.value, B.max), !0) || 0), 0, h);
                  H && (q = t = n.toPixels(B.max));
                  p = Math.abs(q - t);
                  m = Math.min(q, t);
                  g = Math.max(q, t);
                  n.isXAxis ? (w = {
                    x: l ? g : m,
                    y: 0,
                    width: p,
                    height: h
                  }, D || (w.x = a.plotHeight - w.x)) : (w = {
                    x: 0,
                    y: l ? g : m,
                    width: h,
                    height: p
                  }, D && (w.y = a.plotWidth - w.y));
                  l && c.isVML && (w = n.isXAxis ? {
                    x: 0,
                    y: A ? m : g,
                    height: w.width,
                    width: a.chartWidth
                  } : {
                    x: w.y - a.plotLeft - a.spacingBox.x,
                    y: 0,
                    width: w.height,
                    height: a.chartHeight
                  });
                  d[N] ? d[N].animate(w) : d[N] = c.clipRect(w);
                  u = b["zone-area-" + N];
                  r = b["zone-graph-" + N];
                  e && r && r.clip(d[N]);
                  k && u && u.clip(d[N]);
                  H = f.value > B.max;
                  b.resetZones && 0 === t && (t = void 0);
                });
                this.clips = d;
              } else b.visible && (e && e.show(!0), k && k.show(!0));
            };

            e.prototype.invertGroups = function (b) {
              function a() {
                ["group", "markerGroup"].forEach(function (a) {
                  c[a] && (f.renderer.isVML && c[a].attr({
                    width: c.yAxis.len,
                    height: c.xAxis.len
                  }), c[a].width = c.yAxis.len, c[a].height = c.xAxis.len, c[a].invert(c.isRadialSeries ? !1 : b));
                });
              }

              var c = this,
                  f = c.chart;
              c.xAxis && (c.eventsToUnbind.push(K(f, "resize", a)), a(), c.invertGroups = a);
            };

            e.prototype.plotGroup = function (a, c, f, d, e) {
              var k = this[a],
                  h = !k;
              f = {
                visibility: f,
                zIndex: d || .1
              };
              "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (f.opacity = this.opacity);
              h && (this[a] = k = this.chart.renderer.g().add(e));
              k.addClass("highcharts-" + c + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (b(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (k.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
              k.attr(f)[h ? "attr" : "animate"](this.getPlotBox());
              return k;
            };

            e.prototype.getPlotBox = function () {
              var b = this.chart,
                  a = this.xAxis,
                  c = this.yAxis;
              b.inverted && (a = c, c = this.xAxis);
              return {
                translateX: a ? a.left : b.plotLeft,
                translateY: c ? c.top : b.plotTop,
                scaleX: 1,
                scaleY: 1
              };
            };

            e.prototype.removeEvents = function (b) {
              b || P(this);
              this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
                b();
              }), this.eventsToUnbind.length = 0);
            };

            e.prototype.render = function () {
              var b = this,
                  c = b.chart,
                  f = b.options,
                  d = a(f.animation),
                  e = b.visible ? "inherit" : "hidden",
                  k = f.zIndex,
                  h = b.hasRendered,
                  n = c.seriesGroup,
                  l = c.inverted,
                  q = !b.finishedAnimating && c.renderer.isSVG && d.duration;
              u(this, "render");
              var t = b.plotGroup("group", "series", e, k, n);
              b.markerGroup = b.plotGroup("markerGroup", "markers", e, k, n);
              q && b.animate && b.animate(!0);
              t.inverted = F(b.invertible, b.isCartesian) ? l : !1;
              b.drawGraph && (b.drawGraph(), b.applyZones());
              b.visible && b.drawPoints();
              b.drawDataLabels && b.drawDataLabels();
              b.redrawPoints && b.redrawPoints();
              b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();
              b.invertGroups(l);
              !1 === f.clip || b.sharedClipKey || h || t.clip(c.clipRect);
              q && b.animate && b.animate();
              h || (q && d.defer && (q += d.defer), b.animationTimeout = T(function () {
                b.afterAnimate();
              }, q || 0));
              b.isDirty = !1;
              b.hasRendered = !0;
              u(b, "afterRender");
            };

            e.prototype.redraw = function () {
              var b = this.chart,
                  a = this.isDirty || this.isDirtyData,
                  c = this.group,
                  f = this.xAxis,
                  d = this.yAxis;
              c && (b.inverted && c.attr({
                width: b.plotWidth,
                height: b.plotHeight
              }), c.animate({
                translateX: F(f && f.left, b.plotLeft),
                translateY: F(d && d.top, b.plotTop)
              }));
              this.translate();
              this.render();
              a && delete this.kdTree;
            };

            e.prototype.searchPoint = function (b, a) {
              var c = this.xAxis,
                  f = this.yAxis,
                  d = this.chart.inverted;
              return this.searchKDTree({
                clientX: d ? c.len - b.chartY + c.pos : b.chartX - c.pos,
                plotY: d ? f.len - b.chartX + f.pos : b.chartY - f.pos
              }, a, b);
            };

            e.prototype.buildKDTree = function (b) {
              function a(b, f, d) {
                var e = b && b.length;

                if (e) {
                  var k = c.kdAxisArray[f % d];
                  b.sort(function (b, a) {
                    return b[k] - a[k];
                  });
                  e = Math.floor(e / 2);
                  return {
                    point: b[e],
                    left: a(b.slice(0, e), f + 1, d),
                    right: a(b.slice(e + 1), f + 1, d)
                  };
                }
              }

              this.buildingKdTree = !0;
              var c = this,
                  f = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete c.kdTree;
              T(function () {
                c.kdTree = a(c.getValidPoints(null, !c.directTouch), f, f);
                c.buildingKdTree = !1;
              }, c.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
            };

            e.prototype.searchKDTree = function (a, c, f) {
              function d(a, c, f, l) {
                var q = c.point,
                    t = e.kdAxisArray[f % l],
                    w = q,
                    p = b(a[k]) && b(q[k]) ? Math.pow(a[k] - q[k], 2) : null;
                var m = b(a[h]) && b(q[h]) ? Math.pow(a[h] - q[h], 2) : null;
                m = (p || 0) + (m || 0);
                q.dist = b(m) ? Math.sqrt(m) : Number.MAX_VALUE;
                q.distX = b(p) ? Math.sqrt(p) : Number.MAX_VALUE;
                t = a[t] - q[t];
                m = 0 > t ? "left" : "right";
                p = 0 > t ? "right" : "left";
                c[m] && (m = d(a, c[m], f + 1, l), w = m[n] < w[n] ? m : q);
                c[p] && Math.sqrt(t * t) < w[n] && (a = d(a, c[p], f + 1, l), w = a[n] < w[n] ? a : w);
                return w;
              }

              var e = this,
                  k = this.kdAxisArray[0],
                  h = this.kdAxisArray[1],
                  n = c ? "distX" : "dist";
              c = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              this.kdTree || this.buildingKdTree || this.buildKDTree(f);
              if (this.kdTree) return d(a, this.kdTree, c, c);
            };

            e.prototype.pointPlacementToXValue = function () {
              var b = this.options,
                  a = b.pointRange,
                  c = this.xAxis;
              b = b.pointPlacement;
              "between" === b && (b = c.reversed ? -.5 : .5);
              return H(b) ? b * (a || c.pointRange) : 0;
            };

            e.prototype.isPointInside = function (b) {
              return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= this.yAxis.len && 0 <= b.plotX && b.plotX <= this.xAxis.len;
            };

            e.prototype.drawTracker = function () {
              var b = this,
                  a = b.options,
                  c = a.trackByArea,
                  d = [].concat(c ? b.areaPath : b.graphPath),
                  e = b.chart,
                  k = e.pointer,
                  n = e.renderer,
                  l = e.options.tooltip.snap,
                  q = b.tracker,
                  t = function t(a) {
                if (e.hoverSeries !== b) b.onMouseOver();
              },
                  w = "rgba(192,192,192," + (f ? .0001 : .002) + ")";

              q ? q.attr({
                d: d
              }) : b.graph && (b.tracker = n.path(d).attr({
                visibility: b.visible ? "visible" : "hidden",
                zIndex: 2
              }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), e.styledMode || b.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: w,
                fill: c ? w : "none",
                "stroke-width": b.graph.strokeWidth() + (c ? 0 : 2 * l)
              }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
                if (b && (b.addClass("highcharts-tracker").on("mouseover", t).on("mouseout", function (b) {
                  k.onTrackerMouseOut(b);
                }), a.cursor && !e.styledMode && b.css({
                  cursor: a.cursor
                }), h)) b.on("touchstart", t);
              }));
              u(this, "afterDrawTracker");
            };

            e.prototype.addPoint = function (b, a, c, f, d) {
              var e = this.options,
                  k = this.data,
                  h = this.chart,
                  n = this.xAxis;
              n = n && n.hasNames && n.names;
              var l = e.data,
                  q = this.xData,
                  t;
              a = F(a, !0);
              var w = {
                series: this
              };
              this.pointClass.prototype.applyOptions.apply(w, [b]);
              var m = w.x;
              var p = q.length;
              if (this.requireSorting && m < q[p - 1]) for (t = !0; p && q[p - 1] > m;) {
                p--;
              }
              this.updateParallelArrays(w, "splice", p, 0, 0);
              this.updateParallelArrays(w, p);
              n && w.name && (n[m] = w.name);
              l.splice(p, 0, b);
              t && (this.data.splice(p, 0, null), this.processData());
              "point" === e.legendType && this.generatePoints();
              c && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(w, "shift"), l.shift()));
              !1 !== d && u(this, "addPoint", {
                point: w
              });
              this.isDirtyData = this.isDirty = !0;
              a && h.redraw(f);
            };

            e.prototype.removePoint = function (b, a, c) {
              var f = this,
                  d = f.data,
                  e = d[b],
                  k = f.points,
                  h = f.chart,
                  n = function n() {
                k && k.length === d.length && k.splice(b, 1);
                d.splice(b, 1);
                f.options.data.splice(b, 1);
                f.updateParallelArrays(e || {
                  series: f
                }, "splice", b, 1);
                e && e.destroy();
                f.isDirty = !0;
                f.isDirtyData = !0;
                a && h.redraw();
              };

              p(c, h);
              a = F(a, !0);
              e ? e.firePointEvent("remove", null, n) : n();
            };

            e.prototype.remove = function (b, a, c, f) {
              function d() {
                e.destroy(f);
                k.isDirtyLegend = k.isDirtyBox = !0;
                k.linkSeries();
                F(b, !0) && k.redraw(a);
              }

              var e = this,
                  k = e.chart;
              !1 !== c ? u(e, "remove", null, d) : d();
            };

            e.prototype.update = function (b, a) {
              b = A(b, this.userOptions);
              u(this, "update", {
                options: b
              });
              var c = this,
                  f = c.chart,
                  d = c.userOptions,
                  e = c.initialType || c.type,
                  k = f.options.plotOptions,
                  h = J[e].prototype,
                  n = c.finishedAnimating && {
                animation: !1
              },
                  l = {},
                  q,
                  t = ["eventOptions", "navigatorSeries", "baseSeries"],
                  w = b.type || d.type || f.options.chart.type,
                  p = !(this.hasDerivedData || w && w !== this.type || "undefined" !== typeof b.pointStart || "undefined" !== typeof b.pointInterval || "undefined" !== typeof b.relativeXValue || c.hasOptionChanged("dataGrouping") || c.hasOptionChanged("pointStart") || c.hasOptionChanged("pointInterval") || c.hasOptionChanged("pointIntervalUnit") || c.hasOptionChanged("keys"));
              w = w || e;
              p && (t.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== b.visible && t.push("area", "graph"), c.parallelArrays.forEach(function (b) {
                t.push(b + "Data");
              }), b.data && (b.dataSorting && I(c.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));
              b = R(d, n, {
                index: "undefined" === typeof d.index ? c.index : d.index,
                pointStart: F(k && k.series && k.series.pointStart, d.pointStart, c.xData[0])
              }, !p && {
                data: c.options.data
              }, b);
              p && b.data && (b.data = c.options.data);
              t = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(t);
              t.forEach(function (b) {
                t[b] = c[b];
                delete c[b];
              });
              k = !1;

              if (J[w]) {
                if (k = w !== c.type, c.remove(!1, !1, !1, !0), k) if (Object.setPrototypeOf) Object.setPrototypeOf(c, J[w].prototype);else {
                  n = Object.hasOwnProperty.call(c, "hcEvents") && c.hcEvents;

                  for (q in h) {
                    c[q] = void 0;
                  }

                  I(c, J[w].prototype);
                  n ? c.hcEvents = n : delete c.hcEvents;
                }
              } else L(17, !0, f, {
                missingModuleFor: w
              });

              t.forEach(function (b) {
                c[b] = t[b];
              });
              c.init(f, b);

              if (p && this.points) {
                var m = c.options;
                !1 === m.visible ? (l.graphic = 1, l.dataLabel = 1) : c._hasPointLabels || (b = m.marker, h = m.dataLabels, !b || !1 !== b.enabled && (d.marker && d.marker.symbol) === b.symbol || (l.graphic = 1), h && !1 === h.enabled && (l.dataLabel = 1));
                this.points.forEach(function (b) {
                  b && b.series && (b.resolveColor(), Object.keys(l).length && b.destroyElements(l), !1 === m.showInLegend && b.legendItem && f.legend.destroyItem(b));
                }, this);
              }

              c.initialType = e;
              f.linkSeries();
              k && c.linkedSeries.length && (c.isDirtyData = !0);
              u(this, "afterUpdate");
              F(a, !0) && f.redraw(p ? void 0 : !1);
            };

            e.prototype.setName = function (b) {
              this.name = this.options.name = this.userOptions.name = b;
              this.chart.isDirtyLegend = !0;
            };

            e.prototype.hasOptionChanged = function (b) {
              var a = this.options[b],
                  c = this.chart.options.plotOptions,
                  f = this.userOptions[b];
              return f ? a !== f : a !== F(c && c[this.type] && c[this.type][b], c && c.series && c.series[b], a);
            };

            e.prototype.onMouseOver = function () {
              var b = this.chart,
                  a = b.hoverSeries;
              b.pointer.setHoverChartIndex();
              if (a && a !== this) a.onMouseOut();
              this.options.events.mouseOver && u(this, "mouseOver");
              this.setState("hover");
              b.hoverSeries = this;
            };

            e.prototype.onMouseOut = function () {
              var b = this.options,
                  a = this.chart,
                  c = a.tooltip,
                  f = a.hoverPoint;
              a.hoverSeries = null;
              if (f) f.onMouseOut();
              this && b.events.mouseOut && u(this, "mouseOut");
              !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
              a.series.forEach(function (b) {
                b.setState("", !0);
              });
            };

            e.prototype.setState = function (b, a) {
              var c = this,
                  f = c.options,
                  d = c.graph,
                  e = f.inactiveOtherPoints,
                  k = f.states,
                  h = F(k[b || "normal"] && k[b || "normal"].animation, c.chart.options.chart.animation),
                  n = f.lineWidth,
                  l = 0,
                  q = f.opacity;
              b = b || "";

              if (c.state !== b && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (a) {
                a && (c.state && a.removeClass("highcharts-series-" + c.state), b && a.addClass("highcharts-series-" + b));
              }), c.state = b, !c.chart.styledMode)) {
                if (k[b] && !1 === k[b].enabled) return;
                b && (n = k[b].lineWidth || n + (k[b].lineWidthPlus || 0), q = F(k[b].opacity, q));
                if (d && !d.dashstyle) for (f = {
                  "stroke-width": n
                }, d.animate(f, h); c["zone-graph-" + l];) {
                  c["zone-graph-" + l].animate(f, h), l += 1;
                }
                e || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (b) {
                  b && b.animate({
                    opacity: q
                  }, h);
                });
              }

              a && e && c.points && c.setAllPointsToState(b || void 0);
            };

            e.prototype.setAllPointsToState = function (b) {
              this.points.forEach(function (a) {
                a.setState && a.setState(b);
              });
            };

            e.prototype.setVisible = function (b, a) {
              var c = this,
                  f = c.chart,
                  d = c.legendItem,
                  e = f.options.chart.ignoreHiddenSeries,
                  k = c.visible,
                  h = (c.visible = b = c.options.visible = c.userOptions.visible = "undefined" === typeof b ? !k : b) ? "show" : "hide";
              ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
                if (c[b]) c[b][h]();
              });
              if (f.hoverSeries === c || (f.hoverPoint && f.hoverPoint.series) === c) c.onMouseOut();
              d && f.legend.colorizeItem(c, b);
              c.isDirty = !0;
              c.options.stacking && f.series.forEach(function (b) {
                b.options.stacking && b.visible && (b.isDirty = !0);
              });
              c.linkedSeries.forEach(function (a) {
                a.setVisible(b, !1);
              });
              e && (f.isDirtyBox = !0);
              u(c, h);
              !1 !== a && f.redraw();
            };

            e.prototype.show = function () {
              this.setVisible(!0);
            };

            e.prototype.hide = function () {
              this.setVisible(!1);
            };

            e.prototype.select = function (b) {
              this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
              this.checkbox && (this.checkbox.checked = b);
              u(this, b ? "select" : "unselect");
            };

            e.prototype.shouldShowTooltip = function (b, a, c) {
              void 0 === c && (c = {});
              c.series = this;
              c.visiblePlotOnly = !0;
              return this.chart.isInsidePlot(b, a, c);
            };

            e.defaultOptions = x;
            return e;
          }();

          I(e.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: E.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: G,
            requireSorting: !0,
            sorted: !0
          });
          r.series = e;
          "";
          "";
          return e;
        });
        M(g, "Extensions/ScrollablePlotArea.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Series/Series.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v) {
          var G = e.stop,
              x = v.addEvent,
              r = v.createElement,
              m = v.merge,
              d = v.pick;
          x(C, "afterSetChartSize", function (a) {
            var d = this.options.chart.scrollablePlotArea,
                e = d && d.minWidth;
            d = d && d.minHeight;

            if (!this.renderer.forExport) {
              if (e) {
                if (this.scrollablePixelsX = e = Math.max(0, e - this.chartWidth)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox);
                  this.plotBox.width = this.plotWidth += e;
                  this.inverted ? this.clipBox.height += e : this.clipBox.width += e;
                  var l = {
                    1: {
                      name: "right",
                      value: e
                    }
                  };
                }
              } else d && (this.scrollablePixelsY = e = Math.max(0, d - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = m(this.plotBox), this.plotBox.height = this.plotHeight += e, this.inverted ? this.clipBox.width += e : this.clipBox.height += e, l = {
                2: {
                  name: "bottom",
                  value: e
                }
              });

              l && !a.skipAxes && this.axes.forEach(function (a) {
                l[a.side] ? a.getPlotLinePath = function () {
                  var f = l[a.side].name,
                      d = this[f];
                  this[f] = d - l[a.side].value;
                  var e = g.prototype.getPlotLinePath.apply(this, arguments);
                  this[f] = d;
                  return e;
                } : (a.setAxisSize(), a.setAxisTranslation());
              });
            }
          });
          x(C, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });

          C.prototype.setUpScrolling = function () {
            var a = this,
                d = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            this.scrollablePixelsX && (d.overflowX = "auto");
            this.scrollablePixelsY && (d.overflowY = "auto");
            this.scrollingParent = r("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = r("div", {
              className: "highcharts-scrolling"
            }, d, this.scrollingParent);
            x(this.scrollingContainer, "scroll", function () {
              a.pointer && delete a.pointer.chartPosition;
            });
            this.innerContainer = r("div", {
              className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };

          C.prototype.moveFixedElements = function () {
            var a = this.container,
                d = this.fixedRenderer,
                e = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
                l;
            this.scrollablePixelsX && !this.inverted ? l = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? l = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? l = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (l = ".highcharts-yaxis");
            l && e.push(l + ":not(.highcharts-radial-axis)", l + "-labels:not(.highcharts-radial-axis-labels)");
            e.forEach(function (e) {
              [].forEach.call(a.querySelectorAll(e), function (a) {
                (a.namespaceURI === d.SVG_NS ? d.box : d.box.parentNode).appendChild(a);
                a.style.pointerEvents = "auto";
              });
            });
          };

          C.prototype.applyFixed = function () {
            var a = !this.fixedDiv,
                e = this.options.chart,
                m = e.scrollablePlotArea,
                l = E.getRendererType();
            a ? (this.fixedDiv = r("div", {
              className: "highcharts-fixed"
            }, {
              position: "absolute",
              overflow: "hidden",
              pointerEvents: "none",
              zIndex: (e.style && e.style.zIndex || 0) + 2,
              top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = e = new l(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = e.path().attr({
              fill: this.options.chart.backgroundColor || "#fff",
              "fill-opacity": d(m.opacity, .85),
              zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), x(this, "afterShowResetZoom", this.moveFixedElements), x(this, "afterDrilldown", this.moveFixedElements), x(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
            e = this.chartWidth + (this.scrollablePixelsX || 0);
            l = this.chartHeight + (this.scrollablePixelsY || 0);
            G(this.container);
            this.container.style.width = e + "px";
            this.container.style.height = l + "px";
            this.renderer.boxWrapper.attr({
              width: e,
              height: l,
              viewBox: [0, 0, e, l].join(" ")
            });
            this.chartBackground.attr({
              width: e,
              height: l
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            a && (m.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * m.scrollPositionX), m.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * m.scrollPositionY));
            l = this.axisOffset;
            a = this.plotTop - l[0] - 1;
            m = this.plotLeft - l[3] - 1;
            e = this.plotTop + this.plotHeight + l[2] + 1;
            l = this.plotLeft + this.plotWidth + l[1] + 1;
            var h = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                f = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, e], ["L", 0, e], ["Z"], ["M", h, a], ["L", this.chartWidth, a], ["L", this.chartWidth, e], ["L", h, e], ["Z"]] : this.scrollablePixelsY ? [["M", m, 0], ["L", m, this.plotTop - 1], ["L", l, this.plotTop - 1], ["L", l, 0], ["Z"], ["M", m, f], ["L", m, this.chartHeight], ["L", l, this.chartHeight], ["L", l, f], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
              d: a
            });
          };

          x(g, "afterInit", function () {
            this.chart.scrollableDirty = !0;
          });
          x(y, "show", function () {
            this.chart.scrollableDirty = !0;
          });
          "";
        });
        M(g, "Core/Axis/StackingAxis.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = e.getDeferredAnimation,
              E = C.addEvent,
              v = C.destroyObjectProperties,
              G = C.fireEvent,
              x = C.isNumber,
              r = C.objectEach,
              m;

          (function (d) {
            function a() {
              var a = this.stacking;

              if (a) {
                var f = a.stacks;
                r(f, function (a, d) {
                  v(a);
                  f[d] = null;
                });
                a && a.stackTotalGroup && a.stackTotalGroup.destroy();
              }
            }

            function e() {
              this.stacking || (this.stacking = new l(this));
            }

            var m = [];

            d.compose = function (d) {
              -1 === m.indexOf(d) && (m.push(d), E(d, "init", e), E(d, "destroy", a));
              return d;
            };

            var l = function () {
              function a(a) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = a;
              }

              a.prototype.buildStacks = function () {
                var a = this.axis,
                    d = a.series,
                    e = a.options.reversedStacks,
                    h = d.length,
                    l;

                if (!a.isXAxis) {
                  this.usePercentage = !1;

                  for (l = h; l--;) {
                    var m = d[e ? l : h - l - 1];
                    m.setStackedPoints();
                    m.setGroupedPoints();
                  }

                  for (l = 0; l < h; l++) {
                    d[l].modifyStacks();
                  }

                  G(a, "afterBuildStacks");
                }
              };

              a.prototype.cleanStacks = function () {
                if (!this.axis.isXAxis) {
                  if (this.oldStacks) var a = this.stacks = this.oldStacks;
                  r(a, function (a) {
                    r(a, function (a) {
                      a.cumulative = a.total;
                    });
                  });
                }
              };

              a.prototype.resetStacks = function () {
                var a = this,
                    d = a.stacks;
                a.axis.isXAxis || r(d, function (f) {
                  r(f, function (d, e) {
                    x(d.touched) && d.touched < a.stacksTouched ? (d.destroy(), delete f[e]) : (d.total = null, d.cumulative = null);
                  });
                });
              };

              a.prototype.renderStackTotals = function () {
                var a = this.axis,
                    d = a.chart,
                    e = d.renderer,
                    h = this.stacks;
                a = y(d, a.options.stackLabels && a.options.stackLabels.animation || !1);
                var l = this.stackTotalGroup = this.stackTotalGroup || e.g("stack-labels").attr({
                  visibility: "visible",
                  zIndex: 6,
                  opacity: 0
                }).add();
                l.translate(d.plotLeft, d.plotTop);
                r(h, function (a) {
                  r(a, function (a) {
                    a.render(l);
                  });
                });
                l.animate({
                  opacity: 1
                }, a);
              };

              return a;
            }();

            d.Additions = l;
          })(m || (m = {}));

          return m;
        });
        M(g, "Extensions/Stacking.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Series/Series.js"], g["Core/Axis/StackingAxis.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G) {
          var x = C.format,
              r = G.correctFloat,
              m = G.defined,
              d = G.destroyObjectProperties,
              a = G.isArray,
              p = G.isNumber,
              B = G.objectEach,
              l = G.pick,
              h = function () {
            function a(a, f, d, e, h) {
              var k = a.chart.inverted;
              this.axis = a;
              this.isNegative = d;
              this.options = f = f || {};
              this.x = e;
              this.total = null;
              this.points = {};
              this.hasValidPoints = !1;
              this.stack = h;
              this.rightCliff = this.leftCliff = 0;
              this.alignOptions = {
                align: f.align || (k ? d ? "left" : "right" : "center"),
                verticalAlign: f.verticalAlign || (k ? "middle" : d ? "bottom" : "top"),
                y: f.y,
                x: f.x
              };
              this.textAlign = f.textAlign || (k ? d ? "right" : "left" : "center");
            }

            a.prototype.destroy = function () {
              d(this, this.axis);
            };

            a.prototype.render = function (a) {
              var f = this.axis.chart,
                  d = this.options,
                  e = d.format;
              e = e ? x(e, this, f) : d.formatter.call(this);
              this.label ? this.label.attr({
                text: e,
                visibility: "hidden"
              }) : (this.label = f.renderer.label(e, null, null, d.shape, null, null, d.useHTML, !1, "stack-labels"), e = {
                r: d.borderRadius || 0,
                text: e,
                rotation: d.rotation,
                padding: l(d.padding, 5),
                visibility: "hidden"
              }, f.styledMode || (e.fill = d.backgroundColor, e.stroke = d.borderColor, e["stroke-width"] = d.borderWidth, this.label.css(d.style)), this.label.attr(e), this.label.added || this.label.add(a));
              this.label.labelrank = f.plotSizeY;
            };

            a.prototype.setOffset = function (a, f, d, e, h) {
              var k = this.axis,
                  t = k.chart;
              e = k.translate(k.stacking.usePercentage ? 100 : e ? e : this.total, 0, 0, 0, 1);
              d = k.translate(d ? d : 0);
              d = m(e) && Math.abs(e - d);
              a = l(h, t.xAxis[0].translate(this.x)) + a;
              k = m(e) && this.getStackBox(t, this, a, e, f, d, k);
              f = this.label;
              d = this.isNegative;
              a = "justify" === l(this.options.overflow, "justify");
              var c = this.textAlign;
              f && k && (h = f.getBBox(), e = f.padding, c = "left" === c ? t.inverted ? -e : e : "right" === c ? h.width : t.inverted && "center" === c ? h.width / 2 : t.inverted ? d ? h.width + e : -e : h.width / 2, d = t.inverted ? h.height / 2 : d ? -e : h.height, this.alignOptions.x = l(this.options.x, 0), this.alignOptions.y = l(this.options.y, 0), k.x -= c, k.y -= d, f.align(this.alignOptions, null, k), t.isInsidePlot(f.alignAttr.x + c - this.alignOptions.x, f.alignAttr.y + d - this.alignOptions.y) ? f.show() : (f.alignAttr.y = -9999, a = !1), a && E.prototype.justifyDataLabel.call(this.axis, f, this.alignOptions, f.alignAttr, h, k), f.attr({
                x: f.alignAttr.x,
                y: f.alignAttr.y
              }), l(!a && this.options.crop, !0) && ((t = p(f.x) && p(f.y) && t.isInsidePlot(f.x - e + f.width, f.y) && t.isInsidePlot(f.x + e, f.y)) || f.hide()));
            };

            a.prototype.getStackBox = function (a, f, d, e, h, l, m) {
              var c = f.axis.reversed,
                  b = a.inverted,
                  k = m.height + m.pos - (b ? a.plotLeft : a.plotTop);
              f = f.isNegative && !c || !f.isNegative && c;
              return {
                x: b ? f ? e - m.right : e - l + m.pos - a.plotLeft : d + a.xAxis[0].transB - a.plotLeft,
                y: b ? m.height - d - h : f ? k - e - l : k - e,
                width: b ? l : h,
                height: b ? h : l
              };
            };

            return a;
          }();

          g.prototype.getStacks = function () {
            var a = this,
                d = a.inverted;
            a.yAxis.forEach(function (a) {
              a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
            });
            a.series.forEach(function (f) {
              var e = f.xAxis && f.xAxis.options || {};
              !f.options.stacking || !0 !== f.visible && !1 !== a.options.chart.ignoreHiddenSeries || (f.stackKey = [f.type, l(f.options.stack, ""), d ? e.top : e.left, d ? e.height : e.width].join());
            });
          };

          v.compose(e);

          E.prototype.setGroupedPoints = function () {
            var a = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? E.prototype.setStackedPoints.call(this, "group") : a && B(a.stacks, function (f, d) {
              "group" === d.slice(-5) && (B(f, function (a) {
                return a.destroy();
              }), delete a.stacks[d]);
            });
          };

          E.prototype.setStackedPoints = function (f) {
            var d = f || this.options.stacking;

            if (d && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
              var e = this.processedXData,
                  p = this.processedYData,
                  t = [],
                  g = p.length,
                  z = this.options,
                  A = z.threshold,
                  c = l(z.startFromThreshold && A, 0);
              z = z.stack;
              f = f ? this.type + "," + d : this.stackKey;
              var b = "-" + f,
                  D = this.negStacks,
                  B = this.yAxis,
                  I = B.stacking.stacks,
                  n = B.stacking.oldStacks,
                  u,
                  N;
              B.stacking.stacksTouched += 1;

              for (N = 0; N < g; N++) {
                var w = e[N];
                var H = p[N];
                var O = this.getStackIndicator(O, w, this.index);
                var R = O.key;
                var q = (u = D && H < (c ? 0 : A)) ? b : f;
                I[q] || (I[q] = {});
                I[q][w] || (n[q] && n[q][w] ? (I[q][w] = n[q][w], I[q][w].total = null) : I[q][w] = new h(B, B.options.stackLabels, u, w, z));
                q = I[q][w];
                null !== H ? (q.points[R] = q.points[this.index] = [l(q.cumulative, c)], m(q.cumulative) || (q.base = R), q.touched = B.stacking.stacksTouched, 0 < O.index && !1 === this.singleStacks && (q.points[R][0] = q.points[this.index + "," + w + ",0"][0])) : q.points[R] = q.points[this.index] = null;
                "percent" === d ? (u = u ? f : b, D && I[u] && I[u][w] ? (u = I[u][w], q.total = u.total = Math.max(u.total, q.total) + Math.abs(H) || 0) : q.total = r(q.total + (Math.abs(H) || 0))) : "group" === d ? (a(H) && (H = H[0]), null !== H && (q.total = (q.total || 0) + 1)) : q.total = r(q.total + (H || 0));
                q.cumulative = "group" === d ? (q.total || 1) - 1 : l(q.cumulative, c) + (H || 0);
                null !== H && (q.points[R].push(q.cumulative), t[N] = q.cumulative, q.hasValidPoints = !0);
              }

              "percent" === d && (B.stacking.usePercentage = !0);
              "group" !== d && (this.stackedYData = t);
              B.stacking.oldStacks = {};
            }
          };

          E.prototype.modifyStacks = function () {
            var a = this,
                d = a.stackKey,
                e = a.yAxis.stacking.stacks,
                h = a.processedXData,
                l,
                m = a.options.stacking;
            a[m + "Stacker"] && [d, "-" + d].forEach(function (f) {
              for (var d = h.length, c, b; d--;) {
                if (c = h[d], l = a.getStackIndicator(l, c, a.index, f), b = (c = e[f] && e[f][c]) && c.points[l.key]) a[m + "Stacker"](b, c, d);
              }
            });
          };

          E.prototype.percentStacker = function (a, d, e) {
            d = d.total ? 100 / d.total : 0;
            a[0] = r(a[0] * d);
            a[1] = r(a[1] * d);
            this.stackedYData[e] = a[1];
          };

          E.prototype.getStackIndicator = function (a, d, e, h) {
            !m(a) || a.x !== d || h && a.key !== h ? a = {
              x: d,
              index: 0,
              key: h
            } : a.index++;
            a.key = [e, d, a.index].join();
            return a;
          };

          y.StackItem = h;
          "";
          return y.StackItem;
        });
        M(g, "Series/Line/LineSeries.js", [g["Core/Color/Palette.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var E = this && this.__extends || function () {
            var _e2 = function e(g, m) {
              _e2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, a) {
                d.__proto__ = a;
              } || function (d, a) {
                for (var e in a) {
                  a.hasOwnProperty(e) && (d[e] = a[e]);
                }
              };

              return _e2(g, m);
            };

            return function (g, m) {
              function d() {
                this.constructor = g;
              }

              _e2(g, m);

              g.prototype = null === m ? Object.create(m) : (d.prototype = m.prototype, new d());
            };
          }(),
              v = y.defined,
              G = y.merge;

          y = function (x) {
            function r() {
              var e = null !== x && x.apply(this, arguments) || this;
              e.data = void 0;
              e.options = void 0;
              e.points = void 0;
              return e;
            }

            E(r, x);

            r.prototype.drawGraph = function () {
              var m = this,
                  d = this.options,
                  a = (this.gappedPath || this.getGraphPath).call(this),
                  p = this.chart.styledMode,
                  g = [["graph", "highcharts-graph"]];
              p || g[0].push(d.lineColor || this.color || e.neutralColor20, d.dashStyle);
              g = m.getZonesGraphs(g);
              g.forEach(function (e, h) {
                var f = e[0],
                    k = m[f],
                    l = k ? "animate" : "attr";
                k ? (k.endX = m.preventGraphAnimation ? null : a.xMap, k.animate({
                  d: a
                })) : a.length && (m[f] = k = m.chart.renderer.path(a).addClass(e[1]).attr({
                  zIndex: 1
                }).add(m.group));
                k && !p && (f = {
                  stroke: e[2],
                  "stroke-width": d.lineWidth,
                  fill: m.fillGraph && m.color || "none"
                }, e[3] ? f.dashstyle = e[3] : "square" !== d.linecap && (f["stroke-linecap"] = f["stroke-linejoin"] = "round"), k[l](f).shadow(2 > h && d.shadow));
                k && (k.startX = a.xMap, k.isArea = a.isArea);
              });
            };

            r.prototype.getGraphPath = function (e, d, a) {
              var m = this,
                  g = m.options,
                  l = [],
                  h = [],
                  f,
                  k = g.step;
              e = e || m.points;
              var r = e.reversed;
              r && e.reverse();
              (k = {
                right: 1,
                center: 2
              }[k] || k && 3) && r && (k = 4 - k);
              e = this.getValidPoints(e, !1, !(g.connectNulls && !d && !a));
              e.forEach(function (p, t) {
                var r = p.plotX,
                    z = p.plotY,
                    A = e[t - 1];
                (p.leftCliff || A && A.rightCliff) && !a && (f = !0);
                p.isNull && !v(d) && 0 < t ? f = !g.connectNulls : p.isNull && !d ? f = !0 : (0 === t || f ? t = [["M", p.plotX, p.plotY]] : m.getPointSpline ? t = [m.getPointSpline(e, p, t)] : k ? (t = 1 === k ? [["L", A.plotX, z]] : 2 === k ? [["L", (A.plotX + r) / 2, A.plotY], ["L", (A.plotX + r) / 2, z]] : [["L", r, A.plotY]], t.push(["L", r, z])) : t = [["L", r, z]], h.push(p.x), k && (h.push(p.x), 2 === k && h.push(p.x)), l.push.apply(l, t), f = !1);
              });
              l.xMap = h;
              return m.graphPath = l;
            };

            r.prototype.getZonesGraphs = function (e) {
              this.zones.forEach(function (d, a) {
                a = ["zone-graph-" + a, "highcharts-graph highcharts-zone-graph-" + a + " " + (d.className || "")];
                this.chart.styledMode || a.push(d.color || this.color, d.dashStyle || this.options.dashStyle);
                e.push(a);
              }, this);
              return e;
            };

            r.defaultOptions = G(g.defaultOptions, {});
            return r;
          }(g);

          C.registerSeriesType("line", y);
          "";
          return y;
        });
        M(g, "Series/Area/AreaSeries.js", [g["Core/Color/Color.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var E = this && this.__extends || function () {
            var _d3 = function d(a, e) {
              _d3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var e in d) {
                  d.hasOwnProperty(e) && (a[e] = d[e]);
                }
              };

              return _d3(a, e);
            };

            return function (a, e) {
              function m() {
                this.constructor = a;
              }

              _d3(a, e);

              a.prototype = null === e ? Object.create(e) : (m.prototype = e.prototype, new m());
            };
          }(),
              v = e.parse,
              G = C.seriesTypes.line;

          e = y.extend;
          var x = y.merge,
              r = y.objectEach,
              m = y.pick;

          y = function (d) {
            function a() {
              var a = null !== d && d.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            E(a, d);

            a.prototype.drawGraph = function () {
              this.areaPath = [];
              d.prototype.drawGraph.apply(this);
              var a = this,
                  e = this.areaPath,
                  l = this.options,
                  h = [["area", "highcharts-area", this.color, l.fillColor]];
              this.zones.forEach(function (d, e) {
                h.push(["zone-area-" + e, "highcharts-area highcharts-zone-area-" + e + " " + d.className, d.color || a.color, d.fillColor || l.fillColor]);
              });
              h.forEach(function (d) {
                var f = d[0],
                    h = a[f],
                    g = h ? "animate" : "attr",
                    t = {};
                h ? (h.endX = a.preventGraphAnimation ? null : e.xMap, h.animate({
                  d: e
                })) : (t.zIndex = 0, h = a[f] = a.chart.renderer.path(e).addClass(d[1]).add(a.group), h.isArea = !0);
                a.chart.styledMode || (t.fill = m(d[3], v(d[2]).setOpacity(m(l.fillOpacity, .75)).get()));
                h[g](t);
                h.startX = e.xMap;
                h.shiftUnit = l.step ? 2 : 1;
              });
            };

            a.prototype.getGraphPath = function (a) {
              var d = G.prototype.getGraphPath,
                  e = this.options,
                  h = e.stacking,
                  f = this.yAxis,
                  k,
                  g = [],
                  p = [],
                  t = this.index,
                  r = f.stacking.stacks[this.stackKey],
                  z = e.threshold,
                  A = Math.round(f.getThreshold(e.threshold));
              e = m(e.connectNulls, "percent" === h);

              var c = function c(b, _c15, d) {
                var e = a[b];
                b = h && r[e.x].points[t];
                var k = e[d + "Null"] || 0;
                d = e[d + "Cliff"] || 0;
                e = !0;

                if (d || k) {
                  var n = (k ? b[0] : b[1]) + d;
                  var l = b[0] + d;
                  e = !!k;
                } else !h && a[_c15] && a[_c15].isNull && (n = l = z);

                "undefined" !== typeof n && (p.push({
                  plotX: D,
                  plotY: null === n ? A : f.getThreshold(n),
                  isNull: e,
                  isCliff: !0
                }), g.push({
                  plotX: D,
                  plotY: null === l ? A : f.getThreshold(l),
                  doCurve: !1
                }));
              };

              a = a || this.points;
              h && (a = this.getStackPoints(a));

              for (k = 0; k < a.length; k++) {
                h || (a[k].leftCliff = a[k].rightCliff = a[k].leftNull = a[k].rightNull = void 0);
                var b = a[k].isNull;
                var D = m(a[k].rectPlotX, a[k].plotX);
                var x = h ? m(a[k].yBottom, A) : A;
                if (!b || e) e || c(k, k - 1, "left"), b && !h && e || (p.push(a[k]), g.push({
                  x: k,
                  plotX: D,
                  plotY: x
                })), e || c(k, k + 1, "right");
              }

              k = d.call(this, p, !0, !0);
              g.reversed = !0;
              b = d.call(this, g, !0, !0);
              (x = b[0]) && "M" === x[0] && (b[0] = ["L", x[1], x[2]]);
              b = k.concat(b);
              b.length && b.push(["Z"]);
              d = d.call(this, p, !1, e);
              b.xMap = k.xMap;
              this.areaPath = b;
              return d;
            };

            a.prototype.getStackPoints = function (a) {
              var d = this,
                  e = [],
                  h = [],
                  f = this.xAxis,
                  k = this.yAxis,
                  g = k.stacking.stacks[this.stackKey],
                  p = {},
                  t = k.series,
                  x = t.length,
                  z = k.options.reversedStacks ? 1 : -1,
                  A = t.indexOf(d);
              a = a || this.points;

              if (this.options.stacking) {
                for (var c = 0; c < a.length; c++) {
                  a[c].leftNull = a[c].rightNull = void 0, p[a[c].x] = a[c];
                }

                r(g, function (b, a) {
                  null !== b.total && h.push(a);
                });
                h.sort(function (b, a) {
                  return b - a;
                });
                var b = t.map(function (b) {
                  return b.visible;
                });
                h.forEach(function (a, c) {
                  var l = 0,
                      n,
                      u;
                  if (p[a] && !p[a].isNull) e.push(p[a]), [-1, 1].forEach(function (f) {
                    var e = 1 === f ? "rightNull" : "leftNull",
                        k = 0,
                        l = g[h[c + f]];
                    if (l) for (var q = A; 0 <= q && q < x;) {
                      var w = t[q].index;
                      n = l.points[w];
                      n || (w === d.index ? p[a][e] = !0 : b[q] && (u = g[a].points[w]) && (k -= u[1] - u[0]));
                      q += z;
                    }
                    p[a][1 === f ? "rightCliff" : "leftCliff"] = k;
                  });else {
                    for (var r = A; 0 <= r && r < x;) {
                      if (n = g[a].points[t[r].index]) {
                        l = n[1];
                        break;
                      }

                      r += z;
                    }

                    l = m(l, 0);
                    l = k.translate(l, 0, 1, 0, 1);
                    e.push({
                      isNull: !0,
                      plotX: f.translate(a, 0, 0, 0, 1),
                      x: a,
                      plotY: l,
                      yBottom: l
                    });
                  }
                });
              }

              return e;
            };

            a.defaultOptions = x(G.defaultOptions, {
              threshold: 0
            });
            return a;
          }(G);

          e(y.prototype, {
            singleStacks: !1,
            drawLegendSymbol: g.drawRectangle
          });
          C.registerSeriesType("area", y);
          "";
          return y;
        });
        M(g, "Series/Spline/SplineSeries.js", [g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g) {
          var C = this && this.__extends || function () {
            var _e3 = function e(g, r) {
              _e3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, d) {
                e.__proto__ = d;
              } || function (e, d) {
                for (var a in d) {
                  d.hasOwnProperty(a) && (e[a] = d[a]);
                }
              };

              return _e3(g, r);
            };

            return function (g, r) {
              function m() {
                this.constructor = g;
              }

              _e3(g, r);

              g.prototype = null === r ? Object.create(r) : (m.prototype = r.prototype, new m());
            };
          }(),
              y = e.seriesTypes.line,
              E = g.merge,
              v = g.pick;

          g = function (e) {
            function g() {
              var g = null !== e && e.apply(this, arguments) || this;
              g.data = void 0;
              g.options = void 0;
              g.points = void 0;
              return g;
            }

            C(g, e);

            g.prototype.getPointSpline = function (e, m, d) {
              var a = m.plotX || 0,
                  g = m.plotY || 0,
                  r = e[d - 1];
              d = e[d + 1];

              if (r && !r.isNull && !1 !== r.doCurve && !m.isCliff && d && !d.isNull && !1 !== d.doCurve && !m.isCliff) {
                e = r.plotY || 0;
                var l = d.plotX || 0;
                d = d.plotY || 0;
                var h = 0;
                var f = (1.5 * a + (r.plotX || 0)) / 2.5;
                var k = (1.5 * g + e) / 2.5;
                l = (1.5 * a + l) / 2.5;
                var x = (1.5 * g + d) / 2.5;
                l !== f && (h = (x - k) * (l - a) / (l - f) + g - x);
                k += h;
                x += h;
                k > e && k > g ? (k = Math.max(e, g), x = 2 * g - k) : k < e && k < g && (k = Math.min(e, g), x = 2 * g - k);
                x > d && x > g ? (x = Math.max(d, g), k = 2 * g - x) : x < d && x < g && (x = Math.min(d, g), k = 2 * g - x);
                m.rightContX = l;
                m.rightContY = x;
              }

              m = ["C", v(r.rightContX, r.plotX, 0), v(r.rightContY, r.plotY, 0), v(f, a, 0), v(k, g, 0), a, g];
              r.rightContX = r.rightContY = void 0;
              return m;
            };

            g.defaultOptions = E(y.defaultOptions);
            return g;
          }(y);

          e.registerSeriesType("spline", g);
          "";
          return g;
        });
        M(g, "Series/AreaSpline/AreaSplineSeries.js", [g["Series/Area/AreaSeries.js"], g["Series/Spline/SplineSeries.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y, E) {
          var v = this && this.__extends || function () {
            var _e4 = function e(d, a) {
              _e4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var e in d) {
                  d.hasOwnProperty(e) && (a[e] = d[e]);
                }
              };

              return _e4(d, a);
            };

            return function (d, a) {
              function g() {
                this.constructor = d;
              }

              _e4(d, a);

              d.prototype = null === a ? Object.create(a) : (g.prototype = a.prototype, new g());
            };
          }(),
              G = e.prototype,
              x = E.extend,
              r = E.merge;

          E = function (m) {
            function d() {
              var a = null !== m && m.apply(this, arguments) || this;
              a.data = void 0;
              a.points = void 0;
              a.options = void 0;
              return a;
            }

            v(d, m);
            d.defaultOptions = r(g.defaultOptions, e.defaultOptions);
            return d;
          }(g);

          x(E.prototype, {
            getGraphPath: G.getGraphPath,
            getStackPoints: G.getStackPoints,
            drawGraph: G.drawGraph,
            drawLegendSymbol: C.drawRectangle
          });
          y.registerSeriesType("areaspline", E);
          "";
          return E;
        });
        M(g, "Series/Column/ColumnSeries.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Color/Palette.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G, x) {
          var r = this && this.__extends || function () {
            var _a22 = function a(d, c) {
              _a22 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var c in a) {
                  a.hasOwnProperty(c) && (b[c] = a[c]);
                }
              };

              return _a22(d, c);
            };

            return function (d, c) {
              function b() {
                this.constructor = d;
              }

              _a22(d, c);

              d.prototype = null === c ? Object.create(c) : (b.prototype = c.prototype, new b());
            };
          }(),
              m = e.animObject,
              d = g.parse,
              a = C.hasTouch;

          e = C.noop;
          var p = x.clamp,
              B = x.css,
              l = x.defined,
              h = x.extend,
              f = x.fireEvent,
              k = x.isArray,
              J = x.isNumber,
              K = x.merge,
              t = x.pick,
              Q = x.objectEach;

          x = function (e) {
            function g() {
              var a = null !== e && e.apply(this, arguments) || this;
              a.borderWidth = void 0;
              a.data = void 0;
              a.group = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(g, e);

            g.prototype.animate = function (a) {
              var b = this,
                  c = this.yAxis,
                  d = b.options,
                  f = this.chart.inverted,
                  e = {},
                  k = f ? "translateX" : "translateY";
              if (a) e.scaleY = .001, a = p(c.toPixels(d.threshold), c.pos, c.pos + c.len), f ? e.translateX = a - c.len : e.translateY = a, b.clipBox && b.setClip(), b.group.attr(e);else {
                var l = Number(b.group.attr(k));
                b.group.animate({
                  scaleY: 1
                }, h(m(b.options.animation), {
                  step: function step(a, d) {
                    b.group && (e[k] = l + d.pos * (c.pos - l), b.group.attr(e));
                  }
                }));
              }
            };

            g.prototype.init = function (a, b) {
              e.prototype.init.apply(this, arguments);
              var c = this;
              a = c.chart;
              a.hasRendered && a.series.forEach(function (b) {
                b.type === c.type && (b.isDirty = !0);
              });
            };

            g.prototype.getColumnMetrics = function () {
              var a = this,
                  b = a.options,
                  d = a.xAxis,
                  f = a.yAxis,
                  e = d.options.reversedStacks;
              e = d.reversed && !e || !d.reversed && e;
              var h = {},
                  k,
                  l = 0;
              !1 === b.grouping ? l = 1 : a.chart.series.forEach(function (b) {
                var c = b.yAxis,
                    d = b.options;

                if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && f.len === c.len && f.pos === c.pos) {
                  if (d.stacking && "group" !== d.stacking) {
                    k = b.stackKey;
                    "undefined" === typeof h[k] && (h[k] = l++);
                    var e = h[k];
                  } else !1 !== d.grouping && (e = l++);

                  b.columnIndex = e;
                }
              });
              var w = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || b.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),
                  g = w * b.groupPadding,
                  m = (w - 2 * g) / (l || 1);
              b = Math.min(b.maxPointWidth || d.len, t(b.pointWidth, m * (1 - 2 * b.pointPadding)));
              a.columnMetrics = {
                width: b,
                offset: (m - b) / 2 + (g + ((a.columnIndex || 0) + (e ? 1 : 0)) * m - w / 2) * (e ? -1 : 1),
                paddedWidth: m,
                columnCount: l
              };
              return a.columnMetrics;
            };

            g.prototype.crispCol = function (a, b, d, f) {
              var c = this.chart,
                  e = this.borderWidth,
                  h = -(e % 2 ? .5 : 0);
              e = e % 2 ? .5 : 1;
              c.inverted && c.renderer.isVML && (e += 1);
              this.options.crisp && (d = Math.round(a + d) + h, a = Math.round(a) + h, d -= a);
              f = Math.round(b + f) + e;
              h = .5 >= Math.abs(b) && .5 < f;
              b = Math.round(b) + e;
              f -= b;
              h && f && (--b, f += 1);
              return {
                x: a,
                y: b,
                width: d,
                height: f
              };
            };

            g.prototype.adjustForMissingColumns = function (a, b, d, f) {
              var c = this,
                  e = this.options.stacking;

              if (!d.isNull && 1 < f.columnCount) {
                var h = 0,
                    l = 0;
                Q(this.yAxis.stacking && this.yAxis.stacking.stacks, function (b) {
                  if ("number" === typeof d.x && (b = b[d.x.toString()])) {
                    var a = b.points[c.index],
                        f = b.total;
                    e ? (a && (h = l), b.hasValidPoints && l++) : k(a) && (h = a[1], l = f || 0);
                  }
                });
                a = (d.plotX || 0) + ((l - 1) * f.paddedWidth + b) / 2 - b - h * f.paddedWidth;
              }

              return a;
            };

            g.prototype.translate = function () {
              var a = this,
                  b = a.chart,
                  d = a.options,
                  f = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
              f = a.borderWidth = t(d.borderWidth, f ? 0 : 1);
              var e = a.xAxis,
                  h = a.yAxis,
                  k = d.threshold,
                  g = a.translatedThreshold = h.getThreshold(k),
                  w = t(d.minPointLength, 5),
                  m = a.getColumnMetrics(),
                  r = m.width,
                  A = a.pointXOffset = m.offset,
                  q = a.dataMin,
                  z = a.dataMax,
                  B = a.barW = Math.max(r, 1 + 2 * f);
              b.inverted && (g -= .5);
              d.pointPadding && (B = Math.ceil(B));
              v.prototype.translate.apply(a);
              a.points.forEach(function (c) {
                var f = t(c.yBottom, g),
                    n = 999 + Math.abs(f),
                    u = c.plotX || 0;
                n = p(c.plotY, -n, h.len + n);
                var H = Math.min(n, f),
                    F = Math.max(n, f) - H,
                    N = r,
                    D = u + A,
                    O = B;
                w && Math.abs(F) < w && (F = w, u = !h.reversed && !c.negative || h.reversed && c.negative, J(k) && J(z) && c.y === k && z <= k && (h.min || 0) < k && (q !== z || (h.max || 0) <= k) && (u = !u), H = Math.abs(H - g) > w ? f - w : g - (u ? w : 0));
                l(c.options.pointWidth) && (N = O = Math.ceil(c.options.pointWidth), D -= Math.round((N - r) / 2));
                d.centerInCategory && (D = a.adjustForMissingColumns(D, N, c, m));
                c.barX = D;
                c.pointWidth = N;
                c.tooltipPos = b.inverted ? [p(h.len + h.pos - b.plotLeft - n, h.pos - b.plotLeft, h.len + h.pos - b.plotLeft), e.len + e.pos - b.plotTop - D - O / 2, F] : [e.left - b.plotLeft + D + O / 2, p(n + h.pos - b.plotTop, h.pos - b.plotTop, h.len + h.pos - b.plotTop), F];
                c.shapeType = a.pointClass.prototype.shapeType || "rect";
                c.shapeArgs = a.crispCol.apply(a, c.isNull ? [D, g, O, 0] : [D, H, O, F]);
              });
            };

            g.prototype.drawGraph = function () {
              this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };

            g.prototype.pointAttribs = function (a, b) {
              var c = this.options,
                  f = this.pointAttrToOptions || {},
                  e = f.stroke || "borderColor",
                  h = f["stroke-width"] || "borderWidth",
                  k = a && a.color || this.color,
                  l = a && a[e] || c[e] || k;
              f = a && a.options.dashStyle || c.dashStyle;
              var g = a && a[h] || c[h] || this[h] || 0,
                  m = t(a && a.opacity, c.opacity, 1);

              if (a && this.zones.length) {
                var p = a.getZone();
                k = a.options.color || p && (p.color || a.nonZonedColor) || this.color;
                p && (l = p.borderColor || l, f = p.dashStyle || f, g = p.borderWidth || g);
              }

              b && a && (a = K(c.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, k = a.color || "undefined" !== typeof b && d(k).brighten(a.brightness).get() || k, l = a[e] || l, g = a[h] || g, f = a.dashStyle || f, m = t(a.opacity, m));
              e = {
                fill: k,
                stroke: l,
                "stroke-width": g,
                opacity: m
              };
              f && (e.dashstyle = f);
              return e;
            };

            g.prototype.drawPoints = function () {
              var a = this,
                  b = this.chart,
                  d = a.options,
                  f = b.renderer,
                  e = d.animationLimit || 250,
                  h;
              a.points.forEach(function (c) {
                var k = c.graphic,
                    n = !!k,
                    l = k && b.pointCount < e ? "animate" : "attr";

                if (J(c.plotY) && null !== c.y) {
                  h = c.shapeArgs;
                  k && c.hasNewShapeType() && (k = k.destroy());
                  a.enabledDataSorting && (c.startXPos = a.xAxis.reversed ? -(h ? h.width || 0 : 0) : a.xAxis.width);
                  k || (c.graphic = k = f[c.shapeType](h).add(c.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < e && (k.attr({
                    x: c.startXPos
                  }), n = !0, l = "animate");
                  if (k && n) k[l](K(h));
                  if (d.borderRadius) k[l]({
                    r: d.borderRadius
                  });
                  b.styledMode || k[l](a.pointAttribs(c, c.selected && "select")).shadow(!1 !== c.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);
                  k && (k.addClass(c.getClassName(), !0), k.attr({
                    visibility: c.visible ? "inherit" : "hidden"
                  }));
                } else k && (c.graphic = k.destroy());
              });
            };

            g.prototype.drawTracker = function () {
              var c = this,
                  b = c.chart,
                  d = b.pointer,
                  e = function e(b) {
                var a = d.getPointFromEvent(b);
                "undefined" !== typeof a && (d.isDirectTouch = !0, a.onMouseOver(b));
              },
                  h;

              c.points.forEach(function (b) {
                h = k(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
                b.graphic && (b.graphic.element.point = b);
                h.forEach(function (a) {
                  a.div ? a.div.point = b : a.element.point = b;
                });
              });
              c._hasTracking || (c.trackerGroups.forEach(function (f) {
                if (c[f]) {
                  c[f].addClass("highcharts-tracker").on("mouseover", e).on("mouseout", function (b) {
                    d.onTrackerMouseOut(b);
                  });
                  if (a) c[f].on("touchstart", e);
                  !b.styledMode && c.options.cursor && c[f].css(B).css({
                    cursor: c.options.cursor
                  });
                }
              }), c._hasTracking = !0);
              f(this, "afterDrawTracker");
            };

            g.prototype.remove = function () {
              var a = this,
                  b = a.chart;
              b.hasRendered && b.series.forEach(function (b) {
                b.type === a.type && (b.isDirty = !0);
              });
              v.prototype.remove.apply(a, arguments);
            };

            g.defaultOptions = K(v.defaultOptions, {
              borderRadius: 0,
              centerInCategory: !1,
              groupPadding: .2,
              marker: null,
              pointPadding: .1,
              minPointLength: 0,
              cropThreshold: 50,
              pointRange: null,
              states: {
                hover: {
                  halo: !1,
                  brightness: .1
                },
                select: {
                  color: E.neutralColor20,
                  borderColor: E.neutralColor100
                }
              },
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
              },
              startFromThreshold: !0,
              stickyTracking: !1,
              tooltip: {
                distance: 6
              },
              threshold: 0,
              borderColor: E.backgroundColor
            });
            return g;
          }(v);

          h(x.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: y.drawRectangle,
            getSymbol: e,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          G.registerSeriesType("column", x);
          "";
          "";
          return x;
        });
        M(g, "Core/Series/DataLabel.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/FormatUtilities.js"], g["Core/Color/Palette.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var E = e.getDeferredAnimation,
              v = g.format,
              G = y.defined,
              x = y.extend,
              r = y.fireEvent,
              m = y.isArray,
              d = y.merge,
              a = y.objectEach,
              p = y.pick,
              B = y.splat,
              l;

          (function (e) {
            function f(a, c, b, d, f) {
              var e = this,
                  h = this.chart,
                  k = this.isCartesian && h.inverted,
                  l = this.enabledDataSorting,
                  g = p(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
                  t = p(a.plotY, -9999),
                  m = c.getBBox(),
                  r = b.rotation,
                  q = b.align,
                  z = h.isInsidePlot(g, Math.round(t), {
                inverted: k,
                paneCoordinates: !0,
                series: e
              }),
                  A = function A(b) {
                l && e.xAxis && !B && e.setDataLabelStartPos(a, c, f, z, b);
              },
                  B = "justify" === p(b.overflow, l ? "none" : "justify"),
                  D = this.visible && !1 !== a.visible && (a.series.forceDL || l && !B || z || p(b.inside, !!this.options.stacking) && d && h.isInsidePlot(g, k ? d.x + 1 : d.y + d.height - 1, {
                inverted: k,
                paneCoordinates: !0,
                series: e
              }));

              if (D) {
                var Q = h.renderer.fontMetrics(h.styledMode ? void 0 : b.style.fontSize, c).b;
                d = x({
                  x: k ? this.yAxis.len - t : g,
                  y: Math.round(k ? this.xAxis.len - g : t),
                  width: 0,
                  height: 0
                }, d);
                x(b, {
                  width: m.width,
                  height: m.height
                });
                r ? (B = !1, g = h.renderer.rotCorr(Q, r), g = {
                  x: d.x + (b.x || 0) + d.width / 2 + g.x,
                  y: d.y + (b.y || 0) + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                  }[b.verticalAlign] * d.height
                }, A(g), c[f ? "attr" : "animate"](g).attr({
                  align: q
                }), A = (r + 720) % 360, A = 180 < A && 360 > A, "left" === q ? g.y -= A ? m.height : 0 : "center" === q ? (g.x -= m.width / 2, g.y -= m.height / 2) : "right" === q && (g.x -= m.width, g.y -= A ? 0 : m.height), c.placed = !0, c.alignAttr = g) : (A(d), c.align(b, void 0, d), g = c.alignAttr);
                B && 0 <= d.height ? this.justifyDataLabel(c, b, g, m, d, f) : p(b.crop, !0) && (D = h.isInsidePlot(g.x, g.y, {
                  paneCoordinates: !0,
                  series: e
                }) && h.isInsidePlot(g.x + m.width, g.y + m.height, {
                  paneCoordinates: !0,
                  series: e
                }));
                if (b.shape && !r) c[f ? "attr" : "animate"]({
                  anchorX: k ? h.plotWidth - a.plotY : a.plotX,
                  anchorY: k ? h.plotHeight - a.plotX : a.plotY
                });
              }

              f && l && (c.placed = !1);
              D || l && !B || (c.hide(!0), c.placed = !1);
            }

            function h(a, c) {
              var b = c.filter;
              return b ? (c = b.operator, a = a[b.property], b = b.value, ">" === c && a > b || "<" === c && a < b || ">=" === c && a >= b || "<=" === c && a <= b || "==" === c && a == b || "===" === c && a === b ? !0 : !1) : !0;
            }

            function l() {
              var d = this,
                  c = d.chart,
                  b = d.options,
                  f = d.points,
                  e = d.hasRendered || 0,
                  k = c.renderer,
                  n = b.dataLabels,
                  l,
                  g = n.animation;
              g = n.defer ? E(c, g, d) : {
                defer: 0,
                duration: 0
              };
              n = t(t(c.options.plotOptions && c.options.plotOptions.series && c.options.plotOptions.series.dataLabels, c.options.plotOptions && c.options.plotOptions[d.type] && c.options.plotOptions[d.type].dataLabels), n);
              r(this, "drawDataLabels");

              if (m(n) || n.enabled || d._hasPointLabels) {
                var w = d.plotGroup("dataLabelsGroup", "data-labels", e ? "inherit" : "hidden", n.zIndex || 6);
                w.attr({
                  opacity: +e
                });
                !e && (e = d.dataLabelsGroup) && (d.visible && w.show(!0), e[b.animation ? "animate" : "attr"]({
                  opacity: 1
                }, g));
                f.forEach(function (f) {
                  l = B(t(n, f.dlOptions || f.options && f.options.dataLabels));
                  l.forEach(function (e, n) {
                    var l = e.enabled && (!f.isNull || f.dataLabelOnNull) && h(f, e),
                        g = f.connectors ? f.connectors[n] : f.connector,
                        t = f.dataLabels ? f.dataLabels[n] : f.dataLabel,
                        m = p(e.distance, f.labelDistance),
                        r = !t;

                    if (l) {
                      var u = f.getLabelConfig();
                      var z = p(e[f.formatPrefix + "Format"], e.format);
                      u = G(z) ? v(z, u, c) : (e[f.formatPrefix + "Formatter"] || e.formatter).call(u, e);
                      z = e.style;
                      var H = e.rotation;
                      c.styledMode || (z.color = p(e.color, z.color, d.color, C.neutralColor100), "contrast" === z.color ? (f.contrastColor = k.getContrast(f.color || d.color), z.color = !G(m) && e.inside || 0 > m || b.stacking ? f.contrastColor : C.neutralColor100) : delete f.contrastColor, b.cursor && (z.cursor = b.cursor));
                      var A = {
                        r: e.borderRadius || 0,
                        rotation: H,
                        padding: e.padding,
                        zIndex: 1
                      };
                      c.styledMode || (A.fill = e.backgroundColor, A.stroke = e.borderColor, A["stroke-width"] = e.borderWidth);
                      a(A, function (b, a) {
                        "undefined" === typeof b && delete A[a];
                      });
                    }

                    !t || l && G(u) ? l && G(u) && (t ? A.text = u : (f.dataLabels = f.dataLabels || [], t = f.dataLabels[n] = H ? k.text(u, 0, -9999, e.useHTML).addClass("highcharts-data-label") : k.label(u, 0, -9999, e.shape, null, null, e.useHTML, null, "data-label"), n || (f.dataLabel = t), t.addClass(" highcharts-data-label-color-" + f.colorIndex + " " + (e.className || "") + (e.useHTML ? " highcharts-tracker" : ""))), t.options = e, t.attr(A), c.styledMode || t.css(z).shadow(e.shadow), t.added || t.add(w), e.textPath && !e.useHTML && (t.setTextPath(f.getDataLabelPath && f.getDataLabelPath(t) || f.graphic, e.textPath), f.dataLabelPath && !e.textPath.enabled && (f.dataLabelPath = f.dataLabelPath.destroy())), d.alignDataLabel(f, t, e, null, r)) : (f.dataLabel = f.dataLabel && f.dataLabel.destroy(), f.dataLabels && (1 === f.dataLabels.length ? delete f.dataLabels : delete f.dataLabels[n]), n || delete f.dataLabel, g && (f.connector = f.connector.destroy(), f.connectors && (1 === f.connectors.length ? delete f.connectors : delete f.connectors[n])));
                  });
                });
              }

              r(this, "afterDrawDataLabels");
            }

            function g(a, c, b, d, f, e) {
              var h = this.chart,
                  k = c.align,
                  l = c.verticalAlign,
                  g = a.box ? 0 : a.padding || 0,
                  t = c.x;
              t = void 0 === t ? 0 : t;
              var m = c.y;
              m = void 0 === m ? 0 : m;
              var p = (b.x || 0) + g;

              if (0 > p) {
                "right" === k && 0 <= t ? (c.align = "left", c.inside = !0) : t -= p;
                var q = !0;
              }

              p = (b.x || 0) + d.width - g;
              p > h.plotWidth && ("left" === k && 0 >= t ? (c.align = "right", c.inside = !0) : t += h.plotWidth - p, q = !0);
              p = b.y + g;
              0 > p && ("bottom" === l && 0 <= m ? (c.verticalAlign = "top", c.inside = !0) : m -= p, q = !0);
              p = (b.y || 0) + d.height - g;
              p > h.plotHeight && ("top" === l && 0 >= m ? (c.verticalAlign = "bottom", c.inside = !0) : m += h.plotHeight - p, q = !0);
              q && (c.x = t, c.y = m, a.placed = !e, a.align(c, void 0, f));
              return q;
            }

            function t(a, c) {
              var b = [],
                  f;
              if (m(a) && !m(c)) b = a.map(function (b) {
                return d(b, c);
              });else if (m(c) && !m(a)) b = c.map(function (b) {
                return d(a, b);
              });else if (m(a) || m(c)) for (f = Math.max(a.length, c.length); f--;) {
                b[f] = d(a[f], c[f]);
              } else b = d(a, c);
              return b;
            }

            function Q(a, c, b, d, f) {
              var e = this.chart,
                  h = e.inverted,
                  k = this.xAxis,
                  l = k.reversed,
                  g = h ? c.height / 2 : c.width / 2;
              a = (a = a.pointWidth) ? a / 2 : 0;
              c.startXPos = h ? f.x : l ? -g - a : k.width - g + a;
              c.startYPos = h ? l ? this.yAxis.height - g + a : -g - a : f.y;
              d ? "hidden" === c.visibility && (c.show(), c.attr({
                opacity: 0
              }).animate({
                opacity: 1
              })) : c.attr({
                opacity: 1
              }).animate({
                opacity: 0
              }, void 0, c.hide);
              e.hasRendered && (b && c.attr({
                x: c.startXPos,
                y: c.startYPos
              }), c.placed = !0);
            }

            var z = [];

            e.compose = function (a) {
              if (-1 === z.indexOf(a)) {
                var c = a.prototype;
                z.push(a);
                c.alignDataLabel = f;
                c.drawDataLabels = l;
                c.justifyDataLabel = g;
                c.setDataLabelStartPos = Q;
              }
            };
          })(l || (l = {}));

          "";
          return l;
        });
        M(g, "Series/Column/ColumnDataLabel.js", [g["Core/Series/DataLabel.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = g.series,
              E = C.merge,
              v = C.pick,
              G;

          (function (g) {
            function r(d, a, e, g, l) {
              var h = this.chart.inverted,
                  f = d.series,
                  k = d.dlBox || d.shapeArgs,
                  m = v(d.below, d.plotY > v(this.translatedThreshold, f.yAxis.len)),
                  p = v(e.inside, !!this.options.stacking);
              k && (g = E(k), 0 > g.y && (g.height += g.y, g.y = 0), k = g.y + g.height - f.yAxis.len, 0 < k && k < g.height && (g.height -= k), h && (g = {
                x: f.yAxis.len - g.y - g.height,
                y: f.xAxis.len - g.x - g.width,
                width: g.height,
                height: g.width
              }), p || (h ? (g.x += m ? 0 : g.width, g.width = 0) : (g.y += m ? g.height : 0, g.height = 0)));
              e.align = v(e.align, !h || p ? "center" : m ? "right" : "left");
              e.verticalAlign = v(e.verticalAlign, h || p ? "middle" : m ? "top" : "bottom");
              y.prototype.alignDataLabel.call(this, d, a, e, g, l);
              e.inside && d.contrastColor && a.css({
                color: d.contrastColor
              });
            }

            var m = [];

            g.compose = function (d) {
              e.compose(y);
              -1 === m.indexOf(d) && (m.push(d), d.prototype.alignDataLabel = r);
            };
          })(G || (G = {}));

          return G;
        });
        M(g, "Series/Bar/BarSeries.js", [g["Series/Column/ColumnSeries.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = this && this.__extends || function () {
            var _e5 = function e(g, r) {
              _e5 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, d) {
                e.__proto__ = d;
              } || function (e, d) {
                for (var a in d) {
                  d.hasOwnProperty(a) && (e[a] = d[a]);
                }
              };

              return _e5(g, r);
            };

            return function (g, r) {
              function m() {
                this.constructor = g;
              }

              _e5(g, r);

              g.prototype = null === r ? Object.create(r) : (m.prototype = r.prototype, new m());
            };
          }(),
              E = C.extend,
              v = C.merge;

          C = function (g) {
            function x() {
              var e = null !== g && g.apply(this, arguments) || this;
              e.data = void 0;
              e.options = void 0;
              e.points = void 0;
              return e;
            }

            y(x, g);
            x.defaultOptions = v(e.defaultOptions, {});
            return x;
          }(e);

          E(C.prototype, {
            inverted: !0
          });
          g.registerSeriesType("bar", C);
          "";
          return C;
        });
        M(g, "Series/Scatter/ScatterSeries.js", [g["Series/Column/ColumnSeries.js"], g["Series/Line/LineSeries.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var E = this && this.__extends || function () {
            var _e6 = function e(g, d) {
              _e6 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var e in d) {
                  d.hasOwnProperty(e) && (a[e] = d[e]);
                }
              };

              return _e6(g, d);
            };

            return function (g, d) {
              function a() {
                this.constructor = g;
              }

              _e6(g, d);

              g.prototype = null === d ? Object.create(d) : (a.prototype = d.prototype, new a());
            };
          }(),
              v = y.addEvent,
              G = y.extend,
              x = y.merge;

          y = function (e) {
            function m() {
              var d = null !== e && e.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            E(m, e);

            m.prototype.applyJitter = function () {
              var d = this,
                  a = this.options.jitter,
                  e = this.points.length;
              a && this.points.forEach(function (g, l) {
                ["x", "y"].forEach(function (h, f) {
                  var k = "plot" + h.toUpperCase();

                  if (a[h] && !g.isNull) {
                    var m = d[h + "Axis"];
                    var p = a[h] * m.transA;

                    if (m && !m.isLog) {
                      var t = Math.max(0, g[k] - p);
                      m = Math.min(m.len, g[k] + p);
                      f = 1E4 * Math.sin(l + f * e);
                      g[k] = t + (m - t) * (f - Math.floor(f));
                      "x" === h && (g.clientX = g.plotX);
                    }
                  }
                });
              });
            };

            m.prototype.drawGraph = function () {
              this.options.lineWidth ? e.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };

            m.defaultOptions = x(g.defaultOptions, {
              lineWidth: 0,
              findNearestPointBy: "xy",
              jitter: {
                x: 0,
                y: 0
              },
              marker: {
                enabled: !0
              },
              tooltip: {
                headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
              }
            });
            return m;
          }(g);

          G(y.prototype, {
            drawTracker: e.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
          });
          v(y, "afterTranslate", function () {
            this.applyJitter();
          });
          C.registerSeriesType("scatter", y);
          "";
          return y;
        });
        M(g, "Mixins/CenteredSeries.js", [g["Core/Globals.js"], g["Core/Series/Series.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = C.isNumber,
              E = C.pick,
              v = C.relativeLength,
              G = e.deg2rad;
          return e.CenteredSeriesMixin = {
            getCenter: function getCenter() {
              var e = this.options,
                  r = this.chart,
                  m = 2 * (e.slicedOffset || 0),
                  d = r.plotWidth - 2 * m,
                  a = r.plotHeight - 2 * m,
                  p = e.center,
                  B = Math.min(d, a),
                  l = e.size,
                  h = e.innerSize || 0;
              "string" === typeof l && (l = parseFloat(l));
              "string" === typeof h && (h = parseFloat(h));
              e = [E(p[0], "50%"), E(p[1], "50%"), E(l && 0 > l ? void 0 : e.size, "100%"), E(h && 0 > h ? void 0 : e.innerSize || 0, "0%")];
              !r.angular || this instanceof g || (e[3] = 0);

              for (p = 0; 4 > p; ++p) {
                l = e[p], r = 2 > p || 2 === p && /%$/.test(l), e[p] = v(l, [d, a, B, e[2]][p]) + (r ? m : 0);
              }

              e[3] > e[2] && (e[3] = e[2]);
              return e;
            },
            getStartAndEndRadians: function getStartAndEndRadians(e, g) {
              e = y(e) ? e : 0;
              g = y(g) && g > e && 360 > g - e ? g : e + 360;
              return {
                start: G * (e + -90),
                end: G * (g + -90)
              };
            }
          };
        });
        M(g, "Series/Pie/PiePoint.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = this && this.__extends || function () {
            var _d4 = function d(a, e) {
              _d4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var e in d) {
                  d.hasOwnProperty(e) && (a[e] = d[e]);
                }
              };

              return _d4(a, e);
            };

            return function (a, e) {
              function g() {
                this.constructor = a;
              }

              _d4(a, e);

              a.prototype = null === e ? Object.create(e) : (g.prototype = e.prototype, new g());
            };
          }(),
              E = e.setAnimation,
              v = C.addEvent,
              G = C.defined;

          e = C.extend;
          var x = C.isNumber,
              r = C.pick,
              m = C.relativeLength;

          g = function (d) {
            function a() {
              var a = null !== d && d.apply(this, arguments) || this;
              a.labelDistance = void 0;
              a.options = void 0;
              a.series = void 0;
              return a;
            }

            y(a, d);

            a.prototype.getConnectorPath = function () {
              var a = this.labelPosition,
                  d = this.series.options.dataLabels,
                  e = this.connectorShapes,
                  h = d.connectorShape;
              e[h] && (h = e[h]);
              return h.call(this, {
                x: a["final"].x,
                y: a["final"].y,
                alignment: a.alignment
              }, a.connectorPosition, d);
            };

            a.prototype.getTranslate = function () {
              return this.sliced ? this.slicedTranslation : {
                translateX: 0,
                translateY: 0
              };
            };

            a.prototype.haloPath = function (a) {
              var d = this.shapeArgs;
              return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + a, d.r + a, {
                innerR: d.r - 1,
                start: d.start,
                end: d.end
              });
            };

            a.prototype.init = function () {
              var a = this;
              d.prototype.init.apply(this, arguments);
              this.name = r(this.name, "Slice");

              var e = function e(d) {
                a.slice("select" === d.type);
              };

              v(this, "select", e);
              v(this, "unselect", e);
              return this;
            };

            a.prototype.isValid = function () {
              return x(this.y) && 0 <= this.y;
            };

            a.prototype.setVisible = function (a, d) {
              var e = this,
                  h = this.series,
                  f = h.chart,
                  k = h.options.ignoreHiddenPoint;
              d = r(d, k);
              a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, h.options.data[h.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (d) {
                if (e[d]) e[d][a ? "show" : "hide"](a);
              }), this.legendItem && f.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), k && (h.isDirty = !0), d && f.redraw());
            };

            a.prototype.slice = function (a, d, e) {
              var h = this.series;
              E(e, h.chart);
              r(d, !0);
              this.sliced = this.options.sliced = G(a) ? a : !this.sliced;
              h.options.data[h.data.indexOf(this)] = this.options;
              this.graphic && this.graphic.animate(this.getTranslate());
              this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };

            return a;
          }(g);

          e(g.prototype, {
            connectorShapes: {
              fixedOffset: function fixedOffset(d, a, e) {
                var g = a.breakAt;
                a = a.touchingSliceAt;
                return [["M", d.x, d.y], e.softConnector ? ["C", d.x + ("left" === d.alignment ? -5 : 5), d.y, 2 * g.x - a.x, 2 * g.y - a.y, g.x, g.y] : ["L", g.x, g.y], ["L", a.x, a.y]];
              },
              straight: function straight(d, a) {
                a = a.touchingSliceAt;
                return [["M", d.x, d.y], ["L", a.x, a.y]];
              },
              crookedLine: function crookedLine(d, a, e) {
                a = a.touchingSliceAt;
                var g = this.series,
                    l = g.center[0],
                    h = g.chart.plotWidth,
                    f = g.chart.plotLeft;
                g = d.alignment;
                var k = this.shapeArgs.r;
                e = m(e.crookDistance, 1);
                h = "left" === g ? l + k + (h + f - l - k) * (1 - e) : f + (l - k) * e;
                e = ["L", h, d.y];
                l = !0;
                if ("left" === g ? h > d.x || h < a.x : h < d.x || h > a.x) l = !1;
                d = [["M", d.x, d.y]];
                l && d.push(e);
                d.push(["L", a.x, a.y]);
                return d;
              }
            }
          });
          return g;
        });
        M(g, "Series/Pie/PieSeries.js", [g["Mixins/CenteredSeries.js"], g["Series/Column/ColumnSeries.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Color/Palette.js"], g["Series/Pie/PiePoint.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/Symbols.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G, x, r, m) {
          var d = this && this.__extends || function () {
            var _a23 = function a(d, f) {
              _a23 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var f in d) {
                  d.hasOwnProperty(f) && (a[f] = d[f]);
                }
              };

              return _a23(d, f);
            };

            return function (d, f) {
              function e() {
                this.constructor = d;
              }

              _a23(d, f);

              d.prototype = null === f ? Object.create(f) : (e.prototype = f.prototype, new e());
            };
          }(),
              a = e.getStartAndEndRadians;

          C = C.noop;
          var p = m.clamp,
              B = m.extend,
              l = m.fireEvent,
              h = m.merge,
              f = m.pick,
              k = m.relativeLength;

          m = function (e) {
            function g() {
              var a = null !== e && e.apply(this, arguments) || this;
              a.center = void 0;
              a.data = void 0;
              a.maxLabelDistance = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            d(g, e);

            g.prototype.animate = function (a) {
              var d = this,
                  e = d.points,
                  h = d.startAngleRad;
              a || e.forEach(function (a) {
                var b = a.graphic,
                    c = a.shapeArgs;
                b && c && (b.attr({
                  r: f(a.startR, d.center && d.center[3] / 2),
                  start: h,
                  end: h
                }), b.animate({
                  r: c.r,
                  start: c.start,
                  end: c.end
                }, d.options.animation));
              });
            };

            g.prototype.drawEmpty = function () {
              var a = this.startAngleRad,
                  d = this.endAngleRad,
                  f = this.options;

              if (0 === this.total && this.center) {
                var e = this.center[0];
                var c = this.center[1];
                this.graph || (this.graph = this.chart.renderer.arc(e, c, this.center[1] / 2, 0, a, d).addClass("highcharts-empty-series").add(this.group));
                this.graph.attr({
                  d: r.arc(e, c, this.center[2] / 2, 0, {
                    start: a,
                    end: d,
                    innerR: this.center[3] / 2
                  })
                });
                this.chart.styledMode || this.graph.attr({
                  "stroke-width": f.borderWidth,
                  fill: f.fillColor || "none",
                  stroke: f.color || E.neutralColor20
                });
              } else this.graph && (this.graph = this.graph.destroy());
            };

            g.prototype.drawPoints = function () {
              var a = this.chart.renderer;
              this.points.forEach(function (d) {
                d.graphic && d.hasNewShapeType() && (d.graphic = d.graphic.destroy());
                d.graphic || (d.graphic = a[d.shapeType](d.shapeArgs).add(d.series.group), d.delayedRendering = !0);
              });
            };

            g.prototype.generatePoints = function () {
              e.prototype.generatePoints.call(this);
              this.updateTotals();
            };

            g.prototype.getX = function (a, d, f) {
              var e = this.center,
                  c = this.radii ? this.radii[f.index] || 0 : e[2] / 2;
              a = Math.asin(p((a - e[1]) / (c + f.labelDistance), -1, 1));
              return e[0] + (d ? -1 : 1) * Math.cos(a) * (c + f.labelDistance) + (0 < f.labelDistance ? (d ? -1 : 1) * this.options.dataLabels.padding : 0);
            };

            g.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            g.prototype.redrawPoints = function () {
              var a = this,
                  d = a.chart,
                  f = d.renderer,
                  e = a.options.shadow,
                  c,
                  b,
                  k,
                  l;
              this.drawEmpty();
              !e || a.shadowGroup || d.styledMode || (a.shadowGroup = f.g("shadow").attr({
                zIndex: -1
              }).add(a.group));
              a.points.forEach(function (g) {
                var n = {};
                b = g.graphic;

                if (!g.isNull && b) {
                  var m = void 0;
                  l = g.shapeArgs;
                  c = g.getTranslate();
                  d.styledMode || (m = g.shadowGroup, e && !m && (m = g.shadowGroup = f.g("shadow").add(a.shadowGroup)), m && m.attr(c), k = a.pointAttribs(g, g.selected && "select"));
                  g.delayedRendering ? (b.setRadialReference(a.center).attr(l).attr(c), d.styledMode || b.attr(k).attr({
                    "stroke-linejoin": "round"
                  }).shadow(e, m), g.delayedRendering = !1) : (b.setRadialReference(a.center), d.styledMode || h(!0, n, k), h(!0, n, l, c), b.animate(n));
                  b.attr({
                    visibility: g.visible ? "inherit" : "hidden"
                  });
                  b.addClass(g.getClassName(), !0);
                } else b && (g.graphic = b.destroy());
              });
            };

            g.prototype.sortByAngle = function (a, d) {
              a.sort(function (a, f) {
                return "undefined" !== typeof a.angle && (f.angle - a.angle) * d;
              });
            };

            g.prototype.translate = function (d) {
              this.generatePoints();
              var e = this.options,
                  h = e.slicedOffset,
                  g = h + (e.borderWidth || 0),
                  c = a(e.startAngle, e.endAngle),
                  b = this.startAngleRad = c.start;
              c = (this.endAngleRad = c.end) - b;
              var m = this.points,
                  t = e.dataLabels.distance;
              e = e.ignoreHiddenPoint;
              var p = m.length,
                  n,
                  r = 0;
              d || (this.center = d = this.getCenter());

              for (n = 0; n < p; n++) {
                var N = m[n];
                var w = b + r * c;
                !N.isValid() || e && !N.visible || (r += N.percentage / 100);
                var H = b + r * c;
                var O = {
                  x: d[0],
                  y: d[1],
                  r: d[2] / 2,
                  innerR: d[3] / 2,
                  start: Math.round(1E3 * w) / 1E3,
                  end: Math.round(1E3 * H) / 1E3
                };
                N.shapeType = "arc";
                N.shapeArgs = O;
                N.labelDistance = f(N.options.dataLabels && N.options.dataLabels.distance, t);
                N.labelDistance = k(N.labelDistance, O.r);
                this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, N.labelDistance);
                H = (H + w) / 2;
                H > 1.5 * Math.PI ? H -= 2 * Math.PI : H < -Math.PI / 2 && (H += 2 * Math.PI);
                N.slicedTranslation = {
                  translateX: Math.round(Math.cos(H) * h),
                  translateY: Math.round(Math.sin(H) * h)
                };
                O = Math.cos(H) * d[2] / 2;
                var R = Math.sin(H) * d[2] / 2;
                N.tooltipPos = [d[0] + .7 * O, d[1] + .7 * R];
                N.half = H < -Math.PI / 2 || H > Math.PI / 2 ? 1 : 0;
                N.angle = H;
                w = Math.min(g, N.labelDistance / 5);
                N.labelPosition = {
                  natural: {
                    x: d[0] + O + Math.cos(H) * N.labelDistance,
                    y: d[1] + R + Math.sin(H) * N.labelDistance
                  },
                  "final": {},
                  alignment: 0 > N.labelDistance ? "center" : N.half ? "right" : "left",
                  connectorPosition: {
                    breakAt: {
                      x: d[0] + O + Math.cos(H) * w,
                      y: d[1] + R + Math.sin(H) * w
                    },
                    touchingSliceAt: {
                      x: d[0] + O,
                      y: d[1] + R
                    }
                  }
                };
              }

              l(this, "afterTranslate");
            };

            g.prototype.updateTotals = function () {
              var a = this.points,
                  d = a.length,
                  f = this.options.ignoreHiddenPoint,
                  e,
                  c = 0;

              for (e = 0; e < d; e++) {
                var b = a[e];
                !b.isValid() || f && !b.visible || (c += b.y);
              }

              this.total = c;

              for (e = 0; e < d; e++) {
                b = a[e], b.percentage = 0 < c && (b.visible || !f) ? b.y / c * 100 : 0, b.total = c;
              }
            };

            g.defaultOptions = h(G.defaultOptions, {
              center: [null, null],
              clip: !1,
              colorByPoint: !0,
              dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0
              },
              fillColor: void 0,
              ignoreHiddenPoint: !0,
              inactiveOtherPoints: !0,
              legendType: "point",
              marker: null,
              size: null,
              showInLegend: !1,
              slicedOffset: 10,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0
              },
              borderColor: E.backgroundColor,
              borderWidth: 1,
              lineWidth: void 0,
              states: {
                hover: {
                  brightness: .1
                }
              }
            });
            return g;
          }(G);

          B(m.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: y.drawRectangle,
            drawTracker: g.prototype.drawTracker,
            getCenter: e.getCenter,
            getSymbol: C,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: g.prototype.pointAttribs,
            pointClass: v,
            requireSorting: !1,
            searchPoint: C,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          x.registerSeriesType("pie", m);
          "";
          return m;
        });
        M(g, "Series/Pie/PieDataLabel.js", [g["Core/Series/DataLabel.js"], g["Core/Globals.js"], g["Core/Color/Palette.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v) {
          var G = g.noop,
              x = y.distribute,
              r = E.series,
              m = v.arrayMax,
              d = v.clamp,
              a = v.defined,
              p = v.merge,
              B = v.pick,
              l = v.relativeLength,
              h;

          (function (f) {
            function h() {
              var d = this,
                  f = d.data,
                  c = d.chart,
                  b = d.options.dataLabels || {},
                  e = b.connectorPadding,
                  h = c.plotWidth,
                  k = c.plotHeight,
                  n = c.plotLeft,
                  l = Math.round(c.chartWidth / 3),
                  g = d.center,
                  t = g[2] / 2,
                  H = g[1],
                  O = [[], []],
                  R = [0, 0, 0, 0],
                  q = d.dataLabelPositioners,
                  F,
                  v,
                  Q,
                  G,
                  J,
                  E,
                  K,
                  y,
                  P,
                  M,
                  W,
                  U;
              d.visible && (b.enabled || d._hasPointLabels) && (f.forEach(function (b) {
                b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({
                  width: "auto"
                }).css({
                  width: "auto",
                  textOverflow: "clip"
                }), b.dataLabel.shortened = !1);
              }), r.prototype.drawDataLabels.apply(d), f.forEach(function (c) {
                c.dataLabel && (c.visible ? (O[c.half].push(c), c.dataLabel._pos = null, !a(b.style.width) && !a(c.options.dataLabels && c.options.dataLabels.style && c.options.dataLabels.style.width) && c.dataLabel.getBBox().width > l && (c.dataLabel.css({
                  width: Math.round(.7 * l) + "px"
                }), c.dataLabel.shortened = !0)) : (c.dataLabel = c.dataLabel.destroy(), c.dataLabels && 1 === c.dataLabels.length && delete c.dataLabels));
              }), O.forEach(function (f, l) {
                var m = f.length,
                    w = [],
                    p;

                if (m) {
                  d.sortByAngle(f, l - .5);

                  if (0 < d.maxLabelDistance) {
                    var r = Math.max(0, H - t - d.maxLabelDistance);
                    var u = Math.min(H + t + d.maxLabelDistance, c.plotHeight);
                    f.forEach(function (b) {
                      0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, H - t - b.labelDistance), b.bottom = Math.min(H + t + b.labelDistance, c.plotHeight), p = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                        target: b.labelPosition.natural.y - b.top + p / 2,
                        size: p,
                        rank: b.y
                      }, w.push(b.distributeBox));
                    });
                    r = u + p - r;
                    x(w, r, r / 5);
                  }

                  for (W = 0; W < m; W++) {
                    F = f[W];
                    E = F.labelPosition;
                    G = F.dataLabel;
                    M = !1 === F.visible ? "hidden" : "inherit";
                    P = r = E.natural.y;
                    w && a(F.distributeBox) && ("undefined" === typeof F.distributeBox.pos ? M = "hidden" : (K = F.distributeBox.size, P = q.radialDistributionY(F)));
                    delete F.positionIndex;
                    if (b.justify) y = q.justify(F, t, g);else switch (b.alignTo) {
                      case "connectors":
                        y = q.alignToConnectors(f, l, h, n);
                        break;

                      case "plotEdges":
                        y = q.alignToPlotEdges(G, l, h, n);
                        break;

                      default:
                        y = q.radialDistributionX(d, F, P, r);
                    }
                    G._attr = {
                      visibility: M,
                      align: E.alignment
                    };
                    U = F.options.dataLabels || {};
                    G._pos = {
                      x: y + B(U.x, b.x) + ({
                        left: e,
                        right: -e
                      }[E.alignment] || 0),
                      y: P + B(U.y, b.y) - 10
                    };
                    E["final"].x = y;
                    E["final"].y = P;
                    B(b.crop, !0) && (J = G.getBBox().width, r = null, y - J < e && 1 === l ? (r = Math.round(J - y + e), R[3] = Math.max(r, R[3])) : y + J > h - e && 0 === l && (r = Math.round(y + J - h + e), R[1] = Math.max(r, R[1])), 0 > P - K / 2 ? R[0] = Math.max(Math.round(-P + K / 2), R[0]) : P + K / 2 > k && (R[2] = Math.max(Math.round(P + K / 2 - k), R[2])), G.sideOverflow = r);
                  }
                }
              }), 0 === m(R) || this.verifyDataLabelOverflow(R)) && (this.placeDataLabels(), this.points.forEach(function (a) {
                U = p(b, a.options.dataLabels);

                if (v = B(U.connectorWidth, 1)) {
                  var f;
                  Q = a.connector;

                  if ((G = a.dataLabel) && G._pos && a.visible && 0 < a.labelDistance) {
                    M = G._attr.visibility;
                    if (f = !Q) a.connector = Q = c.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(d.dataLabelsGroup), c.styledMode || Q.attr({
                      "stroke-width": v,
                      stroke: U.connectorColor || a.color || C.neutralColor60
                    });
                    Q[f ? "attr" : "animate"]({
                      d: a.getConnectorPath()
                    });
                    Q.attr("visibility", M);
                  } else Q && (a.connector = Q.destroy());
                }
              }));
            }

            function g() {
              this.points.forEach(function (a) {
                var d = a.dataLabel,
                    c;
                d && a.visible && ((c = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({
                  width: d._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), d.shortened = !0), d.attr(d._attr), d[d.moved ? "animate" : "attr"](c), d.moved = !0) : d && d.attr({
                  y: -9999
                }));
                delete a.distributeBox;
              }, this);
            }

            function v(a) {
              var f = this.center,
                  c = this.options,
                  b = c.center,
                  e = c.minSize || 80,
                  h = null !== c.size;

              if (!h) {
                if (null !== b[0]) var k = Math.max(f[2] - Math.max(a[1], a[3]), e);else k = Math.max(f[2] - a[1] - a[3], e), f[0] += (a[3] - a[1]) / 2;
                null !== b[1] ? k = d(k, e, f[2] - Math.max(a[0], a[2])) : (k = d(k, e, f[2] - a[0] - a[2]), f[1] += (a[0] - a[2]) / 2);
                k < f[2] ? (f[2] = k, f[3] = Math.min(l(c.innerSize || 0, k), k), this.translate(f), this.drawDataLabels && this.drawDataLabels()) : h = !0;
              }

              return h;
            }

            var t = [],
                Q = {
              radialDistributionY: function radialDistributionY(a) {
                return a.top + a.distributeBox.pos;
              },
              radialDistributionX: function radialDistributionX(a, d, c, b) {
                return a.getX(c < d.top + 2 || c > d.bottom - 2 ? b : c, d.half, d);
              },
              justify: function justify(a, d, c) {
                return c[0] + (a.half ? -1 : 1) * (d + a.labelDistance);
              },
              alignToPlotEdges: function alignToPlotEdges(a, d, c, b) {
                a = a.getBBox().width;
                return d ? a + b : c - a - b;
              },
              alignToConnectors: function alignToConnectors(a, d, c, b) {
                var f = 0,
                    e;
                a.forEach(function (a) {
                  e = a.dataLabel.getBBox().width;
                  e > f && (f = e);
                });
                return d ? f + b : c - f - b;
              }
            };

            f.compose = function (a) {
              e.compose(r);
              -1 === t.indexOf(a) && (t.push(a), a = a.prototype, a.dataLabelPositioners = Q, a.alignDataLabel = G, a.drawDataLabels = h, a.placeDataLabels = g, a.verifyDataLabelOverflow = v);
            };
          })(h || (h = {}));

          return h;
        });
        M(g, "Extensions/OverlappingDataLabels.js", [g["Core/Chart/Chart.js"], g["Core/Utilities.js"]], function (e, g) {
          function C(e, d) {
            var a = !1;

            if (e) {
              var g = e.newOpacity;
              e.oldOpacity !== g && (e.alignAttr && e.placed ? (e[g ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), a = !0, e.alignAttr.opacity = g, e[e.isOld ? "animate" : "attr"](e.alignAttr, null, function () {
                d.styledMode || e.css({
                  pointerEvents: g ? "auto" : "none"
                });
              }), E(d, "afterHideOverlappingLabel")) : e.attr({
                opacity: g
              }));
              e.isOld = !0;
            }

            return a;
          }

          var y = g.addEvent,
              E = g.fireEvent,
              v = g.isArray,
              G = g.isNumber,
              x = g.objectEach,
              r = g.pick;
          y(e, "render", function () {
            var e = this,
                d = [];
            (this.labelCollectors || []).forEach(function (a) {
              d = d.concat(a());
            });
            (this.yAxis || []).forEach(function (a) {
              a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && x(a.stacking.stacks, function (a) {
                x(a, function (a) {
                  a.label && "hidden" !== a.label.visibility && d.push(a.label);
                });
              });
            });
            (this.series || []).forEach(function (a) {
              var g = a.options.dataLabels;
              a.visible && (!1 !== g.enabled || a._hasPointLabels) && (g = function g(a) {
                return a.forEach(function (a) {
                  a.visible && (v(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : []).forEach(function (h) {
                    var f = h.options;
                    h.labelrank = r(f.labelrank, a.labelrank, a.shapeArgs && a.shapeArgs.height);
                    f.allowOverlap ? (h.oldOpacity = h.opacity, h.newOpacity = 1, C(h, e)) : d.push(h);
                  });
                });
              }, g(a.nodes || []), g(a.points));
            });
            this.hideOverlappingLabels(d);
          });

          e.prototype.hideOverlappingLabels = function (e) {
            var d = this,
                a = e.length,
                g = d.renderer,
                m,
                l,
                h,
                f = !1;

            var k = function k(a) {
              var d,
                  f = a.box ? 0 : a.padding || 0,
                  e = d = 0,
                  c;

              if (a && (!a.alignAttr || a.placed)) {
                var b = a.alignAttr || {
                  x: a.attr("x"),
                  y: a.attr("y")
                };
                var h = a.parentGroup;
                a.width || (d = a.getBBox(), a.width = d.width, a.height = d.height, d = g.fontMetrics(null, a.element).h);
                var k = a.width - 2 * f;
                (c = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[a.alignValue]) ? e = +c * k : G(a.x) && Math.round(a.x) !== a.translateX && (e = a.x - a.translateX);
                return {
                  x: b.x + (h.translateX || 0) + f - (e || 0),
                  y: b.y + (h.translateY || 0) + f - d,
                  width: a.width - 2 * f,
                  height: a.height - 2 * f
                };
              }
            };

            for (l = 0; l < a; l++) {
              if (m = e[l]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = k(m);
            }

            e.sort(function (a, d) {
              return (d.labelrank || 0) - (a.labelrank || 0);
            });

            for (l = 0; l < a; l++) {
              var r = (k = e[l]) && k.absoluteBox;

              for (m = l + 1; m < a; ++m) {
                var x = (h = e[m]) && h.absoluteBox;
                !r || !x || k === h || 0 === k.newOpacity || 0 === h.newOpacity || x.x >= r.x + r.width || x.x + x.width <= r.x || x.y >= r.y + r.height || x.y + x.height <= r.y || ((k.labelrank < h.labelrank ? k : h).newOpacity = 0);
              }
            }

            e.forEach(function (a) {
              C(a, d) && (f = !0);
            });
            f && E(d, "afterHideAllOverlappingLabels");
          };
        });
        M(g, "Core/Responsive.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.extend,
              C = e.find,
              y = e.isArray,
              E = e.isObject,
              v = e.merge,
              G = e.objectEach,
              x = e.pick,
              r = e.splat,
              m = e.uniqueKey,
              d;

          (function (a) {
            var d = [];

            a.compose = function (a) {
              -1 === d.indexOf(a) && (d.push(a), g(a.prototype, e.prototype));
              return a;
            };

            var e = function () {
              function a() {}

              a.prototype.currentOptions = function (a) {
                function d(a, f, h, k) {
                  var g;
                  G(a, function (a, b) {
                    if (!k && -1 < e.collectionsWithUpdate.indexOf(b) && f[b]) for (a = r(a), h[b] = [], g = 0; g < Math.max(a.length, f[b].length); g++) {
                      f[b][g] && (void 0 === a[g] ? h[b][g] = f[b][g] : (h[b][g] = {}, d(a[g], f[b][g], h[b][g], k + 1)));
                    } else E(a) ? (h[b] = y(a) ? [] : {}, d(a, f[b] || {}, h[b], k + 1)) : h[b] = "undefined" === typeof f[b] ? null : f[b];
                  });
                }

                var e = this,
                    h = {};
                d(a, this.options, h, 0);
                return h;
              };

              a.prototype.matchResponsiveRule = function (a, d) {
                var f = a.condition;
                (f.callback || function () {
                  return this.chartWidth <= x(f.maxWidth, Number.MAX_VALUE) && this.chartHeight <= x(f.maxHeight, Number.MAX_VALUE) && this.chartWidth >= x(f.minWidth, 0) && this.chartHeight >= x(f.minHeight, 0);
                }).call(this) && d.push(a._id);
              };

              a.prototype.setResponsive = function (a, d) {
                var f = this,
                    e = this.options.responsive,
                    h = this.currentResponsive,
                    g = [];
                !d && e && e.rules && e.rules.forEach(function (a) {
                  "undefined" === typeof a._id && (a._id = m());
                  f.matchResponsiveRule(a, g);
                }, this);
                d = v.apply(void 0, g.map(function (a) {
                  return C((e || {}).rules || [], function (d) {
                    return d._id === a;
                  });
                }).map(function (a) {
                  return a && a.chartOptions;
                }));
                d.isResponsiveOptions = !0;
                g = g.toString() || void 0;
                g !== (h && h.ruleIds) && (h && this.update(h.undoOptions, a, !0), g ? (h = this.currentOptions(d), h.isResponsiveOptions = !0, this.currentResponsive = {
                  ruleIds: g,
                  mergedOptions: d,
                  undoOptions: h
                }, this.update(d, a, !0)) : this.currentResponsive = void 0);
              };

              return a;
            }();
          })(d || (d = {}));

          "";
          "";
          return d;
        });
        M(g, "masters/highcharts.src.js", [g["Core/Globals.js"], g["Core/Utilities.js"], g["Core/DefaultOptions.js"], g["Core/Animation/Fx.js"], g["Core/Animation/AnimationUtilities.js"], g["Core/Renderer/HTML/AST.js"], g["Core/FormatUtilities.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Renderer/HTML/HTMLElement.js"], g["Core/Renderer/HTML/HTMLRenderer.js"], g["Core/Axis/Axis.js"], g["Core/Axis/DateTimeAxis.js"], g["Core/Axis/LogarithmicAxis.js"], g["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], g["Core/Axis/Tick.js"], g["Core/Tooltip.js"], g["Core/Series/Point.js"], g["Core/Pointer.js"], g["Core/MSPointer.js"], g["Core/Legend/Legend.js"], g["Core/Chart/Chart.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Series/Column/ColumnSeries.js"], g["Series/Column/ColumnDataLabel.js"], g["Series/Pie/PieSeries.js"], g["Series/Pie/PieDataLabel.js"], g["Core/Series/DataLabel.js"], g["Core/Responsive.js"], g["Core/Color/Color.js"], g["Core/Time.js"]], function (e, g, C, y, E, v, G, x, r, m, d, a, p, B, l, h, f, k, J, K, t, Q, z, A, c, b, D, L, I, n, u, N, w) {
          e.animate = E.animate;
          e.animObject = E.animObject;
          e.getDeferredAnimation = E.getDeferredAnimation;
          e.setAnimation = E.setAnimation;
          e.stop = E.stop;
          e.timers = y.timers;
          e.AST = v;
          e.Axis = p;
          e.Chart = z;
          e.chart = z.chart;
          e.Fx = y;
          e.Legend = Q;
          e.PlotLineOrBand = h;
          e.Point = J;
          e.Pointer = t.isRequired() ? t : K;
          e.Series = A;
          e.SVGElement = r;
          e.SVGRenderer = m;
          e.Tick = f;
          e.Time = w;
          e.Tooltip = k;
          e.Color = N;
          e.color = N.parse;
          a.compose(m);
          d.compose(r);
          e.defaultOptions = C.defaultOptions;
          e.getOptions = C.getOptions;
          e.time = C.defaultTime;
          e.setOptions = C.setOptions;
          e.dateFormat = G.dateFormat;
          e.format = G.format;
          e.numberFormat = G.numberFormat;
          e.addEvent = g.addEvent;
          e.arrayMax = g.arrayMax;
          e.arrayMin = g.arrayMin;
          e.attr = g.attr;
          e.clearTimeout = g.clearTimeout;
          e.correctFloat = g.correctFloat;
          e.createElement = g.createElement;
          e.css = g.css;
          e.defined = g.defined;
          e.destroyObjectProperties = g.destroyObjectProperties;
          e.discardElement = g.discardElement;
          e.distribute = x.distribute;
          e.erase = g.erase;
          e.error = g.error;
          e.extend = g.extend;
          e.extendClass = g.extendClass;
          e.find = g.find;
          e.fireEvent = g.fireEvent;
          e.getMagnitude = g.getMagnitude;
          e.getStyle = g.getStyle;
          e.inArray = g.inArray;
          e.isArray = g.isArray;
          e.isClass = g.isClass;
          e.isDOMElement = g.isDOMElement;
          e.isFunction = g.isFunction;
          e.isNumber = g.isNumber;
          e.isObject = g.isObject;
          e.isString = g.isString;
          e.keys = g.keys;
          e.merge = g.merge;
          e.normalizeTickInterval = g.normalizeTickInterval;
          e.objectEach = g.objectEach;
          e.offset = g.offset;
          e.pad = g.pad;
          e.pick = g.pick;
          e.pInt = g.pInt;
          e.relativeLength = g.relativeLength;
          e.removeEvent = g.removeEvent;
          e.seriesType = c.seriesType;
          e.splat = g.splat;
          e.stableSort = g.stableSort;
          e.syncTimeout = g.syncTimeout;
          e.timeUnits = g.timeUnits;
          e.uniqueKey = g.uniqueKey;
          e.useSerialIds = g.useSerialIds;
          e.wrap = g.wrap;
          D.compose(b);
          n.compose(A);
          B.compose(p);
          l.compose(p);
          I.compose(L);
          h.compose(p);
          u.compose(z);
          return e;
        });
        M(g, "Series/XRange/XRangePoint.js", [g["Core/Series/Point.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = this && this.__extends || function () {
            var _e7 = function e(g, G) {
              _e7 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, g) {
                e.__proto__ = g;
              } || function (e, g) {
                for (var m in g) {
                  g.hasOwnProperty(m) && (e[m] = g[m]);
                }
              };

              return _e7(g, G);
            };

            return function (g, G) {
              function x() {
                this.constructor = g;
              }

              _e7(g, G);

              g.prototype = null === G ? Object.create(G) : (x.prototype = G.prototype, new x());
            };
          }();

          C = C.extend;

          g = function (g) {
            function v() {
              var e = null !== g && g.apply(this, arguments) || this;
              e.options = void 0;
              e.series = void 0;
              return e;
            }

            y(v, g);

            v.getColorByCategory = function (e, g) {
              var r = e.options.colors || e.chart.options.colors;
              e = g.y % (r ? r.length : e.chart.options.chart.colorCount);
              return {
                colorIndex: e,
                color: r && r[e]
              };
            };

            v.prototype.resolveColor = function () {
              var e = this.series;

              if (e.options.colorByPoint && !this.options.color) {
                var g = v.getColorByCategory(e, this);
                e.chart.styledMode || (this.color = g.color);
                this.options.colorIndex || (this.colorIndex = g.colorIndex);
              } else this.color || (this.color = e.color);
            };

            v.prototype.init = function () {
              e.prototype.init.apply(this, arguments);
              this.y || (this.y = 0);
              return this;
            };

            v.prototype.setState = function () {
              e.prototype.setState.apply(this, arguments);
              this.series.drawPoint(this, this.series.getAnimationVerb());
            };

            v.prototype.getLabelConfig = function () {
              var g = e.prototype.getLabelConfig.call(this),
                  x = this.series.yAxis.categories;
              g.x2 = this.x2;
              g.yCategory = this.yCategory = x && x[this.y];
              return g;
            };

            v.prototype.isValid = function () {
              return "number" === typeof this.x && "number" === typeof this.x2;
            };

            return v;
          }(g.seriesTypes.column.prototype.pointClass);

          C(g.prototype, {
            tooltipDateKeys: ["x", "x2"]
          });
          return g;
        });
        M(g, "Series/XRange/XRangeComposition.js", [g["Core/Axis/Axis.js"], g["Core/Utilities.js"]], function (e, g) {
          var C = g.addEvent,
              y = g.pick;
          C(e, "afterGetSeriesExtremes", function () {
            var e = this.series,
                g;

            if (this.isXAxis) {
              var G = y(this.dataMax, -Number.MAX_VALUE);
              e.forEach(function (e) {
                e.x2Data && e.x2Data.forEach(function (e) {
                  e > G && (G = e, g = !0);
                });
              });
              g && (this.dataMax = G);
            }
          });
        });
        M(g, "Series/XRange/XRangeSeries.js", [g["Core/Globals.js"], g["Core/Color/Color.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"], g["Series/XRange/XRangePoint.js"]], function (e, g, C, y, E) {
          var v = this && this.__extends || function () {
            var _a24 = function a(d, f) {
              _a24 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var f in d) {
                  d.hasOwnProperty(f) && (a[f] = d[f]);
                }
              };

              return _a24(d, f);
            };

            return function (d, f) {
              function e() {
                this.constructor = d;
              }

              _a24(d, f);

              d.prototype = null === f ? Object.create(f) : (e.prototype = f.prototype, new e());
            };
          }(),
              G = g.parse,
              x = C.series,
              r = C.seriesTypes.column,
              m = r.prototype,
              d = y.clamp,
              a = y.correctFloat,
              p = y.defined;

          g = y.extend;
          var B = y.find,
              l = y.isNumber,
              h = y.isObject,
              f = y.merge,
              k = y.pick;

          y = function (e) {
            function g() {
              var a = null !== e && e.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            v(g, e);

            g.prototype.init = function () {
              r.prototype.init.apply(this, arguments);
              this.options.stacking = void 0;
            };

            g.prototype.getColumnMetrics = function () {
              function a() {
                d.series.forEach(function (a) {
                  var c = a.xAxis;
                  a.xAxis = a.yAxis;
                  a.yAxis = c;
                });
              }

              var d = this.chart;
              a();
              var f = m.getColumnMetrics.call(this);
              a();
              return f;
            };

            g.prototype.cropData = function (a, d, f, e) {
              d = x.prototype.cropData.call(this, this.x2Data, d, f, e);
              d.xData = a.slice(d.start, d.end);
              return d;
            };

            g.prototype.findPointIndex = function (a) {
              var d = this.cropped,
                  f = this.cropStart,
                  e = this.points,
                  c = a.id;
              if (c) var b = (b = B(e, function (a) {
                return a.id === c;
              })) ? b.index : void 0;
              "undefined" === typeof b && (b = (b = B(e, function (b) {
                return b.x === a.x && b.x2 === a.x2 && !b.touched;
              })) ? b.index : void 0);
              d && l(b) && l(f) && b >= f && (b -= f);
              return b;
            };

            g.prototype.translatePoint = function (a) {
              var e = this.xAxis,
                  g = this.yAxis,
                  m = this.columnMetrics,
                  c = this.options,
                  b = c.minPointLength || 0,
                  t = (a.shapeArgs && a.shapeArgs.width || 0) / 2,
                  r = this.pointXOffset = m.offset,
                  B = a.plotX,
                  n = k(a.x2, a.x + (a.len || 0)),
                  u = e.translate(n, 0, 0, 0, 1);
              n = Math.abs(u - B);
              var N = this.chart.inverted,
                  w = k(c.borderWidth, 1) % 2 / 2,
                  H = m.offset,
                  O = Math.round(m.width);
              b && (b -= n, 0 > b && (b = 0), B -= b / 2, u += b / 2);
              B = Math.max(B, -10);
              u = d(u, -10, e.len + 10);
              p(a.options.pointWidth) && (H -= (Math.ceil(a.options.pointWidth) - O) / 2, O = Math.ceil(a.options.pointWidth));
              c.pointPlacement && l(a.plotY) && g.categories && (a.plotY = g.translate(a.y, 0, 1, 0, 1, c.pointPlacement));
              c = Math.floor(Math.min(B, u)) + w;
              c = {
                x: c,
                y: Math.floor(a.plotY + H) + w,
                width: Math.floor(Math.max(B, u)) + w - c,
                height: O,
                r: this.options.borderRadius
              };
              a.shapeArgs = c;
              N ? a.tooltipPos[1] += r + t : a.tooltipPos[0] -= t + r - c.width / 2;
              t = c.x;
              r = t + c.width;
              0 > t || r > e.len ? (t = d(t, 0, e.len), r = d(r, 0, e.len), u = r - t, a.dlBox = f(c, {
                x: t,
                width: r - t,
                centerX: u ? u / 2 : null
              })) : a.dlBox = null;
              t = a.tooltipPos;
              r = N ? 1 : 0;
              u = N ? 0 : 1;
              m = this.columnMetrics ? this.columnMetrics.offset : -m.width / 2;
              t[r] = N ? t[r] + c.width / 2 : t[r] + (e.reversed ? -1 : 0) * c.width;
              t[u] = d(t[u] + (N ? -1 : 1) * m, 0, g.len - 1);
              if (g = a.partialFill) h(g) && (g = g.amount), l(g) || (g = 0), a.partShapeArgs = f(c, {
                r: this.options.borderRadius
              }), B = Math.max(Math.round(n * g + a.plotX - B), 0), a.clipRectArgs = {
                x: e.reversed ? c.x + n - B : c.x,
                y: c.y,
                width: B,
                height: c.height
              };
            };

            g.prototype.translate = function () {
              m.translate.apply(this, arguments);
              this.points.forEach(function (a) {
                this.translatePoint(a);
              }, this);
            };

            g.prototype.drawPoint = function (a, d) {
              var e = this.options,
                  g = this.chart.renderer,
                  c = a.graphic,
                  b = a.shapeType,
                  l = a.shapeArgs,
                  m = a.partShapeArgs,
                  t = a.clipRectArgs,
                  n = a.partialFill,
                  p = e.stacking && !e.borderRadius,
                  r = a.state,
                  w = e.states[r || "normal"] || {},
                  H = "undefined" === typeof r ? "attr" : d;
              r = this.pointAttribs(a, r);
              w = k(this.chart.options.chart.animation, w.animation);
              if (a.isNull || !1 === a.visible) c && (a.graphic = c.destroy());else {
                if (c) c.rect[d](l);else a.graphic = c = g.g("point").addClass(a.getClassName()).add(a.group || this.group), c.rect = g[b](f(l)).addClass(a.getClassName()).addClass("highcharts-partfill-original").add(c);
                m && (c.partRect ? (c.partRect[d](f(m)), c.partialClipRect[d](f(t))) : (c.partialClipRect = g.clipRect(t.x, t.y, t.width, t.height), c.partRect = g[b](m).addClass("highcharts-partfill-overlay").add(c).clip(c.partialClipRect)));
                this.chart.styledMode || (c.rect[d](r, w).shadow(e.shadow, null, p), m && (h(n) || (n = {}), h(e.partialFill) && (n = f(e.partialFill, n)), a = n.fill || G(r.fill).brighten(-.3).get() || G(a.color || this.color).brighten(-.3).get(), r.fill = a, c.partRect[H](r, w).shadow(e.shadow, null, p)));
              }
            };

            g.prototype.drawPoints = function () {
              var a = this,
                  d = a.getAnimationVerb();
              a.points.forEach(function (f) {
                a.drawPoint(f, d);
              });
            };

            g.prototype.getAnimationVerb = function () {
              return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
            };

            g.prototype.isPointInside = function (a) {
              var d = a.shapeArgs,
                  f = a.plotX,
                  h = a.plotY;
              return d ? "undefined" !== typeof f && "undefined" !== typeof h && 0 <= h && h <= this.yAxis.len && 0 <= (d.x || 0) + (d.width || 0) && f <= this.xAxis.len : e.prototype.isPointInside.apply(this, arguments);
            };

            g.defaultOptions = f(r.defaultOptions, {
              colorByPoint: !0,
              dataLabels: {
                formatter: function formatter() {
                  var d = this.point.partialFill;
                  h(d) && (d = d.amount);
                  if (l(d) && 0 < d) return a(100 * d) + "%";
                },
                inside: !0,
                verticalAlign: "middle"
              },
              tooltip: {
                headerFormat: '<span style="font-size: 10px">{point.x} - {point.x2}</span><br/>',
                pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>"
              },
              borderRadius: 3,
              pointRange: 0
            });
            return g;
          }(r);

          g(y.prototype, {
            type: "xrange",
            parallelArrays: ["x", "x2", "y"],
            requireSorting: !1,
            animate: x.prototype.animate,
            cropShoulder: 1,
            getExtremesFromAll: !0,
            autoIncrement: e.noop,
            buildKDTree: e.noop,
            pointClass: E
          });
          C.registerSeriesType("xrange", y);
          "";
          return y;
        });
        M(g, "Series/Gantt/GanttPoint.js", [g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g) {
          var C = this && this.__extends || function () {
            var _e8 = function e(g, G) {
              _e8 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (e, g) {
                e.__proto__ = g;
              } || function (e, g) {
                for (var m in g) {
                  g.hasOwnProperty(m) && (e[m] = g[m]);
                }
              };

              return _e8(g, G);
            };

            return function (g, G) {
              function x() {
                this.constructor = g;
              }

              _e8(g, G);

              g.prototype = null === G ? Object.create(G) : (x.prototype = G.prototype, new x());
            };
          }(),
              y = g.pick;

          return function (e) {
            function g() {
              var g = null !== e && e.apply(this, arguments) || this;
              g.options = void 0;
              g.series = void 0;
              return g;
            }

            C(g, e);

            g.setGanttPointAliases = function (e) {
              function g(g, m) {
                "undefined" !== typeof m && (e[g] = m);
              }

              g("x", y(e.start, e.x));
              g("x2", y(e.end, e.x2));
              g("partialFill", y(e.completed, e.partialFill));
            };

            g.prototype.applyOptions = function (v, x) {
              v = e.prototype.applyOptions.call(this, v, x);
              g.setGanttPointAliases(v);
              return v;
            };

            g.prototype.isValid = function () {
              return ("number" === typeof this.start || "number" === typeof this.x) && ("number" === typeof this.end || "number" === typeof this.x2 || this.milestone);
            };

            return g;
          }(e.seriesTypes.xrange.prototype.pointClass);
        });
        M(g, "Core/Axis/BrokenAxis.js", [g["Extensions/Stacking.js"], g["Core/Utilities.js"]], function (e, g) {
          var C = g.addEvent,
              y = g.find,
              E = g.fireEvent,
              v = g.isArray,
              G = g.isNumber,
              x = g.pick,
              r;

          (function (g) {
            function d() {
              "undefined" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);
            }

            function a() {
              this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);
            }

            function m() {
              var a = this.brokenAxis;

              if (a && a.hasBreaks) {
                for (var d = this.tickPositions, f = this.tickPositions.info, e = [], c = 0; c < d.length; c++) {
                  a.isInAnyBreak(d[c]) || e.push(d[c]);
                }

                this.tickPositions = e;
                this.tickPositions.info = f;
              }
            }

            function r() {
              this.brokenAxis || (this.brokenAxis = new K(this));
            }

            function l() {
              var a = this.options.connectNulls,
                  d = this.points,
                  f = this.xAxis,
                  e = this.yAxis;
              if (this.isDirty) for (var c = d.length; c--;) {
                var b = d[c],
                    h = !(null === b.y && !1 === a) && (f && f.brokenAxis && f.brokenAxis.isInAnyBreak(b.x, !0) || e && e.brokenAxis && e.brokenAxis.isInAnyBreak(b.y, !0));
                b.visible = h ? !1 : !1 !== b.options.visible;
              }
            }

            function h() {
              this.drawBreaks(this.xAxis, ["x"]);
              this.drawBreaks(this.yAxis, x(this.pointArrayMap, ["y"]));
            }

            function f(a, d) {
              var f = this,
                  e = f.points,
                  c,
                  b,
                  h,
                  k;

              if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {
                var g = a.brokenAxis;
                d.forEach(function (d) {
                  c = g && g.breakArray || [];
                  b = a.isXAxis ? a.min : x(f.options.threshold, a.min);
                  e.forEach(function (f) {
                    k = x(f["stack" + d.toUpperCase()], f[d]);
                    c.forEach(function (c) {
                      if (G(b) && G(k)) {
                        h = !1;
                        if (b < c.from && k > c.to || b > c.from && k < c.from) h = "pointBreak";else if (b < c.from && k > c.from && k < c.to || b > c.from && k > c.to && k < c.from) h = "pointInBreak";
                        h && E(a, h, {
                          point: f,
                          brk: c
                        });
                      }
                    });
                  });
                });
              }
            }

            function k() {
              var a = this.currentDataGrouping,
                  d = a && a.gapSize;
              a = this.points.slice();
              var f = this.yAxis,
                  h = this.options.gapSize,
                  c = a.length - 1,
                  b;
              if (h && 0 < c) for ("value" !== this.options.gapUnit && (h *= this.basePointRange), d && d > h && d >= this.basePointRange && (h = d), b = void 0; c--;) {
                b && !1 !== b.visible || (b = a[c + 1]), d = a[c], !1 !== b.visible && !1 !== d.visible && (b.x - d.x > h && (b = (d.x + b.x) / 2, a.splice(c + 1, 0, {
                  isNull: !0,
                  x: b
                }), f.stacking && this.options.stacking && (b = f.stacking.stacks[this.stackKey][b] = new e(f, f.options.stackLabels, !1, b, this.stack), b.total = 0)), b = d);
              }
              return this.getGraphPath(a);
            }

            var J = [];

            g.compose = function (e, g) {
              -1 === J.indexOf(e) && (J.push(e), e.keepProps.push("brokenAxis"), C(e, "init", r), C(e, "afterInit", d), C(e, "afterSetTickPositions", m), C(e, "afterSetOptions", a));

              if (-1 === J.indexOf(g)) {
                J.push(g);
                var t = g.prototype;
                t.drawBreaks = f;
                t.gappedPath = k;
                C(g, "afterGeneratePoints", l);
                C(g, "afterRender", h);
              }

              return e;
            };

            var K = function () {
              function a(a) {
                this.hasBreaks = !1;
                this.axis = a;
              }

              a.isInBreak = function (a, d) {
                var f = a.repeat || Infinity,
                    c = a.from,
                    b = a.to - a.from;
                d = d >= c ? (d - c) % f : f - (c - d) % f;
                return a.inclusive ? d <= b : d < b && 0 !== d;
              };

              a.lin2Val = function (d) {
                var f = this.brokenAxis;
                f = f && f.breakArray;
                if (!f || !G(d)) return d;
                var e;

                for (e = 0; e < f.length; e++) {
                  var c = f[e];
                  if (c.from >= d) break;else c.to < d ? d += c.len : a.isInBreak(c, d) && (d += c.len);
                }

                return d;
              };

              a.val2Lin = function (d) {
                var f = this.brokenAxis;
                f = f && f.breakArray;
                if (!f || !G(d)) return d;
                var e = d,
                    c;

                for (c = 0; c < f.length; c++) {
                  var b = f[c];
                  if (b.to <= d) e -= b.len;else if (b.from >= d) break;else if (a.isInBreak(b, d)) {
                    e -= d - b.from;
                    break;
                  }
                }

                return e;
              };

              a.prototype.findBreakAt = function (a, d) {
                return y(d, function (d) {
                  return d.from < a && a < d.to;
                });
              };

              a.prototype.isInAnyBreak = function (d, f) {
                var e = this.axis,
                    c = e.options.breaks || [],
                    b = c.length,
                    h;

                if (b && G(d)) {
                  for (; b--;) {
                    if (a.isInBreak(c[b], d)) {
                      var k = !0;
                      h || (h = x(c[b].showPoints, !e.isXAxis));
                    }
                  }

                  var g = k && f ? k && !h : k;
                }

                return g;
              };

              a.prototype.setBreaks = function (d, f) {
                var e = this,
                    c = e.axis,
                    b = v(d) && !!d.length;
                c.isDirty = e.hasBreaks !== b;
                e.hasBreaks = b;
                c.options.breaks = c.userOptions.breaks = d;
                c.forceRedraw = !0;
                c.series.forEach(function (a) {
                  a.isDirty = !0;
                });
                b || c.val2lin !== a.val2Lin || (delete c.val2lin, delete c.lin2val);
                b && (c.userOptions.ordinal = !1, c.lin2val = a.lin2Val, c.val2lin = a.val2Lin, c.setExtremes = function (a, b, d, f, h) {
                  if (e.hasBreaks) {
                    for (var k = this.options.breaks || [], g; g = e.findBreakAt(a, k);) {
                      a = g.to;
                    }

                    for (; g = e.findBreakAt(b, k);) {
                      b = g.from;
                    }

                    b < a && (b = a);
                  }

                  c.constructor.prototype.setExtremes.call(this, a, b, d, f, h);
                }, c.setAxisTranslation = function () {
                  c.constructor.prototype.setAxisTranslation.call(this);
                  e.unitLength = void 0;

                  if (e.hasBreaks) {
                    var b = c.options.breaks || [],
                        d = [],
                        f = [],
                        h = x(c.pointRangePadding, 0),
                        k = 0,
                        g,
                        l = c.userMin || c.min,
                        m = c.userMax || c.max,
                        p;
                    b.forEach(function (b) {
                      g = b.repeat || Infinity;
                      G(l) && G(m) && (a.isInBreak(b, l) && (l += b.to % g - l % g), a.isInBreak(b, m) && (m -= m % g - b.from % g));
                    });
                    b.forEach(function (a) {
                      q = a.from;
                      g = a.repeat || Infinity;

                      if (G(l) && G(m)) {
                        for (; q - g > l;) {
                          q -= g;
                        }

                        for (; q < l;) {
                          q += g;
                        }

                        for (p = q; p < m; p += g) {
                          d.push({
                            value: p,
                            move: "in"
                          }), d.push({
                            value: p + a.to - a.from,
                            move: "out",
                            size: a.breakSize
                          });
                        }
                      }
                    });
                    d.sort(function (a, b) {
                      return a.value === b.value ? ("in" === a.move ? 0 : 1) - ("in" === b.move ? 0 : 1) : a.value - b.value;
                    });
                    var t = 0;
                    var q = l;
                    d.forEach(function (a) {
                      t += "in" === a.move ? 1 : -1;
                      1 === t && "in" === a.move && (q = a.value);
                      0 === t && G(q) && (f.push({
                        from: q,
                        to: a.value,
                        len: a.value - q - (a.size || 0)
                      }), k += a.value - q - (a.size || 0));
                    });
                    e.breakArray = f;
                    G(l) && G(m) && G(c.min) && (e.unitLength = m - l - k + h, E(c, "afterBreaks"), c.staticScale ? c.transA = c.staticScale : e.unitLength && (c.transA *= (m - c.min + h) / e.unitLength), h && (c.minPixelPadding = c.transA * (c.minPointOffset || 0)), c.min = l, c.max = m);
                  }
                });
                x(f, !0) && c.chart.redraw();
              };

              return a;
            }();

            g.Additions = K;
          })(r || (r = {}));

          return r;
        });
        M(g, "Core/Axis/GridAxis.js", [g["Core/Axis/Axis.js"], g["Core/Axis/AxisDefaults.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var E = C.dateFormats,
              v = y.addEvent,
              G = y.defined,
              x = y.erase,
              r = y.find,
              m = y.isArray,
              d = y.isNumber,
              a = y.merge,
              p = y.pick,
              B = y.timeUnits,
              l = y.wrap,
              h;

          (function (f) {
            function h(a, b) {
              var c = {
                width: 0,
                height: 0
              };
              b.forEach(function (b) {
                b = a[b];

                if (y.isObject(b, !0)) {
                  var f = y.isObject(b.label, !0) ? b.label : {};
                  b = f.getBBox ? f.getBBox().height : 0;
                  f.textStr && !d(f.textPxLength) && (f.textPxLength = f.getBBox().width);
                  var e = d(f.textPxLength) ? Math.round(f.textPxLength) : 0;
                  f.textStr && (e = Math.round(f.getBBox().width));
                  c.height = Math.max(b, c.height);
                  c.width = Math.max(e, c.width);
                }
              });
              "treegrid" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode && (c.width += this.options.labels.indentation * ((this.treeGrid.mapOfPosToGridNode[-1].height || 0) - 1));
              return c;
            }

            function J() {
              var a = this.grid;
              (a && a.columns || []).forEach(function (a) {
                a.getOffset();
              });
            }

            function E(a) {
              if (!0 === (this.options.grid || {}).enabled) {
                var b = this.axisTitle,
                    c = this.height,
                    d = this.horiz,
                    e = this.left,
                    h = this.offset,
                    k = this.opposite,
                    g = this.options,
                    l = this.top,
                    n = this.width,
                    m = this.tickSize(),
                    w = b && b.getBBox().width,
                    t = g.title.x,
                    r = g.title.y,
                    u = p(g.title.margin, d ? 5 : 10);
                b = this.chart.renderer.fontMetrics(g.title.style.fontSize, b).f;
                m = (d ? l + c : e) + (d ? 1 : -1) * (k ? -1 : 1) * (m ? m[0] / 2 : 0) + (this.side === f.Side.bottom ? b : 0);
                a.titlePosition.x = d ? e - (w || 0) / 2 - u + t : m + (k ? n : 0) + h + t;
                a.titlePosition.y = d ? m - (k ? c : 0) + (k ? b : -b) / 2 + h + r : l - u + r;
              }
            }

            function t() {
              var b = this.chart,
                  c = this.options.grid;
              c = void 0 === c ? {} : c;
              var d = this.userOptions;

              if (c.enabled) {
                var f = this.options;
                f.labels.align = p(f.labels.align, "center");
                this.categories || (f.showLastLabel = !1);
                this.labelRotation = 0;
                f.labels.rotation = 0;
              }

              if (c.columns) {
                f = this.grid.columns = [];

                for (var h = this.grid.columnIndex = 0; ++h < c.columns.length;) {
                  var k = a(d, c.columns[c.columns.length - h - 1], {
                    linkedTo: 0,
                    type: "category",
                    scrollbar: {
                      enabled: !1
                    }
                  });
                  delete k.grid.columns;
                  k = new e(this.chart, k);
                  k.grid.isColumn = !0;
                  k.grid.columnIndex = h;
                  x(b.axes, k);
                  x(b[this.coll], k);
                  f.push(k);
                }
              }
            }

            function Q() {
              var a = this.grid,
                  b = this.options;

              if (!0 === (b.grid || {}).enabled) {
                var c = this.min || 0,
                    d = this.max || 0;
                this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions);
                this.rightWall && this.rightWall.destroy();

                if (this.grid && this.grid.isOuterAxis() && this.axisLine) {
                  var e = b.lineWidth;

                  if (e) {
                    e = this.getLinePath(e);
                    var h = e[0],
                        k = e[1],
                        g = ((this.tickSize("tick") || [1])[0] - 1) * (this.side === f.Side.top || this.side === f.Side.left ? -1 : 1);
                    "M" === h[0] && "L" === k[0] && (this.horiz ? (h[2] += g, k[2] += g) : (h[1] += g, k[1] += g));
                    !this.horiz && this.chart.marginRight && (h = [h, ["L", this.left, h[2] || 0]], g = ["L", this.chart.chartWidth - this.chart.marginRight, this.toPixels(d + this.tickmarkOffset)], k = [["M", k[1] || 0, this.toPixels(d + this.tickmarkOffset)], g], this.grid.upperBorder || 0 === c % 1 || (this.grid.upperBorder = this.grid.renderBorder(h)), this.grid.upperBorder && (this.grid.upperBorder.attr({
                      stroke: b.lineColor,
                      "stroke-width": b.lineWidth
                    }), this.grid.upperBorder.animate({
                      d: h
                    })), this.grid.lowerBorder || 0 === d % 1 || (this.grid.lowerBorder = this.grid.renderBorder(k)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({
                      stroke: b.lineColor,
                      "stroke-width": b.lineWidth
                    }), this.grid.lowerBorder.animate({
                      d: k
                    })));
                    this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({
                      stroke: b.lineColor,
                      "stroke-width": b.lineWidth
                    }), this.grid.axisLineExtra.animate({
                      d: e
                    })) : this.grid.axisLineExtra = this.grid.renderBorder(e);
                    this.axisLine[this.showAxis ? "show" : "hide"](!0);
                  }
                }

                (a && a.columns || []).forEach(function (a) {
                  a.render();
                });

                if (!this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar)) {
                  a = this.tickmarkOffset;
                  b = this.tickPositions[this.tickPositions.length - 1];
                  e = this.tickPositions[0];

                  for (k = void 0; (k = this.hiddenLabels.pop()) && k.element;) {
                    k.show();
                  }

                  (k = this.ticks[e].label) && (c - e > a ? this.hiddenLabels.push(k.hide()) : k.show());
                  (k = this.ticks[b].label) && (b - d > a ? this.hiddenLabels.push(k.hide()) : k.show());
                  (c = this.ticks[b].mark) && (b - d < a && 0 < b - d && this.ticks[b].isLast ? c.hide() : this.ticks[b - 1] && c.show());
                }
              }
            }

            function z() {
              var a = this.tickPositions && this.tickPositions.info,
                  b = this.options,
                  c = this.userOptions.labels || {};
              (b.grid || {}).enabled && (this.horiz ? (this.series.forEach(function (a) {
                a.options.pointRange = 0;
              }), a && b.dateTimeLabelFormats && b.labels && !G(c.align) && (!1 === b.dateTimeLabelFormats[a.unitName].range || 1 < a.count) && (b.labels.align = "left", G(c.x) || (b.labels.x = 3))) : "treegrid" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));
            }

            function A(b) {
              var c = this.options;
              b = b.userOptions;
              var f = c && y.isObject(c.grid, !0) ? c.grid : {};

              if (!0 === f.enabled) {
                var e = a(!0, {
                  className: "highcharts-grid-axis " + (b.className || ""),
                  dateTimeLabelFormats: {
                    hour: {
                      list: ["%H:%M", "%H"]
                    },
                    day: {
                      list: ["%A, %e. %B", "%a, %e. %b", "%E"]
                    },
                    week: {
                      list: ["Week %W", "W%W"]
                    },
                    month: {
                      list: ["%B", "%b", "%o"]
                    }
                  },
                  grid: {
                    borderWidth: 1
                  },
                  labels: {
                    padding: 2,
                    style: {
                      fontSize: "13px"
                    }
                  },
                  margin: 0,
                  title: {
                    text: null,
                    reserveSpace: !1,
                    rotation: 0
                  },
                  units: [["millisecond", [1, 10, 100]], ["second", [1, 10]], ["minute", [1, 5, 15]], ["hour", [1, 6]], ["day", [1]], ["week", [1]], ["month", [1]], ["year", null]]
                }, b);
                "xAxis" === this.coll && (G(b.linkedTo) && !G(b.tickPixelInterval) && (e.tickPixelInterval = 350), G(b.tickPixelInterval) || !G(b.linkedTo) || G(b.tickPositioner) || G(b.tickInterval) || (e.tickPositioner = function (a, b) {
                  var c = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;

                  if (c) {
                    for (var d = e.units || [], f = void 0, h = void 0, k = void 0, g = 0; g < d.length; g++) {
                      if (d[g][0] === c.unitName) {
                        f = g;
                        break;
                      }
                    }

                    d[f + 1] ? (k = d[f + 1][0], h = (d[f + 1][1] || [1])[0]) : "year" === c.unitName && (k = "year", h = 10 * c.count);
                    c = B[k];
                    this.tickInterval = c * h;
                    return this.getTimeTicks({
                      unitRange: c,
                      count: h,
                      unitName: k
                    }, a, b, this.options.startOfWeek);
                  }
                }));
                a(!0, this.options, e);
                this.horiz && (c.minPadding = p(b.minPadding, 0), c.maxPadding = p(b.maxPadding, 0));
                d(c.grid.borderWidth) && (c.tickWidth = c.lineWidth = f.borderWidth);
              }
            }

            function c(b) {
              b = (b = b.userOptions) && b.grid || {};
              var c = b.columns;
              b.enabled && c && a(!0, this.options, c[c.length - 1]);
            }

            function b() {
              (this.grid.columns || []).forEach(function (a) {
                a.setScale();
              });
            }

            function D(a) {
              var b = g.defaultLeftAxisOptions,
                  c = this.horiz,
                  d = this.maxLabelDimensions,
                  f = this.options.grid;
              f = void 0 === f ? {} : f;
              f.enabled && d && (b = 2 * Math.abs(b.labels.x), c = c ? f.cellHeight || b + d.height : b + d.width, m(a.tickSize) ? a.tickSize[0] = c : a.tickSize = [c, 0]);
            }

            function L() {
              this.axes.forEach(function (a) {
                (a.grid && a.grid.columns || []).forEach(function (a) {
                  a.setAxisSize();
                  a.setAxisTranslation();
                });
              });
            }

            function I(a) {
              var b = this.grid;
              (b.columns || []).forEach(function (b) {
                b.destroy(a.keepEvents);
              });
              b.columns = void 0;
            }

            function n(a) {
              a = a.userOptions || {};
              var b = a.grid || {};
              b.enabled && G(b.borderColor) && (a.tickColor = a.lineColor = b.borderColor);
              this.grid || (this.grid = new O(this));
              this.hiddenLabels = [];
            }

            function u(a) {
              var b = this.label,
                  c = this.axis,
                  e = c.reversed,
                  h = c.chart,
                  k = c.options.grid || {},
                  g = c.options.labels,
                  l = g.align,
                  n = f.Side[c.side],
                  m = a.tickmarkOffset,
                  w = c.tickPositions,
                  p = this.pos - m;
              w = d(w[a.index + 1]) ? w[a.index + 1] - m : (c.max || 0) + m;
              var t = c.tickSize("tick");
              m = t ? t[0] : 0;
              t = t ? t[1] / 2 : 0;

              if (!0 === k.enabled) {
                if ("top" === n) {
                  k = c.top + c.offset;
                  var r = k - m;
                } else "bottom" === n ? (r = h.chartHeight - c.bottom + c.offset, k = r + m) : (k = c.top + c.len - (c.translate(e ? w : p) || 0), r = c.top + c.len - (c.translate(e ? p : w) || 0));

                "right" === n ? (n = h.chartWidth - c.right + c.offset, e = n + m) : "left" === n ? (e = c.left + c.offset, n = e - m) : (n = Math.round(c.left + (c.translate(e ? w : p) || 0)) - t, e = Math.min(Math.round(c.left + (c.translate(e ? p : w) || 0)) - t, c.left + c.len));
                this.slotWidth = e - n;
                a.pos.x = "left" === l ? n : "right" === l ? e : n + (e - n) / 2;
                a.pos.y = r + (k - r) / 2;
                h = h.renderer.fontMetrics(g.style.fontSize, b && b.element);
                b = b ? b.getBBox().height : 0;
                g.useHTML ? a.pos.y += h.b + -(b / 2) : (b = Math.round(b / h.h), a.pos.y += (h.b - (h.h - h.f)) / 2 + -((b - 1) * h.h / 2));
                a.pos.x += c.horiz && g.x || 0;
              }
            }

            function N(b) {
              var c = b.axis,
                  d = b.value;

              if (c.options.grid && c.options.grid.enabled) {
                var f = c.tickPositions,
                    e = (c.linkedParent || c).series[0],
                    h = d === f[0];
                f = d === f[f.length - 1];
                var k = e && r(e.options.data, function (a) {
                  return a[c.isXAxis ? "x" : "y"] === d;
                }),
                    g = void 0;
                k && e.is("gantt") && (g = a(k), C.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(g));
                b.isFirst = h;
                b.isLast = f;
                b.point = g;
              }
            }

            function w() {
              var a = this.options,
                  b = this.categories,
                  c = this.tickPositions,
                  d = c[0],
                  f = c[c.length - 1],
                  e = this.linkedParent && this.linkedParent.min || this.min,
                  h = this.linkedParent && this.linkedParent.max || this.max,
                  k = this.tickInterval;
              !0 !== (a.grid || {}).enabled || b || !this.horiz && !this.isLinked || (d < e && d + k > e && !a.startOnTick && (c[0] = e), f > h && f - k < h && !a.endOnTick && (c[c.length - 1] = h));
            }

            function H(a) {
              var b = this.options.grid;
              return !0 === (void 0 === b ? {} : b).enabled && this.categories ? this.tickInterval : a.apply(this, Array.prototype.slice.call(arguments, 1));
            }

            (function (a) {
              a[a.top = 0] = "top";
              a[a.right = 1] = "right";
              a[a.bottom = 2] = "bottom";
              a[a.left = 3] = "left";
            })(f.Side || (f.Side = {}));

            f.compose = function (a, d, f) {
              -1 === a.keepProps.indexOf("grid") && (a.keepProps.push("grid"), a.prototype.getMaxLabelDimensions = h, l(a.prototype, "unsquish", H), v(a, "init", n), v(a, "afterGetOffset", J), v(a, "afterGetTitlePosition", E), v(a, "afterInit", t), v(a, "afterRender", Q), v(a, "afterSetAxisTranslation", z), v(a, "afterSetOptions", A), v(a, "afterSetOptions", c), v(a, "afterSetScale", b), v(a, "afterTickSize", D), v(a, "trimTicks", w), v(a, "destroy", I));
              v(d, "afterSetChartSize", L);
              v(f, "afterGetLabelPosition", u);
              v(f, "labelFormat", N);
              return a;
            };

            var O = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.isOuterAxis = function () {
                var a = this.axis,
                    b = a.grid.columnIndex,
                    c = a.linkedParent && a.linkedParent.grid.columns || a.grid.columns,
                    f = b ? a.linkedParent : a,
                    e = -1,
                    h = 0;
                a.chart[a.coll].forEach(function (b, c) {
                  b.side !== a.side || b.options.isInternal || (h = c, b === f && (e = c));
                });
                return h === e && (d(b) ? c.length === b : !0);
              };

              a.prototype.renderBorder = function (a) {
                var b = this.axis,
                    c = b.chart.renderer,
                    d = b.options;
                a = c.path(a).addClass("highcharts-axis-line").add(b.axisBorder);
                c.styledMode || a.attr({
                  stroke: d.lineColor,
                  "stroke-width": d.lineWidth,
                  zIndex: 7
                });
                return a;
              };

              return a;
            }();

            f.Additions = O;
          })(h || (h = {}));

          E.E = function (a) {
            return this.dateFormat("%a", a, !0).charAt(0);
          };

          E.W = function (a) {
            a = new this.Date(a);
            var d = (this.get("Day", a) + 6) % 7,
                f = new this.Date(a.valueOf());
            this.set("Date", f, this.get("Date", a) - d + 3);
            d = new this.Date(this.get("FullYear", f), 0, 1);
            4 !== this.get("Day", d) && (this.set("Month", a, 0), this.set("Date", a, 1 + (11 - this.get("Day", d)) % 7));
            return (1 + Math.floor((f.valueOf() - d.valueOf()) / 6048E5)).toString();
          };

          "";
          return h;
        });
        M(g, "Gantt/Tree.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.extend,
              C = e.isNumber,
              y = e.pick,
              E = function E(e, g) {
            var r = e.reduce(function (e, d) {
              var a = y(d.parent, "");
              "undefined" === typeof e[a] && (e[a] = []);
              e[a].push(d);
              return e;
            }, {});
            Object.keys(r).forEach(function (e, d) {
              var a = r[e];
              "" !== e && -1 === g.indexOf(e) && (a.forEach(function (a) {
                d[""].push(a);
              }), delete d[e]);
            });
            return r;
          },
              v = function v(e, x, r, m, d, a) {
            var p = 0,
                B = 0,
                l = a && a.after,
                h = a && a.before;
            x = {
              data: m,
              depth: r - 1,
              id: e,
              level: r,
              parent: x
            };
            var f, k;
            "function" === typeof h && h(x, a);
            h = (d[e] || []).map(function (h) {
              var g = v(h.id, e, r + 1, h, d, a),
                  l = h.start;
              h = !0 === h.milestone ? l : h.end;
              f = !C(f) || l < f ? l : f;
              k = !C(k) || h > k ? h : k;
              p = p + 1 + g.descendants;
              B = Math.max(g.height + 1, B);
              return g;
            });
            m && (m.start = y(m.start, f), m.end = y(m.end, k));
            g(x, {
              children: h,
              descendants: p,
              height: B
            });
            "function" === typeof l && l(x, a);
            return x;
          };

          return {
            getListOfParents: E,
            getNode: v,
            getTree: function getTree(e, g) {
              var r = e.map(function (e) {
                return e.id;
              });
              e = E(e, r);
              return v("", null, 1, null, e, g);
            }
          };
        });
        M(g, "Core/Axis/TreeGridTick.js", [g["Core/Color/Palette.js"], g["Core/Utilities.js"]], function (e, g) {
          var C = g.addEvent,
              y = g.isObject,
              E = g.isNumber,
              v = g.pick,
              G = g.wrap,
              x;

          (function (g) {
            function m() {
              this.treeGrid || (this.treeGrid = new l(this));
            }

            function d(a, d) {
              a = a.treeGrid;
              var f = !a.labelIcon,
                  h = d.renderer,
                  g = d.xy,
                  l = d.options,
                  m = l.width || 0,
                  p = l.height || 0,
                  r = g.x - m / 2 - (l.padding || 0);
              g = g.y - p / 2;
              var c = d.collapsed ? 90 : 180,
                  b = d.show && E(g),
                  B = a.labelIcon;
              B || (a.labelIcon = B = h.path(h.symbols[l.type](l.x || 0, l.y || 0, m, p)).addClass("highcharts-label-icon").add(d.group));
              B.attr({
                y: b ? 0 : -9999
              });
              h.styledMode || B.attr({
                cursor: "pointer",
                fill: v(d.color, e.neutralColor60),
                "stroke-width": 1,
                stroke: l.lineColor,
                strokeWidth: l.lineWidth || 0
              });
              B[f ? "attr" : "animate"]({
                translateX: r,
                translateY: g,
                rotation: c
              });
            }

            function a(a, d, e, g, l, m, p, r, B) {
              var c = v(this.options && this.options.labels, m);
              m = this.pos;
              var b = this.axis,
                  f = "treegrid" === b.options.type;
              a = a.apply(this, [d, e, g, l, c, p, r, B]);
              f && (d = c && y(c.symbol, !0) ? c.symbol : {}, c = c && E(c.indentation) ? c.indentation : 0, m = (m = (b = b.treeGrid.mapOfPosToGridNode) && b[m]) && m.depth || 1, a.x += (d.width || 0) + 2 * (d.padding || 0) + (m - 1) * c);
              return a;
            }

            function p(a) {
              var f = this,
                  e = f.pos,
                  h = f.axis,
                  g = f.label,
                  l = h.treeGrid.mapOfPosToGridNode,
                  m = h.options,
                  p = v(f.options && f.options.labels, m && m.labels),
                  r = p && y(p.symbol, !0) ? p.symbol : {},
                  c = (l = l && l[e]) && l.depth;
              m = "treegrid" === m.type;
              var b = -1 < h.tickPositions.indexOf(e);
              e = h.chart.styledMode;
              m && l && g && g.element && g.addClass("highcharts-treegrid-node-level-" + c);
              a.apply(f, Array.prototype.slice.call(arguments, 1));
              m && g && g.element && l && l.descendants && 0 < l.descendants && (h = h.treeGrid.isCollapsed(l), d(f, {
                color: !e && g.styles && g.styles.color || "",
                collapsed: h,
                group: g.parentGroup,
                options: r,
                renderer: g.renderer,
                show: b,
                xy: g.xy
              }), r = "highcharts-treegrid-node-" + (h ? "expanded" : "collapsed"), g.addClass("highcharts-treegrid-node-" + (h ? "collapsed" : "expanded")).removeClass(r), e || g.css({
                cursor: "pointer"
              }), [g, f.treeGrid.labelIcon].forEach(function (a) {
                a && !a.attachedTreeGridEvents && (C(a.element, "mouseover", function () {
                  g.addClass("highcharts-treegrid-node-active");
                  g.renderer.styledMode || g.css({
                    textDecoration: "underline"
                  });
                }), C(a.element, "mouseout", function () {
                  var a = y(p.style) ? p.style : {};
                  g.removeClass("highcharts-treegrid-node-active");
                  g.renderer.styledMode || g.css({
                    textDecoration: a.textDecoration
                  });
                }), C(a.element, "click", function () {
                  f.treeGrid.toggleCollapse();
                }), a.attachedTreeGridEvents = !0);
              }));
            }

            var r = !1;

            g.compose = function (d) {
              r || (C(d, "init", m), G(d.prototype, "getLabelPosition", a), G(d.prototype, "renderLabel", p), d.prototype.collapse = function (a) {
                this.treeGrid.collapse(a);
              }, d.prototype.expand = function (a) {
                this.treeGrid.expand(a);
              }, d.prototype.toggleCollapse = function (a) {
                this.treeGrid.toggleCollapse(a);
              }, r = !0);
            };

            var l = function () {
              function a(a) {
                this.tick = a;
              }

              a.prototype.collapse = function (a) {
                var d = this.tick,
                    f = d.axis,
                    e = f.brokenAxis;
                e && f.treeGrid.mapOfPosToGridNode && (d = f.treeGrid.collapse(f.treeGrid.mapOfPosToGridNode[d.pos]), e.setBreaks(d, v(a, !0)));
              };

              a.prototype.expand = function (a) {
                var d = this.tick,
                    f = d.axis,
                    e = f.brokenAxis;
                e && f.treeGrid.mapOfPosToGridNode && (d = f.treeGrid.expand(f.treeGrid.mapOfPosToGridNode[d.pos]), e.setBreaks(d, v(a, !0)));
              };

              a.prototype.toggleCollapse = function (a) {
                var d = this.tick,
                    f = d.axis,
                    e = f.brokenAxis;
                e && f.treeGrid.mapOfPosToGridNode && (d = f.treeGrid.toggleCollapse(f.treeGrid.mapOfPosToGridNode[d.pos]), e.setBreaks(d, v(a, !0)));
              };

              return a;
            }();

            g.Additions = l;
          })(x || (x = {}));

          return x;
        });
        M(g, "Mixins/TreeSeries.js", [g["Core/Color/Color.js"], g["Core/Utilities.js"]], function (e, g) {
          var C = g.extend,
              y = g.isArray,
              E = g.isNumber,
              v = g.isObject,
              G = g.merge,
              x = g.pick;
          return {
            getColor: function getColor(g, m) {
              var d = m.index,
                  a = m.mapOptionsToLevel,
                  p = m.parentColor,
                  r = m.parentColorIndex,
                  l = m.series,
                  h = m.colors,
                  f = m.siblings,
                  k = l.points,
                  v = l.chart.options.chart,
                  y;

              if (g) {
                k = k[g.i];
                g = a[g.level] || {};

                if (a = k && g.colorByPoint) {
                  var t = k.index % (h ? h.length : v.colorCount);
                  var E = h && h[t];
                }

                if (!l.chart.styledMode) {
                  h = k && k.options.color;
                  v = g && g.color;
                  if (y = p) y = (y = g && g.colorVariation) && "brightness" === y.key ? e.parse(p).brighten(d / f * y.to).get() : p;
                  y = x(h, v, E, y, l.color);
                }

                var z = x(k && k.options.colorIndex, g && g.colorIndex, t, r, m.colorIndex);
              }

              return {
                color: y,
                colorIndex: z
              };
            },
            getLevelOptions: function getLevelOptions(e) {
              var g = null;

              if (v(e)) {
                g = {};
                var d = E(e.from) ? e.from : 1;
                var a = e.levels;
                var p = {};
                var r = v(e.defaults) ? e.defaults : {};
                y(a) && (p = a.reduce(function (a, e) {
                  if (v(e) && E(e.level)) {
                    var f = G({}, e);
                    var h = "boolean" === typeof f.levelIsConstant ? f.levelIsConstant : r.levelIsConstant;
                    delete f.levelIsConstant;
                    delete f.level;
                    e = e.level + (h ? 0 : d - 1);
                    v(a[e]) ? C(a[e], f) : a[e] = f;
                  }

                  return a;
                }, {}));
                a = E(e.to) ? e.to : 1;

                for (e = 0; e <= a; e++) {
                  g[e] = G({}, r, v(p[e]) ? p[e] : {});
                }
              }

              return g;
            },
            setTreeValues: function a(e, d) {
              var g = d.before,
                  m = d.idRoot,
                  l = d.mapIdToNode[m],
                  h = d.points[e.i],
                  f = h && h.options || {},
                  k = 0,
                  v = [];
              e.levelDynamic = e.level - (("boolean" === typeof d.levelIsConstant ? d.levelIsConstant : 1) ? 0 : l.level);
              e.name = x(h && h.name, "");
              e.visible = m === e.id || ("boolean" === typeof d.visible ? d.visible : !1);
              "function" === typeof g && (e = g(e, d));
              e.children.forEach(function (f, h) {
                var g = C({}, d);
                C(g, {
                  index: h,
                  siblings: e.children.length,
                  visible: e.visible
                });
                f = a(f, g);
                v.push(f);
                f.visible && (k += f.val);
              });
              g = x(f.value, k);
              e.visible = 0 <= g && (0 < k || e.visible);
              e.children = v;
              e.childrenTotal = k;
              e.isLeaf = e.visible && !k;
              e.val = g;
              return e;
            },
            updateRootId: function updateRootId(e) {
              if (v(e)) {
                var d = v(e.options) ? e.options : {};
                d = x(e.rootNode, d.rootId, "");
                v(e.userOptions) && (e.userOptions.rootId = d);
                e.rootNode = d;
              }

              return d;
            }
          };
        });
        M(g, "Core/Axis/TreeGridAxis.js", [g["Core/Axis/BrokenAxis.js"], g["Core/Axis/GridAxis.js"], g["Gantt/Tree.js"], g["Core/Axis/TreeGridTick.js"], g["Mixins/TreeSeries.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v) {
          var G = E.getLevelOptions,
              x = v.addEvent,
              r = v.find,
              m = v.fireEvent,
              d = v.isArray,
              a = v.isObject,
              p = v.isString,
              B = v.merge,
              l = v.pick,
              h = v.wrap,
              f;

          (function (f) {
            function k(a, b) {
              var c = a.collapseEnd || 0;
              a = a.collapseStart || 0;
              c >= b && (a -= .5);
              return {
                from: a,
                to: c,
                showPoints: !1
              };
            }

            function v(b, c, d) {
              var f = [],
                  e = [],
                  h = {},
                  k = "boolean" === typeof c ? c : !1,
                  g = {},
                  l = -1;
              b = C.getTree(b, {
                after: function after(a) {
                  a = g[a.pos];
                  var b = 0,
                      c = 0;
                  a.children.forEach(function (a) {
                    c += (a.descendants || 0) + 1;
                    b = Math.max((a.height || 0) + 1, b);
                  });
                  a.descendants = c;
                  a.height = b;
                  a.collapsed && e.push(a);
                },
                before: function before(b) {
                  var c = a(b.data, !0) ? b.data : {},
                      d = p(c.name) ? c.name : "",
                      e = h[b.parent];
                  e = a(e, !0) ? g[e.pos] : null;

                  var n = function n(a) {
                    return a.name === d;
                  },
                      m;

                  k && a(e, !0) && (m = r(e.children, n)) ? (n = m.pos, m.nodes.push(b)) : n = l++;
                  g[n] || (g[n] = m = {
                    depth: e ? e.depth + 1 : 0,
                    name: d,
                    id: c.id,
                    nodes: [b],
                    children: [],
                    pos: n
                  }, -1 !== n && f.push(d), a(e, !0) && e.children.push(m));
                  p(b.id) && (h[b.id] = b);
                  m && !0 === c.collapsed && (m.collapsed = !0);
                  b.pos = n;
                }
              });

              g = function (b, c) {
                var d = function d(b, e, f) {
                  var h = e + (-1 === e ? 0 : c - 1),
                      g = (h - e) / 2,
                      k = e + g;
                  b.nodes.forEach(function (b) {
                    var c = b.data;
                    a(c, !0) && (c.y = e + (c.seriesIndex || 0), delete c.seriesIndex);
                    b.pos = k;
                  });
                  f[k] = b;
                  b.pos = k;
                  b.tickmarkOffset = g + .5;
                  b.collapseStart = h + .5;
                  b.children.forEach(function (a) {
                    d(a, h + 1, f);
                    h = (a.collapseEnd || 0) - .5;
                  });
                  b.collapseEnd = h + .5;
                  return f;
                };

                return d(b["-1"], -1, {});
              }(g, d);

              return {
                categories: f,
                mapOfIdToNode: h,
                mapOfPosToGridNode: g,
                collapsedNodes: e,
                tree: b
              };
            }

            function t(b) {
              b.target.axes.filter(function (a) {
                return "treegrid" === a.options.type;
              }).forEach(function (c) {
                var e = c.options || {},
                    f = e.labels,
                    h = e.uniqueNames;
                e = e.max;
                var g = 0;

                if (!c.treeGrid.mapOfPosToGridNode || c.series.some(function (a) {
                  return !a.hasRendered || a.isDirtyData || a.isDirty;
                })) {
                  var k = c.series.reduce(function (b, c) {
                    c.visible && ((c.options.data || []).forEach(function (d) {
                      c.options.keys && c.options.keys.length && (d = c.pointClass.prototype.optionsToObject.call({
                        series: c
                      }, d), c.pointClass.setGanttPointAliases(d));
                      a(d, !0) && (d.seriesIndex = g, b.push(d));
                    }), !0 === h && g++);
                    return b;
                  }, []);
                  if (e && k.length < e) for (var l = k.length; l <= e; l++) {
                    k.push({
                      name: l + "\u200B"
                    });
                  }
                  e = v(k, h || !1, !0 === h ? g : 1);
                  c.categories = e.categories;
                  c.treeGrid.mapOfPosToGridNode = e.mapOfPosToGridNode;
                  c.hasNames = !0;
                  c.treeGrid.tree = e.tree;
                  c.series.forEach(function (b) {
                    var c = (b.options.data || []).map(function (c) {
                      d(c) && b.options.keys && b.options.keys.length && k.forEach(function (a) {
                        0 <= c.indexOf(a.x) && 0 <= c.indexOf(a.x2) && (c = a);
                      });
                      return a(c, !0) ? B(c) : c;
                    });
                    b.visible && b.setData(c, !1);
                  });
                  c.treeGrid.mapOptionsToLevel = G({
                    defaults: f,
                    from: 1,
                    levels: f && f.levels,
                    to: c.treeGrid.tree && c.treeGrid.tree.height
                  });
                  "beforeRender" === b.type && (c.treeGrid.collapsedNodes = e.collapsedNodes);
                }
              });
            }

            function E(a, b) {
              var d = this.treeGrid.mapOptionsToLevel || {},
                  e = this.ticks,
                  f = e[b],
                  h;

              if ("treegrid" === this.options.type && this.treeGrid.mapOfPosToGridNode) {
                var g = this.treeGrid.mapOfPosToGridNode[b];
                (d = d[g.depth]) && (h = {
                  labels: d
                });
                !f && c ? e[b] = new c(this, b, void 0, void 0, {
                  category: g.name,
                  tickmarkOffset: g.tickmarkOffset,
                  options: h
                }) : (f.parameters.category = g.name, f.options = h, f.addLabel());
              } else a.apply(this, Array.prototype.slice.call(arguments, 1));
            }

            function z(a, c, d) {
              var e = this,
                  f = "treegrid" === d.type;
              e.treeGrid || (e.treeGrid = new b(e));
              f && (x(c, "beforeRender", t), x(c, "beforeRedraw", t), x(c, "addSeries", function (a) {
                a.options.data && (a = v(a.options.data, d.uniqueNames || !1, 1), e.treeGrid.collapsedNodes = (e.treeGrid.collapsedNodes || []).concat(a.collapsedNodes));
              }), x(e, "foundExtremes", function () {
                e.treeGrid.collapsedNodes && e.treeGrid.collapsedNodes.forEach(function (a) {
                  var b = e.treeGrid.collapse(a);
                  e.brokenAxis && (e.brokenAxis.setBreaks(b, !1), e.treeGrid.collapsedNodes && (e.treeGrid.collapsedNodes = e.treeGrid.collapsedNodes.filter(function (b) {
                    return a.collapseStart !== b.collapseStart || a.collapseEnd !== b.collapseEnd;
                  })));
                });
              }), x(e, "afterBreaks", function () {
                "yAxis" === e.coll && !e.staticScale && e.chart.options.chart.height && (e.isDirty = !0);
              }), d = B({
                grid: {
                  enabled: !0
                },
                labels: {
                  align: "left",
                  levels: [{
                    level: void 0
                  }, {
                    level: 1,
                    style: {
                      fontWeight: "bold"
                    }
                  }],
                  symbol: {
                    type: "triangle",
                    x: -5,
                    y: -5,
                    height: 10,
                    width: 10,
                    padding: 5
                  }
                },
                uniqueNames: !1
              }, d, {
                reversed: !0,
                grid: {
                  columns: void 0
                }
              }));
              a.apply(e, [c, d]);
              f && (e.hasNames = !0, e.options.showLastLabel = !0);
            }

            function A(a) {
              var b = this.options;
              "treegrid" === b.type ? (this.min = l(this.userMin, b.min, this.dataMin), this.max = l(this.userMax, b.max, this.dataMax), m(this, "foundExtremes"), this.setAxisTranslation(), this.tickmarkOffset = .5, this.tickInterval = 1, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : []) : a.apply(this, Array.prototype.slice.call(arguments, 1));
            }

            var c;

            f.compose = function (a, b, d, f) {
              -1 === a.keepProps.indexOf("treeGrid") && (a.keepProps.push("treeGrid"), c = f, h(a.prototype, "generateTick", E), h(a.prototype, "init", z), h(a.prototype, "setTickInterval", A), a.prototype.utils = {
                getNode: C.getNode
              }, g.compose(a, b, f), e.compose(a, d), y.compose(f));
              return a;
            };

            var b = function () {
              function a(a) {
                this.axis = a;
              }

              a.prototype.setCollapsedStatus = function (a) {
                var b = this.axis,
                    c = b.chart;
                b.series.forEach(function (b) {
                  var d = b.options.data;

                  if (a.id && d) {
                    var e = c.get(a.id);
                    b = d[b.data.indexOf(e)];
                    e && b && (e.collapsed = a.collapsed, b.collapsed = a.collapsed);
                  }
                });
              };

              a.prototype.collapse = function (a) {
                var b = this.axis,
                    c = b.options.breaks || [],
                    d = k(a, b.max);
                c.push(d);
                a.collapsed = !0;
                b.treeGrid.setCollapsedStatus(a);
                return c;
              };

              a.prototype.expand = function (a) {
                var b = this.axis,
                    c = b.options.breaks || [],
                    d = k(a, b.max);
                a.collapsed = !1;
                b.treeGrid.setCollapsedStatus(a);
                return c.reduce(function (a, b) {
                  b.to === d.to && b.from === d.from || a.push(b);
                  return a;
                }, []);
              };

              a.prototype.getTickPositions = function () {
                var a = this.axis,
                    b = Math.floor(a.min / a.tickInterval) * a.tickInterval,
                    c = Math.ceil(a.max / a.tickInterval) * a.tickInterval;
                return Object.keys(a.treeGrid.mapOfPosToGridNode || {}).reduce(function (d, e) {
                  e = +e;
                  !(e >= b && e <= c) || a.brokenAxis && a.brokenAxis.isInAnyBreak(e) || d.push(e);
                  return d;
                }, []);
              };

              a.prototype.isCollapsed = function (a) {
                var b = this.axis,
                    c = b.options.breaks || [],
                    d = k(a, b.max);
                return c.some(function (a) {
                  return a.from === d.from && a.to === d.to;
                });
              };

              a.prototype.toggleCollapse = function (a) {
                return this.isCollapsed(a) ? this.expand(a) : this.collapse(a);
              };

              return a;
            }();

            f.Additions = b;
          })(f || (f = {}));

          return f;
        });
        M(g, "Extensions/CurrentDateIndication.js", [g["Core/Axis/Axis.js"], g["Core/Color/Palette.js"], g["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          var E = y.addEvent,
              v = y.merge;
          y = y.wrap;
          var G = {
            color: g.highlightColor20,
            width: 2,
            label: {
              format: "%a, %b %d %Y, %H:%M",
              formatter: function formatter(e, g) {
                return this.axis.chart.time.dateFormat(g || "", e);
              },
              rotation: 0,
              style: {
                fontSize: "10px"
              }
            }
          };
          E(e, "afterSetOptions", function () {
            var e = this.options,
                g = e.currentDateIndicator;
            g && (g = "object" === typeof g ? v(G, g) : v(G), g.value = Date.now(), g.className = "highcharts-current-date-indicator", e.plotLines || (e.plotLines = []), e.plotLines.push(g));
          });
          E(C, "render", function () {
            this.label && this.label.attr({
              text: this.getLabelText(this.options.label)
            });
          });
          y(C.prototype, "getLabelText", function (e, g) {
            var m = this.options;
            return m && m.className && -1 !== m.className.indexOf("highcharts-current-date-indicator") && m.label && "function" === typeof m.label.formatter ? (m.value = Date.now(), m.label.formatter.call(this, m.value, m.label.format)) : e.call(this, g);
          });
        });
        M(g, "Extensions/StaticScale.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = C.addEvent,
              E = C.defined,
              v = C.isNumber,
              G = C.pick;
          y(e, "afterSetOptions", function () {
            var e = this.chart.options.chart;
            !this.horiz && v(this.options.staticScale) && (!e.height || e.scrollablePlotArea && e.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);
          });

          g.prototype.adjustHeight = function () {
            "adjustHeight" !== this.redrawTrigger && ((this.axes || []).forEach(function (e) {
              var g = e.chart,
                  m = !!g.initiatedScale && g.options.animation,
                  d = e.options.staticScale;

              if (e.staticScale && E(e.min)) {
                var a = G(e.brokenAxis && e.brokenAxis.unitLength, e.max + e.tickInterval - e.min) * d;
                a = Math.max(a, d);
                d = a - g.plotHeight;
                !g.scrollablePixelsY && 1 <= Math.abs(d) && (g.plotHeight = a, g.redrawTrigger = "adjustHeight", g.setSize(void 0, g.chartHeight + d, m));
                e.series.forEach(function (a) {
                  (a = a.sharedClipKey && g.sharedClips[a.sharedClipKey]) && a.attr(g.inverted ? {
                    width: g.plotHeight
                  } : {
                    height: g.plotHeight
                  });
                });
              }
            }), this.initiatedScale = !0);
            this.redrawTrigger = null;
          };

          y(g, "render", g.prototype.adjustHeight);
        });
        M(g, "Extensions/ArrowSymbols.js", [g["Core/Renderer/SVG/SVGRenderer.js"]], function (e) {
          function g(e, g, y, x) {
            return [["M", e, g + x / 2], ["L", e + y, g], ["L", e, g + x / 2], ["L", e + y, g + x]];
          }

          function C(e, g, y, x) {
            return [["M", e + y, g], ["L", e, g + x / 2], ["L", e + y, g + x], ["Z"]];
          }

          function y(e, g, y, x) {
            return C(e, g, y / 2, x);
          }

          e = e.prototype.symbols;
          e.arrow = g;
          e["arrow-filled"] = C;
          e["arrow-filled-half"] = y;

          e["arrow-half"] = function (e, v, y, x) {
            return g(e, v, y / 2, x);
          };

          e["triangle-left"] = C;
          e["triangle-left-half"] = y;
          return e;
        });
        M(g, "Gantt/Connection.js", [g["Core/Globals.js"], g["Core/DefaultOptions.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"]], function (e, g, C, y) {
          function E(a) {
            var d = a.shapeArgs;
            return d ? {
              xMin: d.x || 0,
              xMax: (d.x || 0) + (d.width || 0),
              yMin: d.y || 0,
              yMax: (d.y || 0) + (d.height || 0)
            } : (d = a.graphic && a.graphic.getBBox()) ? {
              xMin: a.plotX - d.width / 2,
              xMax: a.plotX + d.width / 2,
              yMin: a.plotY - d.height / 2,
              yMax: a.plotY + d.height / 2
            } : null;
          }

          "";
          var v = y.defined,
              G = y.error,
              x = y.extend,
              r = y.merge,
              m = y.objectEach,
              d = e.deg2rad,
              a = Math.max,
              p = Math.min;
          x(g.defaultOptions, {
            connectors: {
              type: "straight",
              lineWidth: 1,
              marker: {
                enabled: !1,
                align: "center",
                verticalAlign: "middle",
                inside: !1,
                lineWidth: 1
              },
              startMarker: {
                symbol: "diamond"
              },
              endMarker: {
                symbol: "arrow-filled"
              }
            }
          });

          g = function () {
            function e(a, d, e) {
              this.toPoint = this.pathfinder = this.graphics = this.fromPoint = this.chart = void 0;
              this.init(a, d, e);
            }

            e.prototype.init = function (a, d, e) {
              this.fromPoint = a;
              this.toPoint = d;
              this.options = e;
              this.chart = a.series.chart;
              this.pathfinder = this.chart.pathfinder;
            };

            e.prototype.renderPath = function (a, d, e) {
              var f = this.chart,
                  h = f.styledMode,
                  g = f.pathfinder,
                  l = !f.options.chart.forExport && !1 !== e,
                  m = this.graphics && this.graphics.path;
              g.group || (g.group = f.renderer.g().addClass("highcharts-pathfinder-group").attr({
                zIndex: -1
              }).add(f.seriesGroup));
              g.group.translate(f.plotLeft, f.plotTop);
              m && m.renderer || (m = f.renderer.path().add(g.group), h || m.attr({
                opacity: 0
              }));
              m.attr(d);
              a = {
                d: a
              };
              h || (a.opacity = 1);
              m[l ? "animate" : "attr"](a, e);
              this.graphics = this.graphics || {};
              this.graphics.path = m;
            };

            e.prototype.addMarker = function (a, e, f) {
              var g = this.fromPoint.series.chart,
                  h = g.pathfinder;
              g = g.renderer;
              var l = "start" === a ? this.fromPoint : this.toPoint,
                  m = l.getPathfinderAnchorPoint(e);

              if (e.enabled && ((f = "start" === a ? f[1] : f[f.length - 2]) && "M" === f[0] || "L" === f[0])) {
                f = {
                  x: f[1],
                  y: f[2]
                };
                f = l.getRadiansToVector(f, m);
                m = l.getMarkerVector(f, e.radius, m);
                f = -f / d;

                if (e.width && e.height) {
                  var p = e.width;
                  var r = e.height;
                } else p = r = 2 * e.radius;

                this.graphics = this.graphics || {};
                m = {
                  x: m.x - p / 2,
                  y: m.y - r / 2,
                  width: p,
                  height: r,
                  rotation: f,
                  rotationOriginX: m.x,
                  rotationOriginY: m.y
                };
                this.graphics[a] ? this.graphics[a].animate(m) : (this.graphics[a] = g.symbol(e.symbol).addClass("highcharts-point-connecting-path-" + a + "-marker").attr(m).add(h.group), g.styledMode || this.graphics[a].attr({
                  fill: e.color || this.fromPoint.color,
                  stroke: e.lineColor,
                  "stroke-width": e.lineWidth,
                  opacity: 0
                }).animate({
                  opacity: 1
                }, l.series.options.animation));
              }
            };

            e.prototype.getPath = function (a) {
              var d = this.pathfinder,
                  e = this.chart,
                  g = d.algorithms[a.type],
                  l = d.chartObstacles;
              if ("function" !== typeof g) return G('"' + a.type + '" is not a Pathfinder algorithm.'), {
                path: [],
                obstacles: []
              };
              g.requiresObstacles && !l && (l = d.chartObstacles = d.getChartObstacles(a), e.options.connectors.algorithmMargin = a.algorithmMargin, d.chartObstacleMetrics = d.getObstacleMetrics(l));
              return g(this.fromPoint.getPathfinderAnchorPoint(a.startMarker), this.toPoint.getPathfinderAnchorPoint(a.endMarker), r({
                chartObstacles: l,
                lineObstacles: d.lineObstacles || [],
                obstacleMetrics: d.chartObstacleMetrics,
                hardBounds: {
                  xMin: 0,
                  xMax: e.plotWidth,
                  yMin: 0,
                  yMax: e.plotHeight
                },
                obstacleOptions: {
                  margin: a.algorithmMargin
                },
                startDirectionX: d.getAlgorithmStartDirection(a.startMarker)
              }, a));
            };

            e.prototype.render = function () {
              var d = this.fromPoint,
                  e = d.series,
                  f = e.chart,
                  g = f.pathfinder,
                  m = r(f.options.connectors, e.options.connectors, d.options.connectors, this.options),
                  B = {};
              f.styledMode || (B.stroke = m.lineColor || d.color, B["stroke-width"] = m.lineWidth, m.dashStyle && (B.dashstyle = m.dashStyle));
              B["class"] = "highcharts-point-connecting-path highcharts-color-" + d.colorIndex;
              m = r(B, m);
              v(m.marker.radius) || (m.marker.radius = p(a(Math.ceil((m.algorithmMargin || 8) / 2) - 1, 1), 5));
              d = this.getPath(m);
              f = d.path;
              d.obstacles && (g.lineObstacles = g.lineObstacles || [], g.lineObstacles = g.lineObstacles.concat(d.obstacles));
              this.renderPath(f, B, e.options.animation);
              this.addMarker("start", r(m.marker, m.startMarker), f);
              this.addMarker("end", r(m.marker, m.endMarker), f);
            };

            e.prototype.destroy = function () {
              this.graphics && (m(this.graphics, function (a) {
                a.destroy();
              }), delete this.graphics);
            };

            return e;
          }();

          e.Connection = g;
          x(C.prototype, {
            getPathfinderAnchorPoint: function getPathfinderAnchorPoint(a) {
              var d = E(this);

              switch (a.align) {
                case "right":
                  var e = "xMax";
                  break;

                case "left":
                  e = "xMin";
              }

              switch (a.verticalAlign) {
                case "top":
                  var f = "yMin";
                  break;

                case "bottom":
                  f = "yMax";
              }

              return {
                x: e ? d[e] : (d.xMin + d.xMax) / 2,
                y: f ? d[f] : (d.yMin + d.yMax) / 2
              };
            },
            getRadiansToVector: function getRadiansToVector(a, d) {
              var e;
              v(d) || (e = E(this)) && (d = {
                x: (e.xMin + e.xMax) / 2,
                y: (e.yMin + e.yMax) / 2
              });
              return Math.atan2(d.y - a.y, a.x - d.x);
            },
            getMarkerVector: function getMarkerVector(a, d, e) {
              var f = 2 * Math.PI,
                  g = E(this),
                  h = g.xMax - g.xMin,
                  l = g.yMax - g.yMin,
                  m = Math.atan2(l, h),
                  p = !1;
              h /= 2;
              var r = l / 2,
                  A = g.xMin + h;
              g = g.yMin + r;

              for (var c = A, b = g, v = 1, B = 1; a < -Math.PI;) {
                a += f;
              }

              for (; a > Math.PI;) {
                a -= f;
              }

              f = Math.tan(a);
              a > -m && a <= m ? (B = -1, p = !0) : a > m && a <= Math.PI - m ? B = -1 : a > Math.PI - m || a <= -(Math.PI - m) ? (v = -1, p = !0) : v = -1;
              p ? (c += v * h, b += B * h * f) : (c += l / (2 * f) * v, b += B * r);
              e.x !== A && (c = e.x);
              e.y !== g && (b = e.y);
              return {
                x: c + d * Math.cos(a),
                y: b - d * Math.sin(a)
              };
            }
          });
          return g;
        });
        M(g, "Gantt/PathfinderAlgorithms.js", [g["Core/Utilities.js"]], function (e) {
          function g(d, a, e) {
            e = e || 0;
            var g = d.length - 1;
            a -= 1e-7;

            for (var l, h; e <= g;) {
              if (l = g + e >> 1, h = a - d[l].xMin, 0 < h) e = l + 1;else if (0 > h) g = l - 1;else return l;
            }

            return 0 < e ? e - 1 : 0;
          }

          function C(d, a) {
            for (var e = g(d, a.x + 1) + 1; e--;) {
              var m;
              if (m = d[e].xMax >= a.x) m = d[e], m = a.x <= m.xMax && a.x >= m.xMin && a.y <= m.yMax && a.y >= m.yMin;
              if (m) return e;
            }

            return -1;
          }

          function y(d) {
            var a = [];

            if (d.length) {
              a.push(["M", d[0].start.x, d[0].start.y]);

              for (var e = 0; e < d.length; ++e) {
                a.push(["L", d[e].end.x, d[e].end.y]);
              }
            }

            return a;
          }

          function E(d, a) {
            d.yMin = x(d.yMin, a.yMin);
            d.yMax = G(d.yMax, a.yMax);
            d.xMin = x(d.xMin, a.xMin);
            d.xMax = G(d.xMax, a.xMax);
          }

          var v = e.pick,
              G = Math.min,
              x = Math.max,
              r = Math.abs;

          e = function e(d, a, _e9) {
            function g(a, d, e, c, b) {
              a = {
                x: a.x,
                y: a.y
              };
              a[d] = e[c || d] + (b || 0);
              return a;
            }

            function l(a, d, e) {
              var c = r(d[e] - a[e + "Min"]) > r(d[e] - a[e + "Max"]);
              return g(d, e, a, e + (c ? "Max" : "Min"), c ? 1 : -1);
            }

            var h = [],
                f = v(_e9.startDirectionX, r(a.x - d.x) > r(a.y - d.y)) ? "x" : "y",
                k = _e9.chartObstacles,
                m = C(k, d);
            _e9 = C(k, a);

            if (-1 < _e9) {
              var p = k[_e9];
              _e9 = l(p, a, f);
              p = {
                start: _e9,
                end: a
              };
              var t = _e9;
            } else t = a;

            -1 < m && (k = k[m], _e9 = l(k, d, f), h.push({
              start: d,
              end: _e9
            }), _e9[f] >= d[f] === _e9[f] >= t[f] && (f = "y" === f ? "x" : "y", a = d[f] < a[f], h.push({
              start: _e9,
              end: g(_e9, f, k, f + (a ? "Max" : "Min"), a ? 1 : -1)
            }), f = "y" === f ? "x" : "y"));
            d = h.length ? h[h.length - 1].end : d;
            _e9 = g(d, f, t);
            h.push({
              start: d,
              end: _e9
            });
            f = g(_e9, "y" === f ? "x" : "y", t);
            h.push({
              start: _e9,
              end: f
            });
            h.push(p);
            return {
              path: y(h),
              obstacles: h
            };
          };

          e.requiresObstacles = !0;

          var m = function m(d, a, e) {
            function m(a, b, c) {
              var d,
                  e = a.x < b.x ? 1 : -1;

              if (a.x < b.x) {
                var f = a;
                var h = b;
              } else f = b, h = a;

              if (a.y < b.y) {
                var k = a;
                var l = b;
              } else k = b, l = a;

              for (d = 0 > e ? G(g(D, h.x), D.length - 1) : 0; D[d] && (0 < e && D[d].xMin <= h.x || 0 > e && D[d].xMax >= f.x);) {
                if (D[d].xMin <= h.x && D[d].xMax >= f.x && D[d].yMin <= l.y && D[d].yMax >= k.y) return c ? {
                  y: a.y,
                  x: a.x < b.x ? D[d].xMin - 1 : D[d].xMax + 1,
                  obstacle: D[d]
                } : {
                  x: a.x,
                  y: a.y < b.y ? D[d].yMin - 1 : D[d].yMax + 1,
                  obstacle: D[d]
                };
                d += e;
              }

              return b;
            }

            function l(a, b, c, d, e) {
              var f = e.soft,
                  g = e.hard,
                  h = d ? "x" : "y",
                  k = {
                x: b.x,
                y: b.y
              },
                  l = {
                x: b.x,
                y: b.y
              };
              e = a[h + "Max"] >= f[h + "Max"];
              f = a[h + "Min"] <= f[h + "Min"];
              var n = a[h + "Max"] >= g[h + "Max"];
              g = a[h + "Min"] <= g[h + "Min"];
              var w = r(a[h + "Min"] - b[h]),
                  p = r(a[h + "Max"] - b[h]);
              c = 10 > r(w - p) ? b[h] < c[h] : p < w;
              l[h] = a[h + "Min"];
              k[h] = a[h + "Max"];
              a = m(b, l, d)[h] !== l[h];
              b = m(b, k, d)[h] !== k[h];
              c = a ? b ? c : !0 : b ? !1 : c;
              c = f ? e ? c : !0 : e ? !1 : c;
              return g ? n ? c : !0 : n ? !1 : c;
            }

            function h(a, d, f) {
              if (a.x === d.x && a.y === d.y) return [];
              var g = f ? "x" : "y",
                  k = e.obstacleOptions.margin;
              var n = {
                soft: {
                  xMin: z,
                  xMax: A,
                  yMin: c,
                  yMax: b
                },
                hard: e.hardBounds
              };
              var p = C(D, a);

              if (-1 < p) {
                p = D[p];
                n = l(p, a, d, f, n);
                E(p, e.hardBounds);
                var q = f ? {
                  y: a.y,
                  x: p[n ? "xMax" : "xMin"] + (n ? 1 : -1)
                } : {
                  x: a.x,
                  y: p[n ? "yMax" : "yMin"] + (n ? 1 : -1)
                };
                var r = C(D, q);
                -1 < r && (r = D[r], E(r, e.hardBounds), q[g] = n ? x(p[g + "Max"] - k + 1, (r[g + "Min"] + p[g + "Max"]) / 2) : G(p[g + "Min"] + k - 1, (r[g + "Max"] + p[g + "Min"]) / 2), a.x === q.x && a.y === q.y ? (t && (q[g] = n ? x(p[g + "Max"], r[g + "Max"]) + 1 : G(p[g + "Min"], r[g + "Min"]) - 1), t = !t) : t = !1);
                a = [{
                  start: a,
                  end: q
                }];
              } else g = m(a, {
                x: f ? d.x : a.x,
                y: f ? a.y : d.y
              }, f), a = [{
                start: a,
                end: {
                  x: g.x,
                  y: g.y
                }
              }], g[f ? "x" : "y"] !== d[f ? "x" : "y"] && (n = l(g.obstacle, g, d, !f, n), E(g.obstacle, e.hardBounds), n = {
                x: f ? g.x : g.obstacle[n ? "xMax" : "xMin"] + (n ? 1 : -1),
                y: f ? g.obstacle[n ? "yMax" : "yMin"] + (n ? 1 : -1) : g.y
              }, f = !f, a = a.concat(h({
                x: g.x,
                y: g.y
              }, n, f)));

              return a = a.concat(h(a[a.length - 1].end, d, !f));
            }

            function f(a, b, c) {
              var d = G(a.xMax - b.x, b.x - a.xMin) < G(a.yMax - b.y, b.y - a.yMin);
              c = l(a, b, c, d, {
                soft: e.hardBounds,
                hard: e.hardBounds
              });
              return d ? {
                y: b.y,
                x: a[c ? "xMax" : "xMin"] + (c ? 1 : -1)
              } : {
                x: b.x,
                y: a[c ? "yMax" : "yMin"] + (c ? 1 : -1)
              };
            }

            var k = v(e.startDirectionX, r(a.x - d.x) > r(a.y - d.y)),
                p = k ? "x" : "y",
                K = [],
                t = !1,
                Q = e.obstacleMetrics,
                z = G(d.x, a.x) - Q.maxWidth - 10,
                A = x(d.x, a.x) + Q.maxWidth + 10,
                c = G(d.y, a.y) - Q.maxHeight - 10,
                b = x(d.y, a.y) + Q.maxHeight + 10,
                D = e.chartObstacles;
            var L = g(D, z);
            Q = g(D, A);
            D = D.slice(L, Q + 1);

            if (-1 < (Q = C(D, a))) {
              var I = f(D[Q], a, d);
              K.push({
                end: a,
                start: I
              });
              a = I;
            }

            for (; -1 < (Q = C(D, a));) {
              L = 0 > a[p] - d[p], I = {
                x: a.x,
                y: a.y
              }, I[p] = D[Q][L ? p + "Max" : p + "Min"] + (L ? 1 : -1), K.push({
                end: a,
                start: I
              }), a = I;
            }

            d = h(d, a, k);
            d = d.concat(K.reverse());
            return {
              path: y(d),
              obstacles: d
            };
          };

          m.requiresObstacles = !0;
          return {
            fastAvoid: m,
            straight: function straight(d, a) {
              return {
                path: [["M", d.x, d.y], ["L", a.x, a.y]],
                obstacles: [{
                  start: d,
                  end: a
                }]
              };
            },
            simpleConnect: e
          };
        });
        M(g, "Gantt/Pathfinder.js", [g["Gantt/Connection.js"], g["Core/Chart/Chart.js"], g["Core/Globals.js"], g["Core/DefaultOptions.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"], g["Gantt/PathfinderAlgorithms.js"]], function (e, g, C, y, E, v, G) {
          function x(a) {
            var d = a.shapeArgs;
            return d ? {
              xMin: d.x || 0,
              xMax: (d.x || 0) + (d.width || 0),
              yMin: d.y || 0,
              yMax: (d.y || 0) + (d.height || 0)
            } : (d = a.graphic && a.graphic.getBBox()) ? {
              xMin: a.plotX - d.width / 2,
              xMax: a.plotX + d.width / 2,
              yMin: a.plotY - d.height / 2,
              yMax: a.plotY + d.height / 2
            } : null;
          }

          function r(a) {
            for (var d = a.length, e = 0, f, c, b = [], g = function g(a, b, c) {
              c = h(c, 10);
              var d = a.yMax + c > b.yMin - c && a.yMin - c < b.yMax + c,
                  e = a.xMax + c > b.xMin - c && a.xMin - c < b.xMax + c,
                  f = d ? a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax : Infinity,
                  k = e ? a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax : Infinity;
              return e && d ? c ? g(a, b, Math.floor(c / 2)) : Infinity : J(f, k);
            }; e < d; ++e) {
              for (f = e + 1; f < d; ++f) {
                c = g(a[e], a[f]), 80 > c && b.push(c);
              }
            }

            b.push(80);
            return k(Math.floor(b.sort(function (a, b) {
              return a - b;
            })[Math.floor(b.length / 10)] / 2 - 1), 1);
          }

          function m(a) {
            if (a.options.pathfinder || a.series.reduce(function (a, d) {
              d.options && l(!0, d.options.connectors = d.options.connectors || {}, d.options.pathfinder);
              return a || d.options && d.options.pathfinder;
            }, !1)) l(!0, a.options.connectors = a.options.connectors || {}, a.options.pathfinder), p('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.');
          }

          "";
          var d = v.addEvent,
              a = v.defined,
              p = v.error,
              B = v.extend,
              l = v.merge,
              h = v.pick,
              f = v.splat,
              k = Math.max,
              J = Math.min;
          B(y.defaultOptions, {
            connectors: {
              type: "straight",
              lineWidth: 1,
              marker: {
                enabled: !1,
                align: "center",
                verticalAlign: "middle",
                inside: !1,
                lineWidth: 1
              },
              startMarker: {
                symbol: "diamond"
              },
              endMarker: {
                symbol: "arrow-filled"
              }
            }
          });

          var K = function () {
            function g(a) {
              this.lineObstacles = this.group = this.connections = this.chartObstacleMetrics = this.chartObstacles = this.chart = void 0;
              this.init(a);
            }

            g.prototype.init = function (a) {
              this.chart = a;
              this.connections = [];
              d(a, "redraw", function () {
                this.pathfinder.update();
              });
            };

            g.prototype.update = function (a) {
              var d = this.chart,
                  g = this,
                  c = g.connections;
              g.connections = [];
              d.series.forEach(function (a) {
                a.visible && !a.options.isInternal && a.points.forEach(function (a) {
                  var b = a.options;
                  b && b.dependency && (b.connect = b.dependency);
                  var c;
                  b = a.options && a.options.connect && f(a.options.connect);
                  a.visible && !1 !== a.isInside && b && b.forEach(function (b) {
                    c = d.get("string" === typeof b ? b : b.to);
                    c instanceof E && c.series.visible && c.visible && !1 !== c.isInside && g.connections.push(new e(a, c, "string" === typeof b ? {} : b));
                  });
                });
              });

              for (var b = 0, h = void 0, k = void 0, l = c.length, n = g.connections.length; b < l; ++b) {
                k = !1;

                for (h = 0; h < n; ++h) {
                  if (c[b].fromPoint === g.connections[h].fromPoint && c[b].toPoint === g.connections[h].toPoint) {
                    g.connections[h].graphics = c[b].graphics;
                    k = !0;
                    break;
                  }
                }

                k || c[b].destroy();
              }

              delete this.chartObstacles;
              delete this.lineObstacles;
              g.renderConnections(a);
            };

            g.prototype.renderConnections = function (a) {
              a ? this.chart.series.forEach(function (a) {
                var e = function e() {
                  var c = a.chart.pathfinder;
                  (c && c.connections || []).forEach(function (b) {
                    b.fromPoint && b.fromPoint.series === a && b.render();
                  });
                  a.pathfinderRemoveRenderEvent && (a.pathfinderRemoveRenderEvent(), delete a.pathfinderRemoveRenderEvent);
                };

                !1 === a.options.animation ? e() : a.pathfinderRemoveRenderEvent = d(a, "afterAnimate", e);
              }) : this.connections.forEach(function (a) {
                a.render();
              });
            };

            g.prototype.getChartObstacles = function (d) {
              for (var e = [], f = this.chart.series, c = h(d.algorithmMargin, 0), b, g = 0, k = f.length; g < k; ++g) {
                if (f[g].visible && !f[g].options.isInternal) {
                  var l = 0,
                      n = f[g].points.length,
                      m = void 0;

                  for (m = void 0; l < n; ++l) {
                    m = f[g].points[l], m.visible && (m = x(m)) && e.push({
                      xMin: m.xMin - c,
                      xMax: m.xMax + c,
                      yMin: m.yMin - c,
                      yMax: m.yMax + c
                    });
                  }
                }
              }

              e = e.sort(function (a, b) {
                return a.xMin - b.xMin;
              });
              a(d.algorithmMargin) || (b = d.algorithmMargin = r(e), e.forEach(function (a) {
                a.xMin -= b;
                a.xMax += b;
                a.yMin -= b;
                a.yMax += b;
              }));
              return e;
            };

            g.prototype.getObstacleMetrics = function (a) {
              for (var d = 0, e = 0, c, b, f = a.length; f--;) {
                c = a[f].xMax - a[f].xMin, b = a[f].yMax - a[f].yMin, d < c && (d = c), e < b && (e = b);
              }

              return {
                maxHeight: e,
                maxWidth: d
              };
            };

            g.prototype.getAlgorithmStartDirection = function (a) {
              var d = "top" !== a.verticalAlign && "bottom" !== a.verticalAlign;
              return "left" !== a.align && "right" !== a.align ? d ? void 0 : !1 : d ? !0 : void 0;
            };

            return g;
          }();

          K.prototype.algorithms = G;
          C.Pathfinder = K;
          B(E.prototype, {
            getPathfinderAnchorPoint: function getPathfinderAnchorPoint(a) {
              var d = x(this);

              switch (a.align) {
                case "right":
                  var e = "xMax";
                  break;

                case "left":
                  e = "xMin";
              }

              switch (a.verticalAlign) {
                case "top":
                  var f = "yMin";
                  break;

                case "bottom":
                  f = "yMax";
              }

              return {
                x: e ? d[e] : (d.xMin + d.xMax) / 2,
                y: f ? d[f] : (d.yMin + d.yMax) / 2
              };
            },
            getRadiansToVector: function getRadiansToVector(d, e) {
              var f;
              a(e) || (f = x(this)) && (e = {
                x: (f.xMin + f.xMax) / 2,
                y: (f.yMin + f.yMax) / 2
              });
              return Math.atan2(e.y - d.y, d.x - e.x);
            },
            getMarkerVector: function getMarkerVector(a, d, e) {
              var f = 2 * Math.PI,
                  c = x(this),
                  b = c.xMax - c.xMin,
                  g = c.yMax - c.yMin,
                  h = Math.atan2(g, b),
                  k = !1;
              b /= 2;
              var l = g / 2,
                  m = c.xMin + b;
              c = c.yMin + l;

              for (var p = m, w = c, r = 1, t = 1; a < -Math.PI;) {
                a += f;
              }

              for (; a > Math.PI;) {
                a -= f;
              }

              f = Math.tan(a);
              a > -h && a <= h ? (t = -1, k = !0) : a > h && a <= Math.PI - h ? t = -1 : a > Math.PI - h || a <= -(Math.PI - h) ? (r = -1, k = !0) : r = -1;
              k ? (p += r * b, w += t * b * f) : (p += g / (2 * f) * r, w += t * l);
              e.x !== m && (p = e.x);
              e.y !== c && (w = e.y);
              return {
                x: p + d * Math.cos(a),
                y: w - d * Math.sin(a)
              };
            }
          });
          g.prototype.callbacks.push(function (a) {
            !1 !== a.options.connectors.enabled && (m(a), this.pathfinder = new K(this), this.pathfinder.update(!0));
          });
          return K;
        });
        M(g, "Series/Gantt/GanttSeries.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Series/Gantt/GanttPoint.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Axis/Tick.js"], g["Core/Utilities.js"], g["Core/Axis/TreeGridAxis.js"]], function (e, g, C, y, E, v, G) {
          var x = this && this.__extends || function () {
            var _a25 = function a(d, e) {
              _a25 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var e in d) {
                  d.hasOwnProperty(e) && (a[e] = d[e]);
                }
              };

              return _a25(d, e);
            };

            return function (d, e) {
              function f() {
                this.constructor = d;
              }

              _a25(d, e);

              d.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());
            };
          }(),
              r = y.series,
              m = y.seriesTypes.xrange,
              d = v.extend,
              a = v.isNumber,
              p = v.merge;

          G.compose(e, g, r, E);

          e = function (d) {
            function e() {
              var a = null !== d && d.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            x(e, d);

            e.prototype.drawPoint = function (d, e) {
              var f = this.options,
                  g = this.chart.renderer,
                  h = d.shapeArgs,
                  l = d.plotY,
                  p = d.graphic,
                  r = d.selected && "select",
                  v = f.stacking && !f.borderRadius;
              if (d.options.milestone) {
                if (a(l) && null !== d.y && !1 !== d.visible) {
                  h = g.symbols.diamond(h.x || 0, h.y || 0, h.width || 0, h.height || 0);
                  if (p) p[e]({
                    d: h
                  });else d.graphic = g.path(h).addClass(d.getClassName(), !0).add(d.group || this.group);
                  this.chart.styledMode || d.graphic.attr(this.pointAttribs(d, r)).shadow(f.shadow, null, v);
                } else p && (d.graphic = p.destroy());
              } else m.prototype.drawPoint.call(this, d, e);
            };

            e.prototype.translatePoint = function (a) {
              m.prototype.translatePoint.call(this, a);

              if (a.options.milestone) {
                var d = a.shapeArgs;
                var e = d.height || 0;
                a.shapeArgs = {
                  x: (d.x || 0) - e / 2,
                  y: d.y,
                  width: e,
                  height: e
                };
              }
            };

            e.defaultOptions = p(m.defaultOptions, {
              grouping: !1,
              dataLabels: {
                enabled: !0
              },
              tooltip: {
                headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>',
                pointFormat: null,
                pointFormatter: function pointFormatter() {
                  var d = this.series,
                      e = d.xAxis,
                      g = d.tooltipOptions.dateTimeLabelFormats,
                      l = e.options.startOfWeek,
                      m = d.tooltipOptions,
                      p = m.xDateFormat,
                      r = this.options.milestone,
                      v = "<b>" + (this.name || this.yCategory) + "</b>";
                  if (m.pointFormat) return this.tooltipFormatter(m.pointFormat);
                  !p && a(this.start) && (p = d.chart.time.getDateFormat(e.closestPointRange, this.start, l, g || {}));
                  e = d.chart.time.dateFormat(p, this.start);
                  d = d.chart.time.dateFormat(p, this.end);
                  v += "<br/>";
                  return r ? v + (e + "<br/>") : v + ("Start: " + e + "<br/>End: ") + (d + "<br/>");
                }
              },
              connectors: {
                type: "simpleConnect",
                animation: {
                  reversed: !0
                },
                startMarker: {
                  enabled: !0,
                  symbol: "arrow-filled",
                  radius: 4,
                  fill: "#fa0",
                  align: "left"
                },
                endMarker: {
                  enabled: !1,
                  align: "right"
                }
              }
            });
            return e;
          }(m);

          d(e.prototype, {
            keyboardMoveVertical: !1,
            pointArrayMap: ["start", "end", "y"],
            pointClass: C,
            setData: r.prototype.setData
          });
          y.registerSeriesType("gantt", e);
          "";
          return e;
        });
        M(g, "Core/Chart/GanttChart.js", [g["Core/Chart/Chart.js"], g["Core/DefaultOptions.js"], g["Core/Utilities.js"]], function (e, g, C) {
          var y = this && this.__extends || function () {
            var _e10 = function e(g, d) {
              _e10 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var e in d) {
                  d.hasOwnProperty(e) && (a[e] = d[e]);
                }
              };

              return _e10(g, d);
            };

            return function (g, d) {
              function a() {
                this.constructor = g;
              }

              _e10(g, d);

              g.prototype = null === d ? Object.create(d) : (a.prototype = d.prototype, new a());
            };
          }(),
              E = g.getOptions,
              v = C.isArray,
              G = C.merge,
              x = C.splat;

          e = function (e) {
            function g() {
              return null !== e && e.apply(this, arguments) || this;
            }

            y(g, e);

            g.prototype.init = function (d, a) {
              var g = E(),
                  m = d.xAxis,
                  l = d.yAxis,
                  h;
              d.xAxis = d.yAxis = void 0;
              var f = G(!0, {
                chart: {
                  type: "gantt"
                },
                title: {
                  text: null
                },
                legend: {
                  enabled: !1
                },
                navigator: {
                  series: {
                    type: "gantt"
                  },
                  yAxis: {
                    type: "category"
                  }
                }
              }, d, {
                isGantt: !0
              });
              d.xAxis = m;
              d.yAxis = l;
              f.xAxis = (v(d.xAxis) ? d.xAxis : [d.xAxis || {}, {}]).map(function (a, d) {
                1 === d && (h = 0);
                return G(g.xAxis, {
                  grid: {
                    enabled: !0
                  },
                  opposite: !0,
                  linkedTo: h
                }, a, {
                  type: "datetime"
                });
              });
              f.yAxis = x(d.yAxis || {}).map(function (a) {
                return G(g.yAxis, {
                  grid: {
                    enabled: !0
                  },
                  staticScale: 50,
                  reversed: !0,
                  type: a.categories ? a.type : "treegrid"
                }, a);
              });
              e.prototype.init.call(this, f, a);
            };

            return g;
          }(e);

          (function (e) {
            e.ganttChart = function (g, d, a) {
              return new e(g, d, a);
            };
          })(e || (e = {}));

          return e;
        });
        M(g, "Core/Axis/ScrollbarAxis.js", [g["Core/Utilities.js"]], function (e) {
          var g = e.addEvent,
              C = e.defined,
              y = e.pick;
          return function () {
            function e() {}

            e.compose = function (v, E) {
              if (-1 === e.composed.indexOf(v)) e.composed.push(v);else return v;

              var x = function x(e) {
                var g = y(e.options && e.options.min, e.min),
                    d = y(e.options && e.options.max, e.max);
                return {
                  axisMin: g,
                  axisMax: d,
                  scrollMin: C(e.dataMin) ? Math.min(g, e.min, e.dataMin, y(e.threshold, Infinity)) : g,
                  scrollMax: C(e.dataMax) ? Math.max(d, e.max, e.dataMax, y(e.threshold, -Infinity)) : d
                };
              };

              g(v, "afterInit", function () {
                var e = this;
                e.options && e.options.scrollbar && e.options.scrollbar.enabled && (e.options.scrollbar.vertical = !e.horiz, e.options.startOnTick = e.options.endOnTick = !1, e.scrollbar = new E(e.chart.renderer, e.options.scrollbar, e.chart), g(e.scrollbar, "changed", function (g) {
                  var d = x(e),
                      a = d.axisMax,
                      m = d.scrollMin,
                      r = d.scrollMax - m;
                  C(d.axisMin) && C(a) && (e.horiz && !e.reversed || !e.horiz && e.reversed ? (d = m + r * this.to, m += r * this.from) : (d = m + r * (1 - this.from), m += r * (1 - this.to)), this.shouldUpdateExtremes(g.DOMType) ? e.setExtremes(m, d, !0, "mousemove" !== g.DOMType && "touchmove" !== g.DOMType, g) : this.setRange(this.from, this.to));
                }));
              });
              g(v, "afterRender", function () {
                var e = x(this),
                    g = e.scrollMin,
                    d = e.scrollMax;
                e = this.scrollbar;
                var a = this.axisTitleMargin + (this.titleOffset || 0),
                    p = this.chart.scrollbarsOffsets,
                    v = this.options.margin || 0;
                e && (this.horiz ? (this.opposite || (p[1] += a), e.position(this.left, this.top + this.height + 2 + p[1] - (this.opposite ? v : 0), this.width, this.height), this.opposite || (p[1] += v), a = 1) : (this.opposite && (p[0] += a), e.position(this.left + this.width + 2 + p[0] - (this.opposite ? 0 : v), this.top, this.width, this.height), this.opposite && (p[0] += v), a = 0), p[a] += e.size + e.options.margin, isNaN(g) || isNaN(d) || !C(this.min) || !C(this.max) || this.min === this.max ? e.setRange(0, 1) : (p = (this.min - g) / (d - g), g = (this.max - g) / (d - g), this.horiz && !this.reversed || !this.horiz && this.reversed ? e.setRange(p, g) : e.setRange(1 - g, 1 - p)));
              });
              g(v, "afterGetOffset", function () {
                var e = this.horiz ? 2 : 1,
                    g = this.scrollbar;
                g && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[e] += g.size + g.options.margin);
              });
              return v;
            };

            e.composed = [];
            return e;
          }();
        });
        M(g, "Core/ScrollbarDefaults.js", [g["Core/Globals.js"], g["Core/Color/Palette.js"]], function (e, g) {
          return {
            height: e.isTouchDevice ? 20 : 14,
            barBorderRadius: 0,
            buttonBorderRadius: 0,
            liveRedraw: void 0,
            margin: 10,
            minWidth: 6,
            step: .2,
            zIndex: 3,
            barBackgroundColor: g.neutralColor20,
            barBorderWidth: 1,
            barBorderColor: g.neutralColor20,
            buttonArrowColor: g.neutralColor80,
            buttonBackgroundColor: g.neutralColor10,
            buttonBorderColor: g.neutralColor20,
            buttonBorderWidth: 1,
            rifleColor: g.neutralColor80,
            trackBackgroundColor: g.neutralColor5,
            trackBorderColor: g.neutralColor5,
            trackBorderWidth: 1
          };
        });
        M(g, "Core/Scrollbar.js", [g["Core/DefaultOptions.js"], g["Core/Globals.js"], g["Core/Axis/ScrollbarAxis.js"], g["Core/ScrollbarDefaults.js"], g["Core/Utilities.js"]], function (e, g, C, y, E) {
          var v = e.defaultOptions,
              G = E.addEvent,
              x = E.correctFloat,
              r = E.defined,
              m = E.destroyObjectProperties,
              d = E.fireEvent,
              a = E.merge,
              p = E.pick,
              B = E.removeEvent;

          e = function () {
            function e(a, d, e) {
              this._events = [];
              this.chart = void 0;
              this.from = this.chartY = this.chartX = 0;
              this.scrollbar = this.renderer = this.options = this.group = void 0;
              this.scrollbarButtons = [];
              this.scrollbarGroup = void 0;
              this.scrollbarLeft = 0;
              this.scrollbarRifles = void 0;
              this.scrollbarStrokeWidth = 1;
              this.to = this.size = this.scrollbarTop = 0;
              this.track = void 0;
              this.trackBorderWidth = 1;
              this.userOptions = void 0;
              this.y = this.x = 0;
              this.init(a, d, e);
            }

            e.compose = function (a) {
              C.compose(a, e);
            };

            e.swapXY = function (a, d) {
              d && a.forEach(function (a) {
                for (var d = a.length, e, f = 0; f < d; f += 2) {
                  e = a[f + 1], "number" === typeof e && (a[f + 1] = a[f + 2], a[f + 2] = e);
                }
              });
              return a;
            };

            e.prototype.addEvents = function () {
              var a = this.options.inverted ? [1, 0] : [0, 1],
                  d = this.scrollbarButtons,
                  e = this.scrollbarGroup.element,
                  l = this.track.element,
                  m = this.mouseDownHandler.bind(this),
                  p = this.mouseMoveHandler.bind(this),
                  r = this.mouseUpHandler.bind(this);
              a = [[d[a[0]].element, "click", this.buttonToMinClick.bind(this)], [d[a[1]].element, "click", this.buttonToMaxClick.bind(this)], [l, "click", this.trackClick.bind(this)], [e, "mousedown", m], [e.ownerDocument, "mousemove", p], [e.ownerDocument, "mouseup", r]];
              g.hasTouch && a.push([e, "touchstart", m], [e.ownerDocument, "touchmove", p], [e.ownerDocument, "touchend", r]);
              a.forEach(function (a) {
                G.apply(null, a);
              });
              this._events = a;
            };

            e.prototype.buttonToMaxClick = function (a) {
              var e = (this.to - this.from) * p(this.options.step, .2);
              this.updatePosition(this.from + e, this.to + e);
              d(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: a
              });
            };

            e.prototype.buttonToMinClick = function (a) {
              var e = x(this.to - this.from) * p(this.options.step, .2);
              this.updatePosition(x(this.from - e), x(this.to - e));
              d(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: a
              });
            };

            e.prototype.cursorToScrollbarPosition = function (a) {
              var d = this.options;
              d = d.minWidth > this.calculatedWidth ? d.minWidth : 0;
              return {
                chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - d),
                chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - d)
              };
            };

            e.prototype.destroy = function () {
              var a = this,
                  d = a.chart.scroller;
              a.removeEvents();
              ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (d) {
                a[d] && a[d].destroy && (a[d] = a[d].destroy());
              });
              d && a === d.scrollbar && (d.scrollbar = null, m(d.scrollbarButtons));
            };

            e.prototype.drawScrollbarButton = function (a) {
              var d = this.renderer,
                  g = this.scrollbarButtons,
                  h = this.options,
                  l = this.size,
                  m = d.g().add(this.group);
              g.push(m);
              m = d.rect().addClass("highcharts-scrollbar-button").add(m);
              this.chart.styledMode || m.attr({
                stroke: h.buttonBorderColor,
                "stroke-width": h.buttonBorderWidth,
                fill: h.buttonBackgroundColor
              });
              m.attr(m.crisp({
                x: -.5,
                y: -.5,
                width: l + 1,
                height: l + 1,
                r: h.buttonBorderRadius
              }, m.strokeWidth()));
              m = d.path(e.swapXY([["M", l / 2 + (a ? -1 : 1), l / 2 - 3], ["L", l / 2 + (a ? -1 : 1), l / 2 + 3], ["L", l / 2 + (a ? 2 : -2), l / 2]], h.vertical)).addClass("highcharts-scrollbar-arrow").add(g[a]);
              this.chart.styledMode || m.attr({
                fill: h.buttonArrowColor
              });
            };

            e.prototype.init = function (d, e, g) {
              this.scrollbarButtons = [];
              this.renderer = d;
              this.userOptions = e;
              this.options = a(y, v.scrollbar, e);
              this.chart = g;
              this.size = p(this.options.size, this.options.height);
              e.enabled && (this.render(), this.addEvents());
            };

            e.prototype.mouseDownHandler = function (a) {
              a = this.chart.pointer.normalize(a);
              a = this.cursorToScrollbarPosition(a);
              this.chartX = a.chartX;
              this.chartY = a.chartY;
              this.initPositions = [this.from, this.to];
              this.grabbedCenter = !0;
            };

            e.prototype.mouseMoveHandler = function (a) {
              var e = this.chart.pointer.normalize(a),
                  g = this.options.vertical ? "chartY" : "chartX",
                  h = this.initPositions || [];
              !this.grabbedCenter || a.touches && 0 === a.touches[0][g] || (e = this.cursorToScrollbarPosition(e)[g], g = this[g], g = e - g, this.hasDragged = !0, this.updatePosition(h[0] + g, h[1] + g), this.hasDragged && d(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: a.type,
                DOMEvent: a
              }));
            };

            e.prototype.mouseUpHandler = function (a) {
              this.hasDragged && d(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMType: a.type,
                DOMEvent: a
              });
              this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
            };

            e.prototype.position = function (a, d, e, g) {
              var f = this.options.vertical,
                  h = this.rendered ? "animate" : "attr",
                  k = 0;
              this.x = a;
              this.y = d + this.trackBorderWidth;
              this.width = e;
              this.xOffset = this.height = g;
              this.yOffset = k;
              f ? (this.width = this.yOffset = e = k = this.size, this.xOffset = d = 0, this.barWidth = g - 2 * e, this.x = a += this.options.margin) : (this.height = this.xOffset = g = d = this.size, this.barWidth = e - 2 * g, this.y += this.options.margin);
              this.group[h]({
                translateX: a,
                translateY: this.y
              });
              this.track[h]({
                width: e,
                height: g
              });
              this.scrollbarButtons[1][h]({
                translateX: f ? 0 : e - d,
                translateY: f ? g - k : 0
              });
            };

            e.prototype.removeEvents = function () {
              this._events.forEach(function (a) {
                B.apply(null, a);
              });

              this._events.length = 0;
            };

            e.prototype.render = function () {
              var a = this.renderer,
                  d = this.options,
                  g = this.size,
                  l = this.chart.styledMode,
                  m = a.g("scrollbar").attr({
                zIndex: d.zIndex,
                translateY: -99999
              }).add();
              this.group = m;
              this.track = a.rect().addClass("highcharts-scrollbar-track").attr({
                x: 0,
                r: d.trackBorderRadius || 0,
                height: g,
                width: g
              }).add(m);
              l || this.track.attr({
                fill: d.trackBackgroundColor,
                stroke: d.trackBorderColor,
                "stroke-width": d.trackBorderWidth
              });
              this.trackBorderWidth = this.track.strokeWidth();
              this.track.attr({
                y: -this.trackBorderWidth % 2 / 2
              });
              this.scrollbarGroup = a.g().add(m);
              this.scrollbar = a.rect().addClass("highcharts-scrollbar-thumb").attr({
                height: g,
                width: g,
                r: d.barBorderRadius || 0
              }).add(this.scrollbarGroup);
              this.scrollbarRifles = a.path(e.swapXY([["M", -3, g / 4], ["L", -3, 2 * g / 3], ["M", 0, g / 4], ["L", 0, 2 * g / 3], ["M", 3, g / 4], ["L", 3, 2 * g / 3]], d.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
              l || (this.scrollbar.attr({
                fill: d.barBackgroundColor,
                stroke: d.barBorderColor,
                "stroke-width": d.barBorderWidth
              }), this.scrollbarRifles.attr({
                stroke: d.rifleColor,
                "stroke-width": 1
              }));
              this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
              this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
              this.drawScrollbarButton(0);
              this.drawScrollbarButton(1);
            };

            e.prototype.setRange = function (a, d) {
              var e = this.options,
                  f = e.vertical,
                  g = e.minWidth,
                  h = this.barWidth,
                  l = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";

              if (r(h)) {
                var m = h * Math.min(d, 1);
                a = Math.max(a, 0);
                var p = Math.ceil(h * a);
                this.calculatedWidth = m = x(m - p);
                m < g && (p = (h - g + m) * a, m = g);
                g = Math.floor(p + this.xOffset + this.yOffset);
                h = m / 2 - .5;
                this.from = a;
                this.to = d;
                f ? (this.scrollbarGroup[l]({
                  translateY: g
                }), this.scrollbar[l]({
                  height: m
                }), this.scrollbarRifles[l]({
                  translateY: h
                }), this.scrollbarTop = g, this.scrollbarLeft = 0) : (this.scrollbarGroup[l]({
                  translateX: g
                }), this.scrollbar[l]({
                  width: m
                }), this.scrollbarRifles[l]({
                  translateX: h
                }), this.scrollbarLeft = g, this.scrollbarTop = 0);
                12 >= m ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);
                !1 === e.showFull && (0 >= a && 1 <= d ? this.group.hide() : this.group.show());
                this.rendered = !0;
              }
            };

            e.prototype.shouldUpdateExtremes = function (a) {
              return p(this.options.liveRedraw, g.svg && !g.isTouchDevice && !this.chart.isBoosting) || "mouseup" === a || "touchend" === a || !r(a);
            };

            e.prototype.trackClick = function (a) {
              var e = this.chart.pointer.normalize(a),
                  g = this.to - this.from,
                  h = this.y + this.scrollbarTop,
                  l = this.x + this.scrollbarLeft;
              this.options.vertical && e.chartY > h || !this.options.vertical && e.chartX > l ? this.updatePosition(this.from + g, this.to + g) : this.updatePosition(this.from - g, this.to - g);
              d(this, "changed", {
                from: this.from,
                to: this.to,
                trigger: "scrollbar",
                DOMEvent: a
              });
            };

            e.prototype.update = function (d) {
              this.destroy();
              this.init(this.chart.renderer, a(!0, this.options, d), this.chart);
            };

            e.prototype.updatePosition = function (a, d) {
              1 < d && (a = x(1 - x(d - a)), d = 1);
              0 > a && (d = x(d - a), a = 0);
              this.from = a;
              this.to = d;
            };

            e.defaultOptions = y;
            return e;
          }();

          v.scrollbar = a(!0, e.defaultOptions, v.scrollbar);
          return e;
        });
        M(g, "Extensions/RangeSelector.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Globals.js"], g["Core/DefaultOptions.js"], g["Core/Color/Palette.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G) {
          function x(a) {
            if (-1 !== a.indexOf("%L")) return "text";
            var b = "aAdewbBmoyY".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            }),
                c = "HkIlMS".split("").some(function (b) {
              return -1 !== a.indexOf("%" + b);
            });
            return b && c ? "datetime-local" : b ? "date" : c ? "time" : "text";
          }

          var r = y.defaultOptions,
              m = G.addEvent,
              d = G.createElement,
              a = G.css,
              p = G.defined,
              B = G.destroyObjectProperties,
              l = G.discardElement,
              h = G.extend,
              f = G.find,
              k = G.fireEvent,
              J = G.isNumber,
              K = G.merge,
              t = G.objectEach,
              M = G.pad,
              z = G.pick,
              A = G.pInt,
              c = G.splat;
          h(r, {
            rangeSelector: {
              allButtonsEnabled: !1,
              buttons: void 0,
              buttonSpacing: 5,
              dropdown: "responsive",
              enabled: void 0,
              verticalAlign: "top",
              buttonTheme: {
                width: 28,
                height: 18,
                padding: 2,
                zIndex: 7
              },
              floating: !1,
              x: 0,
              y: 0,
              height: void 0,
              inputBoxBorderColor: "none",
              inputBoxHeight: 17,
              inputBoxWidth: void 0,
              inputDateFormat: "%b %e, %Y",
              inputDateParser: void 0,
              inputEditDateFormat: "%Y-%m-%d",
              inputEnabled: !0,
              inputPosition: {
                align: "right",
                x: 0,
                y: 0
              },
              inputSpacing: 5,
              selected: void 0,
              buttonPosition: {
                align: "left",
                x: 0,
                y: 0
              },
              inputStyle: {
                color: E.highlightColor80,
                cursor: "pointer"
              },
              labelStyle: {
                color: E.neutralColor60
              }
            }
          });
          h(r.lang, {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "\u2192"
          });

          var b = function () {
            function b(a) {
              this.buttons = void 0;
              this.buttonOptions = b.prototype.defaultButtons;
              this.initialButtonGroupWidth = 0;
              this.options = void 0;
              this.chart = a;
              this.init(a);
            }

            b.prototype.clickButton = function (a, b) {
              var d = this.chart,
                  f = this.buttonOptions[a],
                  g = d.xAxis[0],
                  h = d.scroller && d.scroller.getUnionExtremes() || g || {},
                  l = h.dataMin,
                  n = h.dataMax,
                  r = g && Math.round(Math.min(g.max, z(n, g.max))),
                  t = f.type;
              h = f._range;
              var u,
                  v = f.dataGrouping;

              if (null !== l && null !== n) {
                d.fixedRange = h;
                this.setSelected(a);
                v && (this.forcedDataGrouping = !0, e.prototype.setDataGrouping.call(g || {
                  chart: this.chart
                }, v, !1), this.frozenStates = f.preserveDataGrouping);
                if ("month" === t || "year" === t) {
                  if (g) {
                    t = {
                      range: f,
                      max: r,
                      chart: d,
                      dataMin: l,
                      dataMax: n
                    };
                    var x = g.minFromRange.call(t);
                    J(t.newMax) && (r = t.newMax);
                  } else h = f;
                } else if (h) x = Math.max(r - h, l), r = Math.min(x + h, n);else if ("ytd" === t) {
                  if (g) "undefined" === typeof n && (l = Number.MAX_VALUE, n = Number.MIN_VALUE, d.series.forEach(function (a) {
                    a = a.xData;
                    l = Math.min(a[0], l);
                    n = Math.max(a[a.length - 1], n);
                  }), b = !1), r = this.getYTDExtremes(n, l, d.time.useUTC), x = u = r.min, r = r.max;else {
                    this.deferredYTDClick = a;
                    return;
                  }
                } else "all" === t && g && (d.navigator && d.navigator.baseSeries[0] && (d.navigator.baseSeries[0].xAxis.options.range = void 0), x = l, r = n);
                p(x) && (x += f._offsetMin);
                p(r) && (r += f._offsetMax);
                this.dropdown && (this.dropdown.selectedIndex = a + 1);
                if (g) g.setExtremes(x, r, z(b, !0), void 0, {
                  trigger: "rangeSelectorButton",
                  rangeSelectorButton: f
                });else {
                  var y = c(d.options.xAxis)[0];
                  var A = y.range;
                  y.range = h;
                  var B = y.min;
                  y.min = u;
                  m(d, "load", function () {
                    y.range = A;
                    y.min = B;
                  });
                }
                k(this, "afterBtnClick");
              }
            };

            b.prototype.setSelected = function (a) {
              this.selected = this.options.selected = a;
            };

            b.prototype.init = function (a) {
              var b = this,
                  c = a.options.rangeSelector,
                  d = c.buttons || b.defaultButtons.slice(),
                  e = c.selected,
                  f = function f() {
                var a = b.minInput,
                    c = b.maxInput;
                a && a.blur && k(a, "blur");
                c && c.blur && k(c, "blur");
              };

              b.chart = a;
              b.options = c;
              b.buttons = [];
              b.buttonOptions = d;
              this.eventsToUnbind = [];
              this.eventsToUnbind.push(m(a.container, "mousedown", f));
              this.eventsToUnbind.push(m(a, "resize", f));
              d.forEach(b.computeButtonRange);
              "undefined" !== typeof e && d[e] && this.clickButton(e, !1);
              this.eventsToUnbind.push(m(a, "load", function () {
                a.xAxis && a.xAxis[0] && m(a.xAxis[0], "setExtremes", function (c) {
                  this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);
                });
              }));
            };

            b.prototype.updateButtonStates = function () {
              var a = this,
                  b = this.chart,
                  c = this.dropdown,
                  d = b.xAxis[0],
                  e = Math.round(d.max - d.min),
                  f = !d.hasVisibleSeries,
                  g = b.scroller && b.scroller.getUnionExtremes() || d,
                  h = g.dataMin,
                  k = g.dataMax;
              b = a.getYTDExtremes(k, h, b.time.useUTC);
              var l = b.min,
                  m = b.max,
                  p = a.selected,
                  r = J(p),
                  t = a.options.allButtonsEnabled,
                  v = a.buttons;
              a.buttonOptions.forEach(function (b, g) {
                var n = b._range,
                    q = b.type,
                    w = b.count || 1,
                    u = v[g],
                    H = 0,
                    F = b._offsetMax - b._offsetMin;
                b = g === p;
                var x = n > k - h,
                    O = n < d.minRange,
                    y = !1,
                    z = !1;
                n = n === e;
                ("month" === q || "year" === q) && e + 36E5 >= 864E5 * {
                  month: 28,
                  year: 365
                }[q] * w - F && e - 36E5 <= 864E5 * {
                  month: 31,
                  year: 366
                }[q] * w + F ? n = !0 : "ytd" === q ? (n = m - l + F === e, y = !b) : "all" === q && (n = d.max - d.min >= k - h, z = !b && r && n);
                q = !t && (x || O || z || f);
                w = b && n || n && !r && !y || b && a.frozenStates;
                q ? H = 3 : w && (r = !0, H = 2);
                u.state !== H && (u.setState(H), c && (c.options[g + 1].disabled = q, 2 === H && (c.selectedIndex = g + 1)), 0 === H && p === g && a.setSelected());
              });
            };

            b.prototype.computeButtonRange = function (a) {
              var b = a.type,
                  c = a.count || 1,
                  d = {
                millisecond: 1,
                second: 1E3,
                minute: 6E4,
                hour: 36E5,
                day: 864E5,
                week: 6048E5
              };
              if (d[b]) a._range = d[b] * c;else if ("month" === b || "year" === b) a._range = 864E5 * {
                month: 30,
                year: 365
              }[b] * c;
              a._offsetMin = z(a.offsetMin, 0);
              a._offsetMax = z(a.offsetMax, 0);
              a._range += a._offsetMax - a._offsetMin;
            };

            b.prototype.getInputValue = function (a) {
              a = "min" === a ? this.minInput : this.maxInput;
              var b = this.chart.options.rangeSelector,
                  c = this.chart.time;
              return a ? ("text" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;
            };

            b.prototype.setInputValue = function (a, b) {
              var c = this.options,
                  d = this.chart.time,
                  e = "min" === a ? this.minInput : this.maxInput;
              a = "min" === a ? this.minDateBox : this.maxDateBox;

              if (e) {
                var f = e.getAttribute("data-hc-time");
                f = p(f) ? Number(f) : void 0;
                p(b) && (p(f) && e.setAttribute("data-hc-time-previous", f), e.setAttribute("data-hc-time", b), f = b);
                e.value = d.dateFormat(this.inputTypeFormats[e.type] || c.inputEditDateFormat, f);
                a && a.attr({
                  text: d.dateFormat(c.inputDateFormat, f)
                });
              }
            };

            b.prototype.setInputExtremes = function (a, b, c) {
              if (a = "min" === a ? this.minInput : this.maxInput) {
                var d = this.inputTypeFormats[a.type],
                    e = this.chart.time;
                d && (b = e.dateFormat(d, b), a.min !== b && (a.min = b), c = e.dateFormat(d, c), a.max !== c && (a.max = c));
              }
            };

            b.prototype.showInput = function (b) {
              var c = "min" === b ? this.minDateBox : this.maxDateBox;

              if ((b = "min" === b ? this.minInput : this.maxInput) && c && this.inputGroup) {
                var d = "text" === b.type,
                    e = this.inputGroup,
                    f = e.translateX;
                e = e.translateY;
                var g = this.options.inputBoxWidth;
                a(b, {
                  width: d ? c.width + (g ? -2 : 20) + "px" : "auto",
                  height: d ? c.height - 2 + "px" : "auto",
                  border: "2px solid silver"
                });
                d && g ? a(b, {
                  left: f + c.x + "px",
                  top: e + "px"
                }) : a(b, {
                  left: Math.min(Math.round(c.x + f - (b.offsetWidth - c.width) / 2), this.chart.chartWidth - b.offsetWidth) + "px",
                  top: e - (b.offsetHeight - c.height) / 2 + "px"
                });
              }
            };

            b.prototype.hideInput = function (b) {
              (b = "min" === b ? this.minInput : this.maxInput) && a(b, {
                top: "-9999em",
                border: 0,
                width: "1px",
                height: "1px"
              });
            };

            b.prototype.defaultInputDateParser = function (a, b, c) {
              var d = a.split("/").join("-").split(" ").join("T");
              -1 === d.indexOf("T") && (d += "T00:00");
              if (b) d += "Z";else {
                var e;
                if (e = C.isSafari) e = d, e = !(6 < e.length && (e.lastIndexOf("-") === e.length - 6 || e.lastIndexOf("+") === e.length - 6));
                e && (e = new Date(d).getTimezoneOffset() / 60, d += 0 >= e ? "+" + M(-e) + ":00" : "-" + M(e) + ":00");
              }
              d = Date.parse(d);
              J(d) || (a = a.split("-"), d = Date.UTC(A(a[0]), A(a[1]) - 1, A(a[2])));
              c && b && J(d) && (d += c.getTimezoneOffset(d));
              return d;
            };

            b.prototype.drawInput = function (b) {
              function c() {
                var a = k.getInputValue(b),
                    c = e.xAxis[0],
                    d = e.scroller && e.scroller.xAxis ? e.scroller.xAxis : c,
                    f = d.dataMin;
                d = d.dataMax;
                var g = k.maxInput,
                    h = k.minInput;
                a !== Number(v.getAttribute("data-hc-time-previous")) && J(a) && (v.setAttribute("data-hc-time-previous", a), p && g && J(f) ? a > Number(g.getAttribute("data-hc-time")) ? a = void 0 : a < f && (a = f) : h && J(d) && (a < Number(h.getAttribute("data-hc-time")) ? a = void 0 : a > d && (a = d)), "undefined" !== typeof a && c.setExtremes(p ? a : c.min, p ? c.max : a, void 0, void 0, {
                  trigger: "rangeSelectorInput"
                }));
              }

              var e = this.chart,
                  f = this.div,
                  g = this.inputGroup,
                  k = this,
                  l = e.renderer.style || {},
                  m = e.renderer,
                  n = e.options.rangeSelector,
                  p = "min" === b,
                  t = r.lang[p ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
              t = m.label(t, 0).addClass("highcharts-range-label").attr({
                padding: t ? 2 : 0,
                height: t ? n.inputBoxHeight : 0
              }).add(g);
              m = m.label("", 0).addClass("highcharts-range-input").attr({
                padding: 2,
                width: n.inputBoxWidth,
                height: n.inputBoxHeight,
                "text-align": "center"
              }).on("click", function () {
                k.showInput(b);
                k[b + "Input"].focus();
              });
              e.styledMode || m.attr({
                stroke: n.inputBoxBorderColor,
                "stroke-width": 1
              });
              m.add(g);
              var v = d("input", {
                name: b,
                className: "highcharts-range-selector"
              }, void 0, f);
              v.setAttribute("type", x(n.inputDateFormat || "%b %e, %Y"));
              e.styledMode || (t.css(K(l, n.labelStyle)), m.css(K({
                color: E.neutralColor80
              }, l, n.inputStyle)), a(v, h({
                position: "absolute",
                border: 0,
                boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                width: "1px",
                height: "1px",
                padding: 0,
                textAlign: "center",
                fontSize: l.fontSize,
                fontFamily: l.fontFamily,
                top: "-9999em"
              }, n.inputStyle)));

              v.onfocus = function () {
                k.showInput(b);
              };

              v.onblur = function () {
                v === C.doc.activeElement && c();
                k.hideInput(b);
                k.setInputValue(b);
                v.blur();
              };

              var y = !1;

              v.onchange = function () {
                y || (c(), k.hideInput(b), v.blur());
              };

              v.onkeypress = function (a) {
                13 === a.keyCode && c();
              };

              v.onkeydown = function (a) {
                y = !0;
                38 !== a.keyCode && 40 !== a.keyCode || c();
              };

              v.onkeyup = function () {
                y = !1;
              };

              return {
                dateBox: m,
                input: v,
                label: t
              };
            };

            b.prototype.getPosition = function () {
              var a = this.chart,
                  b = a.options.rangeSelector;
              a = "top" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;
              return {
                buttonTop: a + b.buttonPosition.y,
                inputTop: a + b.inputPosition.y - 10
              };
            };

            b.prototype.getYTDExtremes = function (a, b, c) {
              var d = this.chart.time,
                  e = new d.Date(a),
                  f = d.get("FullYear", e);
              c = c ? d.Date.UTC(f, 0, 1) : +new d.Date(f, 0, 1);
              b = Math.max(b, c);
              e = e.getTime();
              return {
                max: Math.min(a || e, e),
                min: b
              };
            };

            b.prototype.render = function (a, b) {
              var c = this.chart,
                  e = c.renderer,
                  f = c.container,
                  g = c.options,
                  h = g.rangeSelector,
                  k = z(g.chart.style && g.chart.style.zIndex, 0) + 1;
              g = h.inputEnabled;

              if (!1 !== h.enabled) {
                this.rendered || (this.group = e.g("range-selector-group").attr({
                  zIndex: 7
                }).add(), this.div = d("div", void 0, {
                  position: "relative",
                  height: 0,
                  zIndex: k
                }), this.buttonOptions.length && this.renderButtons(), f.parentNode && f.parentNode.insertBefore(this.div, f), g && (this.inputGroup = e.g("input-group").add(this.group), e = this.drawInput("min"), this.minDateBox = e.dateBox, this.minLabel = e.label, this.minInput = e.input, e = this.drawInput("max"), this.maxDateBox = e.dateBox, this.maxLabel = e.label, this.maxInput = e.input));

                if (g && (this.setInputValue("min", a), this.setInputValue("max", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, p(a.dataMin) && p(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes("min", a.dataMin, Math.min(a.dataMax, this.getInputValue("max")) - c), this.setInputExtremes("max", Math.max(a.dataMin, this.getInputValue("min")) + c, a.dataMax)), this.inputGroup)) {
                  var l = 0;
                  [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {
                    if (a) {
                      var b = a.getBBox().width;
                      b && (a.attr({
                        x: l
                      }), l += b + h.inputSpacing);
                    }
                  });
                }

                this.alignElements();
                this.rendered = !0;
              }
            };

            b.prototype.renderButtons = function () {
              var a = this,
                  b = this.buttons,
                  c = this.options,
                  e = r.lang,
                  f = this.chart.renderer,
                  g = K(c.buttonTheme),
                  h = g && g.states,
                  l = g.width || 28;
              delete g.width;
              delete g.states;
              this.buttonGroup = f.g("range-selector-buttons").add(this.group);
              var p = this.dropdown = d("select", void 0, {
                position: "absolute",
                width: "1px",
                height: "1px",
                padding: 0,
                border: 0,
                top: "-9999em",
                cursor: "pointer",
                opacity: .0001
              }, this.div);
              m(p, "touchstart", function () {
                p.style.fontSize = "16px";
              });
              [[C.isMS ? "mouseover" : "mouseenter"], [C.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(function (c) {
                var d = c[0],
                    e = c[1];
                m(p, d, function () {
                  var c = b[a.currentButtonIndex()];
                  c && k(c.element, e || d);
                });
              });
              this.zoomText = f.label(e && e.rangeSelectorZoom || "", 0).attr({
                padding: c.buttonTheme.padding,
                height: c.buttonTheme.height,
                paddingLeft: 0,
                paddingRight: 0
              }).add(this.buttonGroup);
              this.chart.styledMode || (this.zoomText.css(c.labelStyle), g["stroke-width"] = z(g["stroke-width"], 0));
              d("option", {
                textContent: this.zoomText.textStr,
                disabled: !0
              }, void 0, p);
              this.buttonOptions.forEach(function (c, e) {
                d("option", {
                  textContent: c.title || c.text
                }, void 0, p);
                b[e] = f.button(c.text, 0, 0, function (b) {
                  var d = c.events && c.events.click,
                      f;
                  d && (f = d.call(c, b));
                  !1 !== f && a.clickButton(e);
                  a.isActive = !0;
                }, g, h && h.hover, h && h.select, h && h.disabled).attr({
                  "text-align": "center",
                  width: l
                }).add(a.buttonGroup);
                c.title && b[e].attr("title", c.title);
              });
            };

            b.prototype.alignElements = function () {
              var a = this,
                  b = this.buttonGroup,
                  c = this.buttons,
                  d = this.chart,
                  e = this.group,
                  f = this.inputGroup,
                  g = this.options,
                  h = this.zoomText,
                  k = d.options,
                  l = k.exporting && !1 !== k.exporting.enabled && k.navigation && k.navigation.buttonOptions;
              k = g.buttonPosition;

              var m = g.inputPosition,
                  p = g.verticalAlign,
                  r = function r(b, c) {
                return l && a.titleCollision(d) && "top" === p && "right" === c.align && c.y - b.getBBox().height - 12 < (l.y || 0) + (l.height || 0) + d.spacing[0] ? -40 : 0;
              },
                  t = d.plotLeft;

              if (e && k && m) {
                var v = k.x - d.spacing[3];

                if (b) {
                  this.positionButtons();

                  if (!this.initialButtonGroupWidth) {
                    var x = 0;
                    h && (x += h.getBBox().width + 5);
                    c.forEach(function (a, b) {
                      x += a.width;
                      b !== c.length - 1 && (x += g.buttonSpacing);
                    });
                    this.initialButtonGroupWidth = x;
                  }

                  t -= d.spacing[3];
                  this.updateButtonStates();
                  h = r(b, k);
                  this.alignButtonGroup(h);
                  e.placed = b.placed = d.hasLoaded;
                }

                b = 0;
                f && (b = r(f, m), "left" === m.align ? v = t : "right" === m.align && (v = -Math.max(d.axisOffset[1], -b)), f.align({
                  y: m.y,
                  width: f.getBBox().width,
                  align: m.align,
                  x: m.x + v - 2
                }, !0, d.spacingBox), f.placed = d.hasLoaded);
                this.handleCollision(b);
                e.align({
                  verticalAlign: p
                }, !0, d.spacingBox);
                f = e.alignAttr.translateY;
                b = e.getBBox().height + 20;
                r = 0;
                "bottom" === p && (r = (r = d.legend && d.legend.options) && "bottom" === r.verticalAlign && r.enabled && !r.floating ? d.legend.legendHeight + z(r.margin, 10) : 0, b = b + r - 20, r = f - b - (g.floating ? 0 : g.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);
                if ("top" === p) g.floating && (r = 0), d.titleOffset && d.titleOffset[0] && (r = d.titleOffset[0]), r += d.margin[0] - d.spacing[0] || 0;else if ("middle" === p) if (m.y === k.y) r = f;else if (m.y || k.y) r = 0 > m.y || 0 > k.y ? r - Math.min(m.y, k.y) : f - b;
                e.translate(g.x, g.y + Math.floor(r));
                k = this.minInput;
                m = this.maxInput;
                f = this.dropdown;
                g.inputEnabled && k && m && (k.style.marginTop = e.translateY + "px", m.style.marginTop = e.translateY + "px");
                f && (f.style.marginTop = e.translateY + "px");
              }
            };

            b.prototype.alignButtonGroup = function (a, b) {
              var c = this.chart,
                  d = this.buttonGroup,
                  e = this.options.buttonPosition,
                  f = c.plotLeft - c.spacing[3],
                  g = e.x - c.spacing[3];
              "right" === e.align ? g += a - f : "center" === e.align && (g -= f / 2);
              d && d.align({
                y: e.y,
                width: z(b, this.initialButtonGroupWidth),
                align: e.align,
                x: g
              }, !0, c.spacingBox);
            };

            b.prototype.positionButtons = function () {
              var a = this.buttons,
                  b = this.chart,
                  c = this.options,
                  d = this.zoomText,
                  e = b.hasLoaded ? "animate" : "attr",
                  f = c.buttonPosition,
                  g = b.plotLeft,
                  h = g;
              d && "hidden" !== d.visibility && (d[e]({
                x: z(g + f.x, g)
              }), h += f.x + d.getBBox().width + 5);
              this.buttonOptions.forEach(function (b, d) {
                if ("hidden" !== a[d].visibility) a[d][e]({
                  x: h
                }), h += a[d].width + c.buttonSpacing;else a[d][e]({
                  x: g
                });
              });
            };

            b.prototype.handleCollision = function (a) {
              var b = this,
                  c = this.chart,
                  d = this.buttonGroup,
                  e = this.inputGroup,
                  f = this.options,
                  g = f.buttonPosition,
                  h = f.dropdown,
                  k = f.inputPosition;

              f = function f() {
                var a = 0;
                b.buttons.forEach(function (b) {
                  b = b.getBBox();
                  b.width > a && (a = b.width);
                });
                return a;
              };

              var l = function l(b) {
                if (e && d) {
                  var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,
                      f = e.alignOptions.width,
                      h = d.alignAttr.translateX + d.getBBox().x;
                  return h + b > c && c + f > h && g.y < k.y + e.getBBox().height;
                }

                return !1;
              },
                  m = function m() {
                e && d && e.attr({
                  translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),
                  translateY: e.alignAttr.translateY + d.getBBox().height + 10
                });
              };

              if (d) {
                if ("always" === h) {
                  this.collapseButtons(a);
                  l(f()) && m();
                  return;
                }

                "never" === h && this.expandButtons();
              }

              e && d ? k.align === g.align || l(this.initialButtonGroupWidth + 20) ? "responsive" === h ? (this.collapseButtons(a), l(f()) && m()) : m() : "responsive" === h && this.expandButtons() : d && "responsive" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());
            };

            b.prototype.collapseButtons = function (a) {
              var b = this.buttons,
                  c = this.buttonOptions,
                  d = this.chart,
                  e = this.dropdown,
                  f = this.options,
                  g = this.zoomText,
                  h = d.userOptions.rangeSelector && d.userOptions.rangeSelector.buttonTheme || {},
                  k = function k(a) {
                return {
                  text: a ? a + " \u25BE" : "\u25BE",
                  width: "auto",
                  paddingLeft: z(f.buttonTheme.paddingLeft, h.padding, 8),
                  paddingRight: z(f.buttonTheme.paddingRight, h.padding, 8)
                };
              };

              g && g.hide();
              var l = !1;
              c.forEach(function (a, c) {
                c = b[c];
                2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), l = !0);
              });
              l || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));
              c = f.buttonPosition.align;
              this.positionButtons();
              "right" !== c && "center" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);
              this.showDropdown();
            };

            b.prototype.expandButtons = function () {
              var a = this.buttons,
                  b = this.buttonOptions,
                  c = this.options,
                  d = this.zoomText;
              this.hideDropdown();
              d && d.show();
              b.forEach(function (b, d) {
                d = a[d];
                d.show();
                d.attr({
                  text: b.text,
                  width: c.buttonTheme.width || 28,
                  paddingLeft: z(c.buttonTheme.paddingLeft, "unset"),
                  paddingRight: z(c.buttonTheme.paddingRight, "unset")
                });
                2 > d.state && d.setState(0);
              });
              this.positionButtons();
            };

            b.prototype.currentButtonIndex = function () {
              var a = this.dropdown;
              return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;
            };

            b.prototype.showDropdown = function () {
              var b = this.buttonGroup,
                  c = this.buttons,
                  d = this.chart,
                  e = this.dropdown;

              if (b && e) {
                var f = b.translateX;
                b = b.translateY;
                c = c[this.currentButtonIndex()].getBBox();
                a(e, {
                  left: d.plotLeft + f + "px",
                  top: b + .5 + "px",
                  width: c.width + "px",
                  height: c.height + "px"
                });
                this.hasVisibleDropdown = !0;
              }
            };

            b.prototype.hideDropdown = function () {
              var b = this.dropdown;
              b && (a(b, {
                top: "-9999em",
                width: "1px",
                height: "1px"
              }), this.hasVisibleDropdown = !1);
            };

            b.prototype.getHeight = function () {
              var a = this.options,
                  b = this.group,
                  c = a.y,
                  d = a.buttonPosition.y,
                  e = a.inputPosition.y;
              if (a.height) return a.height;
              this.alignElements();
              a = b ? b.getBBox(!0).height + 13 + c : 0;
              b = Math.min(e, d);
              if (0 > e && 0 > d || 0 < e && 0 < d) a += Math.abs(b);
              return a;
            };

            b.prototype.titleCollision = function (a) {
              return !(a.options.title.text || a.options.subtitle.text);
            };

            b.prototype.update = function (a) {
              var b = this.chart;
              K(!0, b.options.rangeSelector, a);
              this.destroy();
              this.init(b);
              this.render();
            };

            b.prototype.destroy = function () {
              var a = this,
                  c = a.minInput,
                  d = a.maxInput;
              a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {
                return a();
              }), a.eventsToUnbind = void 0);
              B(a.buttons);
              c && (c.onfocus = c.onblur = c.onchange = null);
              d && (d.onfocus = d.onblur = d.onchange = null);
              t(a, function (c, d) {
                c && "chart" !== d && (c instanceof v ? c.destroy() : c instanceof window.HTMLElement && l(c));
                c !== b.prototype[d] && (a[d] = null);
              }, this);
            };

            return b;
          }();

          b.prototype.defaultButtons = [{
            type: "month",
            count: 1,
            text: "1m",
            title: "View 1 month"
          }, {
            type: "month",
            count: 3,
            text: "3m",
            title: "View 3 months"
          }, {
            type: "month",
            count: 6,
            text: "6m",
            title: "View 6 months"
          }, {
            type: "ytd",
            text: "YTD",
            title: "View year to date"
          }, {
            type: "year",
            count: 1,
            text: "1y",
            title: "View 1 year"
          }, {
            type: "all",
            text: "All",
            title: "View all"
          }];
          b.prototype.inputTypeFormats = {
            "datetime-local": "%Y-%m-%dT%H:%M:%S",
            date: "%Y-%m-%d",
            time: "%H:%M:%S"
          };

          e.prototype.minFromRange = function () {
            var a = this.range,
                b = a.type,
                c = this.max,
                d = this.chart.time,
                e = function e(a, c) {
              var e = "year" === b ? "FullYear" : "Month",
                  f = new d.Date(a),
                  g = d.get(e, f);
              d.set(e, f, g + c);
              g === d.get(e, f) && d.set("Date", f, 0);
              return f.getTime() - a;
            };

            if (J(a)) {
              var f = c - a;
              var g = a;
            } else f = c + e(c, -a.count), this.chart && (this.chart.fixedRange = c - f);

            var h = z(this.dataMin, Number.MIN_VALUE);
            J(f) || (f = h);
            f <= h && (f = h, "undefined" === typeof g && (g = e(f, a.count)), this.newMax = Math.min(f + g, this.dataMax));
            J(c) || (f = void 0);
            return f;
          };

          if (!C.RangeSelector) {
            var D = [],
                L = function L(a) {
              function b() {
                d && (c = a.xAxis[0].getExtremes(), e = a.legend, h = d && d.options.verticalAlign, J(c.min) && d.render(c.min, c.max), e.display && "top" === h && h === e.options.verticalAlign && (g = K(a.spacingBox), g.y = "vertical" === e.options.layout ? a.plotTop : g.y + d.getHeight(), e.group.placed = !1, e.align(g)));
              }

              var c,
                  d = a.rangeSelector,
                  e,
                  g,
                  h;
              d && (f(D, function (b) {
                return b[0] === a;
              }) || D.push([a, [m(a.xAxis[0], "afterSetExtremes", function (a) {
                d && d.render(a.min, a.max);
              }), m(a, "redraw", b)]]), b());
            };

            m(g, "afterGetContainer", function () {
              this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new b(this));
            });
            m(g, "beforeRender", function () {
              var a = this.axes,
                  b = this.rangeSelector;
              b && (J(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {
                a.updateNames();
                a.setScale();
              }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || ("bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0)));
            });
            m(g, "update", function (a) {
              var c = a.options.rangeSelector;
              a = this.rangeSelector;
              var d = this.extraBottomMargin,
                  e = this.extraTopMargin;
              c && c.enabled && !p(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new b(this));
              this.extraTopMargin = this.extraBottomMargin = !1;
              a && (L(this), c = c && c.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || ("bottom" === c ? this.extraBottomMargin = !0 : "middle" !== c && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== e) && (this.isDirtyBox = !0);
            });
            m(g, "render", function () {
              var a = this.rangeSelector;
              a && !a.options.floating && (a.render(), a = a.options.verticalAlign, "bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0));
            });
            m(g, "getMargins", function () {
              var a = this.rangeSelector;
              a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));
            });
            g.prototype.callbacks.push(L);
            m(g, "destroy", function () {
              for (var a = 0; a < D.length; a++) {
                var b = D[a];

                if (b[0] === this) {
                  b[1].forEach(function (a) {
                    return a();
                  });
                  D.splice(a, 1);
                  break;
                }
              }
            });
            C.RangeSelector = b;
          }

          return b;
        });
        M(g, "Core/Axis/NavigatorAxis.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (e, g) {
          var C = e.isTouchDevice,
              y = g.addEvent,
              E = g.correctFloat,
              v = g.defined,
              G = g.isNumber,
              x = g.pick,
              r = function () {
            function e(d) {
              this.axis = d;
            }

            e.prototype.destroy = function () {
              this.axis = void 0;
            };

            e.prototype.toFixedRange = function (d, a, e, g) {
              var l = this.axis,
                  h = l.chart;
              h = h && h.fixedRange;
              var f = (l.pointRange || 0) / 2;
              d = x(e, l.translate(d, !0, !l.horiz));
              a = x(g, l.translate(a, !0, !l.horiz));
              l = h && (a - d) / h;
              v(e) || (d = E(d + f));
              v(g) || (a = E(a - f));
              .7 < l && 1.3 > l && (g ? d = a - h : a = d + h);
              G(d) && G(a) || (d = a = void 0);
              return {
                min: d,
                max: a
              };
            };

            return e;
          }();

          return function () {
            function e() {}

            e.compose = function (d) {
              d.keepProps.push("navigatorAxis");
              y(d, "init", function () {
                this.navigatorAxis || (this.navigatorAxis = new r(this));
              });
              y(d, "zoom", function (a) {
                var d = this.chart.options,
                    e = d.navigator,
                    g = this.navigatorAxis,
                    h = d.chart.pinchType,
                    f = d.rangeSelector;
                d = d.chart.zoomType;
                this.isXAxis && (e && e.enabled || f && f.enabled) && ("y" === d ? a.zoomed = !1 : (!C && "xy" === d || C && "xy" === h) && this.options.range && (e = g.previousZoom, v(a.newMin) ? g.previousZoom = [this.min, this.max] : e && (a.newMin = e[0], a.newMax = e[1], g.previousZoom = void 0)));
                "undefined" !== typeof a.zoomed && a.preventDefault();
              });
            };

            e.AdditionsClass = r;
            return e;
          }();
        });
        M(g, "Core/Navigator.js", [g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Axis/NavigatorAxis.js"], g["Core/DefaultOptions.js"], g["Core/Color/Palette.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Scrollbar.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (e, g, C, y, E, v, G, x, r, m, d, a) {
          C = C.parse;

          var p = y.hasTouch,
              B = y.isTouchDevice,
              l = v.defaultOptions,
              h = a.addEvent,
              f = a.clamp,
              k = a.correctFloat,
              J = a.defined,
              K = a.destroyObjectProperties,
              t = a.erase,
              M = a.extend,
              z = a.find,
              A = a.isArray,
              c = a.isNumber,
              b = a.merge,
              D = a.pick,
              L = a.removeEvent,
              I = a.splat,
              n = function n(a) {
            for (var b = [], d = 1; d < arguments.length; d++) {
              b[d - 1] = arguments[d];
            }

            b = [].filter.call(b, c);
            if (b.length) return Math[a].apply(0, b);
          };

          v = "undefined" === typeof d.seriesTypes.areaspline ? "line" : "areaspline";
          M(l, {
            navigator: {
              height: 40,
              margin: 25,
              maskInside: !0,
              handles: {
                width: 7,
                height: 15,
                symbols: ["navigator-handle", "navigator-handle"],
                enabled: !0,
                lineWidth: 1,
                backgroundColor: G.neutralColor5,
                borderColor: G.neutralColor40
              },
              maskFill: C(G.highlightColor60).setOpacity(.3).get(),
              outlineColor: G.neutralColor20,
              outlineWidth: 1,
              series: {
                type: v,
                fillOpacity: .05,
                lineWidth: 1,
                compare: null,
                dataGrouping: {
                  approximation: "average",
                  enabled: !0,
                  groupPixelWidth: 2,
                  firstAnchor: "firstPoint",
                  anchor: "middle",
                  lastAnchor: "lastPoint",
                  units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
                },
                dataLabels: {
                  enabled: !1,
                  zIndex: 2
                },
                id: "highcharts-navigator-series",
                className: "highcharts-navigator-series",
                lineColor: null,
                marker: {
                  enabled: !1
                },
                threshold: null
              },
              xAxis: {
                overscroll: 0,
                className: "highcharts-navigator-xaxis",
                tickLength: 0,
                lineWidth: 0,
                gridLineColor: G.neutralColor10,
                gridLineWidth: 1,
                tickPixelInterval: 200,
                labels: {
                  align: "left",
                  style: {
                    color: G.neutralColor40
                  },
                  x: 3,
                  y: -4
                },
                crosshair: !1
              },
              yAxis: {
                className: "highcharts-navigator-yaxis",
                gridLineWidth: 0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: .1,
                maxPadding: .1,
                labels: {
                  enabled: !1
                },
                crosshair: !1,
                title: {
                  text: null
                },
                tickLength: 0,
                tickWidth: 0
              }
            }
          });

          x.getRendererType().prototype.symbols["navigator-handle"] = function (a, b, c, d, e) {
            a = (e && e.width || 0) / 2;
            b = Math.round(a / 3) + .5;
            e = e && e.height || 0;
            return [["M", -a - 1, .5], ["L", a, .5], ["L", a, e + .5], ["L", -a - 1, e + .5], ["L", -a - 1, .5], ["M", -b, 4], ["L", -b, e - 3], ["M", b - 1, 4], ["L", b - 1, e - 3]];
          };

          var u = function () {
            function a(a) {
              this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;
              this.init(a);
            }

            a.prototype.drawHandle = function (a, b, c, d) {
              var e = this.navigatorOptions.handles.height;
              this.handles[b][d](c ? {
                translateX: Math.round(this.left + this.height / 2),
                translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)
              } : {
                translateX: Math.round(this.left + parseInt(a, 10)),
                translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)
              });
            };

            a.prototype.drawOutline = function (a, b, c, d) {
              var e = this.navigatorOptions.maskInside,
                  f = this.outline.strokeWidth(),
                  g = f / 2,
                  h = f % 2 / 2;
              f = this.outlineHeight;
              var k = this.scrollbarHeight || 0,
                  l = this.size,
                  m = this.left - k,
                  n = this.top;
              c ? (m -= g, c = n + b + h, b = n + a + h, h = [["M", m + f, n - k - h], ["L", m + f, c], ["L", m, c], ["L", m, b], ["L", m + f, b], ["L", m + f, n + l + k]], e && h.push(["M", m + f, c - g], ["L", m + f, b + g])) : (a += m + k - h, b += m + k - h, n += g, h = [["M", m, n], ["L", a, n], ["L", a, n + f], ["L", b, n + f], ["L", b, n], ["L", m + l + 2 * k, n]], e && h.push(["M", a - g, n], ["L", b + g, n]));
              this.outline[d]({
                d: h
              });
            };

            a.prototype.drawMasks = function (a, b, c, d) {
              var e = this.left,
                  f = this.top,
                  g = this.height;

              if (c) {
                var h = [e, e, e];
                var k = [f, f + a, f + b];
                var l = [g, g, g];
                var m = [a, b - a, this.size - b];
              } else h = [e, e + a, e + b], k = [f, f, f], l = [a, b - a, this.size - b], m = [g, g, g];

              this.shades.forEach(function (a, b) {
                a[d]({
                  x: h[b],
                  y: k[b],
                  width: l[b],
                  height: m[b]
                });
              });
            };

            a.prototype.renderElements = function () {
              var a = this,
                  b = a.navigatorOptions,
                  c = b.maskInside,
                  d = a.chart,
                  e = d.renderer,
                  f,
                  g = {
                cursor: d.inverted ? "ns-resize" : "ew-resize"
              };
              a.navigatorGroup = f = e.g("navigator").attr({
                zIndex: 8,
                visibility: "hidden"
              }).add();
              [!c, c, !c].forEach(function (c, h) {
                a.shades[h] = e.rect().addClass("highcharts-navigator-mask" + (1 === h ? "-inside" : "-outside")).add(f);
                d.styledMode || a.shades[h].attr({
                  fill: c ? b.maskFill : "rgba(0,0,0,0)"
                }).css(1 === h && g);
              });
              a.outline = e.path().addClass("highcharts-navigator-outline").add(f);
              d.styledMode || a.outline.attr({
                "stroke-width": b.outlineWidth,
                stroke: b.outlineColor
              });
              b.handles.enabled && [0, 1].forEach(function (c) {
                b.handles.inverted = d.inverted;
                a.handles[c] = e.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);
                a.handles[c].attr({
                  zIndex: 7 - c
                }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][c]).add(f);

                if (!d.styledMode) {
                  var h = b.handles;
                  a.handles[c].attr({
                    fill: h.backgroundColor,
                    stroke: h.borderColor,
                    "stroke-width": h.lineWidth
                  }).css(g);
                }
              });
            };

            a.prototype.update = function (a) {
              (this.series || []).forEach(function (a) {
                a.baseSeries && delete a.baseSeries.navigatorSeries;
              });
              this.destroy();
              b(!0, this.chart.options.navigator, this.options, a);
              this.init(this.chart);
            };

            a.prototype.render = function (a, b, d, e) {
              var g = this.chart,
                  h = this.scrollbarHeight,
                  l,
                  m = this.xAxis,
                  n = m.pointRange || 0;
              var p = m.navigatorAxis.fake ? g.xAxis[0] : m;
              var r = this.navigatorEnabled,
                  t,
                  w = this.rendered;
              var u = g.inverted;
              var v = g.xAxis[0].minRange,
                  x = g.xAxis[0].options.maxRange;

              if (!this.hasDragged || J(d)) {
                a = k(a - n / 2);
                b = k(b + n / 2);
                if (!c(a) || !c(b)) if (w) d = 0, e = D(m.width, p.width);else return;
                this.left = D(m.left, g.plotLeft + h + (u ? g.plotWidth : 0));
                this.size = t = l = D(m.len, (u ? g.plotHeight : g.plotWidth) - 2 * h);
                g = u ? h : l + 2 * h;
                d = D(d, m.toPixels(a, !0));
                e = D(e, m.toPixels(b, !0));
                c(d) && Infinity !== Math.abs(d) || (d = 0, e = g);
                a = m.toValue(d, !0);
                b = m.toValue(e, !0);
                var y = Math.abs(k(b - a));
                y < v ? this.grabbedLeft ? d = m.toPixels(b - v - n, !0) : this.grabbedRight && (e = m.toPixels(a + v + n, !0)) : J(x) && k(y - n) > x && (this.grabbedLeft ? d = m.toPixels(b - x - n, !0) : this.grabbedRight && (e = m.toPixels(a + x + n, !0)));
                this.zoomedMax = f(Math.max(d, e), 0, t);
                this.zoomedMin = f(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(d, e), 0, t);
                this.range = this.zoomedMax - this.zoomedMin;
                t = Math.round(this.zoomedMax);
                d = Math.round(this.zoomedMin);
                r && (this.navigatorGroup.attr({
                  visibility: "visible"
                }), w = w && !this.hasDragged ? "animate" : "attr", this.drawMasks(d, t, u, w), this.drawOutline(d, t, u, w), this.navigatorOptions.handles.enabled && (this.drawHandle(d, 0, u, w), this.drawHandle(t, 1, u, w)));
                this.scrollbar && (u ? (u = this.top - h, p = this.left - h + (r || !p.opposite ? 0 : (p.titleOffset || 0) + p.axisTitleMargin), h = l + 2 * h) : (u = this.top + (r ? this.height : -h), p = this.left - h), this.scrollbar.position(p, u, g, h), this.scrollbar.setRange(this.zoomedMin / (l || 1), this.zoomedMax / (l || 1)));
                this.rendered = !0;
              }
            };

            a.prototype.addMouseEvents = function () {
              var a = this,
                  b = a.chart,
                  c = b.container,
                  d = [],
                  e,
                  f;

              a.mouseMoveHandler = e = function e(b) {
                a.onMouseMove(b);
              };

              a.mouseUpHandler = f = function f(b) {
                a.onMouseUp(b);
              };

              d = a.getPartsEvents("mousedown");
              d.push(h(b.renderTo, "mousemove", e), h(c.ownerDocument, "mouseup", f));
              p && (d.push(h(b.renderTo, "touchmove", e), h(c.ownerDocument, "touchend", f)), d.concat(a.getPartsEvents("touchstart")));
              a.eventsToUnbind = d;
              a.series && a.series[0] && d.push(h(a.series[0].xAxis, "foundExtremes", function () {
                b.navigator.modifyNavigatorAxisExtremes();
              }));
            };

            a.prototype.getPartsEvents = function (a) {
              var b = this,
                  c = [];
              ["shades", "handles"].forEach(function (d) {
                b[d].forEach(function (e, f) {
                  c.push(h(e.element, a, function (a) {
                    b[d + "Mousedown"](a, f);
                  }));
                });
              });
              return c;
            };

            a.prototype.shadesMousedown = function (a, b) {
              a = this.chart.pointer.normalize(a);
              var c = this.chart,
                  d = this.xAxis,
                  e = this.zoomedMin,
                  f = this.left,
                  g = this.size,
                  h = this.range,
                  k = a.chartX;
              c.inverted && (k = a.chartY, f = this.top);
              if (1 === b) this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e;else {
                a = k - f - h / 2;
                if (0 === b) a = Math.max(0, a);else if (2 === b && a + h >= g) if (a = g - h, this.reversedExtremes) {
                  a -= h;
                  var l = this.getUnionExtremes().dataMin;
                } else var m = this.getUnionExtremes().dataMax;
                a !== e && (this.fixedWidth = h, b = d.navigatorAxis.toFixedRange(a, a + h, l, m), J(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {
                  trigger: "navigator"
                }));
              }
            };

            a.prototype.handlesMousedown = function (a, b) {
              this.chart.pointer.normalize(a);
              a = this.chart;
              var c = a.xAxis[0],
                  d = this.reversedExtremes;
              0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);
              a.fixedRange = null;
            };

            a.prototype.onMouseMove = function (a) {
              var b = this,
                  c = b.chart,
                  d = b.left,
                  e = b.navigatorSize,
                  f = b.range,
                  g = b.dragOffset,
                  h = c.inverted;
              a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, h && (d = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - d, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - d)) : b.grabbedCenter && (b.hasDragged = !0, c < g ? c = g : c > e + g - f && (c = e + g - f), b.render(0, 0, c - g, c - g + f)), b.hasDragged && b.scrollbar && D(b.scrollbar.options.liveRedraw, y.svg && !B && !this.chart.isBoosting) && (a.DOMType = a.type, setTimeout(function () {
                b.onMouseUp(a);
              }, 0)));
            };

            a.prototype.onMouseUp = function (a) {
              var b = this.chart,
                  d = this.xAxis,
                  e = this.scrollbar,
                  f = a.DOMEvent || a,
                  g = b.inverted,
                  h = this.rendered && !this.hasDragged ? "animate" : "attr";

              if (this.hasDragged && (!e || !e.hasDragged) || "scrollbar" === a.trigger) {
                e = this.getUnionExtremes();
                if (this.zoomedMin === this.otherHandlePos) var k = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var l = this.fixedExtreme;
                this.zoomedMax === this.size && (l = this.reversedExtremes ? e.dataMin : e.dataMax);
                0 === this.zoomedMin && (k = this.reversedExtremes ? e.dataMax : e.dataMin);
                d = d.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, k, l);
                J(d.min) && b.xAxis[0].setExtremes(Math.min(d.min, d.max), Math.max(d.min, d.max), !0, this.hasDragged ? !1 : null, {
                  trigger: "navigator",
                  triggerOp: "navigator-drag",
                  DOMEvent: f
                });
              }

              "mousemove" !== a.DOMType && "touchmove" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
              this.navigatorEnabled && c(this.zoomedMin) && c(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, g, h), this.outline && this.drawOutline(b, a, g, h), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, g, h), this.drawHandle(a, 1, g, h)));
            };

            a.prototype.removeEvents = function () {
              this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {
                a();
              }), this.eventsToUnbind = void 0);
              this.removeBaseSeriesEvents();
            };

            a.prototype.removeBaseSeriesEvents = function () {
              var a = this.baseSeries || [];
              this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {
                L(a, "updatedData", this.updatedDataHandler);
              }, this), a[0].xAxis && L(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
            };

            a.prototype.init = function (a) {
              var c = a.options,
                  d = c.navigator,
                  f = d.enabled,
                  g = c.scrollbar,
                  k = g.enabled;
              c = f ? d.height : 0;
              var l = k ? g.height : 0;
              this.handles = [];
              this.shades = [];
              this.chart = a;
              this.setBaseSeries();
              this.height = c;
              this.scrollbarHeight = l;
              this.scrollbarEnabled = k;
              this.navigatorEnabled = f;
              this.navigatorOptions = d;
              this.scrollbarOptions = g;
              this.outlineHeight = c + l;
              this.opposite = D(d.opposite, !(f || !a.inverted));
              var m = this;
              f = m.baseSeries;
              g = a.xAxis.length;
              k = a.yAxis.length;
              var p = f && f[0] && f[0].xAxis || a.xAxis[0] || {
                options: {}
              };
              a.isDirtyBox = !0;
              m.navigatorEnabled ? (m.xAxis = new e(a, b({
                breaks: p.options.breaks,
                ordinal: p.options.ordinal
              }, d.xAxis, {
                id: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                isX: !0,
                type: "datetime",
                index: g,
                isInternal: !0,
                offset: 0,
                keepOrdinalPadding: !0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: 0,
                maxPadding: 0,
                zoomEnabled: !1
              }, a.inverted ? {
                offsets: [l, 0, -l, 0],
                width: c
              } : {
                offsets: [0, -l, 0, l],
                height: c
              })), m.yAxis = new e(a, b(d.yAxis, {
                id: "navigator-y-axis",
                alignTicks: !1,
                offset: 0,
                index: k,
                isInternal: !0,
                reversed: D(d.yAxis && d.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),
                zoomEnabled: !1
              }, a.inverted ? {
                width: c
              } : {
                height: c
              })), f || d.series.data ? m.updateNavigatorSeries(!1) : 0 === a.series.length && (m.unbindRedraw = h(a, "beforeRedraw", function () {
                0 < a.series.length && !m.series && (m.setBaseSeries(), m.unbindRedraw());
              })), m.reversedExtremes = a.inverted && !m.xAxis.reversed || !a.inverted && m.xAxis.reversed, m.renderElements(), m.addMouseEvents()) : (m.xAxis = {
                chart: a,
                navigatorAxis: {
                  fake: !0
                },
                translate: function translate(b, c) {
                  var d = a.xAxis[0],
                      e = d.getExtremes(),
                      f = d.len - 2 * l,
                      g = n("min", d.options.min, e.dataMin);
                  d = n("max", d.options.max, e.dataMax) - g;
                  return c ? b * d / f + g : f * (b - g) / d;
                },
                toPixels: function toPixels(a) {
                  return this.translate(a);
                },
                toValue: function toValue(a) {
                  return this.translate(a, !0);
                }
              }, m.xAxis.navigatorAxis.axis = m.xAxis, m.xAxis.navigatorAxis.toFixedRange = E.AdditionsClass.prototype.toFixedRange.bind(m.xAxis.navigatorAxis));
              a.options.scrollbar.enabled && (a.scrollbar = m.scrollbar = new r(a.renderer, b(a.options.scrollbar, {
                margin: m.navigatorEnabled ? 0 : 10,
                vertical: a.inverted
              }), a), h(m.scrollbar, "changed", function (a) {
                var b = m.size,
                    c = b * this.to;
                b *= this.from;
                m.hasDragged = m.scrollbar.hasDragged;
                m.render(0, 0, b, c);
                this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {
                  m.onMouseUp(a);
                });
              }));
              m.addBaseSeriesEvents();
              m.addChartEvents();
            };

            a.prototype.getUnionExtremes = function (a) {
              var b = this.chart.xAxis[0],
                  c = this.xAxis,
                  d = c.options,
                  e = b.options,
                  f;
              a && null === b.dataMin || (f = {
                dataMin: D(d && d.min, n("min", e.min, b.dataMin, c.dataMin, c.min)),
                dataMax: D(d && d.max, n("max", e.max, b.dataMax, c.dataMax, c.max))
              });
              return f;
            };

            a.prototype.setBaseSeries = function (a, b) {
              var c = this.chart,
                  d = this.baseSeries = [];
              a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? z(c.series, function (a) {
                return !a.options.isInternal;
              }).index : 0);
              (c.series || []).forEach(function (b, c) {
                b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);
              });
              this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);
            };

            a.prototype.updateNavigatorSeries = function (a, c) {
              var d = this,
                  e = d.chart,
                  f = d.baseSeries,
                  g,
                  h,
                  k = d.navigatorOptions.series,
                  m,
                  n = {
                enableMouseTracking: !1,
                index: null,
                linkedTo: null,
                group: "nav",
                padXAxis: !1,
                xAxis: "navigator-x-axis",
                yAxis: "navigator-y-axis",
                showInLegend: !1,
                stacking: void 0,
                isInternal: !0,
                states: {
                  inactive: {
                    opacity: 1
                  }
                }
              },
                  p = d.series = (d.series || []).filter(function (a) {
                var b = a.baseSeries;
                return 0 > f.indexOf(b) ? (b && (L(b, "updatedData", d.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;
              });
              f && f.length && f.forEach(function (a) {
                var q = a.navigatorSeries,
                    r = M({
                  color: a.color,
                  visible: a.visible
                }, A(k) ? l.navigator.series : k);
                q && !1 === d.navigatorOptions.adaptToUpdatedData || (n.name = "Navigator " + f.length, g = a.options || {}, m = g.navigatorOptions || {}, r.dataLabels = I(r.dataLabels), h = b(g, n, r, m), h.pointRange = D(r.pointRange, m.pointRange, l.plotOptions[h.type || "line"].pointRange), r = m.data || r.data, d.hasNavigatorData = d.hasNavigatorData || !!r, h.data = r || g.data && g.data.slice(0), q && q.options ? q.update(h, c) : (a.navigatorSeries = e.initSeries(h), a.navigatorSeries.baseSeries = a, p.push(a.navigatorSeries)));
              });
              if (k.data && (!f || !f.length) || A(k)) d.hasNavigatorData = !1, k = I(k), k.forEach(function (a, c) {
                n.name = "Navigator " + (p.length + 1);
                h = b(l.navigator.series, {
                  color: e.series[c] && !e.series[c].options.isInternal && e.series[c].color || e.options.colors[c] || e.options.colors[0]
                }, n, a);
                h.data = a.data;
                h.data && (d.hasNavigatorData = !0, p.push(e.initSeries(h)));
              });
              a && this.addBaseSeriesEvents();
            };

            a.prototype.addBaseSeriesEvents = function () {
              var a = this,
                  b = a.baseSeries || [];
              b[0] && b[0].xAxis && b[0].eventsToUnbind.push(h(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
              b.forEach(function (b) {
                b.eventsToUnbind.push(h(b, "show", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);
                }));
                b.eventsToUnbind.push(h(b, "hide", function () {
                  this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);
                }));
                !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(h(b, "updatedData", this.updatedDataHandler));
                b.eventsToUnbind.push(h(b, "remove", function () {
                  this.navigatorSeries && (t(a.series, this.navigatorSeries), J(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);
                }));
              }, this);
            };

            a.prototype.getBaseSeriesMin = function (a) {
              return this.baseSeries.reduce(function (a, b) {
                return Math.min(a, b.xData ? b.xData[0] : a);
              }, a);
            };

            a.prototype.modifyNavigatorAxisExtremes = function () {
              var a = this.xAxis,
                  b;
              "undefined" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));
            };

            a.prototype.modifyBaseAxisExtremes = function () {
              var a = this.chart.navigator,
                  b = this.getExtremes(),
                  d = b.dataMin,
                  e = b.dataMax;
              b = b.max - b.min;
              var f = a.stickToMin,
                  g = a.stickToMax,
                  h = D(this.options.overscroll, 0),
                  k = a.series && a.series[0],
                  l = !!this.setExtremes;

              if (!this.eventArgs || "rangeSelectorButton" !== this.eventArgs.trigger) {
                if (f) {
                  var m = d;
                  var n = m + b;
                }

                g && (n = e + h, f || (m = Math.max(d, n - b, a.getBaseSeriesMin(k && k.xData ? k.xData[0] : -Number.MAX_VALUE))));
                l && (f || g) && c(m) && (this.min = this.userMin = m, this.max = this.userMax = n);
              }

              a.stickToMin = a.stickToMax = null;
            };

            a.prototype.updatedDataHandler = function () {
              var a = this.chart.navigator,
                  b = this.navigatorSeries;
              a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);
              a.stickToMin = a.shouldStickToMin(this, a);
              b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));
            };

            a.prototype.shouldStickToMin = function (a, b) {
              b = b.getBaseSeriesMin(a.xData[0]);
              var d = a.xAxis;
              a = d.max;
              var e = d.min;
              d = d.options.range;
              return c(a) && c(e) ? d && 0 < a - b ? a - b < d && !this.chart.fixedRange : e <= b : !1;
            };

            a.prototype.addChartEvents = function () {
              this.eventsToUnbind || (this.eventsToUnbind = []);
              this.eventsToUnbind.push(h(this.chart, "redraw", function () {
                var a = this.navigator,
                    b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);
                b && a.render(b.min, b.max);
              }), h(this.chart, "getMargins", function () {
                var a = this.navigator,
                    b = a.opposite ? "plotTop" : "marginBottom";
                this.inverted && (b = a.opposite ? "marginRight" : "plotLeft");
                this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;
              }));
            };

            a.prototype.destroy = function () {
              this.removeEvents();
              this.xAxis && (t(this.chart.xAxis, this.xAxis), t(this.chart.axes, this.xAxis));
              this.yAxis && (t(this.chart.yAxis, this.yAxis), t(this.chart.axes, this.yAxis));
              (this.series || []).forEach(function (a) {
                a.destroy && a.destroy();
              });
              "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach(function (a) {
                this[a] && this[a].destroy && this[a].destroy();
                this[a] = null;
              }, this);
              [this.handles].forEach(function (a) {
                K(a);
              }, this);
            };

            return a;
          }();

          y.Navigator || (y.Navigator = u, E.compose(e), h(g, "beforeShowResetZoom", function () {
            var a = this.options,
                b = a.navigator,
                c = a.rangeSelector;
            if ((b && b.enabled || c && c.enabled) && (!B && "x" === a.chart.zoomType || B && "x" === a.chart.pinchType)) return !1;
          }), h(g, "beforeRender", function () {
            var a = this.options;
            if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new u(this);
          }), h(g, "afterSetChartSize", function () {
            var a = this.legend,
                b = this.navigator;

            if (b) {
              var c = a && a.options;
              var d = b.xAxis;
              var e = b.yAxis;
              var f = b.scrollbarHeight;
              this.inverted ? (b.left = b.opposite ? this.chartWidth - f - b.height : this.spacing[3] + f, b.top = this.plotTop + f) : (b.left = D(d.left, this.plotLeft + f), b.top = b.navigatorOptions.top || this.chartHeight - b.height - f - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && "bottom" === c.verticalAlign && "proximate" !== c.layout && c.enabled && !c.floating ? a.legendHeight + D(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));
              d && e && (this.inverted ? d.options.left = e.options.left = b.left : d.options.top = e.options.top = b.top, d.setAxisSize(), e.setAxisSize());
            }
          }), h(g, "update", function (a) {
            var c = a.options.navigator || {},
                d = a.options.scrollbar || {};
            this.navigator || this.scroller || !c.enabled && !d.enabled || (b(!0, this.options.navigator, c), b(!0, this.options.scrollbar, d), delete a.options.navigator, delete a.options.scrollbar);
          }), h(g, "afterUpdate", function (a) {
            this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new u(this), D(a.redraw, !0) && this.redraw(a.animation));
          }), h(g, "afterAddSeries", function () {
            this.navigator && this.navigator.setBaseSeries(null, !1);
          }), h(m, "afterUpdate", function () {
            this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);
          }), g.prototype.callbacks.push(function (a) {
            var b = a.navigator;
            b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));
          }));
          y.Navigator = u;
          return y.Navigator;
        });
        M(g, "masters/modules/gantt.src.js", [g["Core/Globals.js"], g["Core/Chart/GanttChart.js"], g["Core/Scrollbar.js"]], function (e, g, C) {
          e.Scrollbar = C;
          e.GanttChart = g;
          e.ganttChart = g.ganttChart;
          C.compose(e.Axis);
        });
        M(g, "masters/highcharts-gantt.src.js", [g["masters/highcharts.src.js"]], function (e) {
          e.product = "Highcharts Gantt";
          return e;
        });
        g["masters/highcharts-gantt.src.js"]._modules = g;
        return g["masters/highcharts-gantt.src.js"];
      }); //# sourceMappingURL=highcharts-gantt.js.map

      /***/

    },

    /***/
    "bIOw":
    /*!*********************************************!*\
      !*** ./node_modules/highcharts/highmaps.js ***!
      \*********************************************/

    /*! no static exports found */

    /***/
    function bIOw(module, exports, __webpack_require__) {
      "use strict";

      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*
      Highmaps JS v9.2.2 (2021-08-24)
      (c) 2011-2021 Torstein Honsi
      License: www.highcharts.com/license
      */


      (function (aa, I) {
        true && module.exports ? (I["default"] = I, module.exports = aa.document ? I(aa) : I) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return I(aa);
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
      })("undefined" !== typeof window ? window : this, function (aa) {
        function I(r, a, A, y) {
          r.hasOwnProperty(a) || (r[a] = y.apply(null, A));
        }

        var a = {};
        I(a, "Core/Globals.js", [], function () {
          var r = "undefined" !== typeof aa ? aa : "undefined" !== typeof window ? window : {},
              a;

          (function (a) {
            a.SVG_NS = "http://www.w3.org/2000/svg";
            a.product = "Highcharts";
            a.version = "9.2.2";
            a.win = r;
            a.doc = a.win.document;
            a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, "svg").createSVGRect;
            a.userAgent = a.win.navigator && a.win.navigator.userAgent || "";
            a.isChrome = -1 !== a.userAgent.indexOf("Chrome");
            a.isFirefox = -1 !== a.userAgent.indexOf("Firefox");
            a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;
            a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf("Safari");
            a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);
            a.isWebKit = -1 !== a.userAgent.indexOf("AppleWebKit");
            a.deg2rad = 2 * Math.PI / 360;
            a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split("Firefox/")[1], 10);
            a.hasTouch = !!a.win.TouchEvent;
            a.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];

            a.noop = function () {};

            a.supportsPassiveEvents = function () {
              var r = !1;

              if (!a.isMS) {
                var v = Object.defineProperty({}, "passive", {
                  get: function get() {
                    r = !0;
                  }
                });
                a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener("testPassive", a.noop, v), a.win.removeEventListener("testPassive", a.noop, v));
              }

              return r;
            }();

            a.charts = [];
            a.dateFormats = {};
            a.seriesTypes = {};
            a.symbolSizes = {};
            a.chartCount = 0;
          })(a || (a = {}));

          "";
          return a;
        });
        I(a, "Core/Utilities.js", [a["Core/Globals.js"]], function (a) {
          function r(c, e, b, n) {
            var H = e ? "Highcharts error" : "Highcharts warning";
            32 === c && (c = H + ": Deprecated member");
            var f = h(c),
                m = f ? H + " #" + c + ": www.highcharts.com/errors/" + c + "/" : c.toString();

            if ("undefined" !== typeof n) {
              var g = "";
              f && (m += "?");
              B(n, function (c, e) {
                g += "\n - " + e + ": " + c;
                f && (m += encodeURI(e) + "=" + encodeURI(c));
              });
              m += g;
            }

            u(a, "displayError", {
              chart: b,
              code: c,
              message: m,
              params: n
            }, function () {
              if (e) throw Error(m);
              q.console && -1 === r.messages.indexOf(m) && console.warn(m);
            });
            r.messages.push(m);
          }

          function A(c, e) {
            var H = {};
            B(c, function (b, n) {
              if (D(c[n], !0) && !c.nodeType && e[n]) b = A(c[n], e[n]), Object.keys(b).length && (H[n] = b);else if (D(c[n]) || c[n] !== e[n]) H[n] = c[n];
            });
            return H;
          }

          function y(c, e) {
            return parseInt(c, e || 10);
          }

          function z(c) {
            return "string" === typeof c;
          }

          function w(c) {
            c = Object.prototype.toString.call(c);
            return "[object Array]" === c || "[object Array Iterator]" === c;
          }

          function D(c, e) {
            return !!c && "object" === typeof c && (!e || !w(c));
          }

          function t(c) {
            return D(c) && "number" === typeof c.nodeType;
          }

          function l(c) {
            var e = c && c.constructor;
            return !(!D(c, !0) || t(c) || !e || !e.name || "Object" === e.name);
          }

          function h(c) {
            return "number" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;
          }

          function d(c) {
            return "undefined" !== typeof c && null !== c;
          }

          function b(c, e, n) {
            var b;
            z(e) ? d(n) ? c.setAttribute(e, n) : c && c.getAttribute && ((b = c.getAttribute(e)) || "class" !== e || (b = c.getAttribute(e + "Name"))) : B(e, function (e, b) {
              c.setAttribute(b, e);
            });
            return b;
          }

          function g(c, e) {
            var b;
            c || (c = {});

            for (b in e) {
              c[b] = e[b];
            }

            return c;
          }

          function p() {
            for (var c = arguments, e = c.length, b = 0; b < e; b++) {
              var n = c[b];
              if ("undefined" !== typeof n && null !== n) return n;
            }
          }

          function k(c, e) {
            a.isMS && !a.svg && e && "undefined" !== typeof e.opacity && (e.filter = "alpha(opacity=" + 100 * e.opacity + ")");
            g(c.style, e);
          }

          function J(c, e, b, n, f) {
            c = m.createElement(c);
            e && g(c, e);
            f && k(c, {
              padding: "0",
              border: "none",
              margin: "0"
            });
            b && k(c, b);
            n && n.appendChild(c);
            return c;
          }

          function G(c, e) {
            return parseFloat(c.toPrecision(e || 14));
          }

          function f(c, e, b) {
            var n = a.getStyle || f;
            if ("width" === e) return e = Math.min(c.offsetWidth, c.scrollWidth), b = c.getBoundingClientRect && c.getBoundingClientRect().width, b < e && b >= e - 1 && (e = Math.floor(b)), Math.max(0, e - (n(c, "padding-left", !0) || 0) - (n(c, "padding-right", !0) || 0));
            if ("height" === e) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (n(c, "padding-top", !0) || 0) - (n(c, "padding-bottom", !0) || 0));
            q.getComputedStyle || r(27, !0);

            if (c = q.getComputedStyle(c, void 0)) {
              var m = c.getPropertyValue(e);
              p(b, "opacity" !== e) && (m = y(m));
            }

            return m;
          }

          function B(c, e, b) {
            for (var n in c) {
              Object.hasOwnProperty.call(c, n) && e.call(b || c[n], c[n], n, c);
            }
          }

          function x(c, e, b) {
            function n(e, b) {
              var n = c.removeEventListener || a.removeEventListenerPolyfill;
              n && n.call(c, e, b, !1);
            }

            function f(b) {
              var N;

              if (c.nodeName) {
                if (e) {
                  var M = {};
                  M[e] = !0;
                } else M = b;

                B(M, function (c, e) {
                  if (b[e]) for (N = b[e].length; N--;) {
                    n(e, b[e][N].fn);
                  }
                });
              }
            }

            var m = "function" === typeof c && c.prototype || c;

            if (Object.hasOwnProperty.call(m, "hcEvents")) {
              var q = m.hcEvents;
              e ? (m = q[e] || [], b ? (q[e] = m.filter(function (c) {
                return b !== c.fn;
              }), n(e, b)) : (f(q), q[e] = [])) : (f(q), delete m.hcEvents);
            }
          }

          function u(c, e, b, n) {
            b = b || {};

            if (m.createEvent && (c.dispatchEvent || c.fireEvent && c !== a)) {
              var f = m.createEvent("Events");
              f.initEvent(e, !0, !0);
              b = g(f, b);
              c.dispatchEvent ? c.dispatchEvent(b) : c.fireEvent(e, b);
            } else if (c.hcEvents) {
              b.target || g(b, {
                preventDefault: function preventDefault() {
                  b.defaultPrevented = !0;
                },
                target: c,
                type: e
              });
              f = [];

              for (var q = c, d = !1; q.hcEvents;) {
                Object.hasOwnProperty.call(q, "hcEvents") && q.hcEvents[e] && (f.length && (d = !0), f.unshift.apply(f, q.hcEvents[e])), q = Object.getPrototypeOf(q);
              }

              d && f.sort(function (c, e) {
                return c.order - e.order;
              });
              f.forEach(function (e) {
                !1 === e.fn.call(c, b) && b.preventDefault();
              });
            }

            n && !b.defaultPrevented && n.call(c, b);
          }

          var E = a.charts,
              m = a.doc,
              q = a.win;
          (r || (r = {})).messages = [];
          var e;

          Math.easeInOutSine = function (c) {
            return -.5 * (Math.cos(Math.PI * c) - 1);
          };

          var c = Array.prototype.find ? function (c, e) {
            return c.find(e);
          } : function (c, e) {
            var b,
                n = c.length;

            for (b = 0; b < n; b++) {
              if (e(c[b], b)) return c[b];
            }
          };
          B({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function (c, e) {
            a[e] = function (b) {
              var n;
              r(32, !1, void 0, (n = {}, n["Highcharts." + e] = "use Array." + c, n));
              return Array.prototype[c].apply(b, [].slice.call(arguments, 1));
            };
          });

          var n,
              C = function () {
            var c = Math.random().toString(36).substring(2, 9) + "-",
                e = 0;
            return function () {
              return "highcharts-" + (n ? "" : c) + e++;
            };
          }();

          q.jQuery && (q.jQuery.fn.highcharts = function () {
            var c = [].slice.call(arguments);
            if (this[0]) return c[0] ? (new a[z(c[0]) ? c.shift() : "Chart"](this[0], c[0], c[1]), this) : E[b(this[0], "data-highcharts-chart")];
          });
          c = {
            addEvent: function addEvent(c, e, b, n) {
              void 0 === n && (n = {});
              var f = "function" === typeof c && c.prototype || c;
              Object.hasOwnProperty.call(f, "hcEvents") || (f.hcEvents = {});
              f = f.hcEvents;
              a.Point && c instanceof a.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = !0);
              var q = c.addEventListener || a.addEventListenerPolyfill;
              q && q.call(c, e, b, a.supportsPassiveEvents ? {
                passive: void 0 === n.passive ? -1 !== e.indexOf("touch") : n.passive,
                capture: !1
              } : !1);
              f[e] || (f[e] = []);
              f[e].push({
                fn: b,
                order: "number" === typeof n.order ? n.order : Infinity
              });
              f[e].sort(function (c, e) {
                return c.order - e.order;
              });
              return function () {
                x(c, e, b);
              };
            },
            arrayMax: function arrayMax(c) {
              for (var e = c.length, b = c[0]; e--;) {
                c[e] > b && (b = c[e]);
              }

              return b;
            },
            arrayMin: function arrayMin(c) {
              for (var e = c.length, b = c[0]; e--;) {
                c[e] < b && (b = c[e]);
              }

              return b;
            },
            attr: b,
            clamp: function clamp(c, e, b) {
              return c > e ? c < b ? c : b : e;
            },
            cleanRecursively: A,
            clearTimeout: function (_clearTimeout4) {
              function clearTimeout(_x4) {
                return _clearTimeout4.apply(this, arguments);
              }

              clearTimeout.toString = function () {
                return _clearTimeout4.toString();
              };

              return clearTimeout;
            }(function (c) {
              d(c) && clearTimeout(c);
            }),
            correctFloat: G,
            createElement: J,
            css: k,
            defined: d,
            destroyObjectProperties: function destroyObjectProperties(c, e) {
              B(c, function (b, n) {
                b && b !== e && b.destroy && b.destroy();
                delete c[n];
              });
            },
            discardElement: function discardElement(c) {
              e || (e = J("div"));
              c && e.appendChild(c);
              e.innerHTML = "";
            },
            erase: function erase(c, e) {
              for (var b = c.length; b--;) {
                if (c[b] === e) {
                  c.splice(b, 1);
                  break;
                }
              }
            },
            error: r,
            extend: g,
            extendClass: function extendClass(c, e) {
              var b = function b() {};

              b.prototype = new c();
              g(b.prototype, e);
              return b;
            },
            find: c,
            fireEvent: u,
            getMagnitude: function getMagnitude(c) {
              return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));
            },
            getNestedProperty: function getNestedProperty(c, e) {
              for (c = c.split("."); c.length && d(e);) {
                var b = c.shift();
                if ("undefined" === typeof b || "__proto__" === b) return;
                e = e[b];
                if (!d(e) || "function" === typeof e || "number" === typeof e.nodeType || e === q) return;
              }

              return e;
            },
            getStyle: f,
            inArray: function inArray(c, e, b) {
              r(32, !1, void 0, {
                "Highcharts.inArray": "use Array.indexOf"
              });
              return e.indexOf(c, b);
            },
            isArray: w,
            isClass: l,
            isDOMElement: t,
            isFunction: function isFunction(c) {
              return "function" === typeof c;
            },
            isNumber: h,
            isObject: D,
            isString: z,
            keys: function keys(c) {
              r(32, !1, void 0, {
                "Highcharts.keys": "use Object.keys"
              });
              return Object.keys(c);
            },
            merge: function merge() {
              var c,
                  e = arguments,
                  b = {},
                  n = function n(c, e) {
                "object" !== typeof c && (c = {});
                B(e, function (b, N) {
                  "__proto__" !== N && "constructor" !== N && (!D(b, !0) || l(b) || t(b) ? c[N] = e[N] : c[N] = n(c[N] || {}, b));
                });
                return c;
              };

              !0 === e[0] && (b = e[1], e = Array.prototype.slice.call(e, 2));
              var f = e.length;

              for (c = 0; c < f; c++) {
                b = n(b, e[c]);
              }

              return b;
            },
            normalizeTickInterval: function normalizeTickInterval(c, e, b, n, f) {
              var q = c;
              b = p(b, 1);
              var m = c / b;
              e || (e = f ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === n && (1 === b ? e = e.filter(function (c) {
                return 0 === c % 1;
              }) : .1 >= b && (e = [1 / b])));

              for (n = 0; n < e.length && !(q = e[n], f && q * b >= c || !f && m <= (e[n] + (e[n + 1] || e[n])) / 2); n++) {
                ;
              }

              return q = G(q * b, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: B,
            offset: function offset(c) {
              var e = m.documentElement;
              c = c.parentElement || c.parentNode ? c.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
              };
              return {
                top: c.top + (q.pageYOffset || e.scrollTop) - (e.clientTop || 0),
                left: c.left + (q.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),
                width: c.width,
                height: c.height
              };
            },
            pad: function pad(c, e, b) {
              return Array((e || 2) + 1 - String(c).replace("-", "").length).join(b || "0") + c;
            },
            pick: p,
            pInt: y,
            relativeLength: function relativeLength(c, e, b) {
              return /%$/.test(c) ? e * parseFloat(c) / 100 + (b || 0) : parseFloat(c);
            },
            removeEvent: x,
            splat: function splat(c) {
              return w(c) ? c : [c];
            },
            stableSort: function stableSort(c, e) {
              var b = c.length,
                  n,
                  f;

              for (f = 0; f < b; f++) {
                c[f].safeI = f;
              }

              c.sort(function (c, b) {
                n = e(c, b);
                return 0 === n ? c.safeI - b.safeI : n;
              });

              for (f = 0; f < b; f++) {
                delete c[f].safeI;
              }
            },
            syncTimeout: function syncTimeout(c, e, b) {
              if (0 < e) return setTimeout(c, e, b);
              c.call(0, b);
              return -1;
            },
            timeUnits: {
              millisecond: 1,
              second: 1E3,
              minute: 6E4,
              hour: 36E5,
              day: 864E5,
              week: 6048E5,
              month: 24192E5,
              year: 314496E5
            },
            uniqueKey: C,
            useSerialIds: function useSerialIds(c) {
              return n = p(c, n);
            },
            wrap: function wrap(c, e, b) {
              var n = c[e];

              c[e] = function () {
                var c = Array.prototype.slice.call(arguments),
                    e = arguments,
                    f = this;

                f.proceed = function () {
                  n.apply(f, arguments.length ? arguments : e);
                };

                c.unshift(n);
                c = b.apply(this, c);
                f.proceed = null;
                return c;
              };
            }
          };
          "";
          return c;
        });
        I(a, "Core/Color/Palette.js", [], function () {
          return {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            backgroundColor: "#ffffff",
            neutralColor100: "#000000",
            neutralColor80: "#333333",
            neutralColor60: "#666666",
            neutralColor40: "#999999",
            neutralColor20: "#cccccc",
            neutralColor10: "#e6e6e6",
            neutralColor5: "#f2f2f2",
            neutralColor3: "#f7f7f7",
            highlightColor100: "#003399",
            highlightColor80: "#335cad",
            highlightColor60: "#6685c2",
            highlightColor20: "#ccd6eb",
            highlightColor10: "#e6ebf5",
            positiveColor: "#06b535",
            negativeColor: "#f21313"
          };
        });
        I(a, "Core/Chart/ChartDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          return {
            panning: {
              enabled: !1,
              type: "x"
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            zoomBySingleTouch: !1,
            width: null,
            height: null,
            borderColor: a.highlightColor80,
            backgroundColor: a.backgroundColor,
            plotBorderColor: a.neutralColor20
          };
        });
        I(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = v.isNumber,
              y = v.merge,
              z = v.pInt;

          v = function () {
            function w(r) {
              this.rgba = [NaN, NaN, NaN, NaN];
              this.input = r;
              var t = a.Color;
              if (t && t !== w) return new t(r);
              if (!(this instanceof w)) return new w(r);
              this.init(r);
            }

            w.parse = function (a) {
              return a ? new w(a) : w.None;
            };

            w.prototype.init = function (a) {
              var t;
              if ("object" === typeof a && "undefined" !== typeof a.stops) this.stops = a.stops.map(function (b) {
                return new w(b[1]);
              });else if ("string" === typeof a) {
                this.input = a = w.names[a.toLowerCase()] || a;

                if ("#" === a.charAt(0)) {
                  var l = a.length;
                  var h = parseInt(a.substr(1), 16);
                  7 === l ? t = [(h & 16711680) >> 16, (h & 65280) >> 8, h & 255, 1] : 4 === l && (t = [(h & 3840) >> 4 | (h & 3840) >> 8, (h & 240) >> 4 | h & 240, (h & 15) << 4 | h & 15, 1]);
                }

                if (!t) for (h = w.parsers.length; h-- && !t;) {
                  var d = w.parsers[h];
                  (l = d.regex.exec(a)) && (t = d.parse(l));
                }
              }
              t && (this.rgba = t);
            };

            w.prototype.get = function (a) {
              var t = this.input,
                  l = this.rgba;

              if ("object" === typeof t && "undefined" !== typeof this.stops) {
                var h = y(t);
                h.stops = [].slice.call(h.stops);
                this.stops.forEach(function (d, b) {
                  h.stops[b] = [h.stops[b][0], d.get(a)];
                });
                return h;
              }

              return l && r(l[0]) ? "rgb" === a || !a && 1 === l[3] ? "rgb(" + l[0] + "," + l[1] + "," + l[2] + ")" : "a" === a ? "" + l[3] : "rgba(" + l.join(",") + ")" : t;
            };

            w.prototype.brighten = function (a) {
              var t = this.rgba;
              if (this.stops) this.stops.forEach(function (h) {
                h.brighten(a);
              });else if (r(a) && 0 !== a) for (var l = 0; 3 > l; l++) {
                t[l] += z(255 * a), 0 > t[l] && (t[l] = 0), 255 < t[l] && (t[l] = 255);
              }
              return this;
            };

            w.prototype.setOpacity = function (a) {
              this.rgba[3] = a;
              return this;
            };

            w.prototype.tweenTo = function (a, t) {
              var l = this.rgba,
                  h = a.rgba;
              if (!r(l[0]) || !r(h[0])) return a.input || "none";
              a = 1 !== h[3] || 1 !== l[3];
              return (a ? "rgba(" : "rgb(") + Math.round(h[0] + (l[0] - h[0]) * (1 - t)) + "," + Math.round(h[1] + (l[1] - h[1]) * (1 - t)) + "," + Math.round(h[2] + (l[2] - h[2]) * (1 - t)) + (a ? "," + (h[3] + (l[3] - h[3]) * (1 - t)) : "") + ")";
            };

            w.names = {
              white: "#ffffff",
              black: "#000000"
            };
            w.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(a) {
                return [z(a[1]), z(a[2]), z(a[3]), parseFloat(a[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(a) {
                return [z(a[1]), z(a[2]), z(a[3]), 1];
              }
            }];
            w.None = new w("");
            return w;
          }();

          "";
          return v;
        });
        I(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = a.win,
              y = v.defined,
              z = v.error,
              w = v.extend,
              D = v.isObject,
              t = v.merge,
              l = v.objectEach,
              h = v.pad,
              d = v.pick,
              b = v.splat,
              g = v.timeUnits,
              p = a.isSafari && r.Intl && r.Intl.DateTimeFormat.prototype.formatRange,
              k = a.isSafari && r.Intl && !r.Intl.DateTimeFormat.prototype.formatRange;

          v = function () {
            function J(b) {
              this.options = {};
              this.variableTimezone = this.useUTC = !1;
              this.Date = r.Date;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.update(b);
            }

            J.prototype.get = function (b, f) {
              if (this.variableTimezone || this.timezoneOffset) {
                var g = f.getTime(),
                    d = g - this.getTimezoneOffset(f);
                f.setTime(d);
                b = f["getUTC" + b]();
                f.setTime(g);
                return b;
              }

              return this.useUTC ? f["getUTC" + b]() : f["get" + b]();
            };

            J.prototype.set = function (b, f, g) {
              if (this.variableTimezone || this.timezoneOffset) {
                if ("Milliseconds" === b || "Seconds" === b || "Minutes" === b && 0 === this.getTimezoneOffset(f) % 36E5) return f["setUTC" + b](g);
                var d = this.getTimezoneOffset(f);
                d = f.getTime() - d;
                f.setTime(d);
                f["setUTC" + b](g);
                b = this.getTimezoneOffset(f);
                d = f.getTime() + b;
                return f.setTime(d);
              }

              return this.useUTC || p && "FullYear" === b ? f["setUTC" + b](g) : f["set" + b](g);
            };

            J.prototype.update = function (b) {
              var f = d(b && b.useUTC, !0);
              this.options = b = t(!0, this.options || {}, b);
              this.Date = b.Date || r.Date || Date;
              this.timezoneOffset = (this.useUTC = f) && b.timezoneOffset;
              this.getTimezoneOffset = this.timezoneOffsetFunction();
              this.variableTimezone = f && !(!b.getTimezoneOffset && !b.timezone);
            };

            J.prototype.makeTime = function (b, f, g, p, u, h) {
              if (this.useUTC) {
                var m = this.Date.UTC.apply(0, arguments);
                var q = this.getTimezoneOffset(m);
                m += q;
                var e = this.getTimezoneOffset(m);
                q !== e ? m += e - q : q - 36E5 !== this.getTimezoneOffset(m - 36E5) || k || (m -= 36E5);
              } else m = new this.Date(b, f, d(g, 1), d(p, 0), d(u, 0), d(h, 0)).getTime();

              return m;
            };

            J.prototype.timezoneOffsetFunction = function () {
              var b = this,
                  f = this.options,
                  g = f.moment || r.moment;
              if (!this.useUTC) return function (b) {
                return 6E4 * new Date(b.toString()).getTimezoneOffset();
              };

              if (f.timezone) {
                if (g) return function (b) {
                  return 6E4 * -g.tz(b, f.timezone).utcOffset();
                };
                z(25);
              }

              return this.useUTC && f.getTimezoneOffset ? function (b) {
                return 6E4 * f.getTimezoneOffset(b.valueOf());
              } : function () {
                return 6E4 * (b.timezoneOffset || 0);
              };
            };

            J.prototype.dateFormat = function (b, f, g) {
              if (!y(f) || isNaN(f)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
              b = d(b, "%Y-%m-%d %H:%M:%S");
              var k = this,
                  u = new this.Date(f),
                  p = this.get("Hours", u),
                  m = this.get("Day", u),
                  q = this.get("Date", u),
                  e = this.get("Month", u),
                  c = this.get("FullYear", u),
                  n = a.defaultOptions.lang,
                  C = n && n.weekdays,
                  B = n && n.shortWeekdays;
              u = w({
                a: B ? B[m] : C[m].substr(0, 3),
                A: C[m],
                d: h(q),
                e: h(q, 2, " "),
                w: m,
                b: n.shortMonths[e],
                B: n.months[e],
                m: h(e + 1),
                o: e + 1,
                y: c.toString().substr(2, 2),
                Y: c,
                H: h(p),
                k: p,
                I: h(p % 12 || 12),
                l: p % 12 || 12,
                M: h(this.get("Minutes", u)),
                p: 12 > p ? "AM" : "PM",
                P: 12 > p ? "am" : "pm",
                S: h(u.getSeconds()),
                L: h(Math.floor(f % 1E3), 3)
              }, a.dateFormats);
              l(u, function (c, e) {
                for (; -1 !== b.indexOf("%" + e);) {
                  b = b.replace("%" + e, "function" === typeof c ? c.call(k, f) : c);
                }
              });
              return g ? b.substr(0, 1).toUpperCase() + b.substr(1) : b;
            };

            J.prototype.resolveDTLFormat = function (g) {
              return D(g, !0) ? g : (g = b(g), {
                main: g[0],
                from: g[1],
                to: g[2]
              });
            };

            J.prototype.getTimeTicks = function (b, f, k, p) {
              var u = this,
                  h = [],
                  m = {},
                  q = new u.Date(f),
                  e = b.unitRange,
                  c = b.count || 1,
                  n;
              p = d(p, 1);

              if (y(f)) {
                u.set("Milliseconds", q, e >= g.second ? 0 : c * Math.floor(u.get("Milliseconds", q) / c));
                e >= g.second && u.set("Seconds", q, e >= g.minute ? 0 : c * Math.floor(u.get("Seconds", q) / c));
                e >= g.minute && u.set("Minutes", q, e >= g.hour ? 0 : c * Math.floor(u.get("Minutes", q) / c));
                e >= g.hour && u.set("Hours", q, e >= g.day ? 0 : c * Math.floor(u.get("Hours", q) / c));
                e >= g.day && u.set("Date", q, e >= g.month ? 1 : Math.max(1, c * Math.floor(u.get("Date", q) / c)));

                if (e >= g.month) {
                  u.set("Month", q, e >= g.year ? 0 : c * Math.floor(u.get("Month", q) / c));
                  var C = u.get("FullYear", q);
                }

                e >= g.year && u.set("FullYear", q, C - C % c);
                e === g.week && (C = u.get("Day", q), u.set("Date", q, u.get("Date", q) - C + p + (C < p ? -7 : 0)));
                C = u.get("FullYear", q);
                p = u.get("Month", q);
                var B = u.get("Date", q),
                    x = u.get("Hours", q);
                f = q.getTime();
                !u.variableTimezone && u.useUTC || !y(k) || (n = k - f > 4 * g.month || u.getTimezoneOffset(f) !== u.getTimezoneOffset(k));
                f = q.getTime();

                for (q = 1; f < k;) {
                  h.push(f), f = e === g.year ? u.makeTime(C + q * c, 0) : e === g.month ? u.makeTime(C, p + q * c) : !n || e !== g.day && e !== g.week ? n && e === g.hour && 1 < c ? u.makeTime(C, p, B, x + q * c) : f + e * c : u.makeTime(C, p, B + q * c * (e === g.day ? 1 : 7)), q++;
                }

                h.push(f);
                e <= g.hour && 1E4 > h.length && h.forEach(function (c) {
                  0 === c % 18E5 && "000000000" === u.dateFormat("%H%M%S%L", c) && (m[c] = "day");
                });
              }

              h.info = w(b, {
                higherRanks: m,
                totalRange: e * c
              });
              return h;
            };

            J.prototype.getDateFormat = function (b, f, d, k) {
              var u = this.dateFormat("%m-%d %H:%M:%S.%L", f),
                  p = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
              },
                  m = "millisecond";

              for (q in g) {
                if (b === g.week && +this.dateFormat("%w", f) === d && "00:00:00.000" === u.substr(6)) {
                  var q = "week";
                  break;
                }

                if (g[q] > b) {
                  q = m;
                  break;
                }

                if (p[q] && u.substr(p[q]) !== "01-01 00:00:00.000".substr(p[q])) break;
                "week" !== q && (m = q);
              }

              if (q) var e = this.resolveDTLFormat(k[q]).main;
              return e;
            };

            return J;
          }();

          "";
          return v;
        });
        I(a, "Core/DefaultOptions.js", [a["Core/Chart/ChartDefaults.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Time.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w) {
          v = v.parse;
          var r = w.merge,
              t = {
            colors: y.colors,
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
              loading: "Loading...",
              months: "January February March April May June July August September October November December".split(" "),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
              weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
              decimalPoint: ".",
              numericSymbols: "kMGTPE".split(""),
              resetZoom: "Reset zoom",
              resetZoomTitle: "Reset zoom level 1:1",
              thousandsSep: " "
            },
            global: {},
            time: {
              Date: void 0,
              getTimezoneOffset: void 0,
              timezone: void 0,
              timezoneOffset: 0,
              useUTC: !0
            },
            chart: a,
            title: {
              text: "Chart title",
              align: "center",
              margin: 15,
              widthAdjust: -44
            },
            subtitle: {
              text: "",
              align: "center",
              widthAdjust: -44
            },
            caption: {
              margin: 15,
              text: "",
              align: "left",
              verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
              style: {
                position: "absolute",
                color: y.neutralColor80
              }
            },
            legend: {
              enabled: !0,
              align: "center",
              alignColumns: !0,
              className: "highcharts-no-tooltip",
              layout: "horizontal",
              labelFormatter: function labelFormatter() {
                return this.name;
              },
              borderColor: y.neutralColor40,
              borderRadius: 0,
              navigation: {
                activeColor: y.highlightColor100,
                inactiveColor: y.neutralColor20
              },
              itemStyle: {
                color: y.neutralColor80,
                cursor: "pointer",
                fontSize: "12px",
                fontWeight: "bold",
                textOverflow: "ellipsis"
              },
              itemHoverStyle: {
                color: y.neutralColor100
              },
              itemHiddenStyle: {
                color: y.neutralColor20
              },
              shadow: !1,
              itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
              },
              squareSymbol: !0,
              symbolPadding: 5,
              verticalAlign: "bottom",
              x: 0,
              y: 0,
              title: {
                style: {
                  fontWeight: "bold"
                }
              }
            },
            loading: {
              labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "45%"
              },
              style: {
                position: "absolute",
                backgroundColor: y.backgroundColor,
                opacity: .5,
                textAlign: "center"
              }
            },
            tooltip: {
              enabled: !0,
              animation: A.svg,
              borderRadius: 3,
              dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
              },
              footerFormat: "",
              headerShape: "callout",
              hideDelay: 500,
              padding: 8,
              shape: "callout",
              shared: !1,
              snap: A.isTouchDevice ? 25 : 10,
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
              backgroundColor: v(y.neutralColor3).setOpacity(.85).get(),
              borderWidth: 1,
              shadow: !0,
              stickOnContact: !1,
              style: {
                color: y.neutralColor80,
                cursor: "default",
                fontSize: "12px",
                whiteSpace: "nowrap"
              },
              useHTML: !1
            },
            credits: {
              enabled: !0,
              href: "https://www.highcharts.com?credits",
              position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
              },
              style: {
                cursor: "pointer",
                color: y.neutralColor40,
                fontSize: "9px"
              },
              text: "Highcharts.com"
            }
          };
          t.chart.styledMode = !1;
          "";
          var l = new z(r(t.global, t.time));
          a = {
            defaultOptions: t,
            defaultTime: l,
            getOptions: function getOptions() {
              return t;
            },
            setOptions: function setOptions(h) {
              r(!0, t, h);
              if (h.time || h.global) A.time ? A.time.update(r(t.global, t.time, h.global, h.time)) : A.time = l;
              return t;
            }
          };
          "";
          return a;
        });
        I(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = a.parse,
              z = v.win,
              w = A.isNumber,
              D = A.objectEach;
          return function () {
            function a(a, h, d) {
              this.pos = NaN;
              this.options = h;
              this.elem = a;
              this.prop = d;
            }

            a.prototype.dSetter = function () {
              var a = this.paths,
                  h = a && a[0];
              a = a && a[1];
              var d = this.now || 0,
                  b = [];
              if (1 !== d && h && a) {
                if (h.length === a.length && 1 > d) for (var g = 0; g < a.length; g++) {
                  for (var p = h[g], k = a[g], J = [], G = 0; G < k.length; G++) {
                    var f = p[G],
                        B = k[G];
                    w(f) && w(B) && ("A" !== k[0] || 4 !== G && 5 !== G) ? J[G] = f + d * (B - f) : J[G] = B;
                  }

                  b.push(J);
                } else b = a;
              } else b = this.toD || [];
              this.elem.attr("d", b, void 0, !0);
            };

            a.prototype.update = function () {
              var a = this.elem,
                  h = this.prop,
                  d = this.now,
                  b = this.options.step;
              if (this[h + "Setter"]) this[h + "Setter"]();else a.attr ? a.element && a.attr(h, d, null, !0) : a.style[h] = d + this.unit;
              b && b.call(a, d, this);
            };

            a.prototype.run = function (l, h, d) {
              var b = this,
                  g = b.options,
                  p = function p(g) {
                return p.stopped ? !1 : b.step(g);
              },
                  k = z.requestAnimationFrame || function (b) {
                setTimeout(b, 13);
              },
                  J = function J() {
                for (var b = 0; b < a.timers.length; b++) {
                  a.timers[b]() || a.timers.splice(b--, 1);
                }

                a.timers.length && k(J);
              };

              l !== h || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = l, this.end = h, this.unit = d, this.now = this.start, this.pos = 0, p.elem = this.elem, p.prop = this.prop, p() && 1 === a.timers.push(p) && k(J)) : (delete g.curAnim[this.prop], g.complete && 0 === Object.keys(g.curAnim).length && g.complete.call(this.elem));
            };

            a.prototype.step = function (a) {
              var h = +new Date(),
                  d = this.options,
                  b = this.elem,
                  g = d.complete,
                  p = d.duration,
                  k = d.curAnim;
              if (b.attr && !b.element) a = !1;else if (a || h >= p + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                var J = k[this.prop] = !0;
                D(k, function (b) {
                  !0 !== b && (J = !1);
                });
                J && g && g.call(b);
                a = !1;
              } else this.pos = d.easing((h - this.startTime) / p), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0;
              return a;
            };

            a.prototype.initPath = function (a, h, d) {
              function b(b, f) {
                for (; b.length < x;) {
                  var m = b[0],
                      q = f[x - b.length];
                  q && "M" === m[0] && (b[0] = "C" === q[0] ? ["C", m[1], m[2], m[1], m[2], m[1], m[2]] : ["L", m[1], m[2]]);
                  b.unshift(m);
                  J && (m = b.pop(), b.push(b[b.length - 1], m));
                }
              }

              function g(b, f) {
                for (; b.length < x;) {
                  if (f = b[Math.floor(b.length / G) - 1].slice(), "C" === f[0] && (f[1] = f[5], f[2] = f[6]), J) {
                    var m = b[Math.floor(b.length / G)].slice();
                    b.splice(b.length / 2, 0, f, m);
                  } else b.push(f);
                }
              }

              var p = a.startX,
                  k = a.endX;
              d = d.slice();
              var J = a.isArea,
                  G = J ? 2 : 1;
              h = h && h.slice();
              if (!h) return [d, d];

              if (p && k && k.length) {
                for (a = 0; a < p.length; a++) {
                  if (p[a] === k[0]) {
                    var f = a;
                    break;
                  } else if (p[0] === k[k.length - p.length + a]) {
                    f = a;
                    var B = !0;
                    break;
                  } else if (p[p.length - 1] === k[k.length - p.length + a]) {
                    f = p.length - a;
                    break;
                  }
                }

                "undefined" === typeof f && (h = []);
              }

              if (h.length && w(f)) {
                var x = d.length + f * G;
                B ? (b(h, d), g(d, h)) : (b(d, h), g(h, d));
              }

              return [h, d];
            };

            a.prototype.fillSetter = function () {
              a.prototype.strokeSetter.apply(this, arguments);
            };

            a.prototype.strokeSetter = function () {
              this.elem.attr(this.prop, r(this.start).tweenTo(r(this.end), this.pos), null, !0);
            };

            a.timers = [];
            return a;
          }();
        });
        I(a, "Core/Animation/AnimationUtilities.js", [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]], function (a, v) {
          function r(b) {
            return l(b) ? h({
              duration: 500,
              defer: 0
            }, b) : {
              duration: b ? 500 : 0,
              defer: 0
            };
          }

          function y(b, d) {
            for (var g = a.timers.length; g--;) {
              a.timers[g].elem !== b || d && d !== a.timers[g].prop || (a.timers[g].stopped = !0);
            }
          }

          var z = v.defined,
              w = v.getStyle,
              D = v.isArray,
              t = v.isNumber,
              l = v.isObject,
              h = v.merge,
              d = v.objectEach,
              b = v.pick;
          return {
            animate: function animate(b, p, k) {
              var g,
                  G = "",
                  f,
                  B;

              if (!l(k)) {
                var x = arguments;
                k = {
                  duration: x[2],
                  easing: x[3],
                  complete: x[4]
                };
              }

              t(k.duration) || (k.duration = 400);
              k.easing = "function" === typeof k.easing ? k.easing : Math[k.easing] || Math.easeInOutSine;
              k.curAnim = h(p);
              d(p, function (d, h) {
                y(b, h);
                B = new a(b, k, h);
                f = void 0;
                "d" === h && D(p.d) ? (B.paths = B.initPath(b, b.pathArray, p.d), B.toD = p.d, g = 0, f = 1) : b.attr ? g = b.attr(h) : (g = parseFloat(w(b, h)) || 0, "opacity" !== h && (G = "px"));
                f || (f = d);
                "string" === typeof f && f.match("px") && (f = f.replace(/px/g, ""));
                B.run(g, f, G);
              });
            },
            animObject: r,
            getDeferredAnimation: function getDeferredAnimation(b, d, k) {
              var g = r(d),
                  p = 0,
                  f = 0;
              (k ? [k] : b.series).forEach(function (b) {
                b = r(b.options.animation);
                p = d && z(d.defer) ? g.defer : Math.max(p, b.duration + b.defer);
                f = Math.min(g.duration, b.duration);
              });
              b.renderer.forExport && (p = 0);
              return {
                defer: Math.max(0, p - f),
                duration: Math.min(p, f)
              };
            },
            setAnimation: function setAnimation(g, d) {
              d.renderer.globalAnimation = b(g, d.options.chart.animation, !0);
            },
            stop: y
          };
        });
        I(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = a.SVG_NS,
              y = v.attr,
              z = v.createElement,
              w = v.discardElement,
              D = v.error,
              t = v.isString,
              l = v.objectEach,
              h = v.splat;

          try {
            var d = !!new DOMParser().parseFromString("", "text/html");
          } catch (b) {
            d = !1;
          }

          v = function () {
            function b(b) {
              this.nodes = "string" === typeof b ? this.parseMarkup(b) : b;
            }

            b.filterUserAttributes = function (g) {
              l(g, function (d, k) {
                var p = !0;
                -1 === b.allowedAttributes.indexOf(k) && (p = !1);
                -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(k) && (p = t(d) && b.allowedReferences.some(function (b) {
                  return 0 === d.indexOf(b);
                }));
                p || (D("Highcharts warning: Invalid attribute '" + k + "' in config"), delete g[k]);
              });
              return g;
            };

            b.setElementHTML = function (g, d) {
              g.innerHTML = "";
              d && new b(d).addToDOM(g);
            };

            b.prototype.addToDOM = function (d) {
              function g(d, p) {
                var k;
                h(d).forEach(function (f) {
                  var d = f.tagName,
                      h = f.textContent ? a.doc.createTextNode(f.textContent) : void 0;
                  if (d) if ("#text" === d) var u = h;else if (-1 !== b.allowedTags.indexOf(d)) {
                    d = a.doc.createElementNS("svg" === d ? r : p.namespaceURI || r, d);
                    var E = f.attributes || {};
                    l(f, function (b, f) {
                      "tagName" !== f && "attributes" !== f && "children" !== f && "textContent" !== f && (E[f] = b);
                    });
                    y(d, b.filterUserAttributes(E));
                    h && d.appendChild(h);
                    g(f.children || [], d);
                    u = d;
                  } else D("Highcharts warning: Invalid tagName '" + d + "' in config");
                  u && p.appendChild(u);
                  k = u;
                });
                return k;
              }

              return g(this.nodes, d);
            };

            b.prototype.parseMarkup = function (b) {
              var g = [];
              b = b.trim();
              if (d) b = new DOMParser().parseFromString(b, "text/html");else {
                var k = z("div");
                k.innerHTML = b;
                b = {
                  body: k
                };
              }

              var h = function h(b, f) {
                var d = b.nodeName.toLowerCase(),
                    g = {
                  tagName: d
                };
                "#text" === d && (g.textContent = b.textContent || "");

                if (d = b.attributes) {
                  var k = {};
                  [].forEach.call(d, function (b) {
                    k[b.name] = b.value;
                  });
                  g.attributes = k;
                }

                if (b.childNodes.length) {
                  var p = [];
                  [].forEach.call(b.childNodes, function (b) {
                    h(b, p);
                  });
                  p.length && (g.children = p);
                }

                f.push(g);
              };

              [].forEach.call(b.body.childNodes, function (b) {
                return h(b, g);
              });
              k && w(k);
              return g;
            };

            b.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength type valign width x x1 x2 y y1 y2 zIndex".split(" ");
            b.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
            b.allowedTags = "a b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
            return b;
          }();

          "";
          return v;
        });
        I(a, "Core/FormatUtilities.js", [a["Core/DefaultOptions.js"], a["Core/Utilities.js"]], function (a, v) {
          function r(h, d, b, g) {
            h = +h || 0;
            d = +d;
            var p = y.lang,
                k = (h.toString().split(".")[1] || "").split("e")[0].length,
                a = h.toString().split("e"),
                G = d;
            if (-1 === d) d = Math.min(k, 20);else if (!D(d)) d = 2;else if (d && a[1] && 0 > a[1]) {
              var f = d + +a[1];
              0 <= f ? (a[0] = (+a[0]).toExponential(f).split("e")[0], d = f) : (a[0] = a[0].split(".")[0] || 0, h = 20 > d ? (a[0] * Math.pow(10, a[1])).toFixed(d) : 0, a[1] = 0);
            }
            f = (Math.abs(a[1] ? a[0] : h) + Math.pow(10, -Math.max(d, k) - 1)).toFixed(d);
            k = String(l(f));
            var B = 3 < k.length ? k.length % 3 : 0;
            b = t(b, p.decimalPoint);
            g = t(g, p.thousandsSep);
            h = (0 > h ? "-" : "") + (B ? k.substr(0, B) + g : "");
            h = 0 > +a[1] && !G ? "0" : h + k.substr(B).replace(/(\d{3})(?=\d)/g, "$1" + g);
            d && (h += b + f.slice(-d));
            a[1] && 0 !== +h && (h += "e" + a[1]);
            return h;
          }

          var y = a.defaultOptions,
              z = a.defaultTime,
              w = v.getNestedProperty,
              D = v.isNumber,
              t = v.pick,
              l = v.pInt;
          return {
            dateFormat: function dateFormat(a, d, b) {
              return z.dateFormat(a, d, b);
            },
            format: function format(a, d, b) {
              var g = "{",
                  p = !1,
                  k = /f$/,
                  h = /\.([0-9])/,
                  t = y.lang,
                  f = b && b.time || z;
              b = b && b.numberFormatter || r;

              for (var B = []; a;) {
                var x = a.indexOf(g);
                if (-1 === x) break;
                var u = a.slice(0, x);

                if (p) {
                  u = u.split(":");
                  g = w(u.shift() || "", d);
                  if (u.length && "number" === typeof g) if (u = u.join(":"), k.test(u)) {
                    var E = parseInt((u.match(h) || ["", "-1"])[1], 10);
                    null !== g && (g = b(g, E, t.decimalPoint, -1 < u.indexOf(",") ? t.thousandsSep : ""));
                  } else g = f.dateFormat(u, g);
                  B.push(g);
                } else B.push(u);

                a = a.slice(x + 1);
                g = (p = !p) ? "}" : "{";
              }

              B.push(a);
              return B.join("");
            },
            numberFormat: r
          };
        });
        I(a, "Core/Renderer/RendererUtilities.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.clamp,
              A = a.pick,
              y = a.stableSort,
              z;

          (function (a) {
            function w(a, l, h) {
              var d = a,
                  b = d.reducedLen || l,
                  g = function g(b, f) {
                return (f.rank || 0) - (b.rank || 0);
              },
                  p = function p(b, f) {
                return b.target - f.target;
              },
                  k,
                  J = !0,
                  G = [],
                  f = 0;

              for (k = a.length; k--;) {
                f += a[k].size;
              }

              if (f > b) {
                y(a, g);

                for (f = k = 0; f <= b;) {
                  f += a[k].size, k++;
                }

                G = a.splice(k - 1, a.length);
              }

              y(a, p);

              for (a = a.map(function (b) {
                return {
                  size: b.size,
                  targets: [b.target],
                  align: A(b.align, .5)
                };
              }); J;) {
                for (k = a.length; k--;) {
                  b = a[k], g = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = r(g - b.size * b.align, 0, l - b.size);
                }

                k = a.length;

                for (J = !1; k--;) {
                  0 < k && a[k - 1].pos + a[k - 1].size > a[k].pos && (a[k - 1].size += a[k].size, a[k - 1].targets = a[k - 1].targets.concat(a[k].targets), a[k - 1].align = .5, a[k - 1].pos + a[k - 1].size > l && (a[k - 1].pos = l - a[k - 1].size), a.splice(k, 1), J = !0);
                }
              }

              d.push.apply(d, G);
              k = 0;
              a.some(function (b) {
                var f = 0;
                return (b.targets || []).some(function () {
                  d[k].pos = b.pos + f;
                  if ("undefined" !== typeof h && Math.abs(d[k].pos - d[k].target) > h) return d.slice(0, k + 1).forEach(function (b) {
                    return delete b.pos;
                  }), d.reducedLen = (d.reducedLen || l) - .1 * l, d.reducedLen > .1 * l && w(d, l, h), !0;
                  f += d[k].size;
                  k++;
                  return !1;
                });
              });
              y(d, p);
              return d;
            }

            a.distribute = w;
          })(z || (z = {}));

          return z;
        });
        I(a, "Core/Renderer/SVG/SVGElement.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w) {
          var r = a.animate,
              t = a.animObject,
              l = a.stop,
              h = y.deg2rad,
              d = y.doc,
              b = y.noop,
              g = y.svg,
              p = y.SVG_NS,
              k = y.win,
              J = w.addEvent,
              G = w.attr,
              f = w.createElement,
              B = w.css,
              x = w.defined,
              u = w.erase,
              E = w.extend,
              m = w.fireEvent,
              q = w.isArray,
              e = w.isFunction,
              c = w.isNumber,
              n = w.isString,
              C = w.merge,
              H = w.objectEach,
              L = w.pick,
              F = w.pInt,
              W = w.syncTimeout,
              S = w.uniqueKey;

          a = function () {
            function a() {
              this.element = void 0;
              this.onEvents = {};
              this.opacity = 1;
              this.renderer = void 0;
              this.SVG_NS = p;
              this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            }

            a.prototype._defaultGetter = function (c) {
              c = L(this[c + "Value"], this[c], this.element ? this.element.getAttribute(c) : null, 0);
              /^[\-0-9\.]+$/.test(c) && (c = parseFloat(c));
              return c;
            };

            a.prototype._defaultSetter = function (c, b, e) {
              e.setAttribute(b, c);
            };

            a.prototype.add = function (c) {
              var b = this.renderer,
                  e = this.element;
              c && (this.parentGroup = c);
              this.parentInverted = c && c.inverted;
              "undefined" !== typeof this.textStr && "text" === this.element.nodeName && b.buildText(this);
              this.added = !0;
              if (!c || c.handleZ || this.zIndex) var n = this.zIndexSetter();
              n || (c ? c.element : b.box).appendChild(e);
              if (this.onAdd) this.onAdd();
              return this;
            };

            a.prototype.addClass = function (c, b) {
              var e = b ? "" : this.attr("class") || "";
              c = (c || "").split(/ /g).reduce(function (c, b) {
                -1 === e.indexOf(b) && c.push(b);
                return c;
              }, e ? [e] : []).join(" ");
              c !== e && this.attr("class", c);
              return this;
            };

            a.prototype.afterSetters = function () {
              this.doTransform && (this.updateTransform(), this.doTransform = !1);
            };

            a.prototype.align = function (c, b, e) {
              var f = {},
                  a = this.renderer,
                  N = a.alignedObjects,
                  d,
                  q,
                  m;

              if (c) {
                if (this.alignOptions = c, this.alignByTranslate = b, !e || n(e)) this.alignTo = d = e || "renderer", u(N, this), N.push(this), e = void 0;
              } else c = this.alignOptions, b = this.alignByTranslate, d = this.alignTo;

              e = L(e, a[d], "scrollablePlotBox" === d ? a.plotBox : void 0, a);
              d = c.align;
              var g = c.verticalAlign;
              a = (e.x || 0) + (c.x || 0);
              N = (e.y || 0) + (c.y || 0);
              "right" === d ? q = 1 : "center" === d && (q = 2);
              q && (a += (e.width - (c.width || 0)) / q);
              f[b ? "translateX" : "x"] = Math.round(a);
              "bottom" === g ? m = 1 : "middle" === g && (m = 2);
              m && (N += (e.height - (c.height || 0)) / m);
              f[b ? "translateY" : "y"] = Math.round(N);
              this[this.placed ? "animate" : "attr"](f);
              this.placed = !0;
              this.alignAttr = f;
              return this;
            };

            a.prototype.alignSetter = function (c) {
              var b = {
                left: "start",
                center: "middle",
                right: "end"
              };
              b[c] && (this.alignValue = c, this.element.setAttribute("text-anchor", b[c]));
            };

            a.prototype.animate = function (c, b, e) {
              var n = this,
                  f = t(L(b, this.renderer.globalAnimation, !0));
              b = f.defer;
              L(d.hidden, d.msHidden, d.webkitHidden, !1) && (f.duration = 0);
              0 !== f.duration ? (e && (f.complete = e), W(function () {
                n.element && r(n, c, f);
              }, b)) : (this.attr(c, void 0, e), H(c, function (c, b) {
                f.step && f.step.call(this, c, {
                  prop: b,
                  pos: 1,
                  elem: this
                });
              }, this));
              return this;
            };

            a.prototype.applyTextOutline = function (c) {
              var b = this.element;
              -1 !== c.indexOf("contrast") && (c = c.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));
              var e = c.split(" ");
              c = e[e.length - 1];

              if ((e = e[0]) && "none" !== e && y.svg) {
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                e = e.replace(/(^[\d\.]+)(.*?)$/g, function (c, b, e) {
                  return 2 * Number(b) + e;
                });
                this.removeTextOutline();
                var n = d.createElementNS(p, "tspan");
                G(n, {
                  "class": "highcharts-text-outline",
                  fill: c,
                  stroke: c,
                  "stroke-width": e,
                  "stroke-linejoin": "round"
                });
                [].forEach.call(b.childNodes, function (c) {
                  var b = c.cloneNode(!0);
                  b.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (c) {
                    return b.removeAttribute(c);
                  });
                  n.appendChild(b);
                });
                var f = d.createElementNS(p, "tspan");
                f.textContent = "\u200B";
                ["x", "y"].forEach(function (c) {
                  var e = b.getAttribute(c);
                  e && f.setAttribute(c, e);
                });
                n.appendChild(f);
                b.insertBefore(n, b.firstChild);
              }
            };

            a.prototype.attr = function (c, b, e, n) {
              var f = this.element,
                  a = this.symbolCustomAttribs,
                  d,
                  N = this,
                  q,
                  M;

              if ("string" === typeof c && "undefined" !== typeof b) {
                var m = c;
                c = {};
                c[m] = b;
              }

              "string" === typeof c ? N = (this[c + "Getter"] || this._defaultGetter).call(this, c, f) : (H(c, function (b, e) {
                q = !1;
                n || l(this, e);
                this.symbolName && -1 !== a.indexOf(e) && (d || (this.symbolAttr(c), d = !0), q = !0);
                !this.rotation || "x" !== e && "y" !== e || (this.doTransform = !0);
                q || (M = this[e + "Setter"] || this._defaultSetter, M.call(this, b, e, f), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(e) && this.updateShadows(e, b, M));
              }, this), this.afterSetters());
              e && e.call(this);
              return N;
            };

            a.prototype.clip = function (c) {
              return this.attr("clip-path", c ? "url(" + this.renderer.url + "#" + c.id + ")" : "none");
            };

            a.prototype.crisp = function (c, e) {
              e = e || c.strokeWidth || 0;
              var b = Math.round(e) % 2 / 2;
              c.x = Math.floor(c.x || this.x || 0) + b;
              c.y = Math.floor(c.y || this.y || 0) + b;
              c.width = Math.floor((c.width || this.width || 0) - 2 * b);
              c.height = Math.floor((c.height || this.height || 0) - 2 * b);
              x(c.strokeWidth) && (c.strokeWidth = e);
              return c;
            };

            a.prototype.complexColor = function (c, e, b) {
              var n = this.renderer,
                  f,
                  a,
                  d,
                  N,
                  g,
                  k,
                  p,
                  u,
                  h,
                  B,
                  E = [],
                  F;
              m(this.renderer, "complexColor", {
                args: arguments
              }, function () {
                c.radialGradient ? a = "radialGradient" : c.linearGradient && (a = "linearGradient");

                if (a) {
                  d = c[a];
                  g = n.gradients;
                  k = c.stops;
                  h = b.radialReference;
                  q(d) && (c[a] = d = {
                    x1: d[0],
                    y1: d[1],
                    x2: d[2],
                    y2: d[3],
                    gradientUnits: "userSpaceOnUse"
                  });
                  "radialGradient" === a && h && !x(d.gradientUnits) && (N = d, d = C(d, n.getRadialAttr(h, N), {
                    gradientUnits: "userSpaceOnUse"
                  }));
                  H(d, function (c, b) {
                    "id" !== b && E.push(b, c);
                  });
                  H(k, function (c) {
                    E.push(c);
                  });
                  E = E.join(",");
                  if (g[E]) B = g[E].attr("id");else {
                    d.id = B = S();
                    var m = g[E] = n.createElement(a).attr(d).add(n.defs);
                    m.radAttr = N;
                    m.stops = [];
                    k.forEach(function (c) {
                      0 === c[1].indexOf("rgba") ? (f = A.parse(c[1]), p = f.get("rgb"), u = f.get("a")) : (p = c[1], u = 1);
                      c = n.createElement("stop").attr({
                        offset: c[0],
                        "stop-color": p,
                        "stop-opacity": u
                      }).add(m);
                      m.stops.push(c);
                    });
                  }
                  F = "url(" + n.url + "#" + B + ")";
                  b.setAttribute(e, F);
                  b.gradient = E;

                  c.toString = function () {
                    return F;
                  };
                }
              });
            };

            a.prototype.css = function (c) {
              var b = this.styles,
                  e = {},
                  n = this.element,
                  f = ["textOutline", "textOverflow", "width"],
                  a = "",
                  d = !b;
              c && c.color && (c.fill = c.color);
              b && H(c, function (c, n) {
                b && b[n] !== c && (e[n] = c, d = !0);
              });

              if (d) {
                b && (c = E(b, e));
                if (c) if (null === c.width || "auto" === c.width) delete this.textWidth;else if ("text" === n.nodeName.toLowerCase() && c.width) var q = this.textWidth = F(c.width);
                this.styles = c;
                q && !g && this.renderer.forExport && delete c.width;

                if (n.namespaceURI === this.SVG_NS) {
                  var m = function m(c, b) {
                    return "-" + b.toLowerCase();
                  };

                  H(c, function (c, b) {
                    -1 === f.indexOf(b) && (a += b.replace(/([A-Z])/g, m) + ":" + c + ";");
                  });
                  a && G(n, "style", a);
                } else B(n, c);

                this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), c && c.textOutline && this.applyTextOutline(c.textOutline));
              }

              return this;
            };

            a.prototype.dashstyleSetter = function (c) {
              var b = this["stroke-width"];
              "inherit" === b && (b = 1);

              if (c = c && c.toLowerCase()) {
                var e = c.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

                for (c = e.length; c--;) {
                  e[c] = "" + F(e[c]) * L(b, NaN);
                }

                c = e.join(",").replace(/NaN/g, "none");
                this.element.setAttribute("stroke-dasharray", c);
              }
            };

            a.prototype.destroy = function () {
              var c = this,
                  b = c.element || {},
                  e = c.renderer,
                  n = b.ownerSVGElement,
                  f = e.isSVG && "SPAN" === b.nodeName && c.parentGroup || void 0;
              b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;
              l(c);

              if (c.clipPath && n) {
                var a = c.clipPath;
                [].forEach.call(n.querySelectorAll("[clip-path],[CLIP-PATH]"), function (c) {
                  -1 < c.getAttribute("clip-path").indexOf(a.element.id) && c.removeAttribute("clip-path");
                });
                c.clipPath = a.destroy();
              }

              if (c.stops) {
                for (n = 0; n < c.stops.length; n++) {
                  c.stops[n].destroy();
                }

                c.stops.length = 0;
                c.stops = void 0;
              }

              c.safeRemoveChild(b);

              for (e.styledMode || c.destroyShadows(); f && f.div && 0 === f.div.childNodes.length;) {
                b = f.parentGroup, c.safeRemoveChild(f.div), delete f.div, f = b;
              }

              c.alignTo && u(e.alignedObjects, c);
              H(c, function (b, e) {
                c[e] && c[e].parentGroup === c && c[e].destroy && c[e].destroy();
                delete c[e];
              });
            };

            a.prototype.destroyShadows = function () {
              (this.shadows || []).forEach(function (c) {
                this.safeRemoveChild(c);
              }, this);
              this.shadows = void 0;
            };

            a.prototype.destroyTextPath = function (c, b) {
              var e = c.getElementsByTagName("text")[0];

              if (e) {
                if (e.removeAttribute("dx"), e.removeAttribute("dy"), b.element.setAttribute("id", ""), this.textPathWrapper && e.getElementsByTagName("textPath").length) {
                  for (c = this.textPathWrapper.element.childNodes; c.length;) {
                    e.appendChild(c[0]);
                  }

                  e.removeChild(this.textPathWrapper.element);
                }
              } else if (c.getAttribute("dx") || c.getAttribute("dy")) c.removeAttribute("dx"), c.removeAttribute("dy");

              this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
            };

            a.prototype.dSetter = function (c, b, e) {
              q(c) && ("string" === typeof c[0] && (c = this.renderer.pathToSegments(c)), this.pathArray = c, c = c.reduce(function (c, b, e) {
                return b && b.join ? (e ? c + " " : "") + b.join(" ") : (b || "").toString();
              }, ""));
              /(NaN| {2}|^$)/.test(c) && (c = "M 0 0");
              this[b] !== c && (e.setAttribute(b, c), this[b] = c);
            };

            a.prototype.fadeOut = function (c) {
              var b = this;
              b.animate({
                opacity: 0
              }, {
                duration: L(c, 150),
                complete: function complete() {
                  b.attr({
                    y: -9999
                  }).hide();
                }
              });
            };

            a.prototype.fillSetter = function (c, b, e) {
              "string" === typeof c ? e.setAttribute(b, c) : c && this.complexColor(c, b, e);
            };

            a.prototype.getBBox = function (c, b) {
              var n = this.renderer,
                  f = this.element,
                  d = this.styles,
                  q = this.textStr,
                  m = n.cache,
                  g = n.cacheKeys,
                  k = f.namespaceURI === this.SVG_NS;
              b = L(b, this.rotation, 0);
              var p = n.styledMode ? f && a.prototype.getStyle.call(f, "font-size") : d && d.fontSize,
                  C;

              if (x(q)) {
                var u = q.toString();
                -1 === u.indexOf("<") && (u = u.replace(/[0-9]/g, "0"));
                u += ["", b, p, this.textWidth, d && d.textOverflow, d && d.fontWeight].join();
              }

              u && !c && (C = m[u]);

              if (!C) {
                if (k || n.forExport) {
                  try {
                    var H = this.fakeTS && function (c) {
                      var b = f.querySelector(".highcharts-text-outline");
                      b && B(b, {
                        display: c
                      });
                    };

                    e(H) && H("none");
                    C = f.getBBox ? E({}, f.getBBox()) : {
                      width: f.offsetWidth,
                      height: f.offsetHeight
                    };
                    e(H) && H("");
                  } catch (Y) {
                    "";
                  }

                  if (!C || 0 > C.width) C = {
                    width: 0,
                    height: 0
                  };
                } else C = this.htmlGetBBox();

                n.isSVG && (c = C.width, n = C.height, k && (C.height = n = {
                  "11px,17": 14,
                  "13px,20": 16
                }[d && d.fontSize + "," + Math.round(n)] || n), b && (d = b * h, C.width = Math.abs(n * Math.sin(d)) + Math.abs(c * Math.cos(d)), C.height = Math.abs(n * Math.cos(d)) + Math.abs(c * Math.sin(d))));

                if (u && ("" === q || 0 < C.height)) {
                  for (; 250 < g.length;) {
                    delete m[g.shift()];
                  }

                  m[u] || g.push(u);
                  m[u] = C;
                }
              }

              return C;
            };

            a.prototype.getStyle = function (c) {
              return k.getComputedStyle(this.element || this, "").getPropertyValue(c);
            };

            a.prototype.hasClass = function (c) {
              return -1 !== ("" + this.attr("class")).split(" ").indexOf(c);
            };

            a.prototype.hide = function (c) {
              c ? this.attr({
                y: -9999
              }) : this.attr({
                visibility: "hidden"
              });
              return this;
            };

            a.prototype.htmlGetBBox = function () {
              return {
                height: 0,
                width: 0,
                x: 0,
                y: 0
              };
            };

            a.prototype.init = function (c, b) {
              this.element = "span" === b ? f(b) : d.createElementNS(this.SVG_NS, b);
              this.renderer = c;
              m(this, "afterInit");
            };

            a.prototype.invert = function (c) {
              this.inverted = c;
              this.updateTransform();
              return this;
            };

            a.prototype.on = function (c, b) {
              var e = this.onEvents;
              if (e[c]) e[c]();
              e[c] = J(this.element, c, b);
              return this;
            };

            a.prototype.opacitySetter = function (c, b, e) {
              this.opacity = c = Number(Number(c).toFixed(3));
              e.setAttribute(b, c);
            };

            a.prototype.removeClass = function (c) {
              return this.attr("class", ("" + this.attr("class")).replace(n(c) ? new RegExp("(^| )" + c + "( |$)") : c, " ").replace(/ +/g, " ").trim());
            };

            a.prototype.removeTextOutline = function () {
              var c = this.element.querySelector("tspan.highcharts-text-outline");
              c && this.safeRemoveChild(c);
            };

            a.prototype.safeRemoveChild = function (c) {
              var b = c.parentNode;
              b && b.removeChild(c);
            };

            a.prototype.setRadialReference = function (c) {
              var b = this.element.gradient && this.renderer.gradients[this.element.gradient];
              this.element.radialReference = c;
              b && b.radAttr && b.animate(this.renderer.getRadialAttr(c, b.radAttr));
              return this;
            };

            a.prototype.setTextPath = function (e, n) {
              var f = this.element,
                  a = this.text ? this.text.element : f,
                  d = {
                textAnchor: "text-anchor"
              },
                  q = !1,
                  m = this.textPathWrapper,
                  g = !m;
              n = C(!0, {
                enabled: !0,
                attributes: {
                  dy: -5,
                  startOffset: "50%",
                  textAnchor: "middle"
                }
              }, n);
              var k = v.filterUserAttributes(n.attributes);

              if (e && n && n.enabled) {
                m && null === m.element.parentNode ? (g = !0, m = m.destroy()) : m && this.removeTextOutline.call(m.parentGroup);
                this.options && this.options.padding && (k.dx = -this.options.padding);
                m || (this.textPathWrapper = m = this.renderer.createElement("textPath"), q = !0);
                var u = m.element;
                (n = e.element.getAttribute("id")) || e.element.setAttribute("id", n = S());
                if (g) for (a.setAttribute("y", 0), c(k.dx) && a.setAttribute("x", -k.dx), e = [].slice.call(a.childNodes), g = 0; g < e.length; g++) {
                  var p = e[g];
                  p.nodeType !== Node.TEXT_NODE && "tspan" !== p.nodeName || u.appendChild(p);
                }
                q && m && m.add({
                  element: a
                });
                u.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + n);
                x(k.dy) && (u.parentNode.setAttribute("dy", k.dy), delete k.dy);
                x(k.dx) && (u.parentNode.setAttribute("dx", k.dx), delete k.dx);
                H(k, function (c, b) {
                  u.setAttribute(d[b] || b, c);
                });
                f.removeAttribute("transform");
                this.removeTextOutline.call(m);
                this.text && !this.renderer.styledMode && this.attr({
                  fill: "none",
                  "stroke-width": 0
                });
                this.applyTextOutline = this.updateTransform = b;
              } else m && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(f, e), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

              return this;
            };

            a.prototype.shadow = function (c, b, e) {
              var n = [],
                  f = this.element,
                  a = this.oldShadowOptions,
                  d = {
                color: z.neutralColor100,
                offsetX: this.parentInverted ? -1 : 1,
                offsetY: this.parentInverted ? -1 : 1,
                opacity: .15,
                width: 3
              },
                  m = !1,
                  q;
              !0 === c ? q = d : "object" === typeof c && (q = E(d, c));
              q && (q && a && H(q, function (c, b) {
                c !== a[b] && (m = !0);
              }), m && this.destroyShadows(), this.oldShadowOptions = q);
              if (!q) this.destroyShadows();else if (!this.shadows) {
                var g = q.opacity / q.width;
                var N = this.parentInverted ? "translate(" + q.offsetY + ", " + q.offsetX + ")" : "translate(" + q.offsetX + ", " + q.offsetY + ")";

                for (d = 1; d <= q.width; d++) {
                  var k = f.cloneNode(!1);
                  var C = 2 * q.width + 1 - 2 * d;
                  G(k, {
                    stroke: c.color || z.neutralColor100,
                    "stroke-opacity": g * d,
                    "stroke-width": C,
                    transform: N,
                    fill: "none"
                  });
                  k.setAttribute("class", (k.getAttribute("class") || "") + " highcharts-shadow");
                  e && (G(k, "height", Math.max(G(k, "height") - C, 0)), k.cutHeight = C);
                  b ? b.element.appendChild(k) : f.parentNode && f.parentNode.insertBefore(k, f);
                  n.push(k);
                }

                this.shadows = n;
              }
              return this;
            };

            a.prototype.show = function (c) {
              return this.attr({
                visibility: c ? "inherit" : "visible"
              });
            };

            a.prototype.strokeSetter = function (c, b, e) {
              this[b] = c;
              this.stroke && this["stroke-width"] ? (a.prototype.fillSetter.call(this, this.stroke, "stroke", e), e.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === b && 0 === c && this.hasStroke ? (e.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (e.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
            };

            a.prototype.strokeWidth = function () {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              var c = this.getStyle("stroke-width"),
                  b = 0;
              if (c.indexOf("px") === c.length - 2) b = F(c);else if ("" !== c) {
                var e = d.createElementNS(p, "rect");
                G(e, {
                  width: c,
                  "stroke-width": 0
                });
                this.element.parentNode.appendChild(e);
                b = e.getBBox().width;
                e.parentNode.removeChild(e);
              }
              return b;
            };

            a.prototype.symbolAttr = function (c) {
              var b = this;
              "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (e) {
                b[e] = L(c[e], b[e]);
              });
              b.attr({
                d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
              });
            };

            a.prototype.textSetter = function (c) {
              c !== this.textStr && (delete this.textPxLength, this.textStr = c, this.added && this.renderer.buildText(this));
            };

            a.prototype.titleSetter = function (c) {
              var b = this.element,
                  e = b.getElementsByTagName("title")[0] || d.createElementNS(this.SVG_NS, "title");
              b.insertBefore ? b.insertBefore(e, b.firstChild) : b.appendChild(e);
              e.textContent = String(L(c, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            };

            a.prototype.toFront = function () {
              var c = this.element;
              c.parentNode.appendChild(c);
              return this;
            };

            a.prototype.translate = function (c, b) {
              return this.attr({
                translateX: c,
                translateY: b
              });
            };

            a.prototype.updateShadows = function (c, b, e) {
              var n = this.shadows;
              if (n) for (var f = n.length; f--;) {
                e.call(n[f], "height" === c ? Math.max(b - (n[f].cutHeight || 0), 0) : "d" === c ? this.d : b, c, n[f]);
              }
            };

            a.prototype.updateTransform = function () {
              var c = this.scaleX,
                  b = this.scaleY,
                  e = this.inverted,
                  n = this.rotation,
                  f = this.matrix,
                  a = this.element,
                  d = this.translateX || 0,
                  q = this.translateY || 0;
              e && (d += this.width, q += this.height);
              d = ["translate(" + d + "," + q + ")"];
              x(f) && d.push("matrix(" + f.join(",") + ")");
              e ? d.push("rotate(90) scale(-1,1)") : n && d.push("rotate(" + n + " " + L(this.rotationOriginX, a.getAttribute("x"), 0) + " " + L(this.rotationOriginY, a.getAttribute("y") || 0) + ")");
              (x(c) || x(b)) && d.push("scale(" + L(c, 1) + " " + L(b, 1) + ")");
              d.length && a.setAttribute("transform", d.join(" "));
            };

            a.prototype.visibilitySetter = function (c, b, e) {
              "inherit" === c ? e.removeAttribute(b) : this[b] !== c && e.setAttribute(b, c);
              this[b] = c;
            };

            a.prototype.xGetter = function (c) {
              "circle" === this.element.nodeName && ("x" === c ? c = "cx" : "y" === c && (c = "cy"));
              return this._defaultGetter(c);
            };

            a.prototype.zIndexSetter = function (c, b) {
              var e = this.renderer,
                  n = this.parentGroup,
                  f = (n || e).element || e.box,
                  a = this.element;
              e = f === e.box;
              var d = !1;
              var q = this.added;
              var m;
              x(c) ? (a.setAttribute("data-z-index", c), c = +c, this[b] === c && (q = !1)) : x(this[b]) && a.removeAttribute("data-z-index");
              this[b] = c;

              if (q) {
                (c = this.zIndex) && n && (n.handleZ = !0);
                b = f.childNodes;

                for (m = b.length - 1; 0 <= m && !d; m--) {
                  n = b[m];
                  q = n.getAttribute("data-z-index");
                  var g = !x(q);
                  if (n !== a) if (0 > c && g && !e && !m) f.insertBefore(a, b[m]), d = !0;else if (F(q) <= c || g && (!x(c) || 0 <= c)) f.insertBefore(a, b[m + 1] || null), d = !0;
                }

                d || (f.insertBefore(a, b[e ? 3 : 0] || null), d = !0);
              }

              return d;
            };

            return a;
          }();

          a.prototype["stroke-widthSetter"] = a.prototype.strokeSetter;
          a.prototype.yGetter = a.prototype.xGetter;

          a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function (c, b) {
            this[b] = c;
            this.doTransform = !0;
          };

          "";
          return a;
        });
        I(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function (a) {
          var r;

          (function (r) {
            r.rendererTypes = {};
            var v;

            r.getRendererType = function (a) {
              void 0 === a && (a = v);
              return r.rendererTypes[a] || r.rendererTypes[v];
            };

            r.registerRendererType = function (y, w, D) {
              r.rendererTypes[y] = w;
              if (!v || D) v = y, a.Renderer = w;
            };
          })(r || (r = {}));

          return r;
        });
        I(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = this && this.__extends || function () {
            var _a26 = function a(d, b) {
              _a26 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _a26(d, b);
            };

            return function (d, b) {
              function g() {
                this.constructor = d;
              }

              _a26(d, b);

              d.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());
            };
          }(),
              y = v.defined,
              z = v.extend,
              w = v.isNumber,
              D = v.merge,
              t = v.pick,
              l = v.removeEvent;

          return function (h) {
            function d(b, a, p, k, l, G, f, B, x, u) {
              var g = h.call(this) || this;
              g.paddingLeftSetter = g.paddingSetter;
              g.paddingRightSetter = g.paddingSetter;
              g.init(b, "g");
              g.textStr = a;
              g.x = p;
              g.y = k;
              g.anchorX = G;
              g.anchorY = f;
              g.baseline = x;
              g.className = u;
              g.addClass("button" === u ? "highcharts-no-tooltip" : "highcharts-label");
              u && g.addClass("highcharts-" + u);
              g.text = b.text(void 0, 0, 0, B).attr({
                zIndex: 1
              });
              var m;
              "string" === typeof l && ((m = /^url\((.*?)\)$/.test(l)) || g.renderer.symbols[l]) && (g.symbolKey = l);
              g.bBox = d.emptyBBox;
              g.padding = 3;
              g.baselineOffset = 0;
              g.needsBox = b.styledMode || m;
              g.deferredAttr = {};
              g.alignFactor = 0;
              return g;
            }

            r(d, h);

            d.prototype.alignSetter = function (b) {
              b = {
                left: 0,
                center: .5,
                right: 1
              }[b];
              b !== this.alignFactor && (this.alignFactor = b, this.bBox && w(this.xSetting) && this.attr({
                x: this.xSetting
              }));
            };

            d.prototype.anchorXSetter = function (b, a) {
              this.anchorX = b;
              this.boxAttr(a, Math.round(b) - this.getCrispAdjust() - this.xSetting);
            };

            d.prototype.anchorYSetter = function (b, a) {
              this.anchorY = b;
              this.boxAttr(a, b - this.ySetting);
            };

            d.prototype.boxAttr = function (b, a) {
              this.box ? this.box.attr(b, a) : this.deferredAttr[b] = a;
            };

            d.prototype.css = function (b) {
              if (b) {
                var g = {};
                b = D(b);
                d.textProps.forEach(function (a) {
                  "undefined" !== typeof b[a] && (g[a] = b[a], delete b[a]);
                });
                this.text.css(g);
                var p = ("width" in g);
                "fontSize" in g || "fontWeight" in g ? this.updateTextPadding() : p && this.updateBoxSize();
              }

              return a.prototype.css.call(this, b);
            };

            d.prototype.destroy = function () {
              l(this.element, "mouseenter");
              l(this.element, "mouseleave");
              this.text && this.text.destroy();
              this.box && (this.box = this.box.destroy());
              a.prototype.destroy.call(this);
            };

            d.prototype.fillSetter = function (b, a) {
              b && (this.needsBox = !0);
              this.fill = b;
              this.boxAttr(a, b);
            };

            d.prototype.getBBox = function () {
              this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
              var b = this.padding,
                  a = t(this.paddingLeft, b);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - a,
                y: this.bBox.y - b
              };
            };

            d.prototype.getCrispAdjust = function () {
              return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            };

            d.prototype.heightSetter = function (b) {
              this.heightSetting = b;
            };

            d.prototype.onAdd = function () {
              var b = this.textStr;
              this.text.add(this);
              this.attr({
                text: y(b) ? b : "",
                x: this.x,
                y: this.y
              });
              this.box && y(this.anchorX) && this.attr({
                anchorX: this.anchorX,
                anchorY: this.anchorY
              });
            };

            d.prototype.paddingSetter = function (b, a) {
              w(b) ? b !== this[a] && (this[a] = b, this.updateTextPadding()) : this[a] = void 0;
            };

            d.prototype.rSetter = function (b, a) {
              this.boxAttr(a, b);
            };

            d.prototype.shadow = function (b) {
              b && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(b));
              return this;
            };

            d.prototype.strokeSetter = function (b, a) {
              this.stroke = b;
              this.boxAttr(a, b);
            };

            d.prototype["stroke-widthSetter"] = function (b, a) {
              b && (this.needsBox = !0);
              this["stroke-width"] = b;
              this.boxAttr(a, b);
            };

            d.prototype["text-alignSetter"] = function (b) {
              this.textAlign = b;
            };

            d.prototype.textSetter = function (b) {
              "undefined" !== typeof b && this.text.attr({
                text: b
              });
              this.updateTextPadding();
            };

            d.prototype.updateBoxSize = function () {
              var b = this.text.element.style,
                  a = {},
                  p = this.padding,
                  k = this.bBox = w(this.widthSetting) && w(this.heightSetting) && !this.textAlign || !y(this.text.textStr) ? d.emptyBBox : this.text.getBBox();
              this.width = this.getPaddedWidth();
              this.height = (this.heightSetting || k.height || 0) + 2 * p;
              b = this.renderer.fontMetrics(b && b.fontSize, this.text);
              this.baselineOffset = p + Math.min((this.text.firstLineMetrics || b).b, k.height || Infinity);
              this.heightSetting && (this.baselineOffset += (this.heightSetting - b.h) / 2);
              this.needsBox && (this.box || (p = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), p.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), p.add(this)), p = this.getCrispAdjust(), a.x = p, a.y = (this.baseline ? -this.baselineOffset : 0) + p, a.width = Math.round(this.width), a.height = Math.round(this.height), this.box.attr(z(a, this.deferredAttr)), this.deferredAttr = {});
            };

            d.prototype.updateTextPadding = function () {
              var b = this.text;
              this.updateBoxSize();
              var a = this.baseline ? 0 : this.baselineOffset,
                  d = t(this.paddingLeft, this.padding);
              y(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (d += {
                center: .5,
                right: 1
              }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (d !== b.x || a !== b.y) b.attr("x", d), b.hasBoxWidthChanged && (this.bBox = b.getBBox(!0)), "undefined" !== typeof a && b.attr("y", a);
              b.x = d;
              b.y = a;
            };

            d.prototype.widthSetter = function (b) {
              this.widthSetting = w(b) ? b : void 0;
            };

            d.prototype.getPaddedWidth = function () {
              var b = this.padding,
                  a = t(this.paddingLeft, b);
              b = t(this.paddingRight, b);
              return (this.widthSetting || this.bBox.width || 0) + a + b;
            };

            d.prototype.xSetter = function (b) {
              this.x = b;
              this.alignFactor && (b -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
              this.xSetting = Math.round(b);
              this.attr("translateX", this.xSetting);
            };

            d.prototype.ySetter = function (b) {
              this.ySetting = this.y = Math.round(b);
              this.attr("translateY", this.ySetting);
            };

            d.emptyBBox = {
              width: 0,
              height: 0,
              x: 0,
              y: 0
            };
            d.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
            return d;
          }(a);
        });
        I(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function (a) {
          function r(a, l, h, d, b) {
            var g = [];

            if (b) {
              var p = b.start || 0,
                  k = D(b.r, h);
              h = D(b.r, d || h);
              var J = (b.end || 0) - .001;
              d = b.innerR;
              var G = D(b.open, .001 > Math.abs((b.end || 0) - p - 2 * Math.PI)),
                  f = Math.cos(p),
                  B = Math.sin(p),
                  x = Math.cos(J),
                  u = Math.sin(J);
              p = D(b.longArc, .001 > J - p - Math.PI ? 0 : 1);
              g.push(["M", a + k * f, l + h * B], ["A", k, h, 0, p, D(b.clockwise, 1), a + k * x, l + h * u]);
              z(d) && g.push(G ? ["M", a + d * x, l + d * u] : ["L", a + d * x, l + d * u], ["A", d, d, 0, p, z(b.clockwise) ? 1 - b.clockwise : 0, a + d * f, l + d * B]);
              G || g.push(["Z"]);
            }

            return g;
          }

          function A(a, l, h, d, b) {
            return b && b.r ? y(a, l, h, d, b) : [["M", a, l], ["L", a + h, l], ["L", a + h, l + d], ["L", a, l + d], ["Z"]];
          }

          function y(a, l, h, d, b) {
            b = b && b.r || 0;
            return [["M", a + b, l], ["L", a + h - b, l], ["C", a + h, l, a + h, l, a + h, l + b], ["L", a + h, l + d - b], ["C", a + h, l + d, a + h, l + d, a + h - b, l + d], ["L", a + b, l + d], ["C", a, l + d, a, l + d, a, l + d - b], ["L", a, l + b], ["C", a, l, a, l, a + b, l]];
          }

          var z = a.defined,
              w = a.isNumber,
              D = a.pick;
          return {
            arc: r,
            callout: function callout(a, l, h, d, b) {
              var g = Math.min(b && b.r || 0, h, d),
                  p = g + 6,
                  k = b && b.anchorX;
              b = b && b.anchorY || 0;
              var J = y(a, l, h, d, {
                r: g
              });
              if (!w(k)) return J;
              a + k >= h ? b > l + p && b < l + d - p ? J.splice(3, 1, ["L", a + h, b - 6], ["L", a + h + 6, b], ["L", a + h, b + 6], ["L", a + h, l + d - g]) : J.splice(3, 1, ["L", a + h, d / 2], ["L", k, b], ["L", a + h, d / 2], ["L", a + h, l + d - g]) : 0 >= a + k ? b > l + p && b < l + d - p ? J.splice(7, 1, ["L", a, b + 6], ["L", a - 6, b], ["L", a, b - 6], ["L", a, l + g]) : J.splice(7, 1, ["L", a, d / 2], ["L", k, b], ["L", a, d / 2], ["L", a, l + g]) : b && b > d && k > a + p && k < a + h - p ? J.splice(5, 1, ["L", k + 6, l + d], ["L", k, l + d + 6], ["L", k - 6, l + d], ["L", a + g, l + d]) : b && 0 > b && k > a + p && k < a + h - p && J.splice(1, 1, ["L", k - 6, l], ["L", k, l - 6], ["L", k + 6, l], ["L", h - g, l]);
              return J;
            },
            circle: function circle(a, l, h, d) {
              return r(a + h / 2, l + d / 2, h / 2, d / 2, {
                start: .5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1
              });
            },
            diamond: function diamond(a, l, h, d) {
              return [["M", a + h / 2, l], ["L", a + h, l + d / 2], ["L", a + h / 2, l + d], ["L", a, l + d / 2], ["Z"]];
            },
            rect: A,
            roundedRect: y,
            square: A,
            triangle: function triangle(a, l, h, d) {
              return [["M", a + h / 2, l], ["L", a + h, l + d], ["L", a, l + d], ["Z"]];
            },
            "triangle-down": function triangleDown(a, l, h, d) {
              return [["M", a, l], ["L", a + h, l], ["L", a + h / 2, l + d], ["Z"]];
            }
          };
        });
        I(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = v.doc,
              z = v.SVG_NS,
              w = A.attr,
              D = A.isString,
              t = A.objectEach,
              l = A.pick;
          return function () {
            function h(a) {
              var b = a.styles;
              this.renderer = a.renderer;
              this.svgElement = a;
              this.width = a.textWidth;
              this.textLineHeight = b && b.lineHeight;
              this.textOutline = b && b.textOutline;
              this.ellipsis = !(!b || "ellipsis" !== b.textOverflow);
              this.noWrap = !(!b || "nowrap" !== b.whiteSpace);
              this.fontSize = b && b.fontSize;
            }

            h.prototype.buildSVG = function () {
              var d = this.svgElement,
                  b = d.element,
                  g = d.renderer,
                  p = l(d.textStr, "").toString(),
                  k = -1 !== p.indexOf("<"),
                  h = b.childNodes;
              g = this.width && !d.added && g.box;
              var G = /<br.*?>/g,
                  f = [p, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();

              if (f !== d.textCache) {
                d.textCache = f;
                delete d.actualWidth;

                for (f = h.length; f--;) {
                  b.removeChild(h[f]);
                }

                k || this.ellipsis || this.width || -1 !== p.indexOf(" ") && (!this.noWrap || G.test(p)) ? "" !== p && (g && g.appendChild(b), p = new a(p), this.modifyTree(p.nodes), p.addToDOM(d.element), this.modifyDOM(), this.ellipsis && -1 !== (b.textContent || "").indexOf("\u2026") && d.attr("title", this.unescapeEntities(d.textStr || "", ["&lt;", "&gt;"])), g && g.removeChild(b)) : b.appendChild(r.createTextNode(this.unescapeEntities(p)));
                D(this.textOutline) && d.applyTextOutline && d.applyTextOutline(this.textOutline);
              }
            };

            h.prototype.modifyDOM = function () {
              var a = this,
                  b = this.svgElement,
                  g = w(b.element, "x");
              b.firstLineMetrics = void 0;

              for (var p; p = b.element.firstChild;) {
                if (/^[\s\u200B]*$/.test(p.textContent || " ")) b.element.removeChild(p);else break;
              }

              [].forEach.call(b.element.querySelectorAll("tspan.highcharts-br"), function (f, d) {
                f.nextSibling && f.previousSibling && (0 === d && 1 === f.previousSibling.nodeType && (b.firstLineMetrics = b.renderer.fontMetrics(void 0, f.previousSibling)), w(f, {
                  dy: a.getLineHeight(f.nextSibling),
                  x: g
                }));
              });
              var k = this.width || 0;

              if (k) {
                var h = function h(f, d) {
                  var p = f.textContent || "",
                      u = p.replace(/([^\^])-/g, "$1- ").split(" "),
                      h = !a.noWrap && (1 < u.length || 1 < b.element.childNodes.length),
                      m = a.getLineHeight(d),
                      q = 0,
                      e = b.actualWidth;
                  if (a.ellipsis) p && a.truncate(f, p, void 0, 0, Math.max(0, k - parseInt(a.fontSize || 12, 10)), function (c, b) {
                    return c.substring(0, b) + "\u2026";
                  });else if (h) {
                    p = [];

                    for (h = []; d.firstChild && d.firstChild !== f;) {
                      h.push(d.firstChild), d.removeChild(d.firstChild);
                    }

                    for (; u.length;) {
                      u.length && !a.noWrap && 0 < q && (p.push(f.textContent || ""), f.textContent = u.join(" ").replace(/- /g, "-")), a.truncate(f, void 0, u, 0 === q ? e || 0 : 0, k, function (c, b) {
                        return u.slice(0, b).join(" ").replace(/- /g, "-");
                      }), e = b.actualWidth, q++;
                    }

                    h.forEach(function (c) {
                      d.insertBefore(c, f);
                    });
                    p.forEach(function (c) {
                      d.insertBefore(r.createTextNode(c), f);
                      c = r.createElementNS(z, "tspan");
                      c.textContent = "\u200B";
                      w(c, {
                        dy: m,
                        x: g
                      });
                      d.insertBefore(c, f);
                    });
                  }
                },
                    l = function l(a) {
                  [].slice.call(a.childNodes).forEach(function (f) {
                    f.nodeType === Node.TEXT_NODE ? h(f, a) : (-1 !== f.className.baseVal.indexOf("highcharts-br") && (b.actualWidth = 0), l(f));
                  });
                };

                l(b.element);
              }
            };

            h.prototype.getLineHeight = function (a) {
              var b;
              a = a.nodeType === Node.TEXT_NODE ? a.parentElement : a;
              this.renderer.styledMode || (b = a && /(px|em)$/.test(a.style.fontSize) ? a.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
              return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(b, a || this.svgElement.element).h;
            };

            h.prototype.modifyTree = function (a) {
              var b = this,
                  d = function d(g, k) {
                var h = g.tagName,
                    p = b.renderer.styledMode,
                    f = g.attributes || {};
                if ("b" === h || "strong" === h) p ? f["class"] = "highcharts-strong" : f.style = "font-weight:bold;" + (f.style || "");else if ("i" === h || "em" === h) p ? f["class"] = "highcharts-emphasized" : f.style = "font-style:italic;" + (f.style || "");
                D(f.style) && (f.style = f.style.replace(/(;| |^)color([ :])/, "$1fill$2"));
                "br" === h && (f["class"] = "highcharts-br", g.textContent = "\u200B", (k = a[k + 1]) && k.textContent && (k.textContent = k.textContent.replace(/^ +/gm, "")));
                "#text" !== h && "a" !== h && (g.tagName = "tspan");
                g.attributes = f;
                g.children && g.children.filter(function (b) {
                  return "#text" !== b.tagName;
                }).forEach(d);
              };

              a.forEach(d);
            };

            h.prototype.truncate = function (a, b, g, h, k, l) {
              var d = this.svgElement,
                  f = d.renderer,
                  p = d.rotation,
                  x = [],
                  u = g ? 1 : 0,
                  E = (b || g || "").length,
                  m = E,
                  q,
                  e = function e(c, _e11) {
                _e11 = _e11 || c;
                var n = a.parentNode;
                if (n && "undefined" === typeof x[_e11]) if (n.getSubStringLength) try {
                  x[_e11] = h + n.getSubStringLength(0, g ? _e11 + 1 : _e11);
                } catch (L) {
                  "";
                } else f.getSpanWidth && (a.textContent = l(b || g, c), x[_e11] = h + f.getSpanWidth(d, a));
                return x[_e11];
              };

              d.rotation = 0;
              var c = e(a.textContent.length);

              if (h + c > k) {
                for (; u <= E;) {
                  m = Math.ceil((u + E) / 2), g && (q = l(g, m)), c = e(m, q && q.length - 1), u === E ? u = E + 1 : c > k ? E = m - 1 : u = m;
                }

                0 === E ? a.textContent = "" : b && E === b.length - 1 || (a.textContent = q || l(b || g, m));
              }

              g && g.splice(0, m);
              d.actualWidth = c;
              d.rotation = p;
            };

            h.prototype.unescapeEntities = function (a, b) {
              t(this.renderer.escapes, function (d, h) {
                b && -1 !== b.indexOf(d) || (a = a.toString().replace(new RegExp(d, "g"), h));
              });
              return a;
            };

            return h;
          }();
        });
        I(a, "Core/Renderer/SVG/SVGRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGLabel.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Renderer/SVG/TextBuilder.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t, l, h) {
          var d = A.charts,
              b = A.deg2rad,
              g = A.doc,
              p = A.isFirefox,
              k = A.isMS,
              J = A.isWebKit,
              G = A.noop,
              f = A.SVG_NS,
              B = A.symbolSizes,
              x = A.win,
              u = h.addEvent,
              E = h.attr,
              m = h.createElement,
              q = h.css,
              e = h.defined,
              c = h.destroyObjectProperties,
              n = h.extend,
              C = h.isArray,
              H = h.isNumber,
              L = h.isObject,
              F = h.isString,
              r = h.merge,
              S = h.pick,
              R = h.pInt,
              T = h.uniqueKey,
              ba;

          A = function () {
            function f(c, b, e, a, n, f, d) {
              this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
              this.init(c, b, e, a, n, f, d);
            }

            f.prototype.init = function (c, b, e, a, n, f, d) {
              var m = this.createElement("svg").attr({
                version: "1.1",
                "class": "highcharts-root"
              }),
                  k = m.element;
              d || m.css(this.getStyle(a));
              c.appendChild(k);
              E(c, "dir", "ltr");
              -1 === c.innerHTML.indexOf("xmlns") && E(k, "xmlns", this.SVG_NS);
              this.isSVG = !0;
              this.box = k;
              this.boxWrapper = m;
              this.alignedObjects = [];
              this.url = this.getReferenceURL();
              this.createElement("desc").add().element.appendChild(g.createTextNode("Created with Highcharts 9.2.2"));
              this.defs = this.createElement("defs").add();
              this.allowHTML = f;
              this.forExport = n;
              this.styledMode = d;
              this.gradients = {};
              this.cache = {};
              this.cacheKeys = [];
              this.imgCount = 0;
              this.setSize(b, e, !1);
              var M;
              p && c.getBoundingClientRect && (b = function b() {
                q(c, {
                  left: 0,
                  top: 0
                });
                M = c.getBoundingClientRect();
                q(c, {
                  left: Math.ceil(M.left) - M.left + "px",
                  top: Math.ceil(M.top) - M.top + "px"
                });
              }, b(), this.unSubPixelFix = u(x, "resize", b));
            };

            f.prototype.definition = function (c) {
              return new a([c]).addToDOM(this.defs.element);
            };

            f.prototype.getReferenceURL = function () {
              if ((p || J) && g.getElementsByTagName("base").length) {
                if (!e(ba)) {
                  var c = T();
                  c = new a([{
                    tagName: "svg",
                    attributes: {
                      width: 8,
                      height: 8
                    },
                    children: [{
                      tagName: "defs",
                      children: [{
                        tagName: "clipPath",
                        attributes: {
                          id: c
                        },
                        children: [{
                          tagName: "rect",
                          attributes: {
                            width: 4,
                            height: 4
                          }
                        }]
                      }]
                    }, {
                      tagName: "rect",
                      attributes: {
                        id: "hitme",
                        width: 8,
                        height: 8,
                        "clip-path": "url(#" + c + ")",
                        fill: "rgba(0,0,0,0.001)"
                      }
                    }]
                  }]).addToDOM(g.body);
                  q(c, {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    zIndex: 9E5
                  });
                  var b = g.elementFromPoint(6, 6);
                  ba = "hitme" === (b && b.id);
                  g.body.removeChild(c);
                }

                if (ba) return x.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
              }

              return "";
            };

            f.prototype.getStyle = function (c) {
              return this.style = n({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                fontSize: "12px"
              }, c);
            };

            f.prototype.setStyle = function (c) {
              this.boxWrapper.css(this.getStyle(c));
            };

            f.prototype.isHidden = function () {
              return !this.boxWrapper.getBBox().width;
            };

            f.prototype.destroy = function () {
              var b = this.defs;
              this.box = null;
              this.boxWrapper = this.boxWrapper.destroy();
              c(this.gradients || {});
              this.gradients = null;
              b && (this.defs = b.destroy());
              this.unSubPixelFix && this.unSubPixelFix();
              return this.alignedObjects = null;
            };

            f.prototype.createElement = function (c) {
              var b = new this.Element();
              b.init(this, c);
              return b;
            };

            f.prototype.getRadialAttr = function (c, b) {
              return {
                cx: c[0] - c[2] / 2 + (b.cx || 0) * c[2],
                cy: c[1] - c[2] / 2 + (b.cy || 0) * c[2],
                r: (b.r || 0) * c[2]
              };
            };

            f.prototype.buildText = function (c) {
              new l(c).buildSVG();
            };

            f.prototype.getContrast = function (c) {
              c = v.parse(c).rgba;
              c[0] *= 1;
              c[1] *= 1.2;
              c[2] *= .5;
              return 459 < c[0] + c[1] + c[2] ? "#000000" : "#FFFFFF";
            };

            f.prototype.button = function (c, b, e, f, d, q, m, g, C, h) {
              var p = this.label(c, b, e, C, void 0, void 0, h, void 0, "button"),
                  M = this.styledMode,
                  N = 0,
                  K = d ? r(d) : {};
              c = K && K.style || {};
              K = a.filterUserAttributes(K);
              p.attr(r({
                padding: 8,
                r: 2
              }, K));

              if (!M) {
                K = r({
                  fill: y.neutralColor3,
                  stroke: y.neutralColor20,
                  "stroke-width": 1,
                  style: {
                    color: y.neutralColor80,
                    cursor: "pointer",
                    fontWeight: "normal"
                  }
                }, {
                  style: c
                }, K);
                var B = K.style;
                delete K.style;
                q = r(K, {
                  fill: y.neutralColor10
                }, a.filterUserAttributes(q || {}));
                var x = q.style;
                delete q.style;
                m = r(K, {
                  fill: y.highlightColor10,
                  style: {
                    color: y.neutralColor100,
                    fontWeight: "bold"
                  }
                }, a.filterUserAttributes(m || {}));
                var H = m.style;
                delete m.style;
                g = r(K, {
                  style: {
                    color: y.neutralColor20
                  }
                }, a.filterUserAttributes(g || {}));
                var F = g.style;
                delete g.style;
              }

              u(p.element, k ? "mouseover" : "mouseenter", function () {
                3 !== N && p.setState(1);
              });
              u(p.element, k ? "mouseout" : "mouseleave", function () {
                3 !== N && p.setState(N);
              });

              p.setState = function (c) {
                1 !== c && (p.state = N = c);
                p.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][c || 0]);
                M || p.attr([K, q, m, g][c || 0]).css([B, x, H, F][c || 0]);
              };

              M || p.attr(K).css(n({
                cursor: "default"
              }, B));
              return p.on("touchstart", function (c) {
                return c.stopPropagation();
              }).on("click", function (c) {
                3 !== N && f.call(p, c);
              });
            };

            f.prototype.crispLine = function (c, b, a) {
              void 0 === a && (a = "round");
              var n = c[0],
                  f = c[1];
              e(n[1]) && n[1] === f[1] && (n[1] = f[1] = Math[a](n[1]) - b % 2 / 2);
              e(n[2]) && n[2] === f[2] && (n[2] = f[2] = Math[a](n[2]) + b % 2 / 2);
              return c;
            };

            f.prototype.path = function (c) {
              var b = this.styledMode ? {} : {
                fill: "none"
              };
              C(c) ? b.d = c : L(c) && n(b, c);
              return this.createElement("path").attr(b);
            };

            f.prototype.circle = function (c, b, e) {
              c = L(c) ? c : "undefined" === typeof c ? {} : {
                x: c,
                y: b,
                r: e
              };
              b = this.createElement("circle");

              b.xSetter = b.ySetter = function (c, b, e) {
                e.setAttribute("c" + b, c);
              };

              return b.attr(c);
            };

            f.prototype.arc = function (c, b, e, a, n, f) {
              L(c) ? (a = c, b = a.y, e = a.r, c = a.x) : a = {
                innerR: a,
                start: n,
                end: f
              };
              c = this.symbol("arc", c, b, e, e, a);
              c.r = e;
              return c;
            };

            f.prototype.rect = function (c, b, e, a, n, f) {
              n = L(c) ? c.r : n;
              var d = this.createElement("rect");
              c = L(c) ? c : "undefined" === typeof c ? {} : {
                x: c,
                y: b,
                width: Math.max(e, 0),
                height: Math.max(a, 0)
              };
              this.styledMode || ("undefined" !== typeof f && (c["stroke-width"] = f, c = d.crisp(c)), c.fill = "none");
              n && (c.r = n);

              d.rSetter = function (c, b, e) {
                d.r = c;
                E(e, {
                  rx: c,
                  ry: c
                });
              };

              d.rGetter = function () {
                return d.r || 0;
              };

              return d.attr(c);
            };

            f.prototype.setSize = function (c, b, e) {
              this.width = c;
              this.height = b;
              this.boxWrapper.animate({
                width: c,
                height: b
              }, {
                step: function step() {
                  this.attr({
                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                  });
                },
                duration: S(e, !0) ? void 0 : 0
              });
              this.alignElements();
            };

            f.prototype.g = function (c) {
              var b = this.createElement("g");
              return c ? b.attr({
                "class": "highcharts-" + c
              }) : b;
            };

            f.prototype.image = function (c, b, e, a, f, d) {
              var q = {
                preserveAspectRatio: "none"
              },
                  m = function m(c, b) {
                c.setAttributeNS ? c.setAttributeNS("http://www.w3.org/1999/xlink", "href", b) : c.setAttribute("hc-svg-href", b);
              };

              1 < arguments.length && n(q, {
                x: b,
                y: e,
                width: a,
                height: f
              });
              var g = this.createElement("image").attr(q);

              q = function q(b) {
                m(g.element, c);
                d.call(g, b);
              };

              if (d) {
                m(g.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
                var k = new x.Image();
                u(k, "load", q);
                k.src = c;
                k.complete && q({});
              } else m(g.element, c);

              return g;
            };

            f.prototype.symbol = function (c, b, a, f, k, u) {
              var C = this,
                  h = /^url\((.*?)\)$/,
                  p = h.test(c),
                  N = !p && (this.symbols[c] ? c : "circle"),
                  K = N && this.symbols[N],
                  M;

              if (K) {
                "number" === typeof b && (M = K.call(this.symbols, Math.round(b || 0), Math.round(a || 0), f || 0, k || 0, u));
                var x = this.path(M);
                C.styledMode || x.attr("fill", "none");
                n(x, {
                  symbolName: N || void 0,
                  x: b,
                  y: a,
                  width: f,
                  height: k
                });
                u && n(x, u);
              } else if (p) {
                var H = c.match(h)[1];
                var F = x = this.image(H);
                F.imgwidth = S(B[H] && B[H].width, u && u.width);
                F.imgheight = S(B[H] && B[H].height, u && u.height);

                var l = function l(c) {
                  return c.attr({
                    width: c.width,
                    height: c.height
                  });
                };

                ["width", "height"].forEach(function (c) {
                  F[c + "Setter"] = function (c, b) {
                    var a = this["img" + b];
                    this[b] = c;
                    e(a) && (u && "within" === u.backgroundSize && this.width && this.height && (a = Math.round(a * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(b, a), this.alignByTranslate || (c = ((this[b] || 0) - a) / 2, this.attr("width" === b ? {
                      translateX: c
                    } : {
                      translateY: c
                    })));
                  };
                });
                e(b) && F.attr({
                  x: b,
                  y: a
                });
                F.isImg = !0;
                e(F.imgwidth) && e(F.imgheight) ? l(F) : (F.attr({
                  width: 0,
                  height: 0
                }), m("img", {
                  onload: function onload() {
                    var c = d[C.chartIndex];
                    0 === this.width && (q(this, {
                      position: "absolute",
                      top: "-999em"
                    }), g.body.appendChild(this));
                    B[H] = {
                      width: this.width,
                      height: this.height
                    };
                    F.imgwidth = this.width;
                    F.imgheight = this.height;
                    F.element && l(F);
                    this.parentNode && this.parentNode.removeChild(this);
                    C.imgCount--;
                    if (!C.imgCount && c && !c.hasLoaded) c.onload();
                  },
                  src: H
                }), this.imgCount++);
              }

              return x;
            };

            f.prototype.clipRect = function (c, b, e, a) {
              var n = T() + "-",
                  f = this.createElement("clipPath").attr({
                id: n
              }).add(this.defs);
              c = this.rect(c, b, e, a, 0).add(f);
              c.id = n;
              c.clipPath = f;
              c.count = 0;
              return c;
            };

            f.prototype.text = function (c, b, a, n) {
              var f = {};
              if (n && (this.allowHTML || !this.forExport)) return this.html(c, b, a);
              f.x = Math.round(b || 0);
              a && (f.y = Math.round(a));
              e(c) && (f.text = c);
              c = this.createElement("text").attr(f);
              if (!n || this.forExport && !this.allowHTML) c.xSetter = function (c, b, e) {
                for (var a = e.getElementsByTagName("tspan"), n = e.getAttribute(b), f = 0, d; f < a.length; f++) {
                  d = a[f], d.getAttribute(b) === n && d.setAttribute(b, c);
                }

                e.setAttribute(b, c);
              };
              return c;
            };

            f.prototype.fontMetrics = function (c, b) {
              c = !this.styledMode && /px/.test(c) || !x.getComputedStyle ? c || b && b.style && b.style.fontSize || this.style && this.style.fontSize : b && w.prototype.getStyle.call(b, "font-size");
              c = /px/.test(c) ? R(c) : 12;
              b = 24 > c ? c + 3 : Math.round(1.2 * c);
              return {
                h: b,
                b: Math.round(.8 * b),
                f: c
              };
            };

            f.prototype.rotCorr = function (c, e, a) {
              var f = c;
              e && a && (f = Math.max(f * Math.cos(e * b), 4));
              return {
                x: -c / 3 * Math.sin(e * b),
                y: f
              };
            };

            f.prototype.pathToSegments = function (c) {
              for (var b = [], e = [], a = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
              }, f = 0; f < c.length; f++) {
                F(e[0]) && H(c[f]) && e.length === a[e[0].toUpperCase()] && c.splice(f, 0, e[0].replace("M", "L").replace("m", "l")), "string" === typeof c[f] && (e.length && b.push(e.slice(0)), e.length = 0), e.push(c[f]);
              }

              b.push(e.slice(0));
              return b;
            };

            f.prototype.label = function (c, b, e, a, f, n, d, q, m) {
              return new D(this, c, b, e, a, f, n, d, q, m);
            };

            f.prototype.alignElements = function () {
              this.alignedObjects.forEach(function (c) {
                return c.align();
              });
            };

            return f;
          }();

          n(A.prototype, {
            Element: w,
            SVG_NS: f,
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            symbols: t,
            draw: G
          });
          z.registerRendererType("svg", A, !0);
          "";
          return A;
        });
        I(a, "Core/Renderer/HTML/HTMLElement.js", [a["Core/Globals.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = this && this.__extends || function () {
            var _b = function b(a, d) {
              _b = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var f in a) {
                  a.hasOwnProperty(f) && (b[f] = a[f]);
                }
              };

              return _b(a, d);
            };

            return function (a, d) {
              function g() {
                this.constructor = a;
              }

              _b(a, d);

              a.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }(),
              z = a.isFirefox,
              w = a.isMS,
              D = a.isWebKit,
              t = a.win,
              l = A.css,
              h = A.defined,
              d = A.extend,
              b = A.pick,
              g = A.pInt;

          return function (a) {
            function k() {
              return null !== a && a.apply(this, arguments) || this;
            }

            r(k, a);

            k.compose = function (b) {
              if (-1 === k.composedClasses.indexOf(b)) {
                k.composedClasses.push(b);
                var a = k.prototype,
                    f = b.prototype;
                f.getSpanCorrection = a.getSpanCorrection;
                f.htmlCss = a.htmlCss;
                f.htmlGetBBox = a.htmlGetBBox;
                f.htmlUpdateTransform = a.htmlUpdateTransform;
                f.setSpanRotation = a.setSpanRotation;
              }

              return b;
            };

            k.prototype.getSpanCorrection = function (b, a, f) {
              this.xCorr = -b * f;
              this.yCorr = -a;
            };

            k.prototype.htmlCss = function (a) {
              var g = "SPAN" === this.element.tagName && a && "width" in a,
                  f = b(g && a.width, void 0);

              if (g) {
                delete a.width;
                this.textWidth = f;
                var k = !0;
              }

              a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
              this.styles = d(this.styles, a);
              l(this.element, a);
              k && this.htmlUpdateTransform();
              return this;
            };

            k.prototype.htmlGetBBox = function () {
              var b = this.element;
              return {
                x: b.offsetLeft,
                y: b.offsetTop,
                width: b.offsetWidth,
                height: b.offsetHeight
              };
            };

            k.prototype.htmlUpdateTransform = function () {
              if (this.added) {
                var b = this.renderer,
                    a = this.element,
                    f = this.translateX || 0,
                    d = this.translateY || 0,
                    k = this.x || 0,
                    u = this.y || 0,
                    p = this.textAlign || "left",
                    m = {
                  left: 0,
                  center: .5,
                  right: 1
                }[p],
                    q = this.styles;
                q = q && q.whiteSpace;
                l(a, {
                  marginLeft: f,
                  marginTop: d
                });
                !b.styledMode && this.shadows && this.shadows.forEach(function (c) {
                  l(c, {
                    marginLeft: f + 1,
                    marginTop: d + 1
                  });
                });
                this.inverted && [].forEach.call(a.childNodes, function (c) {
                  b.invertChild(c, a);
                });

                if ("SPAN" === a.tagName) {
                  var e = this.rotation,
                      c = this.textWidth && g(this.textWidth),
                      n = [e, p, a.innerHTML, this.textWidth, this.textAlign].join(),
                      C = void 0;
                  (C = c !== this.oldTextWidth) && !(C = c > this.oldTextWidth) && ((C = this.textPxLength) || (l(a, {
                    width: "",
                    whiteSpace: q || "nowrap"
                  }), C = a.offsetWidth), C = C > c);
                  C && (/[ \-]/.test(a.textContent || a.innerText) || "ellipsis" === a.style.textOverflow) ? (l(a, {
                    width: c + "px",
                    display: "block",
                    whiteSpace: q || "normal"
                  }), this.oldTextWidth = c, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
                  n !== this.cTT && (C = b.fontMetrics(a.style.fontSize, a).b, !h(e) || e === (this.oldRotation || 0) && p === this.oldAlign || this.setSpanRotation(e, m, C), this.getSpanCorrection(!h(e) && this.textPxLength || a.offsetWidth, C, m, e, p));
                  l(a, {
                    left: k + (this.xCorr || 0) + "px",
                    top: u + (this.yCorr || 0) + "px"
                  });
                  this.cTT = n;
                  this.oldRotation = e;
                  this.oldAlign = p;
                }
              } else this.alignOnAdd = !0;
            };

            k.prototype.setSpanRotation = function (b, a, f) {
              var d = {},
                  g = w && !/Edge/.test(t.navigator.userAgent) ? "-ms-transform" : D ? "-webkit-transform" : z ? "MozTransform" : t.opera ? "-o-transform" : void 0;
              g && (d[g] = d.transform = "rotate(" + b + "deg)", d[g + (z ? "Origin" : "-origin")] = d.transformOrigin = 100 * a + "% " + f + "px", l(this.element, d));
            };

            k.composedClasses = [];
            return k;
          }(v);
        });
        I(a, "Core/Renderer/HTML/HTMLRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = this && this.__extends || function () {
            var _a27 = function a(d, b) {
              _a27 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _a27(d, b);
            };

            return function (d, b) {
              function g() {
                this.constructor = d;
              }

              _a27(d, b);

              d.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());
            };
          }(),
              w = y.attr,
              D = y.createElement,
              t = y.extend,
              l = y.pick;

          return function (h) {
            function d() {
              return null !== h && h.apply(this, arguments) || this;
            }

            r(d, h);

            d.compose = function (b) {
              -1 === d.composedClasses.indexOf(b) && (d.composedClasses.push(b), b.prototype.html = d.prototype.html);
              return b;
            };

            d.prototype.html = function (b, d, h) {
              var g = this.createElement("span"),
                  p = g.element,
                  G = g.renderer,
                  f = G.isSVG,
                  B = function B(b, a) {
                ["opacity", "visibility"].forEach(function (f) {
                  b[f + "Setter"] = function (d, q, e) {
                    var c = b.div ? b.div.style : a;
                    v.prototype[f + "Setter"].call(this, d, q, e);
                    c && (c[q] = d);
                  };
                });
                b.addedSetters = !0;
              };

              g.textSetter = function (b) {
                b !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, l(b, "")), this.textStr = b, g.doTransform = !0);
              };

              f && B(g, g.element.style);

              g.xSetter = g.ySetter = g.alignSetter = g.rotationSetter = function (b, a) {
                "align" === a ? g.alignValue = g.textAlign = b : g[a] = b;
                g.doTransform = !0;
              };

              g.afterSetters = function () {
                this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
              };

              g.attr({
                text: b,
                x: Math.round(d),
                y: Math.round(h)
              }).css({
                position: "absolute"
              });
              G.styledMode || g.css({
                fontFamily: this.style.fontFamily,
                fontSize: this.style.fontSize
              });
              p.style.whiteSpace = "nowrap";
              g.css = g.htmlCss;
              f && (g.add = function (b) {
                var a = G.box.parentNode,
                    f = [];

                if (this.parentGroup = b) {
                  var d = b.div;

                  if (!d) {
                    for (; b;) {
                      f.push(b), b = b.parentGroup;
                    }

                    f.reverse().forEach(function (b) {
                      function e(c, e) {
                        b[e] = c;
                        "translateX" === e ? q.left = c + "px" : q.top = c + "px";
                        b.doTransform = !0;
                      }

                      var c = w(b.element, "class"),
                          n = b.styles || {};
                      d = b.div = b.div || D("div", c ? {
                        className: c
                      } : void 0, {
                        position: "absolute",
                        left: (b.translateX || 0) + "px",
                        top: (b.translateY || 0) + "px",
                        display: b.display,
                        opacity: b.opacity,
                        cursor: n.cursor,
                        pointerEvents: n.pointerEvents,
                        visibility: b.visibility
                      }, d || a);
                      var q = d.style;
                      t(b, {
                        classSetter: function (c) {
                          return function (b) {
                            this.element.setAttribute("class", b);
                            c.className = b;
                          };
                        }(d),
                        on: function on() {
                          f[0].div && g.on.apply({
                            element: f[0].div,
                            onEvents: b.onEvents
                          }, arguments);
                          return b;
                        },
                        translateXSetter: e,
                        translateYSetter: e
                      });
                      b.addedSetters || B(b);
                    });
                  }
                } else d = a;

                d.appendChild(p);
                g.added = !0;
                g.alignOnAdd && g.htmlUpdateTransform();
                return g;
              });
              return g;
            };

            d.composedClasses = [];
            return d;
          }(A);
        });
        I(a, "Core/Axis/AxisDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          var r;

          (function (r) {
            r.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: !1
                },
                second: {
                  main: "%H:%M:%S",
                  range: !1
                },
                minute: {
                  main: "%H:%M",
                  range: !1
                },
                hour: {
                  main: "%H:%M",
                  range: !1
                },
                day: {
                  main: "%e. %b"
                },
                week: {
                  main: "%e. %b"
                },
                month: {
                  main: "%b '%y"
                },
                year: {
                  main: "%Y"
                }
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: void 0,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                x: 0,
                zIndex: 7,
                style: {
                  color: a.neutralColor60,
                  cursor: "default",
                  fontSize: "11px"
                }
              },
              maxPadding: .01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minPadding: .01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                  color: a.neutralColor60
                }
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: a.neutralColor5,
              minorGridLineWidth: 1,
              minorTickColor: a.neutralColor40,
              lineColor: a.highlightColor20,
              lineWidth: 1,
              gridLineColor: a.neutralColor10,
              gridLineWidth: void 0,
              tickColor: a.highlightColor20
            };
            r.defaultYAxisOptions = {
              reversedStacks: !0,
              endOnTick: !0,
              maxPadding: .05,
              minPadding: .05,
              tickPixelInterval: 72,
              showLastLabel: !0,
              labels: {
                x: -8
              },
              startOnTick: !0,
              title: {
                rotation: 270,
                text: "Values"
              },
              stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function formatter() {
                  var a = this.axis.chart.numberFormatter;
                  return a(this.total, -1);
                },
                style: {
                  color: a.neutralColor100,
                  fontSize: "11px",
                  fontWeight: "bold",
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
            };
            r.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            r.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            r.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            r.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(r || (r = {}));

          return r;
        });
        I(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.addEvent,
              A = a.isFunction,
              y = a.objectEach,
              z = a.removeEvent;
          return {
            registerEventOptions: function registerEventOptions(a, D) {
              a.eventOptions = a.eventOptions || {};
              y(D.events, function (t, l) {
                a.eventOptions[l] !== t && (a.eventOptions[l] && (z(a, l, a.eventOptions[l]), delete a.eventOptions[l]), A(t) && (a.eventOptions[l] = t, r(a, l, t)));
              });
            }
          };
        });
        I(a, "Core/Axis/Tick.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = v.deg2rad,
              z = A.clamp,
              w = A.correctFloat,
              D = A.defined,
              t = A.destroyObjectProperties,
              l = A.extend,
              h = A.fireEvent,
              d = A.isNumber,
              b = A.merge,
              g = A.objectEach,
              p = A.pick;

          v = function () {
            function k(b, a, f, d, g) {
              this.isNewLabel = this.isNew = !0;
              this.axis = b;
              this.pos = a;
              this.type = f || "";
              this.parameters = g || {};
              this.tickmarkOffset = this.parameters.tickmarkOffset;
              this.options = this.parameters.options;
              h(this, "init");
              f || d || this.addLabel();
            }

            k.prototype.addLabel = function () {
              var b = this,
                  g = b.axis,
                  f = g.options,
                  k = g.chart,
                  x = g.categories,
                  u = g.logarithmic,
                  E = g.names,
                  m = b.pos,
                  q = p(b.options && b.options.labels, f.labels),
                  e = g.tickPositions,
                  c = m === e[0],
                  n = m === e[e.length - 1],
                  C = (!q.step || 1 === q.step) && 1 === g.tickInterval;
              e = e.info;
              var H = b.label,
                  L;
              x = this.parameters.category || (x ? p(x[m], E[m], m) : m);
              u && d(x) && (x = w(u.lin2log(x)));
              if (g.dateTime) if (e) {
                var F = k.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && e.higherRanks[m] || e.unitName]);
                var r = F.main;
              } else d(x) && (r = g.dateTime.getXDateFormat(x, f.dateTimeLabelFormats || {}));
              b.isFirst = c;
              b.isLast = n;
              var t = {
                axis: g,
                chart: k,
                dateTimeLabelFormat: r,
                isFirst: c,
                isLast: n,
                pos: m,
                tick: b,
                tickPositionInfo: e,
                value: x
              };
              h(this, "labelFormat", t);

              var v = function v(c) {
                return q.formatter ? q.formatter.call(c, c) : q.format ? (c.text = g.defaultLabelFormatter.call(c), a.format(q.format, c, k)) : g.defaultLabelFormatter.call(c, c);
              };

              f = v.call(t, t);
              var y = F && F.list;
              b.shortenLabel = y ? function () {
                for (L = 0; L < y.length; L++) {
                  if (l(t, {
                    dateTimeLabelFormat: y[L]
                  }), H.attr({
                    text: v.call(t, t)
                  }), H.getBBox().width < g.getSlotWidth(b) - 2 * q.padding) return;
                }

                H.attr({
                  text: ""
                });
              } : void 0;
              C && g._addedPlotLB && b.moveLabel(f, q);
              D(H) || b.movedLabel ? H && H.textStr !== f && !C && (!H.textWidth || q.style.width || H.styles.width || H.css({
                width: null
              }), H.attr({
                text: f
              }), H.textPxLength = H.getBBox().width) : (b.label = H = b.createLabel({
                x: 0,
                y: 0
              }, f, q), b.rotation = 0);
            };

            k.prototype.createLabel = function (a, d, f) {
              var g = this.axis,
                  k = g.chart;
              if (a = D(d) && f.enabled ? k.renderer.text(d, a.x, a.y, f.useHTML).add(g.labelGroup) : null) k.styledMode || a.css(b(f.style)), a.textPxLength = a.getBBox().width;
              return a;
            };

            k.prototype.destroy = function () {
              t(this, this.axis);
            };

            k.prototype.getPosition = function (b, a, f, d) {
              var g = this.axis,
                  k = g.chart,
                  p = d && k.oldChartHeight || k.chartHeight;
              b = {
                x: b ? w(g.translate(a + f, null, null, d) + g.transB) : g.left + g.offset + (g.opposite ? (d && k.oldChartWidth || k.chartWidth) - g.right - g.left : 0),
                y: b ? p - g.bottom + g.offset - (g.opposite ? g.height : 0) : w(p - g.translate(a + f, null, null, d) - g.transB)
              };
              b.y = z(b.y, -1E5, 1E5);
              h(this, "afterGetPosition", {
                pos: b
              });
              return b;
            };

            k.prototype.getLabelPosition = function (b, a, f, d, g, k, p, m) {
              var q = this.axis,
                  e = q.transA,
                  c = q.isLinked && q.linkedParent ? q.linkedParent.reversed : q.reversed,
                  n = q.staggerLines,
                  C = q.tickRotCorr || {
                x: 0,
                y: 0
              },
                  u = d || q.reserveSpaceDefault ? 0 : -q.labelOffset * ("center" === q.labelAlign ? .5 : 1),
                  B = {},
                  F = g.y;
              D(F) || (F = 0 === q.side ? f.rotation ? -8 : -f.getBBox().height : 2 === q.side ? C.y + 8 : Math.cos(f.rotation * r) * (C.y - f.getBBox(!1, 0).height / 2));
              b = b + g.x + u + C.x - (k && d ? k * e * (c ? -1 : 1) : 0);
              a = a + F - (k && !d ? k * e * (c ? 1 : -1) : 0);
              n && (f = p / (m || 1) % n, q.opposite && (f = n - f - 1), a += q.labelOffset / n * f);
              B.x = b;
              B.y = Math.round(a);
              h(this, "afterGetLabelPosition", {
                pos: B,
                tickmarkOffset: k,
                index: p
              });
              return B;
            };

            k.prototype.getLabelSize = function () {
              return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            };

            k.prototype.getMarkPath = function (b, a, f, d, g, k) {
              return k.crispLine([["M", b, a], ["L", b + (g ? 0 : -f), a + (g ? f : 0)]], d);
            };

            k.prototype.handleOverflow = function (b) {
              var a = this.axis,
                  f = a.options.labels,
                  d = b.x,
                  g = a.chart.chartWidth,
                  k = a.chart.spacing,
                  h = p(a.labelLeft, Math.min(a.pos, k[3]));
              k = p(a.labelRight, Math.max(a.isRadial ? 0 : a.pos + a.len, g - k[1]));
              var m = this.label,
                  q = this.rotation,
                  e = {
                left: 0,
                center: .5,
                right: 1
              }[a.labelAlign || m.attr("align")],
                  c = m.getBBox().width,
                  n = a.getSlotWidth(this),
                  C = {},
                  H = n,
                  l = 1,
                  F;
              if (q || "justify" !== f.overflow) 0 > q && d - e * c < h ? F = Math.round(d / Math.cos(q * r) - h) : 0 < q && d + e * c > k && (F = Math.round((g - d) / Math.cos(q * r)));else if (g = d + (1 - e) * c, d - e * c < h ? H = b.x + H * (1 - e) - h : g > k && (H = k - b.x + H * e, l = -1), H = Math.min(n, H), H < n && "center" === a.labelAlign && (b.x += l * (n - H - e * (n - Math.min(c, H)))), c > H || a.autoRotation && (m.styles || {}).width) F = H;
              F && (this.shortenLabel ? this.shortenLabel() : (C.width = Math.floor(F) + "px", (f.style || {}).textOverflow || (C.textOverflow = "ellipsis"), m.css(C)));
            };

            k.prototype.moveLabel = function (b, a) {
              var f = this,
                  d = f.label,
                  k = f.axis,
                  h = k.reversed,
                  p = !1;
              d && d.textStr === b ? (f.movedLabel = d, p = !0, delete f.label) : g(k.ticks, function (a) {
                p || a.isNew || a === f || !a.label || a.label.textStr !== b || (f.movedLabel = a.label, p = !0, a.labelPos = f.movedLabel.xy, delete a.label);
              });

              if (!p && (f.labelPos || d)) {
                var m = f.labelPos || d.xy;
                d = k.horiz ? h ? 0 : k.width + k.left : m.x;
                k = k.horiz ? m.y : h ? k.width + k.left : 0;
                f.movedLabel = f.createLabel({
                  x: d,
                  y: k
                }, b, a);
                f.movedLabel && f.movedLabel.attr({
                  opacity: 0
                });
              }
            };

            k.prototype.render = function (b, a, f) {
              var d = this.axis,
                  g = d.horiz,
                  k = this.pos,
                  l = p(this.tickmarkOffset, d.tickmarkOffset);
              k = this.getPosition(g, k, l, a);
              l = k.x;
              var m = k.y;
              d = g && l === d.pos + d.len || !g && m === d.pos ? -1 : 1;
              g = p(f, this.label && this.label.newOpacity, 1);
              f = p(f, 1);
              this.isActive = !0;
              this.renderGridLine(a, f, d);
              this.renderMark(k, f, d);
              this.renderLabel(k, a, g, b);
              this.isNew = !1;
              h(this, "afterRender");
            };

            k.prototype.renderGridLine = function (b, a, f) {
              var d = this.axis,
                  g = d.options,
                  k = {},
                  h = this.pos,
                  m = this.type,
                  q = p(this.tickmarkOffset, d.tickmarkOffset),
                  e = d.chart.renderer,
                  c = this.gridLine,
                  n = g.gridLineWidth,
                  C = g.gridLineColor,
                  H = g.gridLineDashStyle;
              "minor" === this.type && (n = g.minorGridLineWidth, C = g.minorGridLineColor, H = g.minorGridLineDashStyle);
              c || (d.chart.styledMode || (k.stroke = C, k["stroke-width"] = n || 0, k.dashstyle = H), m || (k.zIndex = 1), b && (a = 0), this.gridLine = c = e.path().attr(k).addClass("highcharts-" + (m ? m + "-" : "") + "grid-line").add(d.gridGroup));
              if (c && (f = d.getPlotLinePath({
                value: h + q,
                lineWidth: c.strokeWidth() * f,
                force: "pass",
                old: b
              }))) c[b || this.isNew ? "attr" : "animate"]({
                d: f,
                opacity: a
              });
            };

            k.prototype.renderMark = function (b, a, f) {
              var d = this.axis,
                  g = d.options,
                  k = d.chart.renderer,
                  h = this.type,
                  m = d.tickSize(h ? h + "Tick" : "tick"),
                  q = b.x;
              b = b.y;
              var e = p(g["minor" !== h ? "tickWidth" : "minorTickWidth"], !h && d.isXAxis ? 1 : 0);
              g = g["minor" !== h ? "tickColor" : "minorTickColor"];
              var c = this.mark,
                  n = !c;
              m && (d.opposite && (m[0] = -m[0]), c || (this.mark = c = k.path().addClass("highcharts-" + (h ? h + "-" : "") + "tick").add(d.axisGroup), d.chart.styledMode || c.attr({
                stroke: g,
                "stroke-width": e
              })), c[n ? "attr" : "animate"]({
                d: this.getMarkPath(q, b, m[0], c.strokeWidth() * f, d.horiz, k),
                opacity: a
              }));
            };

            k.prototype.renderLabel = function (b, a, f, g) {
              var k = this.axis,
                  h = k.horiz,
                  l = k.options,
                  m = this.label,
                  q = l.labels,
                  e = q.step;
              k = p(this.tickmarkOffset, k.tickmarkOffset);
              var c = b.x;
              b = b.y;
              var n = !0;
              m && d(c) && (m.xy = b = this.getLabelPosition(c, b, m, h, q, k, g, e), this.isFirst && !this.isLast && !l.showFirstLabel || this.isLast && !this.isFirst && !l.showLastLabel ? n = !1 : !h || q.step || q.rotation || a || 0 === f || this.handleOverflow(b), e && g % e && (n = !1), n && d(b.y) ? (b.opacity = f, m[this.isNewLabel ? "attr" : "animate"](b), this.isNewLabel = !1) : (m.attr("y", -9999), this.isNewLabel = !0));
            };

            k.prototype.replaceMovedLabel = function () {
              var b = this.label,
                  a = this.axis,
                  f = a.reversed;

              if (b && !this.isNew) {
                var d = a.horiz ? f ? a.left : a.width + a.left : b.xy.x;
                f = a.horiz ? b.xy.y : f ? a.width + a.top : a.top;
                b.animate({
                  x: d,
                  y: f,
                  opacity: 0
                }, void 0, b.destroy);
                delete this.label;
              }

              a.isDirty = !0;
              this.label = this.movedLabel;
              delete this.movedLabel;
            };

            return k;
          }();

          "";
          return v;
        });
        I(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/Color/Palette.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t, l) {
          var h = a.animObject,
              d = z.defaultOptions,
              b = w.registerEventOptions,
              g = D.deg2rad,
              p = l.arrayMax,
              k = l.arrayMin,
              r = l.clamp,
              G = l.correctFloat,
              f = l.defined,
              B = l.destroyObjectProperties,
              x = l.erase,
              u = l.error,
              E = l.extend,
              m = l.fireEvent,
              q = l.getMagnitude,
              e = l.isArray,
              c = l.isNumber,
              n = l.isString,
              C = l.merge,
              H = l.normalizeTickInterval,
              L = l.objectEach,
              F = l.pick,
              W = l.relativeLength,
              S = l.removeEvent,
              R = l.splat,
              T = l.syncTimeout;

          a = function () {
            function a(c, b) {
              this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
              this.init(c, b);
            }

            a.prototype.init = function (a, e) {
              var d = e.isX;
              this.chart = a;
              this.horiz = a.inverted && !this.isZAxis ? !d : d;
              this.isXAxis = d;
              this.coll = this.coll || (d ? "xAxis" : "yAxis");
              m(this, "init", {
                userOptions: e
              });
              this.opposite = F(e.opposite, this.opposite);
              this.side = F(e.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
              this.setOptions(e);
              var n = this.options,
                  g = n.labels,
                  q = n.type;
              this.userOptions = e;
              this.minPixelPadding = 0;
              this.reversed = F(n.reversed, this.reversed);
              this.visible = n.visible;
              this.zoomEnabled = n.zoomEnabled;
              this.hasNames = "category" === q || !0 === n.categories;
              this.categories = n.categories || this.hasNames;
              this.names || (this.names = [], this.names.keys = {});
              this.plotLinesAndBandsGroups = {};
              this.positiveValuesOnly = !!this.logarithmic;
              this.isLinked = f(n.linkedTo);
              this.ticks = {};
              this.labelEdge = [];
              this.minorTicks = {};
              this.plotLinesAndBands = [];
              this.alternateBands = {};
              this.len = 0;
              this.minRange = this.userMinRange = n.minRange || n.maxZoom;
              this.range = n.range;
              this.offset = n.offset || 0;
              this.min = this.max = null;
              e = F(n.crosshair, R(a.options.tooltip.crosshairs)[d ? 0 : 1]);
              this.crosshair = !0 === e ? {} : e;
              -1 === a.axes.indexOf(this) && (d ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));
              this.series = this.series || [];
              a.inverted && !this.isZAxis && d && "undefined" === typeof this.reversed && (this.reversed = !0);
              this.labelRotation = c(g.rotation) ? g.rotation : void 0;
              b(this, n);
              m(this, "afterInit");
            };

            a.prototype.setOptions = function (c) {
              this.options = C(v.defaultXAxisOptions, "yAxis" === this.coll && v.defaultYAxisOptions, [v.defaultTopAxisOptions, v.defaultRightAxisOptions, v.defaultBottomAxisOptions, v.defaultLeftAxisOptions][this.side], C(d[this.coll], c));
              m(this, "afterSetOptions", {
                userOptions: c
              });
            };

            a.prototype.defaultLabelFormatter = function (b) {
              var a = this.axis;
              b = this.chart.numberFormatter;
              var e = c(this.value) ? this.value : NaN,
                  f = a.chart.time,
                  n = this.dateTimeLabelFormat,
                  g = d.lang,
                  m = g.numericSymbols;
              g = g.numericSymbolMagnitude || 1E3;
              var q = a.logarithmic ? Math.abs(e) : a.tickInterval,
                  k = m && m.length;
              if (a.categories) var h = "" + this.value;else if (n) h = f.dateFormat(n, e);else if (k && 1E3 <= q) for (; k-- && "undefined" === typeof h;) {
                a = Math.pow(g, k + 1), q >= a && 0 === 10 * e % a && null !== m[k] && 0 !== e && (h = b(e / a, -1) + m[k]);
              }
              "undefined" === typeof h && (h = 1E4 <= Math.abs(e) ? b(e, -1) : b(e, -1, void 0, ""));
              return h;
            };

            a.prototype.getSeriesExtremes = function () {
              var b = this,
                  a = b.chart,
                  e;
              m(this, "getSeriesExtremes", null, function () {
                b.hasVisibleSeries = !1;
                b.dataMin = b.dataMax = b.threshold = null;
                b.softThreshold = !b.isXAxis;
                b.stacking && b.stacking.buildStacks();
                b.series.forEach(function (n) {
                  if (n.visible || !a.options.chart.ignoreHiddenSeries) {
                    var d = n.options,
                        g = d.threshold;
                    b.hasVisibleSeries = !0;
                    b.positiveValuesOnly && 0 >= g && (g = null);

                    if (b.isXAxis) {
                      if (d = n.xData, d.length) {
                        d = b.logarithmic ? d.filter(b.validatePositiveValue) : d;
                        e = n.getXExtremes(d);
                        var m = e.min;
                        var q = e.max;
                        c(m) || m instanceof Date || (d = d.filter(c), e = n.getXExtremes(d), m = e.min, q = e.max);
                        d.length && (b.dataMin = Math.min(F(b.dataMin, m), m), b.dataMax = Math.max(F(b.dataMax, q), q));
                      }
                    } else if (n = n.applyExtremes(), c(n.dataMin) && (m = n.dataMin, b.dataMin = Math.min(F(b.dataMin, m), m)), c(n.dataMax) && (q = n.dataMax, b.dataMax = Math.max(F(b.dataMax, q), q)), f(g) && (b.threshold = g), !d.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;
                  }
                });
              });
              m(this, "afterGetSeriesExtremes");
            };

            a.prototype.translate = function (b, a, e, n, d, f) {
              var g = this.linkedParent || this,
                  m = n && g.old ? g.old.min : g.min,
                  q = g.minPixelPadding;
              d = (g.isOrdinal || g.brokenAxis && g.brokenAxis.hasBreaks || g.logarithmic && d) && g.lin2val;
              var k = 1,
                  h = 0;
              n = n && g.old ? g.old.transA : g.transA;
              n || (n = g.transA);
              e && (k *= -1, h = g.len);
              g.reversed && (k *= -1, h -= k * (g.sector || g.len));
              a ? (b = (b * k + h - q) / n + m, d && (b = g.lin2val(b))) : (d && (b = g.val2lin(b)), b = c(m) ? k * (b - m) * n + h + k * q + (c(f) ? n * f : 0) : void 0);
              return b;
            };

            a.prototype.toPixels = function (c, b) {
              return this.translate(c, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
            };

            a.prototype.toValue = function (c, b) {
              return this.translate(c - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
            };

            a.prototype.getPlotLinePath = function (b) {
              function a(c, b, a) {
                if ("pass" !== N && c < b || c > a) N ? c = r(c, b, a) : E = !0;
                return c;
              }

              var e = this,
                  n = e.chart,
                  d = e.left,
                  f = e.top,
                  g = b.old,
                  q = b.value,
                  k = b.lineWidth,
                  h = g && n.oldChartHeight || n.chartHeight,
                  p = g && n.oldChartWidth || n.chartWidth,
                  C = e.transB,
                  u = b.translatedValue,
                  N = b.force,
                  H,
                  l,
                  B,
                  x,
                  E;
              b = {
                value: q,
                lineWidth: k,
                old: g,
                force: N,
                acrossPanes: b.acrossPanes,
                translatedValue: u
              };
              m(this, "getPlotLinePath", b, function (b) {
                u = F(u, e.translate(q, null, null, g));
                u = r(u, -1E5, 1E5);
                H = B = Math.round(u + C);
                l = x = Math.round(h - u - C);
                c(u) ? e.horiz ? (l = f, x = h - e.bottom, H = B = a(H, d, d + e.width)) : (H = d, B = p - e.right, l = x = a(l, f, f + e.height)) : (E = !0, N = !1);
                b.path = E && !N ? null : n.renderer.crispLine([["M", H, l], ["L", B, x]], k || 1);
              });
              return b.path;
            };

            a.prototype.getLinearTickPositions = function (c, b, a) {
              var e = G(Math.floor(b / c) * c);
              a = G(Math.ceil(a / c) * c);
              var n = [],
                  d;
              G(e + c) === e && (d = 20);
              if (this.single) return [b];

              for (b = e; b <= a;) {
                n.push(b);
                b = G(b + c, d);
                if (b === f) break;
                var f = b;
              }

              return n;
            };

            a.prototype.getMinorTickInterval = function () {
              var c = this.options;
              return !0 === c.minorTicks ? F(c.minorTickInterval, "auto") : !1 === c.minorTicks ? null : c.minorTickInterval;
            };

            a.prototype.getMinorTickPositions = function () {
              var c = this.options,
                  b = this.tickPositions,
                  a = this.minorTickInterval,
                  e = this.pointRangePadding || 0,
                  n = this.min - e;
              e = this.max + e;
              var d = e - n,
                  f = [];

              if (d && d / a < this.len / 3) {
                var g = this.logarithmic;
                if (g) this.paddedTicks.forEach(function (c, b, e) {
                  b && f.push.apply(f, g.getLogTickPositions(a, e[b - 1], e[b], !0));
                });else if (this.dateTime && "auto" === this.getMinorTickInterval()) f = f.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(a), n, e, c.startOfWeek));else for (c = n + (b[0] - n) % a; c <= e && c !== f[0]; c += a) {
                  f.push(c);
                }
              }

              0 !== f.length && this.trimTicks(f);
              return f;
            };

            a.prototype.adjustForMinRange = function () {
              var c = this.options,
                  b = this.logarithmic,
                  a = this.min,
                  e = this.max,
                  n = 0,
                  d,
                  g,
                  m,
                  q;
              this.isXAxis && "undefined" === typeof this.minRange && !b && (f(c.min) || f(c.max) ? this.minRange = null : (this.series.forEach(function (c) {
                m = c.xData;
                q = c.xIncrement ? 1 : m.length - 1;
                if (1 < m.length) for (d = q; 0 < d; d--) {
                  if (g = m[d] - m[d - 1], !n || g < n) n = g;
                }
              }), this.minRange = Math.min(5 * n, this.dataMax - this.dataMin)));

              if (e - a < this.minRange) {
                var h = this.dataMax - this.dataMin >= this.minRange;
                var C = this.minRange;
                var u = (C - e + a) / 2;
                u = [a - u, F(c.min, a - u)];
                h && (u[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
                a = p(u);
                e = [a + C, F(c.max, a + C)];
                h && (e[2] = b ? b.log2lin(this.dataMax) : this.dataMax);
                e = k(e);
                e - a < C && (u[0] = e - C, u[1] = F(c.min, e - C), a = p(u));
              }

              this.min = a;
              this.max = e;
            };

            a.prototype.getClosest = function () {
              var c;
              this.categories ? c = 1 : this.series.forEach(function (b) {
                var a = b.closestPointRange,
                    e = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
                !b.noSharedTooltip && f(a) && e && (c = f(c) ? Math.min(c, a) : a);
              });
              return c;
            };

            a.prototype.nameToX = function (c) {
              var b = e(this.categories),
                  a = b ? this.categories : this.names,
                  n = c.options.x;
              c.series.requireSorting = !1;
              f(n) || (n = this.options.uniqueNames ? b ? a.indexOf(c.name) : F(a.keys[c.name], -1) : c.series.autoIncrement());

              if (-1 === n) {
                if (!b) var d = a.length;
              } else d = n;

              "undefined" !== typeof d && (this.names[d] = c.name, this.names.keys[c.name] = d);
              return d;
            };

            a.prototype.updateNames = function () {
              var c = this,
                  b = this.names;
              0 < b.length && (Object.keys(b.keys).forEach(function (c) {
                delete b.keys[c];
              }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {
                b.xIncrement = null;
                if (!b.points || b.isDirtyData) c.max = Math.max(c.max, b.xData.length - 1), b.processData(), b.generatePoints();
                b.data.forEach(function (a, e) {
                  if (a && a.options && "undefined" !== typeof a.name) {
                    var n = c.nameToX(a);
                    "undefined" !== typeof n && n !== a.x && (a.x = n, b.xData[e] = n);
                  }
                });
              }));
            };

            a.prototype.setAxisTranslation = function () {
              var c = this,
                  b = c.max - c.min,
                  a = c.linkedParent,
                  e = !!c.categories,
                  d = c.isXAxis,
                  f = c.axisPointRange || 0,
                  g = 0,
                  q = 0,
                  k = c.transA;

              if (d || e || f) {
                var h = c.getClosest();
                a ? (g = a.minPointOffset, q = a.pointRangePadding) : c.series.forEach(function (b) {
                  var a = e ? 1 : d ? F(b.options.pointRange, h, 0) : c.axisPointRange || 0,
                      m = b.options.pointPlacement;
                  f = Math.max(f, a);
                  if (!c.single || e) b = b.is("xrange") ? !d : d, g = Math.max(g, b && n(m) ? 0 : a / 2), q = Math.max(q, b && "on" === m ? 0 : a);
                });
                a = c.ordinal && c.ordinal.slope && h ? c.ordinal.slope / h : 1;
                c.minPointOffset = g *= a;
                c.pointRangePadding = q *= a;
                c.pointRange = Math.min(f, c.single && e ? 1 : b);
                d && (c.closestPointRange = h);
              }

              c.translationSlope = c.transA = k = c.staticScale || c.len / (b + q || 1);
              c.transB = c.horiz ? c.left : c.bottom;
              c.minPixelPadding = k * g;
              m(this, "afterSetAxisTranslation");
            };

            a.prototype.minFromRange = function () {
              return this.max - this.range;
            };

            a.prototype.setTickInterval = function (b) {
              var a = this,
                  e = a.chart,
                  n = a.logarithmic,
                  d = a.options,
                  g = a.isXAxis,
                  k = a.isLinked,
                  h = d.tickPixelInterval,
                  C = a.categories,
                  p = a.softThreshold,
                  l = d.maxPadding,
                  B = d.minPadding,
                  N = d.tickInterval,
                  x = c(a.threshold) ? a.threshold : null;
              a.dateTime || C || k || this.getTickAmount();
              var E = F(a.userMin, d.min);
              var L = F(a.userMax, d.max);

              if (k) {
                a.linkedParent = e[a.coll][d.linkedTo];
                var r = a.linkedParent.getExtremes();
                a.min = F(r.min, r.dataMin);
                a.max = F(r.max, r.dataMax);
                d.type !== a.linkedParent.options.type && u(11, 1, e);
              } else {
                if (p && f(x)) if (a.dataMin >= x) r = x, B = 0;else if (a.dataMax <= x) {
                  var t = x;
                  l = 0;
                }
                a.min = F(E, r, a.dataMin);
                a.max = F(L, t, a.dataMax);
              }

              n && (a.positiveValuesOnly && !b && 0 >= Math.min(a.min, F(a.dataMin, a.min)) && u(10, 1, e), a.min = G(n.log2lin(a.min), 16), a.max = G(n.log2lin(a.max), 16));
              a.range && f(a.max) && (a.userMin = a.min = E = Math.max(a.dataMin, a.minFromRange()), a.userMax = L = a.max, a.range = null);
              m(a, "foundExtremes");
              a.beforePadding && a.beforePadding();
              a.adjustForMinRange();
              !(C || a.axisPointRange || a.stacking && a.stacking.usePercentage || k) && f(a.min) && f(a.max) && (e = a.max - a.min) && (!f(E) && B && (a.min -= e * B), !f(L) && l && (a.max += e * l));
              c(a.userMin) || (c(d.softMin) && d.softMin < a.min && (a.min = E = d.softMin), c(d.floor) && (a.min = Math.max(a.min, d.floor)));
              c(a.userMax) || (c(d.softMax) && d.softMax > a.max && (a.max = L = d.softMax), c(d.ceiling) && (a.max = Math.min(a.max, d.ceiling)));
              p && f(a.dataMin) && (x = x || 0, !f(E) && a.min < x && a.dataMin >= x ? a.min = a.options.minRange ? Math.min(x, a.max - a.minRange) : x : !f(L) && a.max > x && a.dataMax <= x && (a.max = a.options.minRange ? Math.max(x, a.min + a.minRange) : x));
              c(a.min) && c(a.max) && !this.chart.polar && a.min > a.max && (f(a.options.min) ? a.max = a.min : f(a.options.max) && (a.min = a.max));
              a.tickInterval = a.min === a.max || "undefined" === typeof a.min || "undefined" === typeof a.max ? 1 : k && a.linkedParent && !N && h === a.linkedParent.options.tickPixelInterval ? N = a.linkedParent.tickInterval : F(N, this.tickAmount ? (a.max - a.min) / Math.max(this.tickAmount - 1, 1) : void 0, C ? 1 : (a.max - a.min) * h / Math.max(a.len, h));
              g && !b && (a.series.forEach(function (c) {
                c.forceCrop = c.forceCropping && c.forceCropping();
                c.processData(a.min !== (a.old && a.old.min) || a.max !== (a.old && a.old.max));
              }), m(this, "postProcessData"));
              a.setAxisTranslation();
              m(this, "initialAxisTranslation");
              a.pointRange && !N && (a.tickInterval = Math.max(a.pointRange, a.tickInterval));
              b = F(d.minTickInterval, a.dateTime && !a.series.some(function (c) {
                return c.noSharedTooltip;
              }) ? a.closestPointRange : 0);
              !N && a.tickInterval < b && (a.tickInterval = b);
              a.dateTime || a.logarithmic || N || (a.tickInterval = H(a.tickInterval, void 0, q(a.tickInterval), F(d.allowDecimals, .5 > a.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
              this.tickAmount || (a.tickInterval = a.unsquish());
              this.setTickPositions();
            };

            a.prototype.setTickPositions = function () {
              var c = this.options,
                  b = c.tickPositions,
                  a = this.getMinorTickInterval(),
                  e = this.hasVerticalPanning(),
                  d = "colorAxis" === this.coll,
                  n = (d || !e) && c.startOnTick;
              e = (d || !e) && c.endOnTick;
              d = c.tickPositioner;
              this.tickmarkOffset = this.categories && "between" === c.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
              this.minorTickInterval = "auto" === a && this.tickInterval ? this.tickInterval / 5 : a;
              this.single = this.min === this.max && f(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== c.allowDecimals);
              this.tickPositions = a = b && b.slice();
              !a && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? a = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, c.units), this.min, this.max, c.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (a = [this.min, this.max], u(19, !1, this.chart)), a.length > this.len && (a = [a[0], a.pop()], a[0] === a[1] && (a.length = 1)), this.tickPositions = a, d && (d = d.apply(this, [this.min, this.max]))) && (this.tickPositions = a = d);
              this.paddedTicks = a.slice(0);
              this.trimTicks(a, n, e);
              this.isLinked || (this.single && 2 > a.length && !this.categories && !this.series.some(function (c) {
                return c.is("heatmap") && "between" === c.options.pointPlacement;
              }) && (this.min -= .5, this.max += .5), b || d || this.adjustTickAmount());
              m(this, "afterSetTickPositions");
            };

            a.prototype.trimTicks = function (c, b, a) {
              var e = c[0],
                  d = c[c.length - 1],
                  n = !this.isOrdinal && this.minPointOffset || 0;
              m(this, "trimTicks");

              if (!this.isLinked) {
                if (b && -Infinity !== e) this.min = e;else for (; this.min - n > c[0];) {
                  c.shift();
                }
                if (a) this.max = d;else for (; this.max + n < c[c.length - 1];) {
                  c.pop();
                }
                0 === c.length && f(e) && !this.options.tickPositions && c.push((d + e) / 2);
              }
            };

            a.prototype.alignToOthers = function () {
              var c = {},
                  b = this.options,
                  a;
              !1 !== this.chart.options.chart.alignTicks && b.alignTicks && !1 !== b.startOnTick && !1 !== b.endOnTick && !this.logarithmic && this.chart[this.coll].forEach(function (b) {
                var e = b.options;
                e = [b.horiz ? e.left : e.top, e.width, e.height, e.pane].join();
                b.series.length && (c[e] ? a = !0 : c[e] = 1);
              });
              return a;
            };

            a.prototype.getTickAmount = function () {
              var c = this.options,
                  b = c.tickPixelInterval,
                  a = c.tickAmount;
              !f(c.tickInterval) && !a && this.len < b && !this.isRadial && !this.logarithmic && c.startOnTick && c.endOnTick && (a = 2);
              !a && this.alignToOthers() && (a = Math.ceil(this.len / b) + 1);
              4 > a && (this.finalTickAmt = a, a = 5);
              this.tickAmount = a;
            };

            a.prototype.adjustTickAmount = function () {
              var b = this.options,
                  a = this.tickInterval,
                  e = this.tickPositions,
                  d = this.tickAmount,
                  n = this.finalTickAmt,
                  g = e && e.length,
                  m = F(this.threshold, this.softThreshold ? 0 : null);

              if (this.hasData() && c(this.min) && c(this.max)) {
                if (g < d) {
                  for (; e.length < d;) {
                    e.length % 2 || this.min === m ? e.push(G(e[e.length - 1] + a)) : e.unshift(G(e[0] - a));
                  }

                  this.transA *= (g - 1) / (d - 1);
                  this.min = b.startOnTick ? e[0] : Math.min(this.min, e[0]);
                  this.max = b.endOnTick ? e[e.length - 1] : Math.max(this.max, e[e.length - 1]);
                } else g > d && (this.tickInterval *= 2, this.setTickPositions());

                if (f(n)) {
                  for (a = b = e.length; a--;) {
                    (3 === n && 1 === a % 2 || 2 >= n && 0 < a && a < b - 1) && e.splice(a, 1);
                  }

                  this.finalTickAmt = void 0;
                }
              }
            };

            a.prototype.setScale = function () {
              var c = !1,
                  b = !1;
              this.series.forEach(function (a) {
                c = c || a.isDirtyData || a.isDirty;
                b = b || a.xAxis && a.xAxis.isDirty || !1;
              });
              this.setAxisSize();
              var a = this.len !== (this.old && this.old.len);
              a || c || b || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = a || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
              c && this.panningState && (this.panningState.isDirty = !0);
              m(this, "afterSetScale");
            };

            a.prototype.setExtremes = function (c, b, a, e, d) {
              var n = this,
                  f = n.chart;
              a = F(a, !0);
              n.series.forEach(function (c) {
                delete c.kdTree;
              });
              d = E(d, {
                min: c,
                max: b
              });
              m(n, "setExtremes", d, function () {
                n.userMin = c;
                n.userMax = b;
                n.eventArgs = d;
                a && f.redraw(e);
              });
            };

            a.prototype.zoom = function (c, b) {
              var a = this,
                  e = this.dataMin,
                  d = this.dataMax,
                  n = this.options,
                  g = Math.min(e, F(n.min, e)),
                  q = Math.max(d, F(n.max, d));
              c = {
                newMin: c,
                newMax: b
              };
              m(this, "zoom", c, function (c) {
                var b = c.newMin,
                    n = c.newMax;
                if (b !== a.min || n !== a.max) a.allowZoomOutside || (f(e) && (b < g && (b = g), b > q && (b = q)), f(d) && (n < g && (n = g), n > q && (n = q))), a.displayBtn = "undefined" !== typeof b || "undefined" !== typeof n, a.setExtremes(b, n, !1, void 0, {
                  trigger: "zoom"
                });
                c.zoomed = !0;
              });
              return c.zoomed;
            };

            a.prototype.setAxisSize = function () {
              var c = this.chart,
                  b = this.options,
                  a = b.offsets || [0, 0, 0, 0],
                  e = this.horiz,
                  d = this.width = Math.round(W(F(b.width, c.plotWidth - a[3] + a[1]), c.plotWidth)),
                  n = this.height = Math.round(W(F(b.height, c.plotHeight - a[0] + a[2]), c.plotHeight)),
                  f = this.top = Math.round(W(F(b.top, c.plotTop + a[0]), c.plotHeight, c.plotTop));
              b = this.left = Math.round(W(F(b.left, c.plotLeft + a[3]), c.plotWidth, c.plotLeft));
              this.bottom = c.chartHeight - n - f;
              this.right = c.chartWidth - d - b;
              this.len = Math.max(e ? d : n, 0);
              this.pos = e ? b : f;
            };

            a.prototype.getExtremes = function () {
              var c = this.logarithmic;
              return {
                min: c ? G(c.lin2log(this.min)) : this.min,
                max: c ? G(c.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
              };
            };

            a.prototype.getThreshold = function (c) {
              var b = this.logarithmic,
                  a = b ? b.lin2log(this.min) : this.min;
              b = b ? b.lin2log(this.max) : this.max;
              null === c || -Infinity === c ? c = a : Infinity === c ? c = b : a > c ? c = a : b < c && (c = b);
              return this.translate(c, 0, 1, 0, 1);
            };

            a.prototype.autoLabelAlign = function (c) {
              var b = (F(c, 0) - 90 * this.side + 720) % 360;
              c = {
                align: "center"
              };
              m(this, "autoLabelAlign", c, function (c) {
                15 < b && 165 > b ? c.align = "right" : 195 < b && 345 > b && (c.align = "left");
              });
              return c.align;
            };

            a.prototype.tickSize = function (c) {
              var b = this.options,
                  a = F(b["tick" === c ? "tickWidth" : "minorTickWidth"], "tick" === c && this.isXAxis && !this.categories ? 1 : 0),
                  e = b["tick" === c ? "tickLength" : "minorTickLength"];

              if (a && e) {
                "inside" === b[c + "Position"] && (e = -e);
                var d = [e, a];
              }

              c = {
                tickSize: d
              };
              m(this, "afterTickSize", c);
              return c.tickSize;
            };

            a.prototype.labelMetrics = function () {
              var c = this.tickPositions && this.tickPositions[0] || 0;
              return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[c] && this.ticks[c].label);
            };

            a.prototype.unsquish = function () {
              var b = this.options.labels,
                  a = this.horiz,
                  e = this.tickInterval,
                  d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e),
                  n = b.rotation,
                  f = this.labelMetrics(),
                  m = Math.max(this.max - this.min, 0),
                  q = function q(c) {
                var b = c / (d || 1);
                b = 1 < b ? Math.ceil(b) : 1;
                b * e > m && Infinity !== c && Infinity !== d && m && (b = Math.ceil(m / e));
                return G(b * e);
              },
                  k = e,
                  h,
                  C,
                  p = Number.MAX_VALUE;

              if (a) {
                if (!b.staggerLines && !b.step) if (c(n)) var u = [n];else d < b.autoRotationLimit && (u = b.autoRotation);
                u && u.forEach(function (c) {
                  if (c === n || c && -90 <= c && 90 >= c) {
                    C = q(Math.abs(f.h / Math.sin(g * c)));
                    var b = C + Math.abs(c / 360);
                    b < p && (p = b, h = c, k = C);
                  }
                });
              } else b.step || (k = q(f.h));

              this.autoRotation = u;
              this.labelRotation = F(h, c(n) ? n : 0);
              return k;
            };

            a.prototype.getSlotWidth = function (b) {
              var a = this.chart,
                  e = this.horiz,
                  d = this.options.labels,
                  n = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                  f = a.margin[3];
              if (b && c(b.slotWidth)) return b.slotWidth;
              if (e && 2 > d.step) return d.rotation ? 0 : (this.staggerLines || 1) * this.len / n;

              if (!e) {
                b = d.style.width;
                if (void 0 !== b) return parseInt(String(b), 10);
                if (f) return f - a.spacing[3];
              }

              return .33 * a.chartWidth;
            };

            a.prototype.renderUnsquish = function () {
              var c = this.chart,
                  b = c.renderer,
                  a = this.tickPositions,
                  e = this.ticks,
                  d = this.options.labels,
                  f = d.style,
                  g = this.horiz,
                  m = this.getSlotWidth(),
                  q = Math.max(1, Math.round(m - 2 * d.padding)),
                  k = {},
                  h = this.labelMetrics(),
                  C = f.textOverflow,
                  p = 0;
              n(d.rotation) || (k.rotation = d.rotation || 0);
              a.forEach(function (c) {
                c = e[c];
                c.movedLabel && c.replaceMovedLabel();
                c && c.label && c.label.textPxLength > p && (p = c.label.textPxLength);
              });
              this.maxLabelLength = p;
              if (this.autoRotation) p > q && p > h.h ? k.rotation = this.labelRotation : this.labelRotation = 0;else if (m) {
                var u = q;

                if (!C) {
                  var H = "clip";

                  for (q = a.length; !g && q--;) {
                    var l = a[q];
                    if (l = e[l].label) l.styles && "ellipsis" === l.styles.textOverflow ? l.css({
                      textOverflow: "clip"
                    }) : l.textPxLength > m && l.css({
                      width: m + "px"
                    }), l.getBBox().height > this.len / a.length - (h.h - h.f) && (l.specificTextOverflow = "ellipsis");
                  }
                }
              }
              k.rotation && (u = p > .5 * c.chartHeight ? .33 * c.chartHeight : p, C || (H = "ellipsis"));
              if (this.labelAlign = d.align || this.autoLabelAlign(this.labelRotation)) k.align = this.labelAlign;
              a.forEach(function (c) {
                var b = (c = e[c]) && c.label,
                    a = f.width,
                    d = {};
                b && (b.attr(k), c.shortenLabel ? c.shortenLabel() : u && !a && "nowrap" !== f.whiteSpace && (u < b.textPxLength || "SPAN" === b.element.tagName) ? (d.width = u + "px", C || (d.textOverflow = b.specificTextOverflow || H), b.css(d)) : b.styles && b.styles.width && !d.width && !a && b.css({
                  width: null
                }), delete b.specificTextOverflow, c.rotation = k.rotation);
              }, this);
              this.tickRotCorr = b.rotCorr(h.b, this.labelRotation || 0, 0 !== this.side);
            };

            a.prototype.hasData = function () {
              return this.series.some(function (c) {
                return c.hasData();
              }) || this.options.showEmpty && f(this.min) && f(this.max);
            };

            a.prototype.addTitle = function (c) {
              var b = this.chart.renderer,
                  a = this.horiz,
                  e = this.opposite,
                  d = this.options.title,
                  n = this.chart.styledMode,
                  f;
              this.axisTitle || ((f = d.textAlign) || (f = (a ? {
                low: "left",
                middle: "center",
                high: "right"
              } : {
                low: e ? "right" : "left",
                middle: "center",
                high: e ? "left" : "right"
              })[d.align]), this.axisTitle = b.text(d.text || "", 0, 0, d.useHTML).attr({
                zIndex: 7,
                rotation: d.rotation,
                align: f
              }).addClass("highcharts-axis-title"), n || this.axisTitle.css(C(d.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
              n || d.style.width || this.isRadial || this.axisTitle.css({
                width: this.len + "px"
              });
              this.axisTitle[c ? "show" : "hide"](c);
            };

            a.prototype.generateTick = function (c) {
              var b = this.ticks;
              b[c] ? b[c].addLabel() : b[c] = new t(this, c);
            };

            a.prototype.getOffset = function () {
              var c = this,
                  b = this,
                  a = b.chart,
                  e = a.renderer,
                  d = b.options,
                  n = b.tickPositions,
                  g = b.ticks,
                  q = b.horiz,
                  k = b.side,
                  h = a.inverted && !b.isZAxis ? [1, 0, 3, 2][k] : k,
                  C = b.hasData(),
                  p = d.title,
                  u = d.labels,
                  H = a.axisOffset;
              a = a.clipOffset;
              var l = [-1, 1, 1, -1][k],
                  B = d.className,
                  x = b.axisParent,
                  E,
                  r = 0,
                  t = 0,
                  ha = 0;
              b.showAxis = E = C || d.showEmpty;
              b.staggerLines = b.horiz && u.staggerLines || void 0;

              if (!b.axisGroup) {
                var G = function G(b, a, d) {
                  return e.g(b).attr({
                    zIndex: d
                  }).addClass("highcharts-" + c.coll.toLowerCase() + a + " " + (c.isRadial ? "highcharts-radial-axis" + a + " " : "") + (B || "")).add(x);
                };

                b.gridGroup = G("grid", "-grid", d.gridZIndex);
                b.axisGroup = G("axis", "", d.zIndex);
                b.labelGroup = G("axis-labels", "-labels", u.zIndex);
              }

              C || b.isLinked ? (n.forEach(function (c) {
                b.generateTick(c);
              }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === k || 2 === k || {
                1: "left",
                3: "right"
              }[k] === b.labelAlign, F(u.reserveSpace, "center" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && n.forEach(function (c) {
                ha = Math.max(g[c].getLabelSize(), ha);
              }), b.staggerLines && (ha *= b.staggerLines), b.labelOffset = ha * (b.opposite ? -1 : 1)) : L(g, function (c, b) {
                c.destroy();
                delete g[b];
              });

              if (p && p.text && !1 !== p.enabled && (b.addTitle(E), E && !1 !== p.reserveSpace)) {
                b.titleOffset = r = b.axisTitle.getBBox()[q ? "height" : "width"];
                var J = p.offset;
                t = f(J) ? 0 : F(p.margin, q ? 5 : 10);
              }

              b.renderLine();
              b.offset = l * F(d.offset, H[k] ? H[k] + (d.margin || 0) : 0);
              b.tickRotCorr = b.tickRotCorr || {
                x: 0,
                y: 0
              };
              p = 0 === k ? -b.labelMetrics().h : 2 === k ? b.tickRotCorr.y : 0;
              C = Math.abs(ha) + t;
              ha && (C = C - p + l * (q ? F(u.y, b.tickRotCorr.y + 8 * l) : u.x));
              b.axisTitleMargin = F(J, C);
              b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(g, n));
              q = this.tickSize("tick");
              H[k] = Math.max(H[k], (b.axisTitleMargin || 0) + r + l * b.offset, C, n && n.length && q ? q[0] + l * b.offset : 0);
              d = d.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2);
              a[h] = Math.max(a[h], d);
              m(this, "afterGetOffset");
            };

            a.prototype.getLinePath = function (c) {
              var b = this.chart,
                  a = this.opposite,
                  e = this.offset,
                  d = this.horiz,
                  n = this.left + (a ? this.width : 0) + e;
              e = b.chartHeight - this.bottom - (a ? this.height : 0) + e;
              a && (c *= -1);
              return b.renderer.crispLine([["M", d ? this.left : n, d ? e : this.top], ["L", d ? b.chartWidth - this.right : n, d ? e : b.chartHeight - this.bottom]], c);
            };

            a.prototype.renderLine = function () {
              this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                stroke: this.options.lineColor,
                "stroke-width": this.options.lineWidth,
                zIndex: 7
              }));
            };

            a.prototype.getTitlePosition = function () {
              var c = this.horiz,
                  b = this.left,
                  a = this.top,
                  e = this.len,
                  d = this.options.title,
                  n = c ? b : a,
                  f = this.opposite,
                  g = this.offset,
                  q = d.x,
                  k = d.y,
                  h = this.axisTitle,
                  C = this.chart.renderer.fontMetrics(d.style.fontSize, h);
              h = Math.max(h.getBBox(null, 0).height - C.h - 1, 0);
              e = {
                low: n + (c ? 0 : e),
                middle: n + e / 2,
                high: n + (c ? e : 0)
              }[d.align];
              b = (c ? a + this.height : b) + (c ? 1 : -1) * (f ? -1 : 1) * this.axisTitleMargin + [-h, h, C.f, -h][this.side];
              c = {
                x: c ? e + q : b + (f ? this.width : 0) + g + q,
                y: c ? b + k - (f ? this.height : 0) + g : e + k
              };
              m(this, "afterGetTitlePosition", {
                titlePosition: c
              });
              return c;
            };

            a.prototype.renderMinorTick = function (c, b) {
              var a = this.minorTicks;
              a[c] || (a[c] = new t(this, c, "minor"));
              b && a[c].isNew && a[c].render(null, !0);
              a[c].render(null, !1, 1);
            };

            a.prototype.renderTick = function (c, b, a) {
              var e = this.ticks;
              if (!this.isLinked || c >= this.min && c <= this.max || this.grid && this.grid.isColumn) e[c] || (e[c] = new t(this, c)), a && e[c].isNew && e[c].render(b, !0, -1), e[c].render(b);
            };

            a.prototype.render = function () {
              var b = this,
                  a = b.chart,
                  e = b.logarithmic,
                  d = b.options,
                  n = b.isLinked,
                  f = b.tickPositions,
                  g = b.axisTitle,
                  q = b.ticks,
                  k = b.minorTicks,
                  C = b.alternateBands,
                  p = d.stackLabels,
                  u = d.alternateGridColor,
                  H = b.tickmarkOffset,
                  l = b.axisLine,
                  F = b.showAxis,
                  B = h(a.renderer.globalAnimation),
                  x,
                  E;
              b.labelEdge.length = 0;
              b.overlap = !1;
              [q, k, C].forEach(function (c) {
                L(c, function (c) {
                  c.isActive = !1;
                });
              });

              if (b.hasData() || n) {
                var r = b.chart.hasRendered && b.old && c(b.old.min);
                b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (c) {
                  b.renderMinorTick(c, r);
                });
                f.length && (f.forEach(function (c, a) {
                  b.renderTick(c, a, r);
                }), H && (0 === b.min || b.single) && (q[-1] || (q[-1] = new t(b, -1, null, !0)), q[-1].render(-1)));
                u && f.forEach(function (c, d) {
                  E = "undefined" !== typeof f[d + 1] ? f[d + 1] + H : b.max - H;
                  0 === d % 2 && c < b.max && E <= b.max + (a.polar ? -H : H) && (C[c] || (C[c] = new D.PlotLineOrBand(b)), x = c + H, C[c].options = {
                    from: e ? e.lin2log(x) : x,
                    to: e ? e.lin2log(E) : E,
                    color: u,
                    className: "highcharts-alternate-grid"
                  }, C[c].render(), C[c].isActive = !0);
                });
                b._addedPlotLB || (b._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (c) {
                  b.addPlotBandOrLine(c);
                }));
              }

              [q, k, C].forEach(function (c) {
                var b = [],
                    e = B.duration;
                L(c, function (c, a) {
                  c.isActive || (c.render(a, !1, 0), c.isActive = !1, b.push(a));
                });
                T(function () {
                  for (var a = b.length; a--;) {
                    c[b[a]] && !c[b[a]].isActive && (c[b[a]].destroy(), delete c[b[a]]);
                  }
                }, c !== C && a.hasRendered && e ? e : 0);
              });
              l && (l[l.isPlaced ? "animate" : "attr"]({
                d: this.getLinePath(l.strokeWidth())
              }), l.isPlaced = !0, l[F ? "show" : "hide"](F));
              g && F && (d = b.getTitlePosition(), c(d.y) ? (g[g.isNew ? "attr" : "animate"](d), g.isNew = !1) : (g.attr("y", -9999), g.isNew = !0));
              p && p.enabled && b.stacking && b.stacking.renderStackTotals();
              b.old = {
                len: b.len,
                max: b.max,
                min: b.min,
                transA: b.transA,
                userMax: b.userMax,
                userMin: b.userMin
              };
              b.isDirty = !1;
              m(this, "afterRender");
            };

            a.prototype.redraw = function () {
              this.visible && (this.render(), this.plotLinesAndBands.forEach(function (c) {
                c.render();
              }));
              this.series.forEach(function (c) {
                c.isDirty = !0;
              });
            };

            a.prototype.getKeepProps = function () {
              return this.keepProps || a.keepProps;
            };

            a.prototype.destroy = function (c) {
              var b = this,
                  a = b.plotLinesAndBands,
                  e = this.eventOptions;
              m(this, "destroy", {
                keepEvents: c
              });
              c || S(b);
              [b.ticks, b.minorTicks, b.alternateBands].forEach(function (c) {
                B(c);
              });
              if (a) for (c = a.length; c--;) {
                a[c].destroy();
              }
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (c) {
                b[c] && (b[c] = b[c].destroy());
              });

              for (var d in b.plotLinesAndBandsGroups) {
                b.plotLinesAndBandsGroups[d] = b.plotLinesAndBandsGroups[d].destroy();
              }

              L(b, function (c, a) {
                -1 === b.getKeepProps().indexOf(a) && delete b[a];
              });
              this.eventOptions = e;
            };

            a.prototype.drawCrosshair = function (c, b) {
              var a = this.crosshair,
                  e = F(a && a.snap, !0),
                  d = this.chart,
                  n,
                  g = this.cross;
              m(this, "drawCrosshair", {
                e: c,
                point: b
              });
              c || (c = this.cross && this.cross.e);

              if (a && !1 !== (f(b) || !e)) {
                e ? f(b) && (n = F("colorAxis" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : n = c && (this.horiz ? c.chartX - this.pos : this.len - c.chartY + this.pos);

                if (f(n)) {
                  var q = {
                    value: b && (this.isXAxis ? b.x : F(b.stackY, b.y)),
                    translatedValue: n
                  };
                  d.polar && E(q, {
                    isCrosshair: !0,
                    chartX: c && c.chartX,
                    chartY: c && c.chartY,
                    point: b
                  });
                  q = this.getPlotLinePath(q) || null;
                }

                if (!f(q)) {
                  this.hideCrosshair();
                  return;
                }

                e = this.categories && !this.isRadial;
                g || (this.cross = g = d.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (e ? "category " : "thin ") + (a.className || "")).attr({
                  zIndex: F(a.zIndex, 2)
                }).add(), d.styledMode || (g.attr({
                  stroke: a.color || (e ? A.parse(y.highlightColor20).setOpacity(.25).get() : y.neutralColor20),
                  "stroke-width": F(a.width, 1)
                }).css({
                  "pointer-events": "none"
                }), a.dashStyle && g.attr({
                  dashstyle: a.dashStyle
                })));
                g.show().attr({
                  d: q
                });
                e && !a.width && g.attr({
                  "stroke-width": this.transA
                });
                this.cross.e = c;
              } else this.hideCrosshair();

              m(this, "afterDrawCrosshair", {
                e: c,
                point: b
              });
            };

            a.prototype.hideCrosshair = function () {
              this.cross && this.cross.hide();
              m(this, "afterHideCrosshair");
            };

            a.prototype.hasVerticalPanning = function () {
              var c = this.chart.options.chart.panning;
              return !!(c && c.enabled && /y/.test(c.type));
            };

            a.prototype.validatePositiveValue = function (b) {
              return c(b) && 0 < b;
            };

            a.prototype.update = function (c, b) {
              var a = this.chart;
              c = C(this.userOptions, c);
              this.destroy(!0);
              this.init(a, c);
              a.isDirtyBox = !0;
              F(b, !0) && a.redraw();
            };

            a.prototype.remove = function (c) {
              for (var b = this.chart, a = this.coll, e = this.series, d = e.length; d--;) {
                e[d] && e[d].remove(!1);
              }

              x(b.axes, this);
              x(b[a], this);
              b[a].forEach(function (c, b) {
                c.options.index = c.userOptions.index = b;
              });
              this.destroy();
              b.isDirtyBox = !0;
              F(c, !0) && b.redraw();
            };

            a.prototype.setTitle = function (c, b) {
              this.update({
                title: c
              }, b);
            };

            a.prototype.setCategories = function (c, b) {
              this.update({
                categories: c
              }, b);
            };

            a.defaultOptions = v.defaultXAxisOptions;
            a.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
            return a;
          }();

          "";
          return a;
        });
        I(a, "Core/Axis/DateTimeAxis.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.addEvent,
              A = a.getMagnitude,
              y = a.normalizeTickInterval,
              z = a.timeUnits,
              w;

          (function (a) {
            function t() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }

            function l(b) {
              "datetime" !== b.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new d(this));
            }

            var h = [];

            a.compose = function (b) {
              -1 === h.indexOf(b) && (h.push(b), b.keepProps.push("dateTime"), b.prototype.getTimeTicks = t, r(b, "init", l));
              return b;
            };

            var d = function () {
              function b(b) {
                this.axis = b;
              }

              b.prototype.normalizeTimeTickInterval = function (b, a) {
                var d = a || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
                a = d[d.length - 1];
                var g = z[a[0]],
                    h = a[1],
                    f;

                for (f = 0; f < d.length && !(a = d[f], g = z[a[0]], h = a[1], d[f + 1] && b <= (g * h[h.length - 1] + z[d[f + 1][0]]) / 2); f++) {
                  ;
                }

                g === z.year && b < 5 * g && (h = [1, 2, 5]);
                b = y(b / g, h, "year" === a[0] ? Math.max(A(b / g), 1) : 1);
                return {
                  unitRange: g,
                  count: b,
                  unitName: a[0]
                };
              };

              b.prototype.getXDateFormat = function (b, a) {
                var d = this.axis;
                return d.closestPointRange ? d.chart.time.getDateFormat(d.closestPointRange, b, d.options.startOfWeek, a) || a.year : a.day;
              };

              return b;
            }();

            a.Additions = d;
          })(w || (w = {}));

          return w;
        });
        I(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.addEvent,
              A = a.getMagnitude,
              y = a.normalizeTickInterval,
              z = a.pick,
              w;

          (function (a) {
            function t(b) {
              var a = this.logarithmic;
              "logarithmic" !== b.userOptions.type ? this.logarithmic = void 0 : a || (this.logarithmic = new d(this));
            }

            function l() {
              var b = this.logarithmic;
              b && (this.lin2val = function (a) {
                return b.lin2log(a);
              }, this.val2lin = function (a) {
                return b.log2lin(a);
              });
            }

            var h = [];

            a.compose = function (b) {
              -1 === h.indexOf(b) && (h.push(b), b.keepProps.push("logarithmic"), r(b, "init", t), r(b, "afterInit", l));
              return b;
            };

            var d = function () {
              function b(b) {
                this.axis = b;
              }

              b.prototype.getLogTickPositions = function (b, a, d, h) {
                var g = this.axis,
                    f = g.len,
                    k = g.options,
                    p = [];
                h || (this.minorAutoInterval = void 0);
                if (.5 <= b) b = Math.round(b), p = g.getLinearTickPositions(b, a, d);else if (.08 <= b) {
                  var u = Math.floor(a),
                      l,
                      m = k = void 0;

                  for (f = .3 < b ? [1, 2, 4] : .15 < b ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; u < d + 1 && !m; u++) {
                    var q = f.length;

                    for (l = 0; l < q && !m; l++) {
                      var e = this.log2lin(this.lin2log(u) * f[l]);
                      e > a && (!h || k <= d) && "undefined" !== typeof k && p.push(k);
                      k > d && (m = !0);
                      k = e;
                    }
                  }
                } else a = this.lin2log(a), d = this.lin2log(d), b = h ? g.getMinorTickInterval() : k.tickInterval, b = z("auto" === b ? null : b, this.minorAutoInterval, k.tickPixelInterval / (h ? 5 : 1) * (d - a) / ((h ? f / g.tickPositions.length : f) || 1)), b = y(b, void 0, A(b)), p = g.getLinearTickPositions(b, a, d).map(this.log2lin), h || (this.minorAutoInterval = b / 5);
                h || (g.tickInterval = b);
                return p;
              };

              b.prototype.lin2log = function (b) {
                return Math.pow(10, b);
              };

              b.prototype.log2lin = function (b) {
                return Math.log(b) / Math.LN10;
              };

              return b;
            }();

            a.Additions = d;
          })(w || (w = {}));

          return w;
        });
        I(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.erase,
              A = a.extend,
              y = a.isNumber,
              z;

          (function (a) {
            var w = [],
                t;

            a.compose = function (a, d) {
              t || (t = a);
              -1 === w.indexOf(d) && (w.push(d), A(d.prototype, l.prototype));
              return d;
            };

            var l = function () {
              function a() {}

              a.prototype.getPlotBandPath = function (a, b, g) {
                void 0 === g && (g = this.options);
                var d = this.getPlotLinePath({
                  value: b,
                  force: !0,
                  acrossPanes: g.acrossPanes
                }),
                    k = [],
                    h = this.horiz;
                b = !y(this.min) || !y(this.max) || a < this.min && b < this.min || a > this.max && b > this.max;
                a = this.getPlotLinePath({
                  value: a,
                  force: !0,
                  acrossPanes: g.acrossPanes
                });
                g = 1;

                if (a && d) {
                  if (b) {
                    var l = a.toString() === d.toString();
                    g = 0;
                  }

                  for (b = 0; b < a.length; b += 2) {
                    var f = a[b],
                        B = a[b + 1],
                        x = d[b],
                        u = d[b + 1];
                    "M" !== f[0] && "L" !== f[0] || "M" !== B[0] && "L" !== B[0] || "M" !== x[0] && "L" !== x[0] || "M" !== u[0] && "L" !== u[0] || (h && x[1] === f[1] ? (x[1] += g, u[1] += g) : h || x[2] !== f[2] || (x[2] += g, u[2] += g), k.push(["M", f[1], f[2]], ["L", B[1], B[2]], ["L", u[1], u[2]], ["L", x[1], x[2]], ["Z"]));
                    k.isFlat = l;
                  }
                }

                return k;
              };

              a.prototype.addPlotBand = function (a) {
                return this.addPlotBandOrLine(a, "plotBands");
              };

              a.prototype.addPlotLine = function (a) {
                return this.addPlotBandOrLine(a, "plotLines");
              };

              a.prototype.addPlotBandOrLine = function (a, b) {
                var d = this,
                    h = this.userOptions,
                    k = new t(this, a);
                this.visible && (k = k.render());

                if (k) {
                  this._addedPlotLB || (this._addedPlotLB = !0, (h.plotLines || []).concat(h.plotBands || []).forEach(function (b) {
                    d.addPlotBandOrLine(b);
                  }));

                  if (b) {
                    var l = h[b] || [];
                    l.push(a);
                    h[b] = l;
                  }

                  this.plotLinesAndBands.push(k);
                }

                return k;
              };

              a.prototype.removePlotBandOrLine = function (a) {
                var b = this.plotLinesAndBands,
                    d = this.options,
                    h = this.userOptions;

                if (b) {
                  for (var k = b.length; k--;) {
                    b[k].id === a && b[k].destroy();
                  }

                  [d.plotLines || [], h.plotLines || [], d.plotBands || [], h.plotBands || []].forEach(function (b) {
                    for (k = b.length; k--;) {
                      (b[k] || {}).id === a && r(b, b[k]);
                    }
                  });
                }
              };

              a.prototype.removePlotBand = function (a) {
                this.removePlotBandOrLine(a);
              };

              a.prototype.removePlotLine = function (a) {
                this.removePlotBandOrLine(a);
              };

              return a;
            }();
          })(z || (z = {}));

          return z;
        });
        I(a, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [a["Core/Color/Palette.js"], a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = A.arrayMax,
              z = A.arrayMin,
              w = A.defined,
              D = A.destroyObjectProperties,
              t = A.erase,
              l = A.fireEvent,
              h = A.merge,
              d = A.objectEach,
              b = A.pick;

          A = function () {
            function g(b, a) {
              this.axis = b;
              a && (this.options = a, this.id = a.id);
            }

            g.compose = function (b) {
              return v.compose(g, b);
            };

            g.prototype.render = function () {
              l(this, "render");
              var g = this,
                  k = g.axis,
                  r = k.horiz,
                  t = k.logarithmic,
                  f = g.options,
                  B = f.color,
                  x = b(f.zIndex, 0),
                  u = f.events,
                  E = {},
                  m = k.chart.renderer,
                  q = f.label,
                  e = g.label,
                  c = f.to,
                  n = f.from,
                  C = f.value,
                  H = g.svgElem,
                  L = [],
                  F = w(n) && w(c);
              L = w(C);
              var W = !H,
                  v = {
                "class": "highcharts-plot-" + (F ? "band " : "line ") + (f.className || "")
              },
                  D = F ? "bands" : "lines";
              t && (n = t.log2lin(n), c = t.log2lin(c), C = t.log2lin(C));
              k.chart.styledMode || (L ? (v.stroke = B || a.neutralColor40, v["stroke-width"] = b(f.width, 1), f.dashStyle && (v.dashstyle = f.dashStyle)) : F && (v.fill = B || a.highlightColor10, f.borderWidth && (v.stroke = f.borderColor, v["stroke-width"] = f.borderWidth)));
              E.zIndex = x;
              D += "-" + x;
              (t = k.plotLinesAndBandsGroups[D]) || (k.plotLinesAndBandsGroups[D] = t = m.g("plot-" + D).attr(E).add());
              W && (g.svgElem = H = m.path().attr(v).add(t));
              if (L) L = k.getPlotLinePath({
                value: C,
                lineWidth: H.strokeWidth(),
                acrossPanes: f.acrossPanes
              });else if (F) L = k.getPlotBandPath(n, c, f);else return;
              !g.eventsAdded && u && (d(u, function (c, b) {
                H.on(b, function (c) {
                  u[b].apply(g, [c]);
                });
              }), g.eventsAdded = !0);
              (W || !H.d) && L && L.length ? H.attr({
                d: L
              }) : H && (L ? (H.show(!0), H.animate({
                d: L
              })) : H.d && (H.hide(), e && (g.label = e = e.destroy())));
              q && (w(q.text) || w(q.formatter)) && L && L.length && 0 < k.width && 0 < k.height && !L.isFlat ? (q = h({
                align: r && F && "center",
                x: r ? !F && 4 : 10,
                verticalAlign: !r && F && "middle",
                y: r ? F ? 16 : 10 : F ? 6 : -4,
                rotation: r && !F && 90
              }, q), this.renderLabel(q, L, F, x)) : e && e.hide();
              return g;
            };

            g.prototype.renderLabel = function (b, a, d, g) {
              var f = this.axis,
                  k = f.chart.renderer,
                  p = this.label;
              p || (this.label = p = k.text(this.getLabelText(b), 0, 0, b.useHTML).attr({
                align: b.textAlign || b.align,
                rotation: b.rotation,
                "class": "highcharts-plot-" + (d ? "band" : "line") + "-label " + (b.className || ""),
                zIndex: g
              }).add(), f.chart.styledMode || p.css(h({
                textOverflow: "ellipsis"
              }, b.style)));
              g = a.xBounds || [a[0][1], a[1][1], d ? a[2][1] : a[0][1]];
              a = a.yBounds || [a[0][2], a[1][2], d ? a[2][2] : a[0][2]];
              d = z(g);
              k = z(a);
              p.align(b, !1, {
                x: d,
                y: k,
                width: r(g) - d,
                height: r(a) - k
              });
              p.alignValue && "left" !== p.alignValue || p.css({
                width: (90 === p.rotation ? f.height - (p.alignAttr.y - f.top) : f.width - (p.alignAttr.x - f.left)) + "px"
              });
              p.show(!0);
            };

            g.prototype.getLabelText = function (b) {
              return w(b.formatter) ? b.formatter.call(this) : b.text;
            };

            g.prototype.destroy = function () {
              t(this.axis.plotLinesAndBands, this);
              delete this.axis;
              D(this);
            };

            return g;
          }();

          "";
          "";
          return A;
        });
        I(a, "Core/Tooltip.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w) {
          var r = a.format,
              t = v.doc,
              l = y.distribute,
              h = w.addEvent,
              d = w.clamp,
              b = w.css,
              g = w.defined,
              p = w.discardElement,
              k = w.extend,
              J = w.fireEvent,
              G = w.isArray,
              f = w.isNumber,
              B = w.isString,
              x = w.merge,
              u = w.pick,
              E = w.splat,
              m = w.syncTimeout;

          a = function () {
            function a(b, c) {
              this.container = void 0;
              this.crosshairs = [];
              this.distance = 0;
              this.isHidden = !0;
              this.isSticky = !1;
              this.now = {};
              this.options = {};
              this.outside = !1;
              this.chart = b;
              this.init(b, c);
            }

            a.prototype.applyFilter = function () {
              var b = this.chart;
              b.renderer.definition({
                tagName: "filter",
                attributes: {
                  id: "drop-shadow-" + b.index,
                  opacity: .5
                },
                children: [{
                  tagName: "feGaussianBlur",
                  attributes: {
                    "in": "SourceAlpha",
                    stdDeviation: 1
                  }
                }, {
                  tagName: "feOffset",
                  attributes: {
                    dx: 1,
                    dy: 1
                  }
                }, {
                  tagName: "feComponentTransfer",
                  children: [{
                    tagName: "feFuncA",
                    attributes: {
                      type: "linear",
                      slope: .3
                    }
                  }]
                }, {
                  tagName: "feMerge",
                  children: [{
                    tagName: "feMergeNode"
                  }, {
                    tagName: "feMergeNode",
                    attributes: {
                      "in": "SourceGraphic"
                    }
                  }]
                }]
              });
            };

            a.prototype.bodyFormatter = function (b) {
              return b.map(function (c) {
                var b = c.series.tooltipOptions;
                return (b[(c.point.formatPrefix || "point") + "Formatter"] || c.point.tooltipFormatter).call(c.point, b[(c.point.formatPrefix || "point") + "Format"] || "");
              });
            };

            a.prototype.cleanSplit = function (b) {
              this.chart.series.forEach(function (c) {
                var a = c && c.tt;
                a && (!a.isActive || b ? c.tt = a.destroy() : a.isActive = !1);
              });
            };

            a.prototype.defaultFormatter = function (b) {
              var c = this.points || E(this);
              var a = [b.tooltipFooterHeaderFormatter(c[0])];
              a = a.concat(b.bodyFormatter(c));
              a.push(b.tooltipFooterHeaderFormatter(c[0], !0));
              return a;
            };

            a.prototype.destroy = function () {
              this.label && (this.label = this.label.destroy());
              this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
              this.renderer && (this.renderer = this.renderer.destroy(), p(this.container));
              w.clearTimeout(this.hideTimer);
              w.clearTimeout(this.tooltipTimeout);
            };

            a.prototype.getAnchor = function (b, c) {
              var a = this.chart,
                  e = a.pointer,
                  d = a.inverted,
                  f = a.plotTop,
                  g = a.plotLeft,
                  m,
                  q,
                  k = 0,
                  h = 0;
              b = E(b);
              this.followPointer && c ? ("undefined" === typeof c.chartX && (c = e.normalize(c)), e = [c.chartX - g, c.chartY - f]) : b[0].tooltipPos ? e = b[0].tooltipPos : (b.forEach(function (c) {
                m = c.series.yAxis;
                q = c.series.xAxis;
                k += c.plotX || 0;
                h += c.plotLow ? (c.plotLow + (c.plotHigh || 0)) / 2 : c.plotY || 0;
                q && m && (d ? (k += f + a.plotHeight - q.len - q.pos, h += g + a.plotWidth - m.len - m.pos) : (k += q.pos - g, h += m.pos - f));
              }), k /= b.length, h /= b.length, e = [d ? a.plotWidth - h : k, d ? a.plotHeight - k : h], this.shared && 1 < b.length && c && (d ? e[0] = c.chartX - g : e[1] = c.chartY - f));
              return e.map(Math.round);
            };

            a.prototype.getLabel = function () {
              var a = this,
                  c = this.chart.styledMode,
                  d = this.options,
                  f = "tooltip" + (g(d.className) ? " " + d.className : ""),
                  m = d.style.pointerEvents || (!this.followPointer && d.stickOnContact ? "auto" : "none"),
                  q = function q() {
                a.inContact = !0;
              },
                  k = function k(c) {
                var b = a.chart.hoverSeries;
                a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(c.relatedTarget, "highcharts-tooltip");
                if (!a.inContact && b && b.onMouseOut) b.onMouseOut();
              },
                  u,
                  p = this.chart.renderer;

              if (!this.label) {
                if (this.outside) {
                  var l = this.chart.options.chart.style,
                      B = z.getRendererType();
                  this.container = u = v.doc.createElement("div");
                  u.className = "highcharts-tooltip-container";
                  b(u, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: m,
                    zIndex: Math.max(this.options.style.zIndex || 0, (l && l.zIndex || 0) + 3)
                  });
                  h(u, "mouseenter", q);
                  h(u, "mouseleave", k);
                  v.doc.body.appendChild(u);
                  this.renderer = p = new B(u, 0, 0, l, void 0, void 0, p.styledMode);
                }

                this.split ? this.label = p.g(f) : (this.label = p.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, f).attr({
                  padding: d.padding,
                  r: d.borderRadius
                }), c || this.label.attr({
                  fill: d.backgroundColor,
                  "stroke-width": d.borderWidth
                }).css(d.style).css({
                  pointerEvents: m
                }).shadow(d.shadow));
                c && d.shadow && (this.applyFilter(), this.label.attr({
                  filter: "url(#drop-shadow-" + this.chart.index + ")"
                }));

                if (a.outside && !a.split) {
                  var x = this.label,
                      E = x.xSetter,
                      r = x.ySetter;

                  x.xSetter = function (c) {
                    E.call(x, a.distance);
                    u.style.left = c + "px";
                  };

                  x.ySetter = function (c) {
                    r.call(x, a.distance);
                    u.style.top = c + "px";
                  };
                }

                this.label.on("mouseenter", q).on("mouseleave", k).attr({
                  zIndex: 8
                }).add();
              }

              return this.label;
            };

            a.prototype.getPosition = function (b, c, a) {
              var e = this.chart,
                  d = this.distance,
                  n = {},
                  f = e.inverted && a.h || 0,
                  g = this.outside,
                  m = g ? t.documentElement.clientWidth - 2 * d : e.chartWidth,
                  q = g ? Math.max(t.body.scrollHeight, t.documentElement.scrollHeight, t.body.offsetHeight, t.documentElement.offsetHeight, t.documentElement.clientHeight) : e.chartHeight,
                  k = e.pointer.getChartPosition(),
                  h = function h(n) {
                var f = "x" === n;
                return [n, f ? m : q, f ? b : c].concat(g ? [f ? b * k.scaleX : c * k.scaleY, f ? k.left - d + (a.plotX + e.plotLeft) * k.scaleX : k.top - d + (a.plotY + e.plotTop) * k.scaleY, 0, f ? m : q] : [f ? b : c, f ? a.plotX + e.plotLeft : a.plotY + e.plotTop, f ? e.plotLeft : e.plotTop, f ? e.plotLeft + e.plotWidth : e.plotTop + e.plotHeight]);
              },
                  p = h("y"),
                  l = h("x"),
                  B,
                  x = !this.followPointer && u(a.ttBelow, !e.inverted === !!a.negative),
                  E = function E(c, b, a, e, m, q, h) {
                var C = g ? "y" === c ? d * k.scaleY : d * k.scaleX : d,
                    u = (a - e) / 2,
                    p = e < m - d,
                    l = m + d + e < b,
                    H = m - C - a + u;
                m = m + C - u;
                if (x && l) n[c] = m;else if (!x && p) n[c] = H;else if (p) n[c] = Math.min(h - e, 0 > H - f ? H : H - f);else if (l) n[c] = Math.max(q, m + f + a > b ? m : m + f);else return !1;
              },
                  r = function r(c, b, a, e, f) {
                var g;
                f < d || f > b - d ? g = !1 : n[c] = f < a / 2 ? 1 : f > b - e / 2 ? b - e - 2 : f - a / 2;
                return g;
              },
                  K = function K(c) {
                var b = p;
                p = l;
                l = b;
                B = c;
              },
                  G = function G() {
                !1 !== E.apply(0, p) ? !1 !== r.apply(0, l) || B || (K(!0), G()) : B ? n.x = n.y = 0 : (K(!0), G());
              };

              (e.inverted || 1 < this.len) && K();
              G();
              return n;
            };

            a.prototype.hide = function (b) {
              var c = this;
              w.clearTimeout(this.hideTimer);
              b = u(b, this.options.hideDelay);
              this.isHidden || (this.hideTimer = m(function () {
                c.getLabel().fadeOut(b ? void 0 : b);
                c.isHidden = !0;
              }, b));
            };

            a.prototype.init = function (b, c) {
              this.chart = b;
              this.options = c;
              this.crosshairs = [];
              this.now = {
                x: 0,
                y: 0
              };
              this.isHidden = !0;
              this.split = c.split && !b.inverted && !b.polar;
              this.shared = c.shared || this.split;
              this.outside = u(c.outside, !(!b.scrollablePixelsX && !b.scrollablePixelsY));
            };

            a.prototype.shouldStickOnContact = function () {
              return !(this.followPointer || !this.options.stickOnContact);
            };

            a.prototype.isStickyOnContact = function () {
              return !(!this.shouldStickOnContact() || !this.inContact);
            };

            a.prototype.move = function (b, c, a, d) {
              var e = this,
                  f = e.now,
                  n = !1 !== e.options.animation && !e.isHidden && (1 < Math.abs(b - f.x) || 1 < Math.abs(c - f.y)),
                  g = e.followPointer || 1 < e.len;
              k(f, {
                x: n ? (2 * f.x + b) / 3 : b,
                y: n ? (f.y + c) / 2 : c,
                anchorX: g ? void 0 : n ? (2 * f.anchorX + a) / 3 : a,
                anchorY: g ? void 0 : n ? (f.anchorY + d) / 2 : d
              });
              e.getLabel().attr(f);
              e.drawTracker();
              n && (w.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                e && e.move(b, c, a, d);
              }, 32));
            };

            a.prototype.refresh = function (b, c) {
              var a = this.chart,
                  e = this.options,
                  d = E(b),
                  f = d[0],
                  g = [],
                  m = e.formatter || this.defaultFormatter,
                  q = this.shared,
                  k = a.styledMode,
                  h = {};

              if (e.enabled) {
                w.clearTimeout(this.hideTimer);
                this.followPointer = !this.split && f.series.tooltipOptions.followPointer;
                var p = this.getAnchor(b, c),
                    l = p[0],
                    B = p[1];
                !q || !G(b) && b.series && b.series.noSharedTooltip ? h = f.getLabelConfig() : (a.pointer.applyInactiveState(d), d.forEach(function (c) {
                  c.setState("hover");
                  g.push(c.getLabelConfig());
                }), h = {
                  x: f.category,
                  y: f.y
                }, h.points = g);
                this.len = g.length;
                b = m.call(h, this);
                m = f.series;
                this.distance = u(m.tooltipOptions.distance, 16);
                if (!1 === b) this.hide();else {
                  if (this.split) this.renderSplit(b, d);else if (d = l, q = B, c && a.pointer.isDirectTouch && (d = c.chartX - a.plotLeft, q = c.chartY - a.plotTop), a.polar || !1 === m.options.clip || m.shouldShowTooltip(d, q)) c = this.getLabel(), e.style.width && !k || c.css({
                    width: this.chart.spacingBox.width + "px"
                  }), c.attr({
                    text: b && b.join ? b.join("") : b
                  }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + u(f.colorIndex, m.colorIndex)), k || c.attr({
                    stroke: e.borderColor || f.color || m.color || A.neutralColor60
                  }), this.updatePosition({
                    plotX: l,
                    plotY: B,
                    negative: f.negative,
                    ttBelow: f.ttBelow,
                    h: p[2] || 0
                  });else {
                    this.hide();
                    return;
                  }
                  this.isHidden && this.label && this.label.attr({
                    opacity: 1
                  }).show();
                  this.isHidden = !1;
                }
                J(this, "refresh");
              }
            };

            a.prototype.renderSplit = function (b, c) {
              function a(c, b, a, f, n) {
                void 0 === n && (n = !0);
                a ? (b = Y ? 0 : I, c = d(c - f / 2, P.left, P.right - f - (e.outside ? Q : 0))) : (b -= da, c = n ? c - f - J : c + J, c = d(c, n ? c : P.left, P.right));
                return {
                  x: c,
                  y: b
                };
              }

              var e = this,
                  f = e.chart,
                  g = e.chart,
                  m = g.chartWidth,
                  q = g.chartHeight,
                  h = g.plotHeight,
                  p = g.plotLeft,
                  x = g.plotTop,
                  E = g.pointer,
                  r = g.scrollablePixelsY;
              r = void 0 === r ? 0 : r;
              var G = g.scrollablePixelsX,
                  w = g.scrollingContainer;
              w = void 0 === w ? {
                scrollLeft: 0,
                scrollTop: 0
              } : w;
              var v = w.scrollLeft;
              w = w.scrollTop;
              var D = g.styledMode,
                  J = e.distance,
                  K = e.options,
                  U = e.options.positioner,
                  P = e.outside && "number" !== typeof G ? t.documentElement.getBoundingClientRect() : {
                left: v,
                right: v + m,
                top: w,
                bottom: w + q
              },
                  y = e.getLabel(),
                  z = this.renderer || f.renderer,
                  Y = !(!f.xAxis[0] || !f.xAxis[0].opposite);
              f = E.getChartPosition();
              var Q = f.left;
              f = f.top;
              var da = x + w,
                  ea = 0,
                  I = h - r;
              B(b) && (b = [!1, b]);
              b = b.slice(0, c.length + 1).reduce(function (b, f, n) {
                if (!1 !== f && "" !== f) {
                  n = c[n - 1] || {
                    isHeader: !0,
                    plotX: c[0].plotX,
                    plotY: h,
                    series: {}
                  };
                  var g = n.isHeader,
                      m = g ? e : n.series;
                  f = f.toString();
                  var q = m.tt,
                      k = n.isHeader;
                  var C = n.series;
                  var l = "highcharts-color-" + u(n.colorIndex, C.colorIndex, "none");
                  q || (q = {
                    padding: K.padding,
                    r: K.borderRadius
                  }, D || (q.fill = K.backgroundColor, q["stroke-width"] = K.borderWidth), q = z.label("", 0, 0, K[k ? "headerShape" : "shape"], void 0, void 0, K.useHTML).addClass((k ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + l).attr(q).add(y));
                  q.isActive = !0;
                  q.attr({
                    text: f
                  });
                  D || q.css(K.style).shadow(K.shadow).attr({
                    stroke: K.borderColor || n.color || C.color || A.neutralColor80
                  });
                  m = m.tt = q;
                  k = m.getBBox();
                  f = k.width + m.strokeWidth();
                  g && (ea = k.height, I += ea, Y && (da -= ea));
                  C = n.plotX;
                  C = void 0 === C ? 0 : C;
                  l = n.plotY;
                  l = void 0 === l ? 0 : l;
                  q = n.series;

                  if (n.isHeader) {
                    C = p + C;
                    var H = x + h / 2;
                  } else {
                    var B = q.xAxis,
                        F = q.yAxis;
                    C = B.pos + d(C, -J, B.len + J);
                    q.shouldShowTooltip(0, F.pos - x + l, {
                      ignoreX: !0
                    }) && (H = F.pos + l);
                  }

                  C = d(C, P.left - J, P.right + J);
                  "number" === typeof H ? (k = k.height + 1, l = U ? U.call(e, f, k, n) : a(C, H, g, f), b.push({
                    align: U ? 0 : void 0,
                    anchorX: C,
                    anchorY: H,
                    boxWidth: f,
                    point: n,
                    rank: u(l.rank, g ? 1 : 0),
                    size: k,
                    target: l.y,
                    tt: m,
                    x: l.x
                  })) : m.isActive = !1;
                }

                return b;
              }, []);
              !U && b.some(function (c) {
                var b = (e.outside ? Q : 0) + c.anchorX;
                return b < P.left && b + c.boxWidth < P.right ? !0 : b < Q - P.left + c.boxWidth && P.right - b > b;
              }) && (b = b.map(function (c) {
                var b = a(c.anchorX, c.anchorY, c.point.isHeader, c.boxWidth, !1);
                return k(c, {
                  target: b.y,
                  x: b.x
                });
              }));
              e.cleanSplit();
              l(b, I);
              var ca = Q,
                  fa = Q;
              b.forEach(function (c) {
                var b = c.x,
                    a = c.boxWidth;
                c = c.isHeader;
                c || (e.outside && Q + b < ca && (ca = Q + b), !c && e.outside && ca + a > fa && (fa = Q + b));
              });
              b.forEach(function (c) {
                var b = c.x,
                    a = c.anchorX,
                    d = c.pos,
                    f = c.point.isHeader;
                d = {
                  visibility: "undefined" === typeof d ? "hidden" : "inherit",
                  x: b,
                  y: d + da,
                  anchorX: a,
                  anchorY: c.anchorY
                };

                if (e.outside && b < a) {
                  var n = Q - ca;
                  0 < n && (f || (d.x = b + n, d.anchorX = a + n), f && (d.x = (fa - ca) / 2, d.anchorX = a + n));
                }

                c.tt.attr(d);
              });
              b = e.container;
              r = e.renderer;
              e.outside && b && r && (g = y.getBBox(), r.setSize(g.width + g.x, g.height + g.y, !1), b.style.left = ca + "px", b.style.top = f + "px");
            };

            a.prototype.drawTracker = function () {
              if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
                var b = this.chart,
                    c = this.label,
                    a = this.shared ? b.hoverPoints : b.hoverPoint;

                if (c && a) {
                  var d = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                  };
                  a = this.getAnchor(a);
                  var f = c.getBBox();
                  a[0] += b.plotLeft - c.translateX;
                  a[1] += b.plotTop - c.translateY;
                  d.x = Math.min(0, a[0]);
                  d.y = Math.min(0, a[1]);
                  d.width = 0 > a[0] ? Math.max(Math.abs(a[0]), f.width - a[0]) : Math.max(Math.abs(a[0]), f.width);
                  d.height = 0 > a[1] ? Math.max(Math.abs(a[1]), f.height - Math.abs(a[1])) : Math.max(Math.abs(a[1]), f.height);
                  this.tracker ? this.tracker.attr(d) : (this.tracker = c.renderer.rect(d).addClass("highcharts-tracker").add(c), b.styledMode || this.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                  }));
                }
              }
            };

            a.prototype.styledModeFormat = function (b) {
              return b.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            };

            a.prototype.tooltipFooterHeaderFormatter = function (b, c) {
              var a = b.series,
                  e = a.tooltipOptions,
                  d = a.xAxis,
                  g = d && d.dateTime;
              d = {
                isFooter: c,
                labelConfig: b
              };
              var m = e.xDateFormat,
                  q = e[c ? "footerFormat" : "headerFormat"];
              J(this, "headerFormatter", d, function (c) {
                g && !m && f(b.key) && (m = g.getXDateFormat(b.key, e.dateTimeLabelFormats));
                g && m && (b.point && b.point.tooltipDateKeys || ["key"]).forEach(function (c) {
                  q = q.replace("{point." + c + "}", "{point." + c + ":" + m + "}");
                });
                a.chart.styledMode && (q = this.styledModeFormat(q));
                c.text = r(q, {
                  point: b,
                  series: a
                }, this.chart);
              });
              return d.text;
            };

            a.prototype.update = function (b) {
              this.destroy();
              x(!0, this.chart.options.tooltip.userOptions, b);
              this.init(this.chart, x(!0, this.options, b));
            };

            a.prototype.updatePosition = function (a) {
              var c = this.chart,
                  e = this.options,
                  d = c.pointer,
                  f = this.getLabel();
              d = d.getChartPosition();
              var g = (e.positioner || this.getPosition).call(this, f.width, f.height, a),
                  m = a.plotX + c.plotLeft;
              a = a.plotY + c.plotTop;

              if (this.outside) {
                e = e.borderWidth + 2 * this.distance;
                this.renderer.setSize(f.width + e, f.height + e, !1);
                if (1 !== d.scaleX || 1 !== d.scaleY) b(this.container, {
                  transform: "scale(" + d.scaleX + ", " + d.scaleY + ")"
                }), m *= d.scaleX, a *= d.scaleY;
                m += d.left - g.x;
                a += d.top - g.y;
              }

              this.move(Math.round(g.x), Math.round(g.y || 0), m, a);
            };

            return a;
          }();

          "";
          return a;
        });
        I(a, "Core/Series/Point.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function (a, v, A, y, z) {
          var r = v.animObject,
              D = A.defaultOptions,
              t = y.format,
              l = z.addEvent,
              h = z.defined,
              d = z.erase,
              b = z.extend,
              g = z.fireEvent,
              p = z.getNestedProperty,
              k = z.isArray,
              J = z.isFunction,
              G = z.isNumber,
              f = z.isObject,
              B = z.merge,
              x = z.objectEach,
              u = z.pick,
              E = z.syncTimeout,
              m = z.removeEvent,
              q = z.uniqueKey;

          v = function () {
            function e() {
              this.colorIndex = this.category = void 0;
              this.formatPrefix = "point";
              this.id = void 0;
              this.isNull = !1;
              this.percentage = this.options = this.name = void 0;
              this.selected = !1;
              this.total = this.series = void 0;
              this.visible = !0;
              this.x = void 0;
            }

            e.prototype.animateBeforeDestroy = function () {
              var c = this,
                  a = {
                x: c.startXPos,
                opacity: 0
              },
                  e = c.getGraphicalProps();
              e.singular.forEach(function (b) {
                c[b] = c[b].animate("dataLabel" === b ? {
                  x: c[b].startXPos,
                  y: c[b].startYPos,
                  opacity: 0
                } : a);
              });
              e.plural.forEach(function (a) {
                c[a].forEach(function (a) {
                  a.element && a.animate(b({
                    x: c.startXPos
                  }, a.startYPos ? {
                    x: a.startXPos,
                    y: a.startYPos
                  } : {}));
                });
              });
            };

            e.prototype.applyOptions = function (c, a) {
              var d = this.series,
                  f = d.options.pointValKey || d.pointValKey;
              c = e.prototype.optionsToObject.call(this, c);
              b(this, c);
              this.options = this.options ? b(this.options, c) : c;
              c.group && delete this.group;
              c.dataLabels && delete this.dataLabels;
              f && (this.y = e.prototype.getNestedProperty.call(this, f));
              this.formatPrefix = (this.isNull = u(this.isValid && !this.isValid(), null === this.x || !G(this.y))) ? "null" : "point";
              this.selected && (this.state = "select");
              "name" in this && "undefined" === typeof a && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
              "undefined" === typeof this.x && d ? this.x = "undefined" === typeof a ? d.autoIncrement() : a : G(c.x) && d.options.relativeXValue && (this.x = d.autoIncrement(c.x));
              return this;
            };

            e.prototype.destroy = function () {
              function c() {
                if (b.graphic || b.dataLabel || b.dataLabels) m(b), b.destroyElements();

                for (q in b) {
                  b[q] = null;
                }
              }

              var b = this,
                  a = b.series,
                  e = a.chart;
              a = a.options.dataSorting;
              var f = e.hoverPoints,
                  g = r(b.series.chart.renderer.globalAnimation),
                  q;
              b.legendItem && e.legend.destroyItem(b);
              f && (b.setState(), d(f, b), f.length || (e.hoverPoints = null));
              if (b === e.hoverPoint) b.onMouseOut();
              a && a.enabled ? (this.animateBeforeDestroy(), E(c, g.duration)) : c();
              e.pointCount--;
            };

            e.prototype.destroyElements = function (c) {
              var b = this;
              c = b.getGraphicalProps(c);
              c.singular.forEach(function (c) {
                b[c] = b[c].destroy();
              });
              c.plural.forEach(function (c) {
                b[c].forEach(function (c) {
                  c.element && c.destroy();
                });
                delete b[c];
              });
            };

            e.prototype.firePointEvent = function (c, b, a) {
              var e = this,
                  d = this.series.options;
              (d.point.events[c] || e.options && e.options.events && e.options.events[c]) && e.importEvents();
              "click" === c && d.allowPointSelect && (a = function a(c) {
                e.select && e.select(null, c.ctrlKey || c.metaKey || c.shiftKey);
              });
              g(e, c, b, a);
            };

            e.prototype.getClassName = function () {
              return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            };

            e.prototype.getGraphicalProps = function (c) {
              var b = this,
                  a = [],
                  e = {
                singular: [],
                plural: []
              },
                  d;
              c = c || {
                graphic: 1,
                dataLabel: 1
              };
              c.graphic && a.push("graphic", "upperGraphic", "shadowGroup");
              c.dataLabel && a.push("dataLabel", "dataLabelUpper", "connector");

              for (d = a.length; d--;) {
                var f = a[d];
                b[f] && e.singular.push(f);
              }

              ["dataLabel", "connector"].forEach(function (a) {
                var d = a + "s";
                c[a] && b[d] && e.plural.push(d);
              });
              return e;
            };

            e.prototype.getLabelConfig = function () {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
              };
            };

            e.prototype.getNestedProperty = function (c) {
              if (c) return 0 === c.indexOf("custom.") ? p(c, this.options) : this[c];
            };

            e.prototype.getZone = function () {
              var c = this.series,
                  b = c.zones;
              c = c.zoneAxis || "y";
              var a,
                  e = 0;

              for (a = b[e]; this[c] >= a.value;) {
                a = b[++e];
              }

              this.nonZonedColor || (this.nonZonedColor = this.color);
              this.color = a && a.color && !this.options.color ? a.color : this.nonZonedColor;
              return a;
            };

            e.prototype.hasNewShapeType = function () {
              return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            };

            e.prototype.init = function (c, b, a) {
              this.series = c;
              this.applyOptions(b, a);
              this.id = h(this.id) ? this.id : q();
              this.resolveColor();
              c.chart.pointCount++;
              g(this, "afterInit");
              return this;
            };

            e.prototype.optionsToObject = function (c) {
              var b = this.series,
                  a = b.options.keys,
                  d = a || b.pointArrayMap || ["y"],
                  f = d.length,
                  g = {},
                  m = 0,
                  q = 0;
              if (G(c) || null === c) g[d[0]] = c;else if (k(c)) for (!a && c.length > f && (b = typeof c[0], "string" === b ? g.name = c[0] : "number" === b && (g.x = c[0]), m++); q < f;) {
                a && "undefined" === typeof c[m] || (0 < d[q].indexOf(".") ? e.prototype.setNestedProperty(g, c[m], d[q]) : g[d[q]] = c[m]), m++, q++;
              } else "object" === typeof c && (g = c, c.dataLabels && (b._hasPointLabels = !0), c.marker && (b._hasPointMarkers = !0));
              return g;
            };

            e.prototype.resolveColor = function () {
              var c = this.series,
                  b = c.chart.styledMode;
              var a = c.chart.options.chart.colorCount;
              delete this.nonZonedColor;

              if (c.options.colorByPoint) {
                if (!b) {
                  a = c.options.colors || c.chart.options.colors;
                  var e = a[c.colorCounter];
                  a = a.length;
                }

                b = c.colorCounter;
                c.colorCounter++;
                c.colorCounter === a && (c.colorCounter = 0);
              } else b || (e = c.color), b = c.colorIndex;

              this.colorIndex = u(this.options.colorIndex, b);
              this.color = u(this.options.color, e);
            };

            e.prototype.setNestedProperty = function (c, b, a) {
              a.split(".").reduce(function (c, a, e, d) {
                c[a] = d.length - 1 === e ? b : f(c[a], !0) ? c[a] : {};
                return c[a];
              }, c);
              return c;
            };

            e.prototype.tooltipFormatter = function (c) {
              var b = this.series,
                  a = b.tooltipOptions,
                  e = u(a.valueDecimals, ""),
                  d = a.valuePrefix || "",
                  f = a.valueSuffix || "";
              b.chart.styledMode && (c = b.chart.tooltip.styledModeFormat(c));
              (b.pointArrayMap || ["y"]).forEach(function (b) {
                b = "{point." + b;
                if (d || f) c = c.replace(RegExp(b + "}", "g"), d + b + "}" + f);
                c = c.replace(RegExp(b + "}", "g"), b + ":,." + e + "f}");
              });
              return t(c, {
                point: this,
                series: this.series
              }, b.chart);
            };

            e.prototype.update = function (c, b, a, e) {
              function d() {
                g.applyOptions(c);
                var e = m && g.hasDummyGraphic;
                e = null === g.y ? !e : e;
                m && e && (g.graphic = m.destroy(), delete g.hasDummyGraphic);
                f(c, !0) && (m && m.element && c && c.marker && "undefined" !== typeof c.marker.symbol && (g.graphic = m.destroy()), c && c.dataLabels && g.dataLabel && (g.dataLabel = g.dataLabel.destroy()), g.connector && (g.connector = g.connector.destroy()));
                h = g.index;
                n.updateParallelArrays(g, h);
                k.data[h] = f(k.data[h], !0) || f(c, !0) ? g.options : u(c, k.data[h]);
                n.isDirty = n.isDirtyData = !0;
                !n.fixedBox && n.hasCartesianSeries && (q.isDirtyBox = !0);
                "point" === k.legendType && (q.isDirtyLegend = !0);
                b && q.redraw(a);
              }

              var g = this,
                  n = g.series,
                  m = g.graphic,
                  q = n.chart,
                  k = n.options,
                  h;
              b = u(b, !0);
              !1 === e ? d() : g.firePointEvent("update", {
                options: c
              }, d);
            };

            e.prototype.remove = function (c, b) {
              this.series.removePoint(this.series.data.indexOf(this), c, b);
            };

            e.prototype.select = function (c, b) {
              var a = this,
                  e = a.series,
                  d = e.chart;
              this.selectedStaging = c = u(c, !a.selected);
              a.firePointEvent(c ? "select" : "unselect", {
                accumulate: b
              }, function () {
                a.selected = a.options.selected = c;
                e.options.data[e.data.indexOf(a)] = a.options;
                a.setState(c && "select");
                b || d.getSelectedPoints().forEach(function (c) {
                  var b = c.series;
                  c.selected && c !== a && (c.selected = c.options.selected = !1, b.options.data[b.data.indexOf(c)] = c.options, c.setState(d.hoverPoints && b.options.inactiveOtherPoints ? "inactive" : ""), c.firePointEvent("unselect"));
                });
              });
              delete this.selectedStaging;
            };

            e.prototype.onMouseOver = function (c) {
              var b = this.series.chart,
                  a = b.pointer;
              c = c ? a.normalize(c) : a.getChartCoordinatesFromPoint(this, b.inverted);
              a.runPointActions(c, this);
            };

            e.prototype.onMouseOut = function () {
              var c = this.series.chart;
              this.firePointEvent("mouseOut");
              this.series.options.inactiveOtherPoints || (c.hoverPoints || []).forEach(function (c) {
                c.setState();
              });
              c.hoverPoints = c.hoverPoint = null;
            };

            e.prototype.importEvents = function () {
              if (!this.hasImportedEvents) {
                var c = this,
                    b = B(c.series.options.point, c.options).events;
                c.events = b;
                x(b, function (b, a) {
                  J(b) && l(c, a, b);
                });
                this.hasImportedEvents = !0;
              }
            };

            e.prototype.setState = function (c, e) {
              var d = this.series,
                  f = this.state,
                  n = d.options.states[c || "normal"] || {},
                  m = D.plotOptions[d.type].marker && d.options.marker,
                  q = m && !1 === m.enabled,
                  k = m && m.states && m.states[c || "normal"] || {},
                  h = !1 === k.enabled,
                  p = this.marker || {},
                  l = d.chart,
                  B = m && d.markerAttribs,
                  x = d.halo,
                  E,
                  r = d.stateMarkerGraphic;
              c = c || "";

              if (!(c === this.state && !e || this.selected && "select" !== c || !1 === n.enabled || c && (h || q && !1 === k.enabled) || c && p.states && p.states[c] && !1 === p.states[c].enabled)) {
                this.state = c;
                B && (E = d.markerAttribs(this, c));

                if (this.graphic && !this.hasDummyGraphic) {
                  f && this.graphic.removeClass("highcharts-point-" + f);
                  c && this.graphic.addClass("highcharts-point-" + c);

                  if (!l.styledMode) {
                    var t = d.pointAttribs(this, c);
                    var w = u(l.options.chart.animation, n.animation);
                    d.options.inactiveOtherPoints && G(t.opacity) && ((this.dataLabels || []).forEach(function (c) {
                      c && c.animate({
                        opacity: t.opacity
                      }, w);
                    }), this.connector && this.connector.animate({
                      opacity: t.opacity
                    }, w));
                    this.graphic.animate(t, w);
                  }

                  E && this.graphic.animate(E, u(l.options.chart.animation, k.animation, m.animation));
                  r && r.hide();
                } else {
                  if (c && k) {
                    f = p.symbol || d.symbol;
                    r && r.currentSymbol !== f && (r = r.destroy());
                    if (E) if (r) r[e ? "animate" : "attr"]({
                      x: E.x,
                      y: E.y
                    });else f && (d.stateMarkerGraphic = r = l.renderer.symbol(f, E.x, E.y, E.width, E.height).add(d.markerGroup), r.currentSymbol = f);
                    !l.styledMode && r && r.attr(d.pointAttribs(this, c));
                  }

                  r && (r[c && this.isInside ? "show" : "hide"](), r.element.point = this, r.addClass(this.getClassName(), !0));
                }

                n = n.halo;
                E = (r = this.graphic || r) && r.visibility || "inherit";
                n && n.size && r && "hidden" !== E && !this.isCluster ? (x || (d.halo = x = l.renderer.path().add(r.parentGroup)), x.show()[e ? "animate" : "attr"]({
                  d: this.haloPath(n.size)
                }), x.attr({
                  "class": "highcharts-halo highcharts-color-" + u(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
                  visibility: E,
                  zIndex: -1
                }), x.point = this, l.styledMode || x.attr(b({
                  fill: this.color || d.color,
                  "fill-opacity": n.opacity
                }, a.filterUserAttributes(n.attributes || {})))) : x && x.point && x.point.haloPath && x.animate({
                  d: x.point.haloPath(0)
                }, null, x.hide);
                g(this, "afterSetState", {
                  state: c
                });
              }
            };

            e.prototype.haloPath = function (c) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - c, this.plotY - c, 2 * c, 2 * c);
            };

            return e;
          }();

          "";
          return v;
        });
        I(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Tooltip.js"], a["Core/Utilities.js"]], function (a, v, A, y, z) {
          var r = a.parse,
              D = v.charts,
              t = v.noop,
              l = z.addEvent,
              h = z.attr,
              d = z.css,
              b = z.defined,
              g = z.extend,
              p = z.find,
              k = z.fireEvent,
              J = z.isNumber,
              G = z.isObject,
              f = z.objectEach,
              B = z.offset,
              x = z.pick,
              u = z.splat;

          a = function () {
            function a(b, a) {
              this.lastValidTouch = {};
              this.pinchDown = [];
              this.runChartClick = !1;
              this.eventsToUnbind = [];
              this.chart = b;
              this.hasDragged = !1;
              this.options = a;
              this.init(b, a);
            }

            a.prototype.applyInactiveState = function (b) {
              var a = [],
                  e;
              (b || []).forEach(function (c) {
                e = c.series;
                a.push(e);
                e.linkedParent && a.push(e.linkedParent);
                e.linkedSeries && (a = a.concat(e.linkedSeries));
                e.navigatorSeries && a.push(e.navigatorSeries);
              });
              this.chart.series.forEach(function (c) {
                -1 === a.indexOf(c) ? c.setState("inactive", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState("inactive");
              });
            };

            a.prototype.destroy = function () {
              var b = this;
              this.eventsToUnbind.forEach(function (b) {
                return b();
              });
              this.eventsToUnbind = [];
              v.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
              clearInterval(b.tooltipTimeout);
              f(b, function (a, e) {
                b[e] = void 0;
              });
            };

            a.prototype.drag = function (b) {
              var a = this.chart,
                  e = a.options.chart,
                  c = this.zoomHor,
                  d = this.zoomVert,
                  f = a.plotLeft,
                  g = a.plotTop,
                  m = a.plotWidth,
                  k = a.plotHeight,
                  h = this.mouseDownX || 0,
                  u = this.mouseDownY || 0,
                  p = G(e.panning) ? e.panning && e.panning.enabled : e.panning,
                  l = e.panKey && b[e.panKey + "Key"],
                  B = b.chartX,
                  x = b.chartY,
                  t = this.selectionMarker;
              if (!t || !t.touch) if (B < f ? B = f : B > f + m && (B = f + m), x < g ? x = g : x > g + k && (x = g + k), this.hasDragged = Math.sqrt(Math.pow(h - B, 2) + Math.pow(u - x, 2)), 10 < this.hasDragged) {
                var E = a.isInsidePlot(h - f, u - g, {
                  visiblePlotOnly: !0
                });
                a.hasCartesianSeries && (this.zoomX || this.zoomY) && E && !l && !t && (this.selectionMarker = t = a.renderer.rect(f, g, c ? 1 : m, d ? 1 : k, 0).attr({
                  "class": "highcharts-selection-marker",
                  zIndex: 7
                }).add(), a.styledMode || t.attr({
                  fill: e.selectionMarkerFill || r(A.highlightColor80).setOpacity(.25).get()
                }));
                t && c && (c = B - h, t.attr({
                  width: Math.abs(c),
                  x: (0 < c ? 0 : c) + h
                }));
                t && d && (c = x - u, t.attr({
                  height: Math.abs(c),
                  y: (0 < c ? 0 : c) + u
                }));
                E && !t && p && a.pan(b, e.panning);
              }
            };

            a.prototype.dragStart = function (b) {
              var a = this.chart;
              a.mouseIsDown = b.type;
              a.cancelClick = !1;
              a.mouseDownX = this.mouseDownX = b.chartX;
              a.mouseDownY = this.mouseDownY = b.chartY;
            };

            a.prototype.drop = function (a) {
              var f = this,
                  e = this.chart,
                  c = this.hasPinched;

              if (this.selectionMarker) {
                var n = {
                  originalEvent: a,
                  xAxis: [],
                  yAxis: []
                },
                    m = this.selectionMarker,
                    h = m.attr ? m.attr("x") : m.x,
                    u = m.attr ? m.attr("y") : m.y,
                    p = m.attr ? m.attr("width") : m.width,
                    l = m.attr ? m.attr("height") : m.height,
                    B;
                if (this.hasDragged || c) e.axes.forEach(function (e) {
                  if (e.zoomEnabled && b(e.min) && (c || f[{
                    xAxis: "zoomX",
                    yAxis: "zoomY"
                  }[e.coll]]) && J(h) && J(u)) {
                    var d = e.horiz,
                        g = "touchend" === a.type ? e.minPixelPadding : 0,
                        m = e.toValue((d ? h : u) + g);
                    d = e.toValue((d ? h + p : u + l) - g);
                    n[e.coll].push({
                      axis: e,
                      min: Math.min(m, d),
                      max: Math.max(m, d)
                    });
                    B = !0;
                  }
                }), B && k(e, "selection", n, function (b) {
                  e.zoom(g(b, c ? {
                    animation: !1
                  } : null));
                });
                J(e.index) && (this.selectionMarker = this.selectionMarker.destroy());
                c && this.scaleGroups();
              }

              e && J(e.index) && (d(e.container, {
                cursor: e._cursor
              }), e.cancelClick = 10 < this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
            };

            a.prototype.findNearestKDPoint = function (b, a, e) {
              var c = this.chart,
                  d = c.hoverPoint;
              c = c.tooltip;
              if (d && c && c.isStickyOnContact()) return d;
              var f;
              b.forEach(function (c) {
                var b = !(c.noSharedTooltip && a) && 0 > c.options.findNearestPointBy.indexOf("y");
                c = c.searchPoint(e, b);

                if ((b = G(c, !0) && c.series) && !(b = !G(f, !0))) {
                  b = f.distX - c.distX;
                  var d = f.dist - c.dist,
                      g = (c.series.group && c.series.group.zIndex) - (f.series.group && f.series.group.zIndex);
                  b = 0 < (0 !== b && a ? b : 0 !== d ? d : 0 !== g ? g : f.series.index > c.series.index ? -1 : 1);
                }

                b && (f = c);
              });
              return f;
            };

            a.prototype.getChartCoordinatesFromPoint = function (b, a) {
              var e = b.series,
                  c = e.xAxis;
              e = e.yAxis;
              var d = b.shapeArgs;

              if (c && e) {
                var f = x(b.clientX, b.plotX),
                    g = b.plotY || 0;
                b.isNode && d && J(d.x) && J(d.y) && (f = d.x, g = d.y);
                return a ? {
                  chartX: e.len + e.pos - g,
                  chartY: c.len + c.pos - f
                } : {
                  chartX: f + c.pos,
                  chartY: g + e.pos
                };
              }

              if (d && d.x && d.y) return {
                chartX: d.x,
                chartY: d.y
              };
            };

            a.prototype.getChartPosition = function () {
              if (this.chartPosition) return this.chartPosition;
              var b = this.chart.container,
                  a = B(b);
              this.chartPosition = {
                left: a.left,
                top: a.top,
                scaleX: 1,
                scaleY: 1
              };
              var e = b.offsetWidth;
              b = b.offsetHeight;
              2 < e && 2 < b && (this.chartPosition.scaleX = a.width / e, this.chartPosition.scaleY = a.height / b);
              return this.chartPosition;
            };

            a.prototype.getCoordinates = function (b) {
              var a = {
                xAxis: [],
                yAxis: []
              };
              this.chart.axes.forEach(function (e) {
                a[e.isXAxis ? "xAxis" : "yAxis"].push({
                  axis: e,
                  value: e.toValue(b[e.horiz ? "chartX" : "chartY"])
                });
              });
              return a;
            };

            a.prototype.getHoverData = function (b, a, e, c, d, f) {
              var g = [];
              c = !(!c || !b);
              var n = {
                chartX: f ? f.chartX : void 0,
                chartY: f ? f.chartY : void 0,
                shared: d
              };
              k(this, "beforeGetHoverData", n);
              var m = a && !a.stickyTracking ? [a] : e.filter(function (c) {
                return n.filter ? n.filter(c) : c.visible && !(!d && c.directTouch) && x(c.options.enableMouseTracking, !0) && c.stickyTracking;
              });
              var q = c || !f ? b : this.findNearestKDPoint(m, d, f);
              a = q && q.series;
              q && (d && !a.noSharedTooltip ? (m = e.filter(function (c) {
                return n.filter ? n.filter(c) : c.visible && !(!d && c.directTouch) && x(c.options.enableMouseTracking, !0) && !c.noSharedTooltip;
              }), m.forEach(function (c) {
                var b = p(c.points, function (c) {
                  return c.x === q.x && !c.isNull;
                });
                G(b) && (c.chart.isBoosting && (b = c.getPoint(b)), g.push(b));
              })) : g.push(q));
              n = {
                hoverPoint: q
              };
              k(this, "afterGetHoverData", n);
              return {
                hoverPoint: n.hoverPoint,
                hoverSeries: a,
                hoverPoints: g
              };
            };

            a.prototype.getPointFromEvent = function (b) {
              b = b.target;

              for (var a; b && !a;) {
                a = b.point, b = b.parentNode;
              }

              return a;
            };

            a.prototype.onTrackerMouseOut = function (b) {
              b = b.relatedTarget || b.toElement;
              var a = this.chart.hoverSeries;
              this.isDirectTouch = !1;
              if (!(!a || !b || a.stickyTracking || this.inClass(b, "highcharts-tooltip") || this.inClass(b, "highcharts-series-" + a.index) && this.inClass(b, "highcharts-tracker"))) a.onMouseOut();
            };

            a.prototype.inClass = function (b, a) {
              for (var e; b;) {
                if (e = h(b, "class")) {
                  if (-1 !== e.indexOf(a)) return !0;
                  if (-1 !== e.indexOf("highcharts-container")) return !1;
                }

                b = b.parentNode;
              }
            };

            a.prototype.init = function (b, a) {
              this.options = a;
              this.chart = b;
              this.runChartClick = !(!a.chart.events || !a.chart.events.click);
              this.pinchDown = [];
              this.lastValidTouch = {};
              y && (b.tooltip = new y(b, a.tooltip), this.followTouchMove = x(a.tooltip.followTouchMove, !0));
              this.setDOMEvents();
            };

            a.prototype.normalize = function (b, a) {
              var e = b.touches,
                  c = e ? e.length ? e.item(0) : x(e.changedTouches, b.changedTouches)[0] : b;
              a || (a = this.getChartPosition());
              e = c.pageX - a.left;
              c = c.pageY - a.top;
              e /= a.scaleX;
              c /= a.scaleY;
              return g(b, {
                chartX: Math.round(e),
                chartY: Math.round(c)
              });
            };

            a.prototype.onContainerClick = function (b) {
              var a = this.chart,
                  e = a.hoverPoint;
              b = this.normalize(b);
              var c = a.plotLeft,
                  d = a.plotTop;
              a.cancelClick || (e && this.inClass(b.target, "highcharts-tracker") ? (k(e.series, "click", g(b, {
                point: e
              })), a.hoverPoint && e.firePointEvent("click", b)) : (g(b, this.getCoordinates(b)), a.isInsidePlot(b.chartX - c, b.chartY - d, {
                visiblePlotOnly: !0
              }) && k(a, "click", b)));
            };

            a.prototype.onContainerMouseDown = function (b) {
              var a = 1 === ((b.buttons || b.button) & 1);
              b = this.normalize(b);
              if (v.isFirefox && 0 !== b.button) this.onContainerMouseMove(b);
              if ("undefined" === typeof b.button || a) this.zoomOption(b), a && b.preventDefault && b.preventDefault(), this.dragStart(b);
            };

            a.prototype.onContainerMouseLeave = function (b) {
              var d = D[x(a.hoverChartIndex, -1)],
                  e = this.chart.tooltip;
              e && e.shouldStickOnContact() && this.inClass(b.relatedTarget, "highcharts-tooltip-container") || (b = this.normalize(b), d && (b.relatedTarget || b.toElement) && (d.pointer.reset(), d.pointer.chartPosition = void 0), e && !e.isHidden && this.reset());
            };

            a.prototype.onContainerMouseEnter = function (b) {
              delete this.chartPosition;
            };

            a.prototype.onContainerMouseMove = function (b) {
              var a = this.chart;
              b = this.normalize(b);
              this.setHoverChartIndex();
              b.preventDefault || (b.returnValue = !1);
              ("mousedown" === a.mouseIsDown || this.touchSelect(b)) && this.drag(b);
              a.openMenu || !this.inClass(b.target, "highcharts-tracker") && !a.isInsidePlot(b.chartX - a.plotLeft, b.chartY - a.plotTop, {
                visiblePlotOnly: !0
              }) || (this.inClass(b.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(b));
            };

            a.prototype.onDocumentTouchEnd = function (b) {
              var d = D[x(a.hoverChartIndex, -1)];
              d && d.pointer.drop(b);
            };

            a.prototype.onContainerTouchMove = function (b) {
              if (this.touchSelect(b)) this.onContainerMouseMove(b);else this.touch(b);
            };

            a.prototype.onContainerTouchStart = function (b) {
              if (this.touchSelect(b)) this.onContainerMouseDown(b);else this.zoomOption(b), this.touch(b, !0);
            };

            a.prototype.onDocumentMouseMove = function (b) {
              var a = this.chart,
                  e = this.chartPosition;
              b = this.normalize(b, e);
              var c = a.tooltip;
              !e || c && c.isStickyOnContact() || a.isInsidePlot(b.chartX - a.plotLeft, b.chartY - a.plotTop, {
                visiblePlotOnly: !0
              }) || this.inClass(b.target, "highcharts-tracker") || this.reset();
            };

            a.prototype.onDocumentMouseUp = function (b) {
              var d = D[x(a.hoverChartIndex, -1)];
              d && d.pointer.drop(b);
            };

            a.prototype.pinch = function (b) {
              var a = this,
                  e = a.chart,
                  c = a.pinchDown,
                  d = b.touches || [],
                  f = d.length,
                  k = a.lastValidTouch,
                  h = a.hasZoom,
                  m = {},
                  u = 1 === f && (a.inClass(b.target, "highcharts-tracker") && e.runTrackerClick || a.runChartClick),
                  p = {},
                  l = a.selectionMarker;
              1 < f ? a.initiated = !0 : 1 === f && this.followTouchMove && (a.initiated = !1);
              h && a.initiated && !u && !1 !== b.cancelable && b.preventDefault();
              [].map.call(d, function (b) {
                return a.normalize(b);
              });
              "touchstart" === b.type ? ([].forEach.call(d, function (b, a) {
                c[a] = {
                  chartX: b.chartX,
                  chartY: b.chartY
                };
              }), k.x = [c[0].chartX, c[1] && c[1].chartX], k.y = [c[0].chartY, c[1] && c[1].chartY], e.axes.forEach(function (b) {
                if (b.zoomEnabled) {
                  var c = e.bounds[b.horiz ? "h" : "v"],
                      a = b.minPixelPadding,
                      d = b.toPixels(Math.min(x(b.options.min, b.dataMin), b.dataMin)),
                      f = b.toPixels(Math.max(x(b.options.max, b.dataMax), b.dataMax)),
                      g = Math.max(d, f);
                  c.min = Math.min(b.pos, Math.min(d, f) - a);
                  c.max = Math.max(b.pos + b.len, g + a);
                }
              }), a.res = !0) : a.followTouchMove && 1 === f ? this.runPointActions(a.normalize(b)) : c.length && (l || (a.selectionMarker = l = g({
                destroy: t,
                touch: !0
              }, e.plotBox)), a.pinchTranslate(c, d, m, l, p, k), a.hasPinched = h, a.scaleGroups(m, p), a.res && (a.res = !1, this.reset(!1, 0)));
            };

            a.prototype.pinchTranslate = function (b, a, e, c, d, f) {
              this.zoomHor && this.pinchTranslateDirection(!0, b, a, e, c, d, f);
              this.zoomVert && this.pinchTranslateDirection(!1, b, a, e, c, d, f);
            };

            a.prototype.pinchTranslateDirection = function (b, a, e, c, d, f, g, k) {
              var n = this.chart,
                  h = b ? "x" : "y",
                  m = b ? "X" : "Y",
                  q = "chart" + m,
                  u = b ? "width" : "height",
                  p = n["plot" + (b ? "Left" : "Top")],
                  l = n.inverted,
                  B = n.bounds[b ? "h" : "v"],
                  x = 1 === a.length,
                  C = a[0][q],
                  r = !x && a[1][q];

              a = function a() {
                "number" === typeof G && 20 < Math.abs(C - r) && (E = k || Math.abs(H - G) / Math.abs(C - r));
                K = (p - H) / E + C;
                t = n["plot" + (b ? "Width" : "Height")] / E;
              };

              var t,
                  K,
                  E = k || 1,
                  H = e[0][q],
                  G = !x && e[1][q];
              a();
              e = K;

              if (e < B.min) {
                e = B.min;
                var w = !0;
              } else e + t > B.max && (e = B.max - t, w = !0);

              w ? (H -= .8 * (H - g[h][0]), "number" === typeof G && (G -= .8 * (G - g[h][1])), a()) : g[h] = [H, G];
              l || (f[h] = K - p, f[u] = t);
              f = l ? 1 / E : E;
              d[u] = t;
              d[h] = e;
              c[l ? b ? "scaleY" : "scaleX" : "scale" + m] = E;
              c["translate" + m] = f * p + (H - f * C);
            };

            a.prototype.reset = function (b, a) {
              var e = this.chart,
                  c = e.hoverSeries,
                  d = e.hoverPoint,
                  f = e.hoverPoints,
                  g = e.tooltip,
                  k = g && g.shared ? f : d;
              b && k && u(k).forEach(function (c) {
                c.series.isCartesian && "undefined" === typeof c.plotX && (b = !1);
              });
              if (b) g && k && u(k).length && (g.refresh(k), g.shared && f ? f.forEach(function (b) {
                b.setState(b.state, !0);
                b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
              }) : d && (d.setState(d.state, !0), e.axes.forEach(function (b) {
                b.crosshair && d.series[b.coll] === b && b.drawCrosshair(null, d);
              })));else {
                if (d) d.onMouseOut();
                f && f.forEach(function (b) {
                  b.setState();
                });
                if (c) c.onMouseOut();
                g && g.hide(a);
                this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                e.axes.forEach(function (b) {
                  b.hideCrosshair();
                });
                this.hoverX = e.hoverPoints = e.hoverPoint = null;
              }
            };

            a.prototype.runPointActions = function (b, d) {
              var e = this.chart,
                  c = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,
                  f = c ? c.shared : !1,
                  g = d || e.hoverPoint,
                  k = g && g.series || e.hoverSeries;
              d = this.getHoverData(g, k, e.series, (!b || "touchmove" !== b.type) && (!!d || k && k.directTouch && this.isDirectTouch), f, b);
              g = d.hoverPoint;
              k = d.hoverSeries;
              var h = d.hoverPoints;
              d = k && k.tooltipOptions.followPointer && !k.tooltipOptions.split;
              f = f && k && !k.noSharedTooltip;

              if (g && (g !== e.hoverPoint || c && c.isHidden)) {
                (e.hoverPoints || []).forEach(function (b) {
                  -1 === h.indexOf(b) && b.setState();
                });
                if (e.hoverSeries !== k) k.onMouseOver();
                this.applyInactiveState(h);
                (h || []).forEach(function (b) {
                  b.setState("hover");
                });
                e.hoverPoint && e.hoverPoint.firePointEvent("mouseOut");
                if (!g.series) return;
                e.hoverPoints = h;
                e.hoverPoint = g;
                g.firePointEvent("mouseOver");
                c && c.refresh(f ? h : g, b);
              } else d && c && !c.isHidden && (g = c.getAnchor([{}], b), e.isInsidePlot(g[0], g[1], {
                visiblePlotOnly: !0
              }) && c.updatePosition({
                plotX: g[0],
                plotY: g[1]
              }));

              this.unDocMouseMove || (this.unDocMouseMove = l(e.container.ownerDocument, "mousemove", function (b) {
                var c = D[a.hoverChartIndex];
                if (c) c.pointer.onDocumentMouseMove(b);
              }), this.eventsToUnbind.push(this.unDocMouseMove));
              e.axes.forEach(function (c) {
                var a = x((c.crosshair || {}).snap, !0),
                    d;
                a && ((d = e.hoverPoint) && d.series[c.coll] === c || (d = p(h, function (b) {
                  return b.series[c.coll] === c;
                })));
                d || !a ? c.drawCrosshair(b, d) : c.hideCrosshair();
              });
            };

            a.prototype.scaleGroups = function (b, a) {
              var e = this.chart;
              e.series.forEach(function (c) {
                var d = b || c.getPlotBox();
                c.xAxis && c.xAxis.zoomEnabled && c.group && (c.group.attr(d), c.markerGroup && (c.markerGroup.attr(d), c.markerGroup.clip(a ? e.clipRect : null)), c.dataLabelsGroup && c.dataLabelsGroup.attr(d));
              });
              e.clipRect.attr(a || e.clipBox);
            };

            a.prototype.setDOMEvents = function () {
              var b = this,
                  d = this.chart.container,
                  e = d.ownerDocument;
              d.onmousedown = this.onContainerMouseDown.bind(this);
              d.onmousemove = this.onContainerMouseMove.bind(this);
              d.onclick = this.onContainerClick.bind(this);
              this.eventsToUnbind.push(l(d, "mouseenter", this.onContainerMouseEnter.bind(this)));
              this.eventsToUnbind.push(l(d, "mouseleave", this.onContainerMouseLeave.bind(this)));
              a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = l(e, "mouseup", this.onDocumentMouseUp.bind(this)));

              for (var c = this.chart.renderTo.parentElement; c && "BODY" !== c.tagName;) {
                this.eventsToUnbind.push(l(c, "scroll", function () {
                  delete b.chartPosition;
                })), c = c.parentElement;
              }

              v.hasTouch && (this.eventsToUnbind.push(l(d, "touchstart", this.onContainerTouchStart.bind(this), {
                passive: !1
              })), this.eventsToUnbind.push(l(d, "touchmove", this.onContainerTouchMove.bind(this), {
                passive: !1
              })), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = l(e, "touchend", this.onDocumentTouchEnd.bind(this), {
                passive: !1
              })));
            };

            a.prototype.setHoverChartIndex = function () {
              var b = this.chart,
                  d = v.charts[x(a.hoverChartIndex, -1)];
              if (d && d !== b) d.pointer.onContainerMouseLeave({
                relatedTarget: !0
              });
              d && d.mouseIsDown || (a.hoverChartIndex = b.index);
            };

            a.prototype.touch = function (b, a) {
              var e = this.chart,
                  c;
              this.setHoverChartIndex();
              if (1 === b.touches.length) {
                if (b = this.normalize(b), (c = e.isInsidePlot(b.chartX - e.plotLeft, b.chartY - e.plotTop, {
                  visiblePlotOnly: !0
                })) && !e.openMenu) {
                  a && this.runPointActions(b);

                  if ("touchmove" === b.type) {
                    a = this.pinchDown;
                    var d = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - b.chartX, 2) + Math.pow(a[0].chartY - b.chartY, 2)) : !1;
                  }

                  x(d, !0) && this.pinch(b);
                } else a && this.reset();
              } else 2 === b.touches.length && this.pinch(b);
            };

            a.prototype.touchSelect = function (b) {
              return !(!this.chart.options.chart.zoomBySingleTouch || !b.touches || 1 !== b.touches.length);
            };

            a.prototype.zoomOption = function (b) {
              var a = this.chart,
                  e = a.options.chart;
              a = a.inverted;
              var c = e.zoomType || "";
              /touch/.test(b.type) && (c = x(e.pinchType, c));
              this.zoomX = b = /x/.test(c);
              this.zoomY = e = /y/.test(c);
              this.zoomHor = b && !a || e && a;
              this.zoomVert = e && !a || b && a;
              this.hasZoom = b || e;
            };

            return a;
          }();

          "";
          return a;
        });
        I(a, "Core/MSPointer.js", [a["Core/Globals.js"], a["Core/Pointer.js"], a["Core/Utilities.js"]], function (a, v, A) {
          function r() {
            var b = [];

            b.item = function (b) {
              return this[b];
            };

            g(k, function (a) {
              b.push({
                pageX: a.pageX,
                pageY: a.pageY,
                target: a.target
              });
            });
            return b;
          }

          function z(b, a, d, g) {
            var f = D[v.hoverChartIndex || NaN];
            "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !f || (f = f.pointer, g(b), f[a]({
              type: d,
              target: b.currentTarget,
              preventDefault: l,
              touches: r()
            }));
          }

          var w = this && this.__extends || function () {
            var _b2 = function b(a, d) {
              _b2 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _b2(a, d);
            };

            return function (a, d) {
              function f() {
                this.constructor = a;
              }

              _b2(a, d);

              a.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
            };
          }(),
              D = a.charts,
              t = a.doc,
              l = a.noop,
              h = a.win,
              d = A.addEvent,
              b = A.css,
              g = A.objectEach,
              p = A.removeEvent,
              k = {},
              J = !!h.PointerEvent;

          return function (g) {
            function f() {
              return null !== g && g.apply(this, arguments) || this;
            }

            w(f, g);

            f.isRequired = function () {
              return !(a.hasTouch || !h.PointerEvent && !h.MSPointerEvent);
            };

            f.prototype.batchMSEvents = function (b) {
              b(this.chart.container, J ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              b(this.chart.container, J ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              b(t, J ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            };

            f.prototype.destroy = function () {
              this.batchMSEvents(p);
              g.prototype.destroy.call(this);
            };

            f.prototype.init = function (a, d) {
              g.prototype.init.call(this, a, d);
              this.hasZoom && b(a.container, {
                "-ms-touch-action": "none",
                "touch-action": "none"
              });
            };

            f.prototype.onContainerPointerDown = function (b) {
              z(b, "onContainerTouchStart", "touchstart", function (b) {
                k[b.pointerId] = {
                  pageX: b.pageX,
                  pageY: b.pageY,
                  target: b.currentTarget
                };
              });
            };

            f.prototype.onContainerPointerMove = function (b) {
              z(b, "onContainerTouchMove", "touchmove", function (b) {
                k[b.pointerId] = {
                  pageX: b.pageX,
                  pageY: b.pageY
                };
                k[b.pointerId].target || (k[b.pointerId].target = b.currentTarget);
              });
            };

            f.prototype.onDocumentPointerUp = function (b) {
              z(b, "onDocumentTouchEnd", "touchend", function (b) {
                delete k[b.pointerId];
              });
            };

            f.prototype.setDOMEvents = function () {
              g.prototype.setDOMEvents.call(this);
              (this.hasZoom || this.followTouchMove) && this.batchMSEvents(d);
            };

            return f;
          }(v);
        });
        I(a, "Core/Legend/Legend.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w) {
          var r = a.animObject,
              t = a.setAnimation,
              l = v.format;
          a = A.isFirefox;
          var h = A.marginNames;
          A = A.win;
          var d = z.distribute,
              b = w.addEvent,
              g = w.createElement,
              p = w.css,
              k = w.defined,
              J = w.discardElement,
              G = w.find,
              f = w.fireEvent,
              B = w.isNumber,
              x = w.merge,
              u = w.pick,
              E = w.relativeLength,
              m = w.stableSort,
              q = w.syncTimeout;
          z = w.wrap;

          w = function () {
            function a(b, a) {
              this.allItems = [];
              this.contentGroup = this.box = void 0;
              this.display = !1;
              this.group = void 0;
              this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
              this.options = {};
              this.padding = 0;
              this.pages = [];
              this.proximate = !1;
              this.scrollGroup = void 0;
              this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
              this.chart = b;
              this.init(b, a);
            }

            a.prototype.init = function (c, a) {
              this.chart = c;
              this.setOptions(a);
              a.enabled && (this.render(), b(this.chart, "endResize", function () {
                this.legend.positionCheckboxes();
              }), this.proximate ? this.unchartrender = b(this.chart, "render", function () {
                this.legend.proximatePositions();
                this.legend.positionItems();
              }) : this.unchartrender && this.unchartrender());
            };

            a.prototype.setOptions = function (b) {
              var a = u(b.padding, 8);
              this.options = b;
              this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = x(this.itemStyle, b.itemHiddenStyle));
              this.itemMarginTop = b.itemMarginTop || 0;
              this.itemMarginBottom = b.itemMarginBottom || 0;
              this.padding = a;
              this.initialItemY = a - 5;
              this.symbolWidth = u(b.symbolWidth, 16);
              this.pages = [];
              this.proximate = "proximate" === b.layout && !this.chart.inverted;
              this.baseline = void 0;
            };

            a.prototype.update = function (b, a) {
              var c = this.chart;
              this.setOptions(x(!0, this.options, b));
              this.destroy();
              c.isDirtyLegend = c.isDirtyBox = !0;
              u(a, !0) && c.redraw();
              f(this, "afterUpdate");
            };

            a.prototype.colorizeItem = function (b, a) {
              b.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

              if (!this.chart.styledMode) {
                var c = this.options,
                    e = b.legendItem,
                    d = b.legendLine,
                    g = b.legendSymbol,
                    n = this.itemHiddenStyle.color;
                c = a ? c.itemStyle.color : n;
                var k = a ? b.color || n : n,
                    h = b.options && b.options.marker,
                    m = {
                  fill: k
                };
                e && e.css({
                  fill: c,
                  color: c
                });
                d && d.attr({
                  stroke: k
                });
                g && (h && g.isMarker && (m = b.pointAttribs(), a || (m.stroke = m.fill = n)), g.attr(m));
              }

              f(this, "afterColorizeItem", {
                item: b,
                visible: a
              });
            };

            a.prototype.positionItems = function () {
              this.allItems.forEach(this.positionItem, this);
              this.chart.isResizing || this.positionCheckboxes();
            };

            a.prototype.positionItem = function (b) {
              var a = this,
                  c = this.options,
                  e = c.symbolPadding,
                  d = !c.rtl,
                  g = b._legendItemPos;
              c = g[0];
              g = g[1];
              var h = b.checkbox,
                  m = b.legendGroup;
              m && m.element && (e = {
                translateX: d ? c : this.legendWidth - c - 2 * e - 4,
                translateY: g
              }, d = function d() {
                f(a, "afterPositionItem", {
                  item: b
                });
              }, k(m.translateY) ? m.animate(e, void 0, d) : (m.attr(e), d()));
              h && (h.x = c, h.y = g);
            };

            a.prototype.destroyItem = function (b) {
              var a = b.checkbox;
              ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
                b[a] && (b[a] = b[a].destroy());
              });
              a && J(b.checkbox);
            };

            a.prototype.destroy = function () {
              function b(b) {
                this[b] && (this[b] = this[b].destroy());
              }

              this.getAllItems().forEach(function (a) {
                ["legendItem", "legendGroup"].forEach(b, a);
              });
              "clipRect up down pager nav box title group".split(" ").forEach(b, this);
              this.display = null;
            };

            a.prototype.positionCheckboxes = function () {
              var b = this.group && this.group.alignAttr,
                  a = this.clipHeight || this.legendHeight,
                  e = this.titleHeight;

              if (b) {
                var d = b.translateY;
                this.allItems.forEach(function (c) {
                  var f = c.checkbox;

                  if (f) {
                    var g = d + e + f.y + (this.scrollOffset || 0) + 3;
                    p(f, {
                      left: b.translateX + c.checkboxOffset + f.x - 20 + "px",
                      top: g + "px",
                      display: this.proximate || g > d - 6 && g < d + a - 6 ? "" : "none"
                    });
                  }
                }, this);
              }
            };

            a.prototype.renderTitle = function () {
              var b = this.options,
                  a = this.padding,
                  e = b.title,
                  d = 0;
              e.text && (this.title || (this.title = this.chart.renderer.label(e.text, a - 3, a - 4, null, null, null, b.useHTML, null, "legend-title").attr({
                zIndex: 1
              }), this.chart.styledMode || this.title.css(e.style), this.title.add(this.group)), e.width || this.title.css({
                width: this.maxLegendWidth + "px"
              }), b = this.title.getBBox(), d = b.height, this.offsetWidth = b.width, this.contentGroup.attr({
                translateY: d
              }));
              this.titleHeight = d;
            };

            a.prototype.setText = function (b) {
              var a = this.options;
              b.legendItem.attr({
                text: a.labelFormat ? l(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)
              });
            };

            a.prototype.renderItem = function (b) {
              var a = this.chart,
                  c = a.renderer,
                  e = this.options,
                  d = this.symbolWidth,
                  f = e.symbolPadding || 0,
                  g = this.itemStyle,
                  k = this.itemHiddenStyle,
                  h = "horizontal" === e.layout ? u(e.itemDistance, 20) : 0,
                  m = !e.rtl,
                  q = !b.series,
                  p = !q && b.series.drawLegendSymbol ? b.series : b,
                  l = p.options,
                  B = this.createCheckboxForItem && l && l.showCheckbox,
                  r = e.useHTML,
                  t = b.options.className,
                  E = b.legendItem;
              l = d + f + h + (B ? 20 : 0);
              E || (b.legendGroup = c.g("legend-item").addClass("highcharts-" + p.type + "-series highcharts-color-" + b.colorIndex + (t ? " " + t : "") + (q ? " highcharts-series-" + b.index : "")).attr({
                zIndex: 1
              }).add(this.scrollGroup), b.legendItem = E = c.text("", m ? d + f : -f, this.baseline || 0, r), a.styledMode || E.css(x(b.visible ? g : k)), E.attr({
                align: m ? "left" : "right",
                zIndex: 2
              }).add(b.legendGroup), this.baseline || (this.fontMetrics = c.fontMetrics(a.styledMode ? 12 : g.fontSize, E), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, E.attr("y", this.baseline), this.symbolHeight = e.symbolHeight || this.fontMetrics.f, e.squareSymbol && (this.symbolWidth = u(e.symbolWidth, Math.max(this.symbolHeight, 16)), l = this.symbolWidth + f + h + (B ? 20 : 0), m && E.attr("x", this.symbolWidth + f))), p.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, E, r));
              B && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
              this.colorizeItem(b, b.visible);
              !a.styledMode && g.width || E.css({
                width: (e.itemWidth || this.widthOption || a.spacingBox.width) - l + "px"
              });
              this.setText(b);
              a = E.getBBox();
              b.itemWidth = b.checkboxOffset = e.itemWidth || b.legendItemWidth || a.width + l;
              this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
              this.totalItemWidth += b.itemWidth;
              this.itemHeight = b.itemHeight = Math.round(b.legendItemHeight || a.height || this.symbolHeight);
            };

            a.prototype.layoutItem = function (b) {
              var a = this.options,
                  c = this.padding,
                  e = "horizontal" === a.layout,
                  d = b.itemHeight,
                  f = this.itemMarginBottom,
                  g = this.itemMarginTop,
                  k = e ? u(a.itemDistance, 20) : 0,
                  h = this.maxLegendWidth;
              a = a.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : b.itemWidth;
              e && this.itemX - c + a > h && (this.itemX = c, this.lastLineHeight && (this.itemY += g + this.lastLineHeight + f), this.lastLineHeight = 0);
              this.lastItemY = g + this.itemY + f;
              this.lastLineHeight = Math.max(d, this.lastLineHeight);
              b._legendItemPos = [this.itemX, this.itemY];
              e ? this.itemX += a : (this.itemY += g + d + f, this.lastLineHeight = d);
              this.offsetWidth = this.widthOption || Math.max((e ? this.itemX - c - (b.checkbox ? 0 : k) : a) + c, this.offsetWidth);
            };

            a.prototype.getAllItems = function () {
              var b = [];
              this.chart.series.forEach(function (a) {
                var c = a && a.options;
                a && u(c.showInLegend, k(c.linkedTo) ? !1 : void 0, !0) && (b = b.concat(a.legendItems || ("point" === c.legendType ? a.data : a)));
              });
              f(this, "afterGetAllItems", {
                allItems: b
              });
              return b;
            };

            a.prototype.getAlignment = function () {
              var b = this.options;
              return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
            };

            a.prototype.adjustMargins = function (b, a) {
              var c = this.chart,
                  e = this.options,
                  d = this.getAlignment();
              d && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (f, g) {
                f.test(d) && !k(b[g]) && (c[h[g]] = Math.max(c[h[g]], c.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * e[g % 2 ? "x" : "y"] + u(e.margin, 12) + a[g] + (c.titleOffset[g] || 0)));
              });
            };

            a.prototype.proximatePositions = function () {
              var b = this.chart,
                  a = [],
                  e = "left" === this.options.align;
              this.allItems.forEach(function (c) {
                var d;
                var f = e;

                if (c.yAxis) {
                  c.xAxis.options.reversed && (f = !f);
                  c.points && (d = G(f ? c.points : c.points.slice(0).reverse(), function (b) {
                    return B(b.plotY);
                  }));
                  f = this.itemMarginTop + c.legendItem.getBBox().height + this.itemMarginBottom;
                  var g = c.yAxis.top - b.plotTop;
                  c.visible ? (d = d ? d.plotY : c.yAxis.height, d += g - .3 * f) : d = g + c.yAxis.height;
                  a.push({
                    target: d,
                    size: f,
                    item: c
                  });
                }
              }, this);
              d(a, b.plotHeight).forEach(function (a) {
                a.item._legendItemPos && (a.item._legendItemPos[1] = b.plotTop - b.spacing[0] + a.pos);
              });
            };

            a.prototype.render = function () {
              var b = this.chart,
                  a = b.renderer,
                  e = this.options,
                  d = this.padding,
                  g = this.getAllItems(),
                  k = this.group,
                  h = this.box;
              this.itemX = d;
              this.itemY = this.initialItemY;
              this.lastItemY = this.offsetWidth = 0;
              this.widthOption = E(e.width, b.spacingBox.width - d);
              var q = b.spacingBox.width - 2 * d - e.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (q /= 2);
              this.maxLegendWidth = this.widthOption || q;
              k || (this.group = k = a.g("legend").addClass(e.className || "").attr({
                zIndex: 7
              }).add(), this.contentGroup = a.g().attr({
                zIndex: 1
              }).add(k), this.scrollGroup = a.g().add(this.contentGroup));
              this.renderTitle();
              m(g, function (b, a) {
                return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
              });
              e.reversed && g.reverse();
              this.allItems = g;
              this.display = q = !!g.length;
              this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
              g.forEach(this.renderItem, this);
              g.forEach(this.layoutItem, this);
              g = (this.widthOption || this.offsetWidth) + d;
              var p = this.lastItemY + this.lastLineHeight + this.titleHeight;
              p = this.handleOverflow(p);
              p += d;
              h || (this.box = h = a.rect().addClass("highcharts-legend-box").attr({
                r: e.borderRadius
              }).add(k), h.isNew = !0);
              b.styledMode || h.attr({
                stroke: e.borderColor,
                "stroke-width": e.borderWidth || 0,
                fill: e.backgroundColor || "none"
              }).shadow(e.shadow);
              0 < g && 0 < p && (h[h.isNew ? "attr" : "animate"](h.crisp.call({}, {
                x: 0,
                y: 0,
                width: g,
                height: p
              }, h.strokeWidth())), h.isNew = !1);
              h[q ? "show" : "hide"]();
              b.styledMode && "none" === k.getStyle("display") && (g = p = 0);
              this.legendWidth = g;
              this.legendHeight = p;
              q && this.align();
              this.proximate || this.positionItems();
              f(this, "afterRender");
            };

            a.prototype.align = function (b) {
              void 0 === b && (b = this.chart.spacingBox);
              var a = this.chart,
                  c = this.options,
                  e = b.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? e += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (e -= a.titleOffset[2]);
              e !== b.y && (b = x(b, {
                y: e
              }));
              this.group.align(x(c, {
                width: this.legendWidth,
                height: this.legendHeight,
                verticalAlign: this.proximate ? "top" : c.verticalAlign
              }), !0, b);
            };

            a.prototype.handleOverflow = function (b) {
              var a = this,
                  c = this.chart,
                  e = c.renderer,
                  d = this.options,
                  f = d.y,
                  g = "top" === d.verticalAlign,
                  k = this.padding,
                  h = d.maxHeight,
                  m = d.navigation,
                  q = u(m.animation, !0),
                  p = m.arrowSize || 12,
                  l = this.pages,
                  B = this.allItems,
                  x = function x(b) {
                "number" === typeof b ? P.attr({
                  height: b
                }) : P && (a.clipRect = P.destroy(), a.contentGroup.clip());
                a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + k + "px,9999px," + (k + b) + "px,0)" : "auto");
              },
                  r = function r(b) {
                a[b] = e.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(E);
                c.styledMode || a[b].attr("fill", "rgba(0,0,0,0.0001)");
                return a[b];
              },
                  t,
                  K;

              f = c.spacingBox.height + (g ? -f : f) - k;
              var E = this.nav,
                  P = this.clipRect;
              "horizontal" !== d.layout || "middle" === d.verticalAlign || d.floating || (f /= 2);
              h && (f = Math.min(f, h));
              l.length = 0;
              b && 0 < f && b > f && !1 !== m.enabled ? (this.clipHeight = t = Math.max(f - 20 - this.titleHeight - k, 0), this.currentPage = u(this.currentPage, 1), this.fullHeight = b, B.forEach(function (b, a) {
                var c = b._legendItemPos[1],
                    e = Math.round(b.legendItem.getBBox().height),
                    d = l.length;
                if (!d || c - l[d - 1] > t && (K || c) !== l[d - 1]) l.push(K || c), d++;
                b.pageIx = d - 1;
                K && (B[a - 1].pageIx = d - 1);
                a === B.length - 1 && c + e - l[d - 1] > t && c !== K && (l.push(c), b.pageIx = d);
                c !== K && (K = c);
              }), P || (P = a.clipRect = e.clipRect(0, k, 9999, 0), a.contentGroup.clip(P)), x(t), E || (this.nav = E = e.g().attr({
                zIndex: 1
              }).add(this.group), this.up = e.symbol("triangle", 0, 0, p, p).add(E), r("upTracker").on("click", function () {
                a.scroll(-1, q);
              }), this.pager = e.text("", 15, 10).addClass("highcharts-legend-navigation"), c.styledMode || this.pager.css(m.style), this.pager.add(E), this.down = e.symbol("triangle-down", 0, 0, p, p).add(E), r("downTracker").on("click", function () {
                a.scroll(1, q);
              })), a.scroll(0), b = f) : E && (x(), this.nav = E.destroy(), this.scrollGroup.attr({
                translateY: 1
              }), this.clipHeight = 0);
              return b;
            };

            a.prototype.scroll = function (b, a) {
              var c = this,
                  e = this.chart,
                  d = this.pages,
                  g = d.length,
                  k = this.clipHeight,
                  h = this.options.navigation,
                  n = this.pager,
                  m = this.padding,
                  p = this.currentPage + b;
              p > g && (p = g);
              0 < p && ("undefined" !== typeof a && t(a, e), this.nav.attr({
                translateX: m,
                translateY: k + this.padding + 7 + this.titleHeight,
                visibility: "visible"
              }), [this.up, this.upTracker].forEach(function (b) {
                b.attr({
                  "class": 1 === p ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }), n.attr({
                text: p + "/" + g
              }), [this.down, this.downTracker].forEach(function (b) {
                b.attr({
                  x: 18 + this.pager.getBBox().width,
                  "class": p === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                });
              }, this), e.styledMode || (this.up.attr({
                fill: 1 === p ? h.inactiveColor : h.activeColor
              }), this.upTracker.css({
                cursor: 1 === p ? "default" : "pointer"
              }), this.down.attr({
                fill: p === g ? h.inactiveColor : h.activeColor
              }), this.downTracker.css({
                cursor: p === g ? "default" : "pointer"
              })), this.scrollOffset = -d[p - 1] + this.initialItemY, this.scrollGroup.animate({
                translateY: this.scrollOffset
              }), this.currentPage = p, this.positionCheckboxes(), b = r(u(a, e.renderer.globalAnimation, !0)), q(function () {
                f(c, "afterScroll", {
                  currentPage: p
                });
              }, b.duration));
            };

            a.prototype.setItemEvents = function (b, a, e) {
              var c = this,
                  d = c.chart.renderer.boxWrapper,
                  g = b instanceof y,
                  k = "highcharts-legend-" + (g ? "point" : "series") + "-active",
                  h = c.chart.styledMode,
                  n = function n(a) {
                c.allItems.forEach(function (c) {
                  b !== c && [c].concat(c.linkedSeries || []).forEach(function (b) {
                    b.setState(a, !g);
                  });
                });
              };

              (e ? [a, b.legendSymbol] : [b.legendGroup]).forEach(function (e) {
                if (e) e.on("mouseover", function () {
                  b.visible && n("inactive");
                  b.setState("hover");
                  b.visible && d.addClass(k);
                  h || a.css(c.options.itemHoverStyle);
                }).on("mouseout", function () {
                  c.chart.styledMode || a.css(x(b.visible ? c.itemStyle : c.itemHiddenStyle));
                  n("");
                  d.removeClass(k);
                  b.setState();
                }).on("click", function (a) {
                  var c = function c() {
                    b.setVisible && b.setVisible();
                    n(b.visible ? "inactive" : "");
                  };

                  d.removeClass(k);
                  a = {
                    browserEvent: a
                  };
                  b.firePointEvent ? b.firePointEvent("legendItemClick", a, c) : f(b, "legendItemClick", a, c);
                });
              });
            };

            a.prototype.createCheckboxForItem = function (a) {
              a.checkbox = g("input", {
                type: "checkbox",
                className: "highcharts-legend-checkbox",
                checked: a.selected,
                defaultChecked: a.selected
              }, this.options.itemCheckboxStyle, this.chart.container);
              b(a.checkbox, "click", function (b) {
                f(a.series || a, "checkboxClick", {
                  checked: b.target.checked,
                  item: a
                }, function () {
                  a.select();
                });
              });
            };

            return a;
          }();

          (/Trident\/7\.0/.test(A.navigator && A.navigator.userAgent) || a) && z(w.prototype, "positionItem", function (b, a) {
            var c = this,
                e = function e() {
              a._legendItemPos && b.call(c, a);
            };

            e();
            c.bubbleLegend || setTimeout(e);
          });
          "";
          return w;
        });
        I(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/DefaultOptions.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = v.defaultOptions,
              w = y.error,
              D = y.extendClass,
              t = y.merge,
              l;

          (function (h) {
            function d(b, a) {
              var d = r.plotOptions || {},
                  g = a.defaultOptions;
              a.prototype.pointClass || (a.prototype.pointClass = A);
              a.prototype.type = b;
              g && (d[b] = g);
              h.seriesTypes[b] = a;
            }

            h.seriesTypes = a.seriesTypes;

            h.getSeries = function (b, a) {
              void 0 === a && (a = {});
              var d = b.options.chart;
              d = a.type || d.type || d.defaultSeriesType || "";
              var g = h.seriesTypes[d];
              h || w(17, !0, b, {
                missingModuleFor: d
              });
              d = new g();
              "function" === typeof d.init && d.init(b, a);
              return d;
            };

            h.registerSeriesType = d;

            h.seriesType = function (b, a, p, k, l) {
              var g = r.plotOptions || {};
              a = a || "";
              g[b] = t(g[a], p);
              d(b, D(h.seriesTypes[a] || function () {}, k));
              h.seriesTypes[b].prototype.type = b;
              l && (h.seriesTypes[b].prototype.pointClass = D(A, l));
              return h.seriesTypes[b];
            };
          })(l || (l = {}));

          return l;
        });
        I(a, "Core/Chart/Chart.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/FormatUtilities.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/Legend.js"], a["Core/MSPointer.js"], a["Core/DefaultOptions.js"], a["Core/Color/Palette.js"], a["Core/Pointer.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Time.js"], a["Core/Utilities.js"], a["Core/Renderer/HTML/AST.js"]], function (a, v, A, y, z, w, D, t, l, h, d, b, g, p, k, J) {
          var r = a.animate,
              f = a.animObject,
              B = a.setAnimation,
              x = A.numberFormat,
              u = y.registerEventOptions,
              E = z.charts,
              m = z.doc,
              q = z.marginNames,
              e = z.svg,
              c = z.win,
              n = t.defaultOptions,
              C = t.defaultTime,
              H = b.seriesTypes,
              L = k.addEvent,
              F = k.attr,
              W = k.cleanRecursively,
              S = k.createElement,
              R = k.css,
              T = k.defined,
              ba = k.discardElement,
              N = k.erase,
              M = k.error,
              I = k.extend,
              ia = k.find,
              O = k.fireEvent,
              Z = k.getStyle,
              K = k.isArray,
              U = k.isNumber,
              P = k.isObject,
              X = k.isString,
              V = k.merge,
              Y = k.objectEach,
              Q = k.pick,
              da = k.pInt,
              ea = k.relativeLength,
              ja = k.removeEvent,
              ca = k.splat,
              fa = k.syncTimeout,
              ka = k.uniqueKey;

          a = function () {
            function b(b, a, c) {
              this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
              this.sharedClips = {};
              this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
              this.getArgs(b, a, c);
            }

            b.chart = function (a, c, e) {
              return new b(a, c, e);
            };

            b.prototype.getArgs = function (b, a, c) {
              X(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);
            };

            b.prototype.init = function (b, a) {
              var c = b.plotOptions || {};
              O(this, "init", {
                args: arguments
              }, function () {
                var e = V(n, b),
                    d = e.chart;
                Y(e.plotOptions, function (b, a) {
                  P(b) && (b.tooltip = c[a] && V(c[a].tooltip) || void 0);
                });
                e.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
                this.userOptions = b;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                  h: {},
                  v: {}
                };
                this.labelCollectors = [];
                this.callback = a;
                this.isResizing = 0;
                this.options = e;
                this.axes = [];
                this.series = [];
                this.time = b.time && Object.keys(b.time).length ? new p(b.time) : z.time;
                this.numberFormatter = d.numberFormatter || x;
                this.styledMode = d.styledMode;
                this.hasCartesianSeries = d.showAxes;
                this.index = E.length;
                E.push(this);
                z.chartCount++;
                u(this, d);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                O(this, "afterInit");
                this.firstRender();
              });
            };

            b.prototype.initSeries = function (b) {
              var a = this.options.chart;
              a = b.type || a.type || a.defaultSeriesType;
              var c = H[a];
              c || M(17, !0, this, {
                missingModuleFor: a
              });
              a = new c();
              "function" === typeof a.init && a.init(this, b);
              return a;
            };

            b.prototype.setSeriesData = function () {
              this.getSeriesOrderByLinks().forEach(function (b) {
                b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
              });
            };

            b.prototype.getSeriesOrderByLinks = function () {
              return this.series.concat().sort(function (b, a) {
                return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
              });
            };

            b.prototype.orderSeries = function (b) {
              var a = this.series;
              b = b || 0;

              for (var c = a.length; b < c; ++b) {
                a[b] && (a[b].index = b, a[b].name = a[b].getName());
              }
            };

            b.prototype.isInsidePlot = function (b, a, c) {
              void 0 === c && (c = {});
              var e = this.inverted,
                  d = this.plotBox,
                  f = this.plotLeft,
                  g = this.plotTop,
                  k = this.scrollablePlotBox,
                  h = 0;
              var n = 0;
              c.visiblePlotOnly && this.scrollingContainer && (n = this.scrollingContainer, h = n.scrollLeft, n = n.scrollTop);
              var m = c.series;
              d = c.visiblePlotOnly && k || d;
              k = c.inverted ? a : b;
              a = c.inverted ? b : a;
              b = {
                x: k,
                y: a,
                isInsidePlot: !0
              };

              if (!c.ignoreX) {
                var q = m && (e ? m.yAxis : m.xAxis) || {
                  pos: f,
                  len: Infinity
                };
                k = c.paneCoordinates ? q.pos + k : f + k;
                k >= Math.max(h + f, q.pos) && k <= Math.min(h + f + d.width, q.pos + q.len) || (b.isInsidePlot = !1);
              }

              !c.ignoreY && b.isInsidePlot && (e = m && (e ? m.xAxis : m.yAxis) || {
                pos: g,
                len: Infinity
              }, c = c.paneCoordinates ? e.pos + a : g + a, c >= Math.max(n + g, e.pos) && c <= Math.min(n + g + d.height, e.pos + e.len) || (b.isInsidePlot = !1));
              O(this, "afterIsInsidePlot", b);
              return b.isInsidePlot;
            };

            b.prototype.redraw = function (b) {
              O(this, "beforeRedraw");
              var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                  c = this.series,
                  e = this.pointer,
                  d = this.legend,
                  f = this.userOptions.legend,
                  g = this.renderer,
                  k = g.isHidden(),
                  h = [],
                  n = this.isDirtyBox,
                  m = this.isDirtyLegend;
              this.setResponsive && this.setResponsive(!1);
              B(this.hasRendered ? b : !1, this);
              k && this.temporaryDisplay();
              this.layOutTitles();

              for (b = c.length; b--;) {
                var q = c[b];

                if (q.options.stacking || q.options.centerInCategory) {
                  var p = !0;

                  if (q.isDirty) {
                    var u = !0;
                    break;
                  }
                }
              }

              if (u) for (b = c.length; b--;) {
                q = c[b], q.options.stacking && (q.isDirty = !0);
              }
              c.forEach(function (b) {
                b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), m = !0) : f && (f.labelFormatter || f.labelFormat) && (m = !0));
                b.isDirtyData && O(b, "updatedData");
              });
              m && d && d.options.enabled && (d.render(), this.isDirtyLegend = !1);
              p && this.getStacks();
              a.forEach(function (b) {
                b.updateNames();
                b.setScale();
              });
              this.getMargins();
              a.forEach(function (b) {
                b.isDirty && (n = !0);
              });
              a.forEach(function (b) {
                var a = b.min + "," + b.max;
                b.extKey !== a && (b.extKey = a, h.push(function () {
                  O(b, "afterSetExtremes", I(b.eventArgs, b.getExtremes()));
                  delete b.eventArgs;
                }));
                (n || p) && b.redraw();
              });
              n && this.drawChartBox();
              O(this, "predraw");
              c.forEach(function (b) {
                (n || b.isDirty) && b.visible && b.redraw();
                b.isDirtyData = !1;
              });
              e && e.reset(!0);
              g.draw();
              O(this, "redraw");
              O(this, "render");
              k && this.temporaryDisplay(!0);
              h.forEach(function (b) {
                b.call();
              });
            };

            b.prototype.get = function (b) {
              function a(a) {
                return a.id === b || a.options && a.options.id === b;
              }

              for (var c = this.series, e = ia(this.axes, a) || ia(this.series, a), d = 0; !e && d < c.length; d++) {
                e = ia(c[d].points || [], a);
              }

              return e;
            };

            b.prototype.getAxes = function () {
              var b = this,
                  a = this.options,
                  c = a.xAxis = ca(a.xAxis || {});
              a = a.yAxis = ca(a.yAxis || {});
              O(this, "getAxes");
              c.forEach(function (b, a) {
                b.index = a;
                b.isX = !0;
              });
              a.forEach(function (b, a) {
                b.index = a;
              });
              c.concat(a).forEach(function (a) {
                new v(b, a);
              });
              O(this, "afterGetAxes");
            };

            b.prototype.getSelectedPoints = function () {
              return this.series.reduce(function (b, a) {
                a.getPointsCollection().forEach(function (a) {
                  Q(a.selectedStaging, a.selected) && b.push(a);
                });
                return b;
              }, []);
            };

            b.prototype.getSelectedSeries = function () {
              return this.series.filter(function (b) {
                return b.selected;
              });
            };

            b.prototype.setTitle = function (b, a, c) {
              this.applyDescription("title", b);
              this.applyDescription("subtitle", a);
              this.applyDescription("caption", void 0);
              this.layOutTitles(c);
            };

            b.prototype.applyDescription = function (b, a) {
              var c = this,
                  e = "title" === b ? {
                color: l.neutralColor80,
                fontSize: this.options.isStock ? "16px" : "18px"
              } : {
                color: l.neutralColor60
              };
              e = this.options[b] = V(!this.styledMode && {
                style: e
              }, this.options[b], a);
              var d = this[b];
              d && a && (this[b] = d = d.destroy());
              e && !d && (d = this.renderer.text(e.text, 0, 0, e.useHTML).attr({
                align: e.align,
                "class": "highcharts-" + b,
                zIndex: e.zIndex || 4
              }).add(), d.update = function (a) {
                c[{
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }[b]](a);
              }, this.styledMode || d.css(e.style), this[b] = d);
            };

            b.prototype.layOutTitles = function (b) {
              var a = [0, 0, 0],
                  c = this.renderer,
                  e = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (b) {
                var d = this[b],
                    f = this.options[b],
                    g = f.verticalAlign || "top";
                b = "title" === b ? "top" === g ? -3 : 0 : "top" === g ? a[0] + 2 : 0;
                var k;

                if (d) {
                  this.styledMode || (k = f.style && f.style.fontSize);
                  k = c.fontMetrics(k, d).b;
                  d.css({
                    width: (f.width || e.width + (f.widthAdjust || 0)) + "px"
                  });
                  var h = Math.round(d.getBBox(f.useHTML).height);
                  d.align(I({
                    y: "bottom" === g ? k : b + k,
                    height: h
                  }, f), !1, "spacingBox");
                  f.floating || ("top" === g ? a[0] = Math.ceil(a[0] + h) : "bottom" === g && (a[2] = Math.ceil(a[2] + h)));
                }
              }, this);
              a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
              a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
              var d = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
              this.titleOffset = a;
              O(this, "afterLayOutTitles");
              !this.isDirtyBox && d && (this.isDirtyBox = this.isDirtyLegend = d, this.hasRendered && Q(b, !0) && this.isDirtyBox && this.redraw());
            };

            b.prototype.getChartSize = function () {
              var b = this.options.chart,
                  a = b.width;
              b = b.height;
              var c = this.renderTo;
              T(a) || (this.containerWidth = Z(c, "width"));
              T(b) || (this.containerHeight = Z(c, "height"));
              this.chartWidth = Math.max(0, a || this.containerWidth || 600);
              this.chartHeight = Math.max(0, ea(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            };

            b.prototype.temporaryDisplay = function (b) {
              var a = this.renderTo;
              if (b) for (; a && a.style;) {
                a.hcOrigStyle && (R(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (m.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;
              } else for (; a && a.style;) {
                m.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, m.body.appendChild(a));
                if ("none" === Z(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
                  display: a.style.display,
                  height: a.style.height,
                  overflow: a.style.overflow
                }, b = {
                  display: "block",
                  overflow: "hidden"
                }, a !== this.renderTo && (b.height = 0), R(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
                a = a.parentNode;
                if (a === m.body) break;
              }
            };

            b.prototype.setClassName = function (b) {
              this.container.className = "highcharts-container " + (b || "");
            };

            b.prototype.getContainer = function () {
              var b = this.options,
                  a = b.chart,
                  c = ka(),
                  f,
                  k = this.renderTo;
              k || (this.renderTo = k = a.renderTo);
              X(k) && (this.renderTo = k = m.getElementById(k));
              k || M(13, !0, this);
              var h = da(F(k, "data-highcharts-chart"));
              U(h) && E[h] && E[h].hasRendered && E[h].destroy();
              F(k, "data-highcharts-chart", this.index);
              k.innerHTML = "";
              a.skipClone || k.offsetWidth || this.temporaryDisplay();
              this.getChartSize();
              h = this.chartWidth;
              var n = this.chartHeight;
              R(k, {
                overflow: "hidden"
              });
              this.styledMode || (f = I({
                position: "relative",
                overflow: "hidden",
                width: h + "px",
                height: n + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                userSelect: "none",
                "touch-action": "manipulation",
                outline: "none"
              }, a.style || {}));
              this.container = c = S("div", {
                id: c
              }, f, k);
              this._cursor = c.style.cursor;
              this.renderer = new (a.renderer || !e ? d.getRendererType(a.renderer) : g)(c, h, n, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
              B(void 0, this);
              this.setClassName(a.className);
              if (this.styledMode) for (var q in b.defs) {
                this.renderer.definition(b.defs[q]);
              } else this.renderer.setStyle(a.style);
              this.renderer.chartIndex = this.index;
              O(this, "afterGetContainer");
            };

            b.prototype.getMargins = function (b) {
              var a = this.spacing,
                  c = this.margin,
                  e = this.titleOffset;
              this.resetMargins();
              e[0] && !T(c[0]) && (this.plotTop = Math.max(this.plotTop, e[0] + a[0]));
              e[2] && !T(c[2]) && (this.marginBottom = Math.max(this.marginBottom, e[2] + a[2]));
              this.legend && this.legend.display && this.legend.adjustMargins(c, a);
              O(this, "getMargins");
              b || this.getAxisMargins();
            };

            b.prototype.getAxisMargins = function () {
              var b = this,
                  a = b.axisOffset = [0, 0, 0, 0],
                  c = b.colorAxis,
                  e = b.margin,
                  d = function d(b) {
                b.forEach(function (b) {
                  b.visible && b.getOffset();
                });
              };

              b.hasCartesianSeries ? d(b.axes) : c && c.length && d(c);
              q.forEach(function (c, d) {
                T(e[d]) || (b[c] += a[d]);
              });
              b.setChartSize();
            };

            b.prototype.reflow = function (b) {
              var a = this,
                  e = a.options.chart,
                  d = a.renderTo,
                  f = T(e.width) && T(e.height),
                  g = e.width || Z(d, "width");
              e = e.height || Z(d, "height");
              d = b ? b.target : c;
              delete a.pointer.chartPosition;

              if (!f && !a.isPrinting && g && e && (d === c || d === m)) {
                if (g !== a.containerWidth || e !== a.containerHeight) k.clearTimeout(a.reflowTimeout), a.reflowTimeout = fa(function () {
                  a.container && a.setSize(void 0, void 0, !1);
                }, b ? 100 : 0);
                a.containerWidth = g;
                a.containerHeight = e;
              }
            };

            b.prototype.setReflow = function (b) {
              var a = this;
              !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = L(c, "resize", function (b) {
                a.options && a.reflow(b);
              }), L(this, "destroy", this.unbindReflow));
            };

            b.prototype.setSize = function (b, a, c) {
              var e = this,
                  d = e.renderer;
              e.isResizing += 1;
              B(c, e);
              c = d.globalAnimation;
              e.oldChartHeight = e.chartHeight;
              e.oldChartWidth = e.chartWidth;
              "undefined" !== typeof b && (e.options.chart.width = b);
              "undefined" !== typeof a && (e.options.chart.height = a);
              e.getChartSize();
              e.styledMode || (c ? r : R)(e.container, {
                width: e.chartWidth + "px",
                height: e.chartHeight + "px"
              }, c);
              e.setChartSize(!0);
              d.setSize(e.chartWidth, e.chartHeight, c);
              e.axes.forEach(function (b) {
                b.isDirty = !0;
                b.setScale();
              });
              e.isDirtyLegend = !0;
              e.isDirtyBox = !0;
              e.layOutTitles();
              e.getMargins();
              e.redraw(c);
              e.oldChartHeight = null;
              O(e, "resize");
              fa(function () {
                e && O(e, "endResize", null, function () {
                  --e.isResizing;
                });
              }, f(c).duration);
            };

            b.prototype.setChartSize = function (b) {
              var a = this.inverted,
                  c = this.renderer,
                  e = this.chartWidth,
                  d = this.chartHeight,
                  f = this.options.chart,
                  g = this.spacing,
                  k = this.clipOffset,
                  h,
                  n,
                  m,
                  q;
              this.plotLeft = h = Math.round(this.plotLeft);
              this.plotTop = n = Math.round(this.plotTop);
              this.plotWidth = m = Math.max(0, Math.round(e - h - this.marginRight));
              this.plotHeight = q = Math.max(0, Math.round(d - n - this.marginBottom));
              this.plotSizeX = a ? q : m;
              this.plotSizeY = a ? m : q;
              this.plotBorderWidth = f.plotBorderWidth || 0;
              this.spacingBox = c.spacingBox = {
                x: g[3],
                y: g[0],
                width: e - g[3] - g[1],
                height: d - g[0] - g[2]
              };
              this.plotBox = c.plotBox = {
                x: h,
                y: n,
                width: m,
                height: q
              };
              a = 2 * Math.floor(this.plotBorderWidth / 2);
              e = Math.ceil(Math.max(a, k[3]) / 2);
              d = Math.ceil(Math.max(a, k[0]) / 2);
              this.clipBox = {
                x: e,
                y: d,
                width: Math.floor(this.plotSizeX - Math.max(a, k[1]) / 2 - e),
                height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, k[2]) / 2 - d))
              };
              b || (this.axes.forEach(function (b) {
                b.setAxisSize();
                b.setAxisTranslation();
              }), c.alignElements());
              O(this, "afterSetChartSize", {
                skipAxes: b
              });
            };

            b.prototype.resetMargins = function () {
              O(this, "resetMargins");
              var b = this,
                  a = b.options.chart;
              ["margin", "spacing"].forEach(function (c) {
                var e = a[c],
                    d = P(e) ? e : [e, e, e, e];
                ["Top", "Right", "Bottom", "Left"].forEach(function (e, f) {
                  b[c][f] = Q(a[c + e], d[f]);
                });
              });
              q.forEach(function (a, c) {
                b[a] = Q(b.margin[c], b.spacing[c]);
              });
              b.axisOffset = [0, 0, 0, 0];
              b.clipOffset = [0, 0, 0, 0];
            };

            b.prototype.drawChartBox = function () {
              var b = this.options.chart,
                  a = this.renderer,
                  c = this.chartWidth,
                  e = this.chartHeight,
                  d = this.styledMode,
                  f = this.plotBGImage,
                  g = b.backgroundColor,
                  k = b.plotBackgroundColor,
                  h = b.plotBackgroundImage,
                  n = this.plotLeft,
                  m = this.plotTop,
                  q = this.plotWidth,
                  p = this.plotHeight,
                  u = this.plotBox,
                  l = this.clipRect,
                  B = this.clipBox,
                  x = this.chartBackground,
                  K = this.plotBackground,
                  r = this.plotBorder,
                  t,
                  E = "animate";
              x || (this.chartBackground = x = a.rect().addClass("highcharts-background").add(), E = "attr");
              if (d) var C = t = x.strokeWidth();else {
                C = b.borderWidth || 0;
                t = C + (b.shadow ? 8 : 0);
                g = {
                  fill: g || "none"
                };
                if (C || x["stroke-width"]) g.stroke = b.borderColor, g["stroke-width"] = C;
                x.attr(g).shadow(b.shadow);
              }
              x[E]({
                x: t / 2,
                y: t / 2,
                width: c - t - C % 2,
                height: e - t - C % 2,
                r: b.borderRadius
              });
              E = "animate";
              K || (E = "attr", this.plotBackground = K = a.rect().addClass("highcharts-plot-background").add());
              K[E](u);
              d || (K.attr({
                fill: k || "none"
              }).shadow(b.plotShadow), h && (f ? (h !== f.attr("href") && f.attr("href", h), f.animate(u)) : this.plotBGImage = a.image(h, n, m, q, p).add()));
              l ? l.animate({
                width: B.width,
                height: B.height
              }) : this.clipRect = a.clipRect(B);
              E = "animate";
              r || (E = "attr", this.plotBorder = r = a.rect().addClass("highcharts-plot-border").attr({
                zIndex: 1
              }).add());
              d || r.attr({
                stroke: b.plotBorderColor,
                "stroke-width": b.plotBorderWidth || 0,
                fill: "none"
              });
              r[E](r.crisp({
                x: n,
                y: m,
                width: q,
                height: p
              }, -r.strokeWidth()));
              this.isDirtyBox = !1;
              O(this, "afterDrawChartBox");
            };

            b.prototype.propFromSeries = function () {
              var b = this,
                  a = b.options.chart,
                  c = b.options.series,
                  e,
                  d,
                  f;
              ["inverted", "angular", "polar"].forEach(function (g) {
                d = H[a.type || a.defaultSeriesType];
                f = a[g] || d && d.prototype[g];

                for (e = c && c.length; !f && e--;) {
                  (d = H[c[e].type]) && d.prototype[g] && (f = !0);
                }

                b[g] = f;
              });
            };

            b.prototype.linkSeries = function () {
              var b = this,
                  a = b.series;
              a.forEach(function (b) {
                b.linkedSeries.length = 0;
              });
              a.forEach(function (a) {
                var c = a.options.linkedTo;
                X(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = Q(a.options.visible, c.options.visible, a.visible));
              });
              O(this, "afterLinkSeries");
            };

            b.prototype.renderSeries = function () {
              this.series.forEach(function (b) {
                b.translate();
                b.render();
              });
            };

            b.prototype.renderLabels = function () {
              var b = this,
                  a = b.options.labels;
              a.items && a.items.forEach(function (c) {
                var e = I(a.style, c.style),
                    d = da(e.left) + b.plotLeft,
                    f = da(e.top) + b.plotTop + 12;
                delete e.left;
                delete e.top;
                b.renderer.text(c.html, d, f).attr({
                  zIndex: 2
                }).css(e).add();
              });
            };

            b.prototype.render = function () {
              var b = this.axes,
                  a = this.colorAxis,
                  c = this.renderer,
                  e = this.options,
                  d = function d(b) {
                b.forEach(function (b) {
                  b.visible && b.render();
                });
              },
                  f = 0;

              this.setTitle();
              this.legend = new w(this, e.legend);
              this.getStacks && this.getStacks();
              this.getMargins(!0);
              this.setChartSize();
              e = this.plotWidth;
              b.some(function (b) {
                if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;
              });
              var g = this.plotHeight = Math.max(this.plotHeight - f, 0);
              b.forEach(function (b) {
                b.setScale();
              });
              this.getAxisMargins();
              var k = 1.1 < e / this.plotWidth,
                  h = 1.05 < g / this.plotHeight;
              if (k || h) b.forEach(function (b) {
                (b.horiz && k || !b.horiz && h) && b.setTickInterval(!0);
              }), this.getMargins();
              this.drawChartBox();
              this.hasCartesianSeries ? d(b) : a && a.length && d(a);
              this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
                zIndex: 3
              }).add());
              this.renderSeries();
              this.renderLabels();
              this.addCredits();
              this.setResponsive && this.setResponsive();
              this.hasRendered = !0;
            };

            b.prototype.addCredits = function (b) {
              var a = this,
                  e = V(!0, this.options.credits, b);
              e.enabled && !this.credits && (this.credits = this.renderer.text(e.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                e.href && (c.location.href = e.href);
              }).attr({
                align: e.position.align,
                zIndex: 8
              }), a.styledMode || this.credits.css(e.style), this.credits.add().align(e.position), this.credits.update = function (b) {
                a.credits = a.credits.destroy();
                a.addCredits(b);
              });
            };

            b.prototype.destroy = function () {
              var b = this,
                  a = b.axes,
                  c = b.series,
                  e = b.container,
                  d = e && e.parentNode,
                  f;
              O(b, "destroy");
              b.renderer.forExport ? N(E, b) : E[b.index] = void 0;
              z.chartCount--;
              b.renderTo.removeAttribute("data-highcharts-chart");
              ja(b);

              for (f = a.length; f--;) {
                a[f] = a[f].destroy();
              }

              this.scroller && this.scroller.destroy && this.scroller.destroy();

              for (f = c.length; f--;) {
                c[f] = c[f].destroy();
              }

              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
                var c = b[a];
                c && c.destroy && (b[a] = c.destroy());
              });
              e && (e.innerHTML = "", ja(e), d && ba(e));
              Y(b, function (a, c) {
                delete b[c];
              });
            };

            b.prototype.firstRender = function () {
              var b = this,
                  a = b.options;

              if (!b.isReadyToRender || b.isReadyToRender()) {
                b.getContainer();
                b.resetMargins();
                b.setChartSize();
                b.propFromSeries();
                b.getAxes();
                (K(a.series) ? a.series : []).forEach(function (a) {
                  b.initSeries(a);
                });
                b.linkSeries();
                b.setSeriesData();
                O(b, "beforeRender");
                h && (D.isRequired() ? b.pointer = new D(b, a) : b.pointer = new h(b, a));
                b.render();
                b.pointer.getChartPosition();
                if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
                b.temporaryDisplay(!0);
              }
            };

            b.prototype.onload = function () {
              this.callbacks.concat([this.callback]).forEach(function (b) {
                b && "undefined" !== typeof this.index && b.apply(this, [this]);
              }, this);
              O(this, "load");
              O(this, "render");
              T(this.index) && this.setReflow(this.options.chart.reflow);
              this.hasLoaded = !0;
            };

            b.prototype.addSeries = function (b, a, c) {
              var e = this,
                  d;
              b && (a = Q(a, !0), O(e, "addSeries", {
                options: b
              }, function () {
                d = e.initSeries(b);
                e.isDirtyLegend = !0;
                e.linkSeries();
                d.enabledDataSorting && d.setData(b.data, !1);
                O(e, "afterAddSeries", {
                  series: d
                });
                a && e.redraw(c);
              }));
              return d;
            };

            b.prototype.addAxis = function (b, a, c, e) {
              return this.createAxis(a ? "xAxis" : "yAxis", {
                axis: b,
                redraw: c,
                animation: e
              });
            };

            b.prototype.addColorAxis = function (b, a, c) {
              return this.createAxis("colorAxis", {
                axis: b,
                redraw: a,
                animation: c
              });
            };

            b.prototype.createAxis = function (b, a) {
              b = new v(this, V(a.axis, {
                index: this[b].length,
                isX: "xAxis" === b
              }));
              Q(a.redraw, !0) && this.redraw(a.animation);
              return b;
            };

            b.prototype.showLoading = function (b) {
              var a = this,
                  c = a.options,
                  e = c.loading,
                  d = function d() {
                f && R(f, {
                  left: a.plotLeft + "px",
                  top: a.plotTop + "px",
                  width: a.plotWidth + "px",
                  height: a.plotHeight + "px"
                });
              },
                  f = a.loadingDiv,
                  g = a.loadingSpan;

              f || (a.loadingDiv = f = S("div", {
                className: "highcharts-loading highcharts-loading-hidden"
              }, null, a.container));
              g || (a.loadingSpan = g = S("span", {
                className: "highcharts-loading-inner"
              }, null, f), L(a, "redraw", d));
              f.className = "highcharts-loading";
              J.setElementHTML(g, Q(b, c.lang.loading, ""));
              a.styledMode || (R(f, I(e.style, {
                zIndex: 10
              })), R(g, e.labelStyle), a.loadingShown || (R(f, {
                opacity: 0,
                display: ""
              }), r(f, {
                opacity: e.style.opacity || .5
              }, {
                duration: e.showDuration || 0
              })));
              a.loadingShown = !0;
              d();
            };

            b.prototype.hideLoading = function () {
              var b = this.options,
                  a = this.loadingDiv;
              a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || r(a, {
                opacity: 0
              }, {
                duration: b.loading.hideDuration || 100,
                complete: function complete() {
                  R(a, {
                    display: "none"
                  });
                }
              }));
              this.loadingShown = !1;
            };

            b.prototype.update = function (b, a, c, e) {
              var d = this,
                  f = {
                credits: "addCredits",
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              },
                  g = b.isResponsiveOptions,
                  k = [],
                  h,
                  n;
              O(d, "update", {
                options: b
              });
              g || d.setResponsive(!1, !0);
              b = W(b, d.options);
              d.userOptions = V(d.userOptions, b);
              var m = b.chart;

              if (m) {
                V(!0, d.options.chart, m);
                "className" in m && d.setClassName(m.className);
                "reflow" in m && d.setReflow(m.reflow);

                if ("inverted" in m || "polar" in m || "type" in m) {
                  d.propFromSeries();
                  var q = !0;
                }

                "alignTicks" in m && (q = !0);
                "events" in m && u(this, m);
                Y(m, function (b, a) {
                  -1 !== d.propsRequireUpdateSeries.indexOf("chart." + a) && (h = !0);
                  -1 !== d.propsRequireDirtyBox.indexOf(a) && (d.isDirtyBox = !0);
                  -1 !== d.propsRequireReflow.indexOf(a) && (g ? d.isDirtyBox = !0 : n = !0);
                });
                !d.styledMode && m.style && d.renderer.setStyle(d.options.chart.style || {});
              }

              !d.styledMode && b.colors && (this.options.colors = b.colors);
              b.time && (this.time === C && (this.time = new p(b.time)), V(!0, d.options.time, b.time));
              Y(b, function (a, c) {
                if (d[c] && "function" === typeof d[c].update) d[c].update(a, !1);else if ("function" === typeof d[f[c]]) d[f[c]](a);else "colors" !== c && -1 === d.collectionsWithUpdate.indexOf(c) && V(!0, d.options[c], b[c]);
                "chart" !== c && -1 !== d.propsRequireUpdateSeries.indexOf(c) && (h = !0);
              });
              this.collectionsWithUpdate.forEach(function (a) {
                if (b[a]) {
                  var e = [];
                  d[a].forEach(function (b, a) {
                    b.options.isInternal || e.push(Q(b.options.index, a));
                  });
                  ca(b[a]).forEach(function (b, f) {
                    var g = T(b.id),
                        k;
                    g && (k = d.get(b.id));
                    !k && d[a] && (k = d[a][e ? e[f] : f]) && g && T(k.options.id) && (k = void 0);
                    k && k.coll === a && (k.update(b, !1), c && (k.touched = !0));
                    !k && c && d.collectionsWithInit[a] && (d.collectionsWithInit[a][0].apply(d, [b].concat(d.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
                  });
                  c && d[a].forEach(function (b) {
                    b.touched || b.options.isInternal ? delete b.touched : k.push(b);
                  });
                }
              });
              k.forEach(function (b) {
                b.chart && b.remove && b.remove(!1);
              });
              q && d.axes.forEach(function (b) {
                b.update({}, !1);
              });
              h && d.getSeriesOrderByLinks().forEach(function (b) {
                b.chart && b.update({}, !1);
              }, this);
              q = m && m.width;
              m = m && (X(m.height) ? ea(m.height, q || d.chartWidth) : m.height);
              n || U(q) && q !== d.chartWidth || U(m) && m !== d.chartHeight ? d.setSize(q, m, e) : Q(a, !0) && d.redraw(e);
              O(d, "afterUpdate", {
                options: b,
                redraw: a,
                animation: e
              });
            };

            b.prototype.setSubtitle = function (b, a) {
              this.applyDescription("subtitle", b);
              this.layOutTitles(a);
            };

            b.prototype.setCaption = function (b, a) {
              this.applyDescription("caption", b);
              this.layOutTitles(a);
            };

            b.prototype.showResetZoom = function () {
              function b() {
                a.zoomOut();
              }

              var a = this,
                  c = n.lang,
                  e = a.options.chart.resetZoomButton,
                  d = e.theme,
                  f = d.states,
                  g = "chart" === e.relativeTo || "spacingBox" === e.relativeTo ? null : "scrollablePlotBox";
              O(this, "beforeShowResetZoom", null, function () {
                a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, d, f && f.hover).attr({
                  align: e.position.align,
                  title: c.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(e.position, !1, g);
              });
              O(this, "afterShowResetZoom");
            };

            b.prototype.zoomOut = function () {
              O(this, "selection", {
                resetSelection: !0
              }, this.zoom);
            };

            b.prototype.zoom = function (b) {
              var a = this,
                  c = a.pointer,
                  e = a.inverted ? c.mouseDownX : c.mouseDownY,
                  d = !1,
                  f;
              !b || b.resetSelection ? (a.axes.forEach(function (b) {
                f = b.zoom();
              }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
                var g = b.axis,
                    k = a.inverted ? g.left : g.top,
                    h = a.inverted ? k + g.width : k + g.height,
                    n = g.isXAxis,
                    m = !1;
                if (!n && e >= k && e <= h || n || !T(e)) m = !0;
                c[n ? "zoomX" : "zoomY"] && m && (f = g.zoom(b.min, b.max), g.displayBtn && (d = !0));
              });
              var g = a.resetZoomButton;
              d && !g ? a.showResetZoom() : !d && P(g) && (a.resetZoomButton = g.destroy());
              f && a.redraw(Q(a.options.chart.animation, b && b.animation, 100 > a.pointCount));
            };

            b.prototype.pan = function (b, a) {
              var c = this,
                  e = c.hoverPoints;
              a = "object" === typeof a ? a : {
                enabled: a,
                type: "x"
              };
              var d = c.options.chart,
                  f = c.options.mapNavigation && c.options.mapNavigation.enabled;
              d && d.panning && (d.panning = a);
              var g = a.type,
                  k;
              O(this, "pan", {
                originalEvent: b
              }, function () {
                e && e.forEach(function (b) {
                  b.setState();
                });
                var a = c.xAxis;
                "xy" === g ? a = a.concat(c.yAxis) : "y" === g && (a = c.yAxis);
                var d = {};
                a.forEach(function (a) {
                  if (a.options.panningEnabled && !a.options.isInternal) {
                    var e = a.horiz,
                        h = b[e ? "chartX" : "chartY"];
                    e = e ? "mouseDownX" : "mouseDownY";
                    var n = c[e],
                        m = a.minPointOffset || 0,
                        q = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,
                        p = a.getExtremes(),
                        u = a.toValue(n - h, !0) + m * q,
                        l = a.toValue(n + a.len - h, !0) - (m * q || a.isXAxis && a.pointRangePadding || 0),
                        B = l < u;
                    q = a.hasVerticalPanning();
                    n = B ? l : u;
                    u = B ? u : l;
                    var x = a.panningState;
                    !q || a.isXAxis || x && !x.isDirty || a.series.forEach(function (b) {
                      var a = b.getProcessedData(!0);
                      a = b.getExtremes(a.yData, !0);
                      x || (x = {
                        startMin: Number.MAX_VALUE,
                        startMax: -Number.MAX_VALUE
                      });
                      U(a.dataMin) && U(a.dataMax) && (x.startMin = Math.min(Q(b.options.threshold, Infinity), a.dataMin, x.startMin), x.startMax = Math.max(Q(b.options.threshold, -Infinity), a.dataMax, x.startMax));
                    });
                    q = Math.min(Q(x && x.startMin, p.dataMin), m ? p.min : a.toValue(a.toPixels(p.min) - a.minPixelPadding));
                    l = Math.max(Q(x && x.startMax, p.dataMax), m ? p.max : a.toValue(a.toPixels(p.max) + a.minPixelPadding));
                    a.panningState = x;
                    a.isOrdinal || (m = q - n, 0 < m && (u += m, n = q), m = u - l, 0 < m && (u = l, n -= m), a.series.length && n !== p.min && u !== p.max && n >= q && u <= l && (a.setExtremes(n, u, !1, !1, {
                      trigger: "pan"
                    }), c.resetZoomButton || f || n === q || u === l || !g.match("y") || (c.showResetZoom(), a.displayBtn = !1), k = !0), d[e] = h);
                  }
                });
                Y(d, function (b, a) {
                  c[a] = b;
                });
                k && c.redraw(!1);
                R(c.container, {
                  cursor: "move"
                });
              });
            };

            return b;
          }();

          I(a.prototype, {
            callbacks: [],
            collectionsWithInit: {
              xAxis: [a.prototype.addAxis, [!0]],
              yAxis: [a.prototype.addAxis, [!1]],
              series: [a.prototype.addSeries]
            },
            collectionsWithUpdate: ["xAxis", "yAxis", "series"],
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
          });
          "";
          return a;
        });
        I(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.merge,
              A = a.pick,
              y;

          (function (a) {
            a.drawLineMarker = function (a) {
              var w = this.options,
                  t = a.symbolWidth,
                  l = a.symbolHeight,
                  h = l / 2,
                  d = this.chart.renderer,
                  b = this.legendGroup;
              a = a.baseline - Math.round(.3 * a.fontMetrics.b);
              var g = {},
                  p = w.marker;
              this.chart.styledMode || (g = {
                "stroke-width": w.lineWidth || 0
              }, w.dashStyle && (g.dashstyle = w.dashStyle));
              this.legendLine = d.path([["M", 0, a], ["L", t, a]]).addClass("highcharts-graph").attr(g).add(b);
              p && !1 !== p.enabled && t && (w = Math.min(A(p.radius, h), h), 0 === this.symbol.indexOf("url") && (p = r(p, {
                width: l,
                height: l
              }), w = 0), this.legendSymbol = t = d.symbol(this.symbol, t / 2 - w, a - w, 2 * w, 2 * w, p).addClass("highcharts-point").add(b), t.isMarker = !0);
            };

            a.drawRectangle = function (a, r) {
              var t = a.symbolHeight,
                  l = a.options.squareSymbol;
              r.legendSymbol = this.chart.renderer.rect(l ? (a.symbolWidth - t) / 2 : 0, a.baseline - t + 1, l ? t : a.symbolWidth, t, A(a.options.symbolRadius, t / 2)).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(r.legendGroup);
            };
          })(y || (y = {}));

          return y;
        });
        I(a, "Core/Series/SeriesDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          return {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
              duration: 1E3
            },
            events: {},
            marker: {
              enabledThreshold: 2,
              lineColor: a.backgroundColor,
              lineWidth: 0,
              radius: 4,
              states: {
                normal: {
                  animation: !0
                },
                hover: {
                  animation: {
                    duration: 50
                  },
                  enabled: !0,
                  radiusPlus: 2,
                  lineWidthPlus: 1
                },
                select: {
                  fillColor: a.neutralColor20,
                  lineColor: a.neutralColor100,
                  lineWidth: 2
                }
              }
            },
            point: {
              events: {}
            },
            dataLabels: {
              animation: {},
              align: "center",
              defer: !0,
              formatter: function formatter() {
                var a = this.series.chart.numberFormatter;
                return "number" !== typeof this.y ? "" : a(this.y, -1);
              },
              padding: 5,
              style: {
                fontSize: "11px",
                fontWeight: "bold",
                color: "contrast",
                textOutline: "1px contrast"
              },
              verticalAlign: "bottom",
              x: 0,
              y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                lineWidthPlus: 1,
                marker: {},
                halo: {
                  size: 10,
                  opacity: .25
                }
              },
              select: {
                animation: {
                  duration: 0
                }
              },
              inactive: {
                animation: {
                  duration: 50
                },
                opacity: .2
              }
            },
            stickyTracking: !0,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
          };
        });
        I(a, "Core/Series/Series.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/DefaultOptions.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Color/Palette.js"], a["Core/Series/Point.js"], a["Core/Series/SeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t, l, h, d) {
          var b = a.animObject,
              g = a.setAnimation,
              p = v.defaultOptions,
              k = A.registerEventOptions,
              r = y.hasTouch,
              G = y.svg,
              f = y.win,
              B = l.seriesTypes,
              x = d.addEvent,
              u = d.arrayMax,
              E = d.arrayMin,
              m = d.clamp,
              q = d.cleanRecursively,
              e = d.correctFloat,
              c = d.defined,
              n = d.erase,
              C = d.error,
              H = d.extend,
              L = d.find,
              F = d.fireEvent,
              W = d.getNestedProperty,
              S = d.isArray,
              R = d.isNumber,
              T = d.isString,
              ba = d.merge,
              N = d.objectEach,
              M = d.pick,
              I = d.removeEvent,
              ia = d.splat,
              O = d.syncTimeout;

          a = function () {
            function a() {
              this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
            }

            a.prototype.init = function (b, a) {
              F(this, "init", {
                options: a
              });
              var c = this,
                  e = b.series;
              this.eventsToUnbind = [];
              c.chart = b;
              c.options = c.setOptions(a);
              a = c.options;
              c.linkedSeries = [];
              c.bindAxes();
              H(c, {
                name: a.name,
                state: "",
                visible: !1 !== a.visible,
                selected: !0 === a.selected
              });
              k(this, a);
              var d = a.events;
              if (d && d.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;
              c.getColor();
              c.getSymbol();
              c.parallelArrays.forEach(function (b) {
                c[b + "Data"] || (c[b + "Data"] = []);
              });
              c.isCartesian && (b.hasCartesianSeries = !0);
              var f;
              e.length && (f = e[e.length - 1]);
              c._i = M(f && f._i, -1) + 1;
              c.opacity = c.options.opacity;
              b.orderSeries(this.insert(e));
              a.dataSorting && a.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(a.data, !1);
              F(this, "afterInit");
            };

            a.prototype.is = function (b) {
              return B[b] && this instanceof B[b];
            };

            a.prototype.insert = function (b) {
              var a = this.options.index,
                  c;

              if (R(a)) {
                for (c = b.length; c--;) {
                  if (a >= M(b[c].options.index, b[c]._i)) {
                    b.splice(c + 1, 0, this);
                    break;
                  }
                }

                -1 === c && b.unshift(this);
                c += 1;
              } else b.push(this);

              return M(c, b.length - 1);
            };

            a.prototype.bindAxes = function () {
              var b = this,
                  a = b.options,
                  c = b.chart,
                  e;
              F(this, "bindAxes", null, function () {
                (b.axisTypes || []).forEach(function (d) {
                  var f = 0;
                  c[d].forEach(function (c) {
                    e = c.options;
                    if (a[d] === f && !e.isInternal || "undefined" !== typeof a[d] && a[d] === e.id || "undefined" === typeof a[d] && 0 === e.index) b.insert(c.series), b[d] = c, c.isDirty = !0;
                    e.isInternal || f++;
                  });
                  b[d] || b.optionalAxis === d || C(18, !0, c);
                });
              });
              F(this, "afterBindAxes");
            };

            a.prototype.updateParallelArrays = function (b, a) {
              var c = b.series,
                  e = arguments,
                  d = R(a) ? function (e) {
                var d = "y" === e && c.toYData ? c.toYData(b) : b[e];
                c[e + "Data"][a] = d;
              } : function (b) {
                Array.prototype[a].apply(c[b + "Data"], Array.prototype.slice.call(e, 2));
              };
              c.parallelArrays.forEach(d);
            };

            a.prototype.hasData = function () {
              return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            };

            a.prototype.autoIncrement = function (b) {
              var a = this.options,
                  c = a.pointIntervalUnit,
                  e = a.relativeXValue,
                  d = this.chart.time,
                  f = this.xIncrement,
                  g;
              f = M(f, a.pointStart, 0);
              this.pointInterval = g = M(this.pointInterval, a.pointInterval, 1);
              e && R(b) && (g *= b);
              c && (a = new d.Date(f), "day" === c ? d.set("Date", a, d.get("Date", a) + g) : "month" === c ? d.set("Month", a, d.get("Month", a) + g) : "year" === c && d.set("FullYear", a, d.get("FullYear", a) + g), g = a.getTime() - f);
              if (e && R(b)) return f + g;
              this.xIncrement = f + g;
              return f;
            };

            a.prototype.setDataSortingOptions = function () {
              var b = this.options;
              H(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1
              });
              c(b.pointRange) || (b.pointRange = 1);
            };

            a.prototype.setOptions = function (b) {
              var a = this.chart,
                  e = a.options,
                  d = e.plotOptions,
                  f = a.userOptions || {};
              b = ba(b);
              a = a.styledMode;
              var g = {
                plotOptions: d,
                userOptions: b
              };
              F(this, "setOptions", g);
              var k = g.plotOptions[this.type],
                  h = f.plotOptions || {};
              this.userOptions = g.userOptions;
              f = ba(k, d.series, f.plotOptions && f.plotOptions[this.type], b);
              this.tooltipOptions = ba(p.tooltip, p.plotOptions.series && p.plotOptions.series.tooltip, p.plotOptions[this.type].tooltip, e.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, b.tooltip);
              this.stickyTracking = M(b.stickyTracking, h[this.type] && h[this.type].stickyTracking, h.series && h.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);
              null === k.marker && delete f.marker;
              this.zoneAxis = f.zoneAxis;
              d = this.zones = (f.zones || []).slice();
              !f.negativeColor && !f.negativeFillColor || f.zones || (e = {
                value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,
                className: "highcharts-negative"
              }, a || (e.color = f.negativeColor, e.fillColor = f.negativeFillColor), d.push(e));
              d.length && c(d[d.length - 1].value) && d.push(a ? {} : {
                color: this.color,
                fillColor: this.fillColor
              });
              F(this, "afterSetOptions", {
                options: f
              });
              return f;
            };

            a.prototype.getName = function () {
              return M(this.options.name, "Series " + (this.index + 1));
            };

            a.prototype.getCyclic = function (b, a, e) {
              var d = this.chart,
                  f = this.userOptions,
                  g = b + "Index",
                  k = b + "Counter",
                  h = e ? e.length : M(d.options.chart[b + "Count"], d[b + "Count"]);

              if (!a) {
                var n = M(f[g], f["_" + g]);
                c(n) || (d.series.length || (d[k] = 0), f["_" + g] = n = d[k] % h, d[k] += 1);
                e && (a = e[n]);
              }

              "undefined" !== typeof n && (this[g] = n);
              this[b] = a;
            };

            a.prototype.getColor = function () {
              this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = w.neutralColor20 : this.getCyclic("color", this.options.color || p.plotOptions[this.type].color, this.chart.options.colors);
            };

            a.prototype.getPointsCollection = function () {
              return (this.hasGroupedData ? this.points : this.data) || [];
            };

            a.prototype.getSymbol = function () {
              this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            };

            a.prototype.findPointIndex = function (b, a) {
              var c = b.id,
                  e = b.x,
                  d = this.points,
                  f = this.options.dataSorting,
                  g,
                  k;
              if (c) f = this.chart.get(c), f instanceof D && (g = f);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (g = function g(a) {
                return !a.touched && a.index === b.index;
              }, f && f.matchByName ? g = function g(a) {
                return !a.touched && a.name === b.name;
              } : this.options.relativeXValue && (g = function g(a) {
                return !a.touched && a.options.x === b.x;
              }), g = L(d, g), !g) return;

              if (g) {
                var h = g && g.index;
                "undefined" !== typeof h && (k = !0);
              }

              "undefined" === typeof h && R(e) && (h = this.xData.indexOf(e, a));
              -1 !== h && "undefined" !== typeof h && this.cropped && (h = h >= this.cropStart ? h - this.cropStart : h);
              !k && R(h) && d[h] && d[h].touched && (h = void 0);
              return h;
            };

            a.prototype.updateData = function (b, a) {
              var e = this.options,
                  d = e.dataSorting,
                  f = this.points,
                  g = [],
                  k = this.requireSorting,
                  h = b.length === f.length,
                  n,
                  m,
                  q,
                  p = !0;
              this.xIncrement = null;
              b.forEach(function (b, a) {
                var m = c(b) && this.pointClass.prototype.optionsToObject.call({
                  series: this
                }, b) || {},
                    p = m.x;

                if (m.id || R(p)) {
                  if (m = this.findPointIndex(m, q), -1 === m || "undefined" === typeof m ? g.push(b) : f[m] && b !== e.data[m] ? (f[m].update(b, !1, null, !1), f[m].touched = !0, k && (q = m + 1)) : f[m] && (f[m].touched = !0), !h || a !== m || d && d.enabled || this.hasDerivedData) n = !0;
                } else g.push(b);
              }, this);
              if (n) for (b = f.length; b--;) {
                (m = f[b]) && !m.touched && m.remove && m.remove(!1, a);
              } else !h || d && d.enabled ? p = !1 : (b.forEach(function (b, a) {
                b !== f[a].y && f[a].update && f[a].update(b, !1, null, !1);
              }), g.length = 0);
              f.forEach(function (b) {
                b && (b.touched = !1);
              });
              if (!p) return !1;
              g.forEach(function (b) {
                this.addPoint(b, !1, null, null, !1);
              }, this);
              null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = u(this.xData), this.autoIncrement());
              return !0;
            };

            a.prototype.setData = function (b, a, c, e) {
              var d = this,
                  f = d.points,
                  g = f && f.length || 0,
                  k = d.options,
                  h = d.chart,
                  n = k.dataSorting,
                  m = d.xAxis,
                  q = k.turboThreshold,
                  p = this.xData,
                  u = this.yData,
                  l = d.pointArrayMap;
              l = l && l.length;
              var B = k.keys,
                  x,
                  t = 0,
                  E = 1,
                  r = null;
              b = b || [];
              var K = b.length;
              a = M(a, !0);
              n && n.enabled && (b = this.sortData(b));
              !1 !== e && K && g && !d.cropped && !d.hasGroupedData && d.visible && !d.isSeriesBoosting && (x = this.updateData(b, c));

              if (!x) {
                d.xIncrement = null;
                d.colorCounter = 0;
                this.parallelArrays.forEach(function (b) {
                  d[b + "Data"].length = 0;
                });
                if (q && K > q) {
                  if (r = d.getFirstValidPoint(b), R(r)) for (c = 0; c < K; c++) {
                    p[c] = this.autoIncrement(), u[c] = b[c];
                  } else if (S(r)) {
                    if (l) for (c = 0; c < K; c++) {
                      e = b[c], p[c] = e[0], u[c] = e.slice(1, l + 1);
                    } else for (B && (t = B.indexOf("x"), E = B.indexOf("y"), t = 0 <= t ? t : 0, E = 0 <= E ? E : 1), c = 0; c < K; c++) {
                      e = b[c], p[c] = e[t], u[c] = e[E];
                    }
                  } else C(12, !1, h);
                } else for (c = 0; c < K; c++) {
                  "undefined" !== typeof b[c] && (e = {
                    series: d
                  }, d.pointClass.prototype.applyOptions.apply(e, [b[c]]), d.updateParallelArrays(e, c));
                }
                u && T(u[0]) && C(14, !0, h);
                d.data = [];
                d.options.data = d.userOptions.data = b;

                for (c = g; c--;) {
                  f[c] && f[c].destroy && f[c].destroy();
                }

                m && (m.minRange = m.userMinRange);
                d.isDirty = h.isDirtyBox = !0;
                d.isDirtyData = !!f;
                c = !1;
              }

              "point" === k.legendType && (this.processData(), this.generatePoints());
              a && h.redraw(c);
            };

            a.prototype.sortData = function (b) {
              var a = this,
                  e = a.options.dataSorting.sortKey || "y",
                  d = function d(b, a) {
                return c(a) && b.pointClass.prototype.optionsToObject.call({
                  series: b
                }, a) || {};
              };

              b.forEach(function (c, e) {
                b[e] = d(a, c);
                b[e].index = e;
              }, this);
              b.concat().sort(function (b, a) {
                b = W(e, b);
                a = W(e, a);
                return a < b ? -1 : a > b ? 1 : 0;
              }).forEach(function (b, a) {
                b.x = a;
              }, this);
              a.linkedSeries && a.linkedSeries.forEach(function (a) {
                var c = a.options,
                    e = c.data;
                c.dataSorting && c.dataSorting.enabled || !e || (e.forEach(function (c, f) {
                  e[f] = d(a, c);
                  b[f] && (e[f].x = b[f].x, e[f].index = f);
                }), a.setData(e, !1));
              });
              return b;
            };

            a.prototype.getProcessedData = function (b) {
              var a = this.xAxis,
                  c = this.options,
                  e = c.cropThreshold,
                  d = b || this.getExtremesFromAll || c.getExtremesFromAll,
                  f = this.isCartesian;
              b = a && a.val2lin;
              c = !(!a || !a.logarithmic);
              var g = 0,
                  k = this.xData,
                  h = this.yData,
                  n = this.requireSorting;
              var m = !1;
              var q = k.length;

              if (a) {
                m = a.getExtremes();
                var p = m.min;
                var u = m.max;
                m = a.categories && !a.names.length;
              }

              if (f && this.sorted && !d && (!e || q > e || this.forceCrop)) if (k[q - 1] < p || k[0] > u) k = [], h = [];else if (this.yData && (k[0] < p || k[q - 1] > u)) {
                var l = this.cropData(this.xData, this.yData, p, u);
                k = l.xData;
                h = l.yData;
                g = l.start;
                l = !0;
              }

              for (e = k.length || 1; --e;) {
                if (a = c ? b(k[e]) - b(k[e - 1]) : k[e] - k[e - 1], 0 < a && ("undefined" === typeof B || a < B)) var B = a;else 0 > a && n && !m && (C(15, !1, this.chart), n = !1);
              }

              return {
                xData: k,
                yData: h,
                cropped: l,
                cropStart: g,
                closestPointRange: B
              };
            };

            a.prototype.processData = function (b) {
              var a = this.xAxis;
              if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;
              b = this.getProcessedData();
              this.cropped = b.cropped;
              this.cropStart = b.cropStart;
              this.processedXData = b.xData;
              this.processedYData = b.yData;
              this.closestPointRange = this.basePointRange = b.closestPointRange;
            };

            a.prototype.cropData = function (b, a, c, e, d) {
              var f = b.length,
                  g,
                  k = 0,
                  h = f;
              d = M(d, this.cropShoulder);

              for (g = 0; g < f; g++) {
                if (b[g] >= c) {
                  k = Math.max(0, g - d);
                  break;
                }
              }

              for (c = g; c < f; c++) {
                if (b[c] > e) {
                  h = c + d;
                  break;
                }
              }

              return {
                xData: b.slice(k, h),
                yData: a.slice(k, h),
                start: k,
                end: h
              };
            };

            a.prototype.generatePoints = function () {
              var b = this.options,
                  a = b.data,
                  c = this.processedXData,
                  e = this.processedYData,
                  d = this.pointClass,
                  f = c.length,
                  g = this.cropStart || 0,
                  k = this.hasGroupedData,
                  h = b.keys,
                  n = [];
              b = b.dataGrouping && b.dataGrouping.groupAll ? g : 0;
              var m,
                  q,
                  p = this.data;

              if (!p && !k) {
                var u = [];
                u.length = a.length;
                p = this.data = u;
              }

              h && k && (this.options.keys = !1);

              for (q = 0; q < f; q++) {
                u = g + q;

                if (k) {
                  var l = new d().init(this, [c[q]].concat(ia(e[q])));
                  l.dataGroup = this.groupMap[b + q];
                  l.dataGroup.options && (l.options = l.dataGroup.options, H(l, l.dataGroup.options), delete l.dataLabels);
                } else (l = p[u]) || "undefined" === typeof a[u] || (p[u] = l = new d().init(this, a[u], c[q]));

                l && (l.index = k ? b + q : u, n[q] = l);
              }

              this.options.keys = h;
              if (p && (f !== (m = p.length) || k)) for (q = 0; q < m; q++) {
                q !== g || k || (q += f), p[q] && (p[q].destroyElements(), p[q].plotX = void 0);
              }
              this.data = p;
              this.points = n;
              F(this, "afterGeneratePoints");
            };

            a.prototype.getXExtremes = function (b) {
              return {
                min: E(b),
                max: u(b)
              };
            };

            a.prototype.getExtremes = function (b, a) {
              var c = this.xAxis,
                  e = this.yAxis,
                  d = this.processedXData || this.xData,
                  f = [],
                  g = this.requireSorting ? this.cropShoulder : 0;
              e = e ? e.positiveValuesOnly : !1;
              var k,
                  h = 0,
                  n = 0,
                  m = 0;
              b = b || this.stackedYData || this.processedYData || [];
              var q = b.length;

              if (c) {
                var p = c.getExtremes();
                h = p.min;
                n = p.max;
              }

              for (k = 0; k < q; k++) {
                var l = d[k];
                p = b[k];
                var B = (R(p) || S(p)) && (p.length || 0 < p || !e);
                l = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (d[k + g] || l) >= h && (d[k - g] || l) <= n;
                if (B && l) if (B = p.length) for (; B--;) {
                  R(p[B]) && (f[m++] = p[B]);
                } else f[m++] = p;
              }

              b = {
                dataMin: E(f),
                dataMax: u(f)
              };
              F(this, "afterGetExtremes", {
                dataExtremes: b
              });
              return b;
            };

            a.prototype.applyExtremes = function () {
              var b = this.getExtremes();
              this.dataMin = b.dataMin;
              this.dataMax = b.dataMax;
              return b;
            };

            a.prototype.getFirstValidPoint = function (b) {
              for (var a = b.length, c = 0, e = null; null === e && c < a;) {
                e = b[c], c++;
              }

              return e;
            };

            a.prototype.translate = function () {
              this.processedXData || this.processData();
              this.generatePoints();
              var b = this.options,
                  a = b.stacking,
                  d = this.xAxis,
                  f = d.categories,
                  g = this.enabledDataSorting,
                  k = this.yAxis,
                  h = this.points,
                  n = h.length,
                  q = !!this.modifyValue,
                  p = this.pointPlacementToXValue(),
                  u = !!p,
                  l = b.threshold,
                  B = b.startFromThreshold ? l : 0,
                  x = this.zoneAxis || "y",
                  t,
                  E,
                  r = Number.MAX_VALUE;

              for (t = 0; t < n; t++) {
                var C = h[t],
                    w = C.x,
                    G = void 0,
                    v = void 0,
                    H = C.y,
                    J = C.low,
                    D = a && k.stacking && k.stacking.stacks[(this.negStacks && H < (B ? 0 : l) ? "-" : "") + this.stackKey];
                if (k.positiveValuesOnly && !k.validatePositiveValue(H) || d.positiveValuesOnly && !d.validatePositiveValue(w)) C.isNull = !0;
                C.plotX = E = e(m(d.translate(w, 0, 0, 0, 1, p, "flags" === this.type), -1E5, 1E5));

                if (a && this.visible && D && D[w]) {
                  var y = this.getStackIndicator(y, w, this.index);
                  C.isNull || (G = D[w], v = G.points[y.key]);
                }

                S(v) && (J = v[0], H = v[1], J === B && y.key === D[w].base && (J = M(R(l) && l, k.min)), k.positiveValuesOnly && 0 >= J && (J = null), C.total = C.stackTotal = G.total, C.percentage = G.total && C.y / G.total * 100, C.stackY = H, this.irregularWidths || G.setOffset(this.pointXOffset || 0, this.barW || 0));
                C.yBottom = c(J) ? m(k.translate(J, 0, 1, 0, 1), -1E5, 1E5) : null;
                q && (H = this.modifyValue(H, C));
                C.plotY = void 0;
                R(H) && (G = k.translate(H, !1, !0, !1, !0), "undefined" !== typeof G && (C.plotY = m(G, -1E5, 1E5)));
                C.isInside = this.isPointInside(C);
                C.clientX = u ? e(d.translate(w, 0, 0, 0, 1, p)) : E;
                C.negative = C[x] < (b[x + "Threshold"] || l || 0);
                C.category = f && "undefined" !== typeof f[C.x] ? f[C.x] : C.x;

                if (!C.isNull && !1 !== C.visible) {
                  "undefined" !== typeof A && (r = Math.min(r, Math.abs(E - A)));
                  var A = E;
                }

                C.zone = this.zones.length && C.getZone();
                !C.graphic && this.group && g && (C.isNew = !0);
              }

              this.closestPointRangePx = r;
              F(this, "afterTranslate");
            };

            a.prototype.getValidPoints = function (b, a, c) {
              var e = this.chart;
              return (b || this.points || []).filter(function (b) {
                return a && !e.isInsidePlot(b.plotX, b.plotY, {
                  inverted: e.inverted
                }) ? !1 : !1 !== b.visible && (c || !b.isNull);
              });
            };

            a.prototype.getClipBox = function (b, a) {
              var c = this.options,
                  e = this.chart,
                  d = e.inverted,
                  f = this.xAxis,
                  g = f && this.yAxis,
                  k = e.options.chart.scrollablePlotArea || {};
              b && !1 === c.clip && g ? b = d ? {
                y: -e.chartWidth + g.len + g.pos,
                height: e.chartWidth,
                width: e.chartHeight,
                x: -e.chartHeight + f.len + f.pos
              } : {
                y: -g.pos,
                height: e.chartHeight,
                width: e.chartWidth,
                x: -f.pos
              } : (b = this.clipBox || e.clipBox, a && (b.width = e.plotSizeX, b.x = (e.scrollablePixelsX || 0) * (k.scrollPositionX || 0)));
              return a ? {
                width: b.width,
                x: b.x
              } : b;
            };

            a.prototype.getSharedClipKey = function (b) {
              if (this.sharedClipKey) return this.sharedClipKey;
              var a = [b && b.duration, b && b.easing, b && b.defer, this.getClipBox(b).height, this.options.xAxis, this.options.yAxis].join();
              if (!1 !== this.options.clip || b) this.sharedClipKey = a;
              return a;
            };

            a.prototype.setClip = function (b) {
              var a = this.chart,
                  c = this.options,
                  e = a.renderer,
                  d = a.inverted,
                  f = this.clipBox,
                  g = this.getClipBox(b),
                  k = this.getSharedClipKey(b),
                  h = a.sharedClips[k],
                  n = a.sharedClips[k + "m"];
              b && (g.width = 0, d && (g.x = a.plotHeight + (!1 !== c.clip ? 0 : a.plotTop)));
              h ? a.hasLoaded || h.attr(g) : (b && (a.sharedClips[k + "m"] = n = e.clipRect(d ? (a.plotSizeX || 0) + 99 : -99, d ? -a.plotLeft : -a.plotTop, 99, d ? a.chartWidth : a.chartHeight)), a.sharedClips[k] = h = e.clipRect(g), h.count = {
                length: 0
              });
              b && !h.count[this.index] && (h.count[this.index] = !0, h.count.length += 1);
              if (!1 !== c.clip || b) this.group.clip(b || f ? h : a.clipRect), this.markerGroup.clip(n);
              b || (h.count[this.index] && (delete h.count[this.index], --h.count.length), 0 === h.count.length && (f || (a.sharedClips[k] = h.destroy()), n && (a.sharedClips[k + "m"] = n.destroy())));
            };

            a.prototype.animate = function (a) {
              var c = this.chart,
                  e = b(this.options.animation),
                  d = this.sharedClipKey;
              if (a) this.setClip(e);else if (d) {
                a = c.sharedClips[d];
                d = c.sharedClips[d + "m"];
                var f = this.getClipBox(e, !0);
                a && a.animate(f, e);
                d && d.animate({
                  width: f.width + 99,
                  x: f.x - (c.inverted ? 0 : 99)
                }, e);
              }
            };

            a.prototype.afterAnimate = function () {
              this.setClip();
              F(this, "afterAnimate");
              this.finishedAnimating = !0;
            };

            a.prototype.drawPoints = function () {
              var b = this.points,
                  a = this.chart,
                  c = this.options.marker,
                  e = this[this.specialGroup] || this.markerGroup,
                  d = this.xAxis,
                  f = M(c.enabled, !d || d.isRadial ? !0 : null, this.closestPointRangePx >= c.enabledThreshold * c.radius),
                  g,
                  k;
              if (!1 !== c.enabled || this._hasPointMarkers) for (g = 0; g < b.length; g++) {
                var h = b[g];
                var n = (k = h.graphic) ? "animate" : "attr";
                var m = h.marker || {};
                var q = !!h.marker;

                if ((f && "undefined" === typeof m.enabled || m.enabled) && !h.isNull && !1 !== h.visible) {
                  var p = M(m.symbol, this.symbol, "rect");
                  var u = this.markerAttribs(h, h.selected && "select");
                  this.enabledDataSorting && (h.startXPos = d.reversed ? -(u.width || 0) : d.width);
                  var l = !1 !== h.isInside;
                  k ? k[l ? "show" : "hide"](l).animate(u) : l && (0 < (u.width || 0) || h.hasImage) && (h.graphic = k = a.renderer.symbol(p, u.x, u.y, u.width, u.height, q ? m : c).add(e), this.enabledDataSorting && a.hasRendered && (k.attr({
                    x: h.startXPos
                  }), n = "animate"));
                  k && "animate" === n && k[l ? "show" : "hide"](l).animate(u);
                  if (k && !a.styledMode) k[n](this.pointAttribs(h, h.selected && "select"));
                  k && k.addClass(h.getClassName(), !0);
                } else k && (h.graphic = k.destroy());
              }
            };

            a.prototype.markerAttribs = function (b, a) {
              var c = this.options,
                  e = c.marker,
                  d = b.marker || {},
                  f = d.symbol || e.symbol,
                  g = M(d.radius, e.radius);
              a && (e = e.states[a], a = d.states && d.states[a], g = M(a && a.radius, e && e.radius, g + (e && e.radiusPlus || 0)));
              b.hasImage = f && 0 === f.indexOf("url");
              b.hasImage && (g = 0);
              b = {
                x: c.crisp ? Math.floor(b.plotX - g) : b.plotX - g,
                y: b.plotY - g
              };
              g && (b.width = b.height = 2 * g);
              return b;
            };

            a.prototype.pointAttribs = function (b, a) {
              var c = this.options.marker,
                  e = b && b.options,
                  d = e && e.marker || {},
                  f = e && e.color,
                  g = b && b.color,
                  k = b && b.zone && b.zone.color,
                  h = this.color;
              b = M(d.lineWidth, c.lineWidth);
              e = 1;
              h = f || k || g || h;
              f = d.fillColor || c.fillColor || h;
              g = d.lineColor || c.lineColor || h;
              a = a || "normal";
              c = c.states[a];
              a = d.states && d.states[a] || {};
              b = M(a.lineWidth, c.lineWidth, b + M(a.lineWidthPlus, c.lineWidthPlus, 0));
              f = a.fillColor || c.fillColor || f;
              g = a.lineColor || c.lineColor || g;
              e = M(a.opacity, c.opacity, e);
              return {
                stroke: g,
                "stroke-width": b,
                fill: f,
                opacity: e
              };
            };

            a.prototype.destroy = function (b) {
              var a = this,
                  c = a.chart,
                  e = /AppleWebKit\/533/.test(f.navigator.userAgent),
                  g = a.data || [],
                  k,
                  m,
                  q,
                  p;
              F(a, "destroy");
              this.removeEvents(b);
              (a.axisTypes || []).forEach(function (b) {
                (p = a[b]) && p.series && (n(p.series, a), p.isDirty = p.forceRedraw = !0);
              });
              a.legendItem && a.chart.legend.destroyItem(a);

              for (m = g.length; m--;) {
                (q = g[m]) && q.destroy && q.destroy();
              }

              a.clips && a.clips.forEach(function (b) {
                return b.destroy();
              });
              d.clearTimeout(a.animationTimeout);
              N(a, function (b, a) {
                b instanceof h && !b.survive && (k = e && "group" === a ? "hide" : "destroy", b[k]());
              });
              c.hoverSeries === a && (c.hoverSeries = void 0);
              n(c.series, a);
              c.orderSeries();
              N(a, function (c, e) {
                b && "hcEvents" === e || delete a[e];
              });
            };

            a.prototype.applyZones = function () {
              var b = this,
                  a = this.chart,
                  c = a.renderer,
                  e = this.zones,
                  d = this.clips || [],
                  f = this.graph,
                  g = this.area,
                  k = Math.max(a.chartWidth, a.chartHeight),
                  h = this[(this.zoneAxis || "y") + "Axis"],
                  n = a.inverted,
                  q,
                  p,
                  u,
                  l,
                  B,
                  x,
                  t,
                  E,
                  r = !1;

              if (e.length && (f || g) && h && "undefined" !== typeof h.min) {
                var C = h.reversed;
                var w = h.horiz;
                f && !this.showLine && f.hide();
                g && g.hide();
                var G = h.getExtremes();
                e.forEach(function (e, v) {
                  q = C ? w ? a.plotWidth : 0 : w ? 0 : h.toPixels(G.min) || 0;
                  q = m(M(p, q), 0, k);
                  p = m(Math.round(h.toPixels(M(e.value, G.max), !0) || 0), 0, k);
                  r && (q = p = h.toPixels(G.max));
                  l = Math.abs(q - p);
                  B = Math.min(q, p);
                  x = Math.max(q, p);
                  h.isXAxis ? (u = {
                    x: n ? x : B,
                    y: 0,
                    width: l,
                    height: k
                  }, w || (u.x = a.plotHeight - u.x)) : (u = {
                    x: 0,
                    y: n ? x : B,
                    width: k,
                    height: l
                  }, w && (u.y = a.plotWidth - u.y));
                  n && c.isVML && (u = h.isXAxis ? {
                    x: 0,
                    y: C ? B : x,
                    height: u.width,
                    width: a.chartWidth
                  } : {
                    x: u.y - a.plotLeft - a.spacingBox.x,
                    y: 0,
                    width: u.height,
                    height: a.chartHeight
                  });
                  d[v] ? d[v].animate(u) : d[v] = c.clipRect(u);
                  t = b["zone-area-" + v];
                  E = b["zone-graph-" + v];
                  f && E && E.clip(d[v]);
                  g && t && t.clip(d[v]);
                  r = e.value > G.max;
                  b.resetZones && 0 === p && (p = void 0);
                });
                this.clips = d;
              } else b.visible && (f && f.show(!0), g && g.show(!0));
            };

            a.prototype.invertGroups = function (b) {
              function a() {
                ["group", "markerGroup"].forEach(function (a) {
                  c[a] && (e.renderer.isVML && c[a].attr({
                    width: c.yAxis.len,
                    height: c.xAxis.len
                  }), c[a].width = c.yAxis.len, c[a].height = c.xAxis.len, c[a].invert(c.isRadialSeries ? !1 : b));
                });
              }

              var c = this,
                  e = c.chart;
              c.xAxis && (c.eventsToUnbind.push(x(e, "resize", a)), a(), c.invertGroups = a);
            };

            a.prototype.plotGroup = function (b, a, e, d, f) {
              var g = this[b],
                  k = !g;
              e = {
                visibility: e,
                zIndex: d || .1
              };
              "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (e.opacity = this.opacity);
              k && (this[b] = g = this.chart.renderer.g().add(f));
              g.addClass("highcharts-" + a + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (c(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (g.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
              g.attr(e)[k ? "attr" : "animate"](this.getPlotBox());
              return g;
            };

            a.prototype.getPlotBox = function () {
              var b = this.chart,
                  a = this.xAxis,
                  c = this.yAxis;
              b.inverted && (a = c, c = this.xAxis);
              return {
                translateX: a ? a.left : b.plotLeft,
                translateY: c ? c.top : b.plotTop,
                scaleX: 1,
                scaleY: 1
              };
            };

            a.prototype.removeEvents = function (b) {
              b || I(this);
              this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
                b();
              }), this.eventsToUnbind.length = 0);
            };

            a.prototype.render = function () {
              var a = this,
                  c = a.chart,
                  e = a.options,
                  d = b(e.animation),
                  f = a.visible ? "inherit" : "hidden",
                  g = e.zIndex,
                  k = a.hasRendered,
                  h = c.seriesGroup,
                  n = c.inverted,
                  m = !a.finishedAnimating && c.renderer.isSVG && d.duration;
              F(this, "render");
              var q = a.plotGroup("group", "series", f, g, h);
              a.markerGroup = a.plotGroup("markerGroup", "markers", f, g, h);
              m && a.animate && a.animate(!0);
              q.inverted = M(a.invertible, a.isCartesian) ? n : !1;
              a.drawGraph && (a.drawGraph(), a.applyZones());
              a.visible && a.drawPoints();
              a.drawDataLabels && a.drawDataLabels();
              a.redrawPoints && a.redrawPoints();
              a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
              a.invertGroups(n);
              !1 === e.clip || a.sharedClipKey || k || q.clip(c.clipRect);
              m && a.animate && a.animate();
              k || (m && d.defer && (m += d.defer), a.animationTimeout = O(function () {
                a.afterAnimate();
              }, m || 0));
              a.isDirty = !1;
              a.hasRendered = !0;
              F(a, "afterRender");
            };

            a.prototype.redraw = function () {
              var b = this.chart,
                  a = this.isDirty || this.isDirtyData,
                  c = this.group,
                  e = this.xAxis,
                  d = this.yAxis;
              c && (b.inverted && c.attr({
                width: b.plotWidth,
                height: b.plotHeight
              }), c.animate({
                translateX: M(e && e.left, b.plotLeft),
                translateY: M(d && d.top, b.plotTop)
              }));
              this.translate();
              this.render();
              a && delete this.kdTree;
            };

            a.prototype.searchPoint = function (b, a) {
              var c = this.xAxis,
                  e = this.yAxis,
                  d = this.chart.inverted;
              return this.searchKDTree({
                clientX: d ? c.len - b.chartY + c.pos : b.chartX - c.pos,
                plotY: d ? e.len - b.chartX + e.pos : b.chartY - e.pos
              }, a, b);
            };

            a.prototype.buildKDTree = function (b) {
              function a(b, e, d) {
                var f = b && b.length;

                if (f) {
                  var g = c.kdAxisArray[e % d];
                  b.sort(function (b, a) {
                    return b[g] - a[g];
                  });
                  f = Math.floor(f / 2);
                  return {
                    point: b[f],
                    left: a(b.slice(0, f), e + 1, d),
                    right: a(b.slice(f + 1), e + 1, d)
                  };
                }
              }

              this.buildingKdTree = !0;
              var c = this,
                  e = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete c.kdTree;
              O(function () {
                c.kdTree = a(c.getValidPoints(null, !c.directTouch), e, e);
                c.buildingKdTree = !1;
              }, c.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
            };

            a.prototype.searchKDTree = function (b, a, e) {
              function d(b, a, e, n) {
                var m = a.point,
                    q = f.kdAxisArray[e % n],
                    p = m,
                    u = c(b[g]) && c(m[g]) ? Math.pow(b[g] - m[g], 2) : null;
                var l = c(b[k]) && c(m[k]) ? Math.pow(b[k] - m[k], 2) : null;
                l = (u || 0) + (l || 0);
                m.dist = c(l) ? Math.sqrt(l) : Number.MAX_VALUE;
                m.distX = c(u) ? Math.sqrt(u) : Number.MAX_VALUE;
                q = b[q] - m[q];
                l = 0 > q ? "left" : "right";
                u = 0 > q ? "right" : "left";
                a[l] && (l = d(b, a[l], e + 1, n), p = l[h] < p[h] ? l : m);
                a[u] && Math.sqrt(q * q) < p[h] && (b = d(b, a[u], e + 1, n), p = b[h] < p[h] ? b : p);
                return p;
              }

              var f = this,
                  g = this.kdAxisArray[0],
                  k = this.kdAxisArray[1],
                  h = a ? "distX" : "dist";
              a = -1 < f.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              this.kdTree || this.buildingKdTree || this.buildKDTree(e);
              if (this.kdTree) return d(b, this.kdTree, a, a);
            };

            a.prototype.pointPlacementToXValue = function () {
              var b = this.options,
                  a = b.pointRange,
                  c = this.xAxis;
              b = b.pointPlacement;
              "between" === b && (b = c.reversed ? -.5 : .5);
              return R(b) ? b * (a || c.pointRange) : 0;
            };

            a.prototype.isPointInside = function (b) {
              return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= this.yAxis.len && 0 <= b.plotX && b.plotX <= this.xAxis.len;
            };

            a.prototype.drawTracker = function () {
              var b = this,
                  a = b.options,
                  c = a.trackByArea,
                  e = [].concat(c ? b.areaPath : b.graphPath),
                  d = b.chart,
                  f = d.pointer,
                  g = d.renderer,
                  k = d.options.tooltip.snap,
                  h = b.tracker,
                  n = function n(a) {
                if (d.hoverSeries !== b) b.onMouseOver();
              },
                  m = "rgba(192,192,192," + (G ? .0001 : .002) + ")";

              h ? h.attr({
                d: e
              }) : b.graph && (b.tracker = g.path(e).attr({
                visibility: b.visible ? "visible" : "hidden",
                zIndex: 2
              }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), d.styledMode || b.tracker.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                stroke: m,
                fill: c ? m : "none",
                "stroke-width": b.graph.strokeWidth() + (c ? 0 : 2 * k)
              }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
                if (b && (b.addClass("highcharts-tracker").on("mouseover", n).on("mouseout", function (b) {
                  f.onTrackerMouseOut(b);
                }), a.cursor && !d.styledMode && b.css({
                  cursor: a.cursor
                }), r)) b.on("touchstart", n);
              }));
              F(this, "afterDrawTracker");
            };

            a.prototype.addPoint = function (b, a, c, e, d) {
              var f = this.options,
                  g = this.data,
                  k = this.chart,
                  h = this.xAxis;
              h = h && h.hasNames && h.names;
              var n = f.data,
                  m = this.xData,
                  q;
              a = M(a, !0);
              var p = {
                series: this
              };
              this.pointClass.prototype.applyOptions.apply(p, [b]);
              var u = p.x;
              var l = m.length;
              if (this.requireSorting && u < m[l - 1]) for (q = !0; l && m[l - 1] > u;) {
                l--;
              }
              this.updateParallelArrays(p, "splice", l, 0, 0);
              this.updateParallelArrays(p, l);
              h && p.name && (h[u] = p.name);
              n.splice(l, 0, b);
              q && (this.data.splice(l, 0, null), this.processData());
              "point" === f.legendType && this.generatePoints();
              c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(p, "shift"), n.shift()));
              !1 !== d && F(this, "addPoint", {
                point: p
              });
              this.isDirtyData = this.isDirty = !0;
              a && k.redraw(e);
            };

            a.prototype.removePoint = function (b, a, c) {
              var e = this,
                  d = e.data,
                  f = d[b],
                  k = e.points,
                  h = e.chart,
                  n = function n() {
                k && k.length === d.length && k.splice(b, 1);
                d.splice(b, 1);
                e.options.data.splice(b, 1);
                e.updateParallelArrays(f || {
                  series: e
                }, "splice", b, 1);
                f && f.destroy();
                e.isDirty = !0;
                e.isDirtyData = !0;
                a && h.redraw();
              };

              g(c, h);
              a = M(a, !0);
              f ? f.firePointEvent("remove", null, n) : n();
            };

            a.prototype.remove = function (b, a, c, e) {
              function d() {
                f.destroy(e);
                g.isDirtyLegend = g.isDirtyBox = !0;
                g.linkSeries();
                M(b, !0) && g.redraw(a);
              }

              var f = this,
                  g = f.chart;
              !1 !== c ? F(f, "remove", null, d) : d();
            };

            a.prototype.update = function (b, a) {
              b = q(b, this.userOptions);
              F(this, "update", {
                options: b
              });
              var c = this,
                  e = c.chart,
                  d = c.userOptions,
                  f = c.initialType || c.type,
                  g = e.options.plotOptions,
                  k = B[f].prototype,
                  h = c.finishedAnimating && {
                animation: !1
              },
                  n = {},
                  m,
                  p = ["eventOptions", "navigatorSeries", "baseSeries"],
                  u = b.type || d.type || e.options.chart.type,
                  l = !(this.hasDerivedData || u && u !== this.type || "undefined" !== typeof b.pointStart || "undefined" !== typeof b.pointInterval || "undefined" !== typeof b.relativeXValue || c.hasOptionChanged("dataGrouping") || c.hasOptionChanged("pointStart") || c.hasOptionChanged("pointInterval") || c.hasOptionChanged("pointIntervalUnit") || c.hasOptionChanged("keys"));
              u = u || f;
              l && (p.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== b.visible && p.push("area", "graph"), c.parallelArrays.forEach(function (b) {
                p.push(b + "Data");
              }), b.data && (b.dataSorting && H(c.options.dataSorting, b.dataSorting), this.setData(b.data, !1)));
              b = ba(d, h, {
                index: "undefined" === typeof d.index ? c.index : d.index,
                pointStart: M(g && g.series && g.series.pointStart, d.pointStart, c.xData[0])
              }, !l && {
                data: c.options.data
              }, b);
              l && b.data && (b.data = c.options.data);
              p = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(p);
              p.forEach(function (b) {
                p[b] = c[b];
                delete c[b];
              });
              g = !1;

              if (B[u]) {
                if (g = u !== c.type, c.remove(!1, !1, !1, !0), g) if (Object.setPrototypeOf) Object.setPrototypeOf(c, B[u].prototype);else {
                  h = Object.hasOwnProperty.call(c, "hcEvents") && c.hcEvents;

                  for (m in k) {
                    c[m] = void 0;
                  }

                  H(c, B[u].prototype);
                  h ? c.hcEvents = h : delete c.hcEvents;
                }
              } else C(17, !0, e, {
                missingModuleFor: u
              });

              p.forEach(function (b) {
                c[b] = p[b];
              });
              c.init(e, b);

              if (l && this.points) {
                var x = c.options;
                !1 === x.visible ? (n.graphic = 1, n.dataLabel = 1) : c._hasPointLabels || (b = x.marker, k = x.dataLabels, !b || !1 !== b.enabled && (d.marker && d.marker.symbol) === b.symbol || (n.graphic = 1), k && !1 === k.enabled && (n.dataLabel = 1));
                this.points.forEach(function (b) {
                  b && b.series && (b.resolveColor(), Object.keys(n).length && b.destroyElements(n), !1 === x.showInLegend && b.legendItem && e.legend.destroyItem(b));
                }, this);
              }

              c.initialType = f;
              e.linkSeries();
              g && c.linkedSeries.length && (c.isDirtyData = !0);
              F(this, "afterUpdate");
              M(a, !0) && e.redraw(l ? void 0 : !1);
            };

            a.prototype.setName = function (b) {
              this.name = this.options.name = this.userOptions.name = b;
              this.chart.isDirtyLegend = !0;
            };

            a.prototype.hasOptionChanged = function (b) {
              var a = this.options[b],
                  c = this.chart.options.plotOptions,
                  e = this.userOptions[b];
              return e ? a !== e : a !== M(c && c[this.type] && c[this.type][b], c && c.series && c.series[b], a);
            };

            a.prototype.onMouseOver = function () {
              var b = this.chart,
                  a = b.hoverSeries;
              b.pointer.setHoverChartIndex();
              if (a && a !== this) a.onMouseOut();
              this.options.events.mouseOver && F(this, "mouseOver");
              this.setState("hover");
              b.hoverSeries = this;
            };

            a.prototype.onMouseOut = function () {
              var b = this.options,
                  a = this.chart,
                  c = a.tooltip,
                  e = a.hoverPoint;
              a.hoverSeries = null;
              if (e) e.onMouseOut();
              this && b.events.mouseOut && F(this, "mouseOut");
              !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
              a.series.forEach(function (b) {
                b.setState("", !0);
              });
            };

            a.prototype.setState = function (b, a) {
              var c = this,
                  e = c.options,
                  d = c.graph,
                  f = e.inactiveOtherPoints,
                  g = e.states,
                  k = M(g[b || "normal"] && g[b || "normal"].animation, c.chart.options.chart.animation),
                  h = e.lineWidth,
                  n = 0,
                  m = e.opacity;
              b = b || "";

              if (c.state !== b && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (a) {
                a && (c.state && a.removeClass("highcharts-series-" + c.state), b && a.addClass("highcharts-series-" + b));
              }), c.state = b, !c.chart.styledMode)) {
                if (g[b] && !1 === g[b].enabled) return;
                b && (h = g[b].lineWidth || h + (g[b].lineWidthPlus || 0), m = M(g[b].opacity, m));
                if (d && !d.dashstyle) for (e = {
                  "stroke-width": h
                }, d.animate(e, k); c["zone-graph-" + n];) {
                  c["zone-graph-" + n].animate(e, k), n += 1;
                }
                f || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (b) {
                  b && b.animate({
                    opacity: m
                  }, k);
                });
              }

              a && f && c.points && c.setAllPointsToState(b || void 0);
            };

            a.prototype.setAllPointsToState = function (b) {
              this.points.forEach(function (a) {
                a.setState && a.setState(b);
              });
            };

            a.prototype.setVisible = function (b, a) {
              var c = this,
                  e = c.chart,
                  d = c.legendItem,
                  f = e.options.chart.ignoreHiddenSeries,
                  g = c.visible,
                  k = (c.visible = b = c.options.visible = c.userOptions.visible = "undefined" === typeof b ? !g : b) ? "show" : "hide";
              ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
                if (c[b]) c[b][k]();
              });
              if (e.hoverSeries === c || (e.hoverPoint && e.hoverPoint.series) === c) c.onMouseOut();
              d && e.legend.colorizeItem(c, b);
              c.isDirty = !0;
              c.options.stacking && e.series.forEach(function (b) {
                b.options.stacking && b.visible && (b.isDirty = !0);
              });
              c.linkedSeries.forEach(function (a) {
                a.setVisible(b, !1);
              });
              f && (e.isDirtyBox = !0);
              F(c, k);
              !1 !== a && e.redraw();
            };

            a.prototype.show = function () {
              this.setVisible(!0);
            };

            a.prototype.hide = function () {
              this.setVisible(!1);
            };

            a.prototype.select = function (b) {
              this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
              this.checkbox && (this.checkbox.checked = b);
              F(this, b ? "select" : "unselect");
            };

            a.prototype.shouldShowTooltip = function (b, a, c) {
              void 0 === c && (c = {});
              c.series = this;
              c.visiblePlotOnly = !0;
              return this.chart.isInsidePlot(b, a, c);
            };

            a.defaultOptions = t;
            return a;
          }();

          H(a.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            drawLegendSymbol: z.drawLineMarker,
            isCartesian: !0,
            kdAxisArray: ["clientX", "plotY"],
            parallelArrays: ["x", "y"],
            pointClass: D,
            requireSorting: !0,
            sorted: !0
          });
          l.series = a;
          "";
          "";
          return a;
        });
        I(a, "Extensions/ScrollablePlotArea.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w) {
          var r = a.stop,
              t = w.addEvent,
              l = w.createElement,
              h = w.merge,
              d = w.pick;
          t(A, "afterSetChartSize", function (b) {
            var a = this.options.chart.scrollablePlotArea,
                d = a && a.minWidth;
            a = a && a.minHeight;

            if (!this.renderer.forExport) {
              if (d) {
                if (this.scrollablePixelsX = d = Math.max(0, d - this.chartWidth)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = h(this.plotBox);
                  this.plotBox.width = this.plotWidth += d;
                  this.inverted ? this.clipBox.height += d : this.clipBox.width += d;
                  var k = {
                    1: {
                      name: "right",
                      value: d
                    }
                  };
                }
              } else a && (this.scrollablePixelsY = d = Math.max(0, a - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = h(this.plotBox), this.plotBox.height = this.plotHeight += d, this.inverted ? this.clipBox.width += d : this.clipBox.height += d, k = {
                2: {
                  name: "bottom",
                  value: d
                }
              });

              k && !b.skipAxes && this.axes.forEach(function (b) {
                k[b.side] ? b.getPlotLinePath = function () {
                  var a = k[b.side].name,
                      d = this[a];
                  this[a] = d - k[b.side].value;
                  var g = v.prototype.getPlotLinePath.apply(this, arguments);
                  this[a] = d;
                  return g;
                } : (b.setAxisSize(), b.setAxisTranslation());
              });
            }
          });
          t(A, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
          });

          A.prototype.setUpScrolling = function () {
            var b = this,
                a = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            this.scrollablePixelsX && (a.overflowX = "auto");
            this.scrollablePixelsY && (a.overflowY = "auto");
            this.scrollingParent = l("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = l("div", {
              className: "highcharts-scrolling"
            }, a, this.scrollingParent);
            t(this.scrollingContainer, "scroll", function () {
              b.pointer && delete b.pointer.chartPosition;
            });
            this.innerContainer = l("div", {
              className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };

          A.prototype.moveFixedElements = function () {
            var b = this.container,
                a = this.fixedRenderer,
                d = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
                k;
            this.scrollablePixelsX && !this.inverted ? k = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? k = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? k = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (k = ".highcharts-yaxis");
            k && d.push(k + ":not(.highcharts-radial-axis)", k + "-labels:not(.highcharts-radial-axis-labels)");
            d.forEach(function (d) {
              [].forEach.call(b.querySelectorAll(d), function (b) {
                (b.namespaceURI === a.SVG_NS ? a.box : a.box.parentNode).appendChild(b);
                b.style.pointerEvents = "auto";
              });
            });
          };

          A.prototype.applyFixed = function () {
            var b = !this.fixedDiv,
                a = this.options.chart,
                h = a.scrollablePlotArea,
                k = z.getRendererType();
            b ? (this.fixedDiv = l("div", {
              className: "highcharts-fixed"
            }, {
              position: "absolute",
              overflow: "hidden",
              pointerEvents: "none",
              zIndex: (a.style && a.style.zIndex || 0) + 2,
              top: 0
            }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = a = new k(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = a.path().attr({
              fill: this.options.chart.backgroundColor || "#fff",
              "fill-opacity": d(h.opacity, .85),
              zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), t(this, "afterShowResetZoom", this.moveFixedElements), t(this, "afterDrilldown", this.moveFixedElements), t(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            if (this.scrollableDirty || b) this.scrollableDirty = !1, this.moveFixedElements();
            a = this.chartWidth + (this.scrollablePixelsX || 0);
            k = this.chartHeight + (this.scrollablePixelsY || 0);
            r(this.container);
            this.container.style.width = a + "px";
            this.container.style.height = k + "px";
            this.renderer.boxWrapper.attr({
              width: a,
              height: k,
              viewBox: [0, 0, a, k].join(" ")
            });
            this.chartBackground.attr({
              width: a,
              height: k
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            b && (h.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * h.scrollPositionX), h.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * h.scrollPositionY));
            k = this.axisOffset;
            b = this.plotTop - k[0] - 1;
            h = this.plotLeft - k[3] - 1;
            a = this.plotTop + this.plotHeight + k[2] + 1;
            k = this.plotLeft + this.plotWidth + k[1] + 1;
            var w = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                v = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            b = this.scrollablePixelsX ? [["M", 0, b], ["L", this.plotLeft - 1, b], ["L", this.plotLeft - 1, a], ["L", 0, a], ["Z"], ["M", w, b], ["L", this.chartWidth, b], ["L", this.chartWidth, a], ["L", w, a], ["Z"]] : this.scrollablePixelsY ? [["M", h, 0], ["L", h, this.plotTop - 1], ["L", k, this.plotTop - 1], ["L", k, 0], ["Z"], ["M", h, v], ["L", h, this.chartHeight], ["L", k, this.chartHeight], ["L", k, v], ["Z"]] : [["M", 0, 0]];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
              d: b
            });
          };

          t(v, "afterInit", function () {
            this.chart.scrollableDirty = !0;
          });
          t(y, "show", function () {
            this.chart.scrollableDirty = !0;
          });
          "";
        });
        I(a, "Core/Axis/StackingAxis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = a.getDeferredAnimation,
              z = A.addEvent,
              w = A.destroyObjectProperties,
              D = A.fireEvent,
              t = A.isNumber,
              l = A.objectEach,
              h;

          (function (a) {
            function b() {
              var b = this.stacking;

              if (b) {
                var a = b.stacks;
                l(a, function (b, d) {
                  w(b);
                  a[d] = null;
                });
                b && b.stackTotalGroup && b.stackTotalGroup.destroy();
              }
            }

            function d() {
              this.stacking || (this.stacking = new k(this));
            }

            var h = [];

            a.compose = function (a) {
              -1 === h.indexOf(a) && (h.push(a), z(a, "init", d), z(a, "destroy", b));
              return a;
            };

            var k = function () {
              function b(b) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = b;
              }

              b.prototype.buildStacks = function () {
                var b = this.axis,
                    a = b.series,
                    d = b.options.reversedStacks,
                    g = a.length,
                    k;

                if (!b.isXAxis) {
                  this.usePercentage = !1;

                  for (k = g; k--;) {
                    var h = a[d ? k : g - k - 1];
                    h.setStackedPoints();
                    h.setGroupedPoints();
                  }

                  for (k = 0; k < g; k++) {
                    a[k].modifyStacks();
                  }

                  D(b, "afterBuildStacks");
                }
              };

              b.prototype.cleanStacks = function () {
                if (!this.axis.isXAxis) {
                  if (this.oldStacks) var b = this.stacks = this.oldStacks;
                  l(b, function (b) {
                    l(b, function (b) {
                      b.cumulative = b.total;
                    });
                  });
                }
              };

              b.prototype.resetStacks = function () {
                var b = this,
                    a = b.stacks;
                b.axis.isXAxis || l(a, function (a) {
                  l(a, function (d, f) {
                    t(d.touched) && d.touched < b.stacksTouched ? (d.destroy(), delete a[f]) : (d.total = null, d.cumulative = null);
                  });
                });
              };

              b.prototype.renderStackTotals = function () {
                var b = this.axis,
                    a = b.chart,
                    d = a.renderer,
                    g = this.stacks;
                b = r(a, b.options.stackLabels && b.options.stackLabels.animation || !1);
                var k = this.stackTotalGroup = this.stackTotalGroup || d.g("stack-labels").attr({
                  visibility: "visible",
                  zIndex: 6,
                  opacity: 0
                }).add();
                k.translate(a.plotLeft, a.plotTop);
                l(g, function (b) {
                  l(b, function (b) {
                    b.render(k);
                  });
                });
                k.animate({
                  opacity: 1
                }, b);
              };

              return b;
            }();

            a.Additions = k;
          })(h || (h = {}));

          return h;
        });
        I(a, "Extensions/Stacking.js", [a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Axis/StackingAxis.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D) {
          var t = A.format,
              l = D.correctFloat,
              h = D.defined,
              d = D.destroyObjectProperties,
              b = D.isArray,
              g = D.isNumber,
              p = D.objectEach,
              k = D.pick,
              r = function () {
            function b(b, a, d, g, k) {
              var f = b.chart.inverted;
              this.axis = b;
              this.isNegative = d;
              this.options = a = a || {};
              this.x = g;
              this.total = null;
              this.points = {};
              this.hasValidPoints = !1;
              this.stack = k;
              this.rightCliff = this.leftCliff = 0;
              this.alignOptions = {
                align: a.align || (f ? d ? "left" : "right" : "center"),
                verticalAlign: a.verticalAlign || (f ? "middle" : d ? "bottom" : "top"),
                y: a.y,
                x: a.x
              };
              this.textAlign = a.textAlign || (f ? d ? "right" : "left" : "center");
            }

            b.prototype.destroy = function () {
              d(this, this.axis);
            };

            b.prototype.render = function (b) {
              var a = this.axis.chart,
                  d = this.options,
                  f = d.format;
              f = f ? t(f, this, a) : d.formatter.call(this);
              this.label ? this.label.attr({
                text: f,
                visibility: "hidden"
              }) : (this.label = a.renderer.label(f, null, null, d.shape, null, null, d.useHTML, !1, "stack-labels"), f = {
                r: d.borderRadius || 0,
                text: f,
                rotation: d.rotation,
                padding: k(d.padding, 5),
                visibility: "hidden"
              }, a.styledMode || (f.fill = d.backgroundColor, f.stroke = d.borderColor, f["stroke-width"] = d.borderWidth, this.label.css(d.style)), this.label.attr(f), this.label.added || this.label.add(b));
              this.label.labelrank = a.plotSizeY;
            };

            b.prototype.setOffset = function (b, a, d, p, l) {
              var f = this.axis,
                  q = f.chart;
              p = f.translate(f.stacking.usePercentage ? 100 : p ? p : this.total, 0, 0, 0, 1);
              d = f.translate(d ? d : 0);
              d = h(p) && Math.abs(p - d);
              b = k(l, q.xAxis[0].translate(this.x)) + b;
              f = h(p) && this.getStackBox(q, this, b, p, a, d, f);
              a = this.label;
              d = this.isNegative;
              b = "justify" === k(this.options.overflow, "justify");
              var e = this.textAlign;
              a && f && (l = a.getBBox(), p = a.padding, e = "left" === e ? q.inverted ? -p : p : "right" === e ? l.width : q.inverted && "center" === e ? l.width / 2 : q.inverted ? d ? l.width + p : -p : l.width / 2, d = q.inverted ? l.height / 2 : d ? -p : l.height, this.alignOptions.x = k(this.options.x, 0), this.alignOptions.y = k(this.options.y, 0), f.x -= e, f.y -= d, a.align(this.alignOptions, null, f), q.isInsidePlot(a.alignAttr.x + e - this.alignOptions.x, a.alignAttr.y + d - this.alignOptions.y) ? a.show() : (a.alignAttr.y = -9999, b = !1), b && z.prototype.justifyDataLabel.call(this.axis, a, this.alignOptions, a.alignAttr, l, f), a.attr({
                x: a.alignAttr.x,
                y: a.alignAttr.y
              }), k(!b && this.options.crop, !0) && ((q = g(a.x) && g(a.y) && q.isInsidePlot(a.x - p + a.width, a.y) && q.isInsidePlot(a.x + p, a.y)) || a.hide()));
            };

            b.prototype.getStackBox = function (b, a, d, g, k, h, q) {
              var e = a.axis.reversed,
                  c = b.inverted,
                  f = q.height + q.pos - (c ? b.plotLeft : b.plotTop);
              a = a.isNegative && !e || !a.isNegative && e;
              return {
                x: c ? a ? g - q.right : g - h + q.pos - b.plotLeft : d + b.xAxis[0].transB - b.plotLeft,
                y: c ? q.height - d - k : a ? f - g - h : f - g,
                width: c ? h : k,
                height: c ? k : h
              };
            };

            return b;
          }();

          v.prototype.getStacks = function () {
            var b = this,
                a = b.inverted;
            b.yAxis.forEach(function (b) {
              b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);
            });
            b.series.forEach(function (d) {
              var f = d.xAxis && d.xAxis.options || {};
              !d.options.stacking || !0 !== d.visible && !1 !== b.options.chart.ignoreHiddenSeries || (d.stackKey = [d.type, k(d.options.stack, ""), a ? f.top : f.left, a ? f.height : f.width].join());
            });
          };

          w.compose(a);

          z.prototype.setGroupedPoints = function () {
            var b = this.yAxis.stacking;
            this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? z.prototype.setStackedPoints.call(this, "group") : b && p(b.stacks, function (a, d) {
              "group" === d.slice(-5) && (p(a, function (b) {
                return b.destroy();
              }), delete b.stacks[d]);
            });
          };

          z.prototype.setStackedPoints = function (a) {
            var d = a || this.options.stacking;

            if (d && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
              var g = this.processedXData,
                  p = this.processedYData,
                  u = [],
                  t = p.length,
                  m = this.options,
                  q = m.threshold,
                  e = k(m.startFromThreshold && q, 0);
              m = m.stack;
              a = a ? this.type + "," + d : this.stackKey;
              var c = "-" + a,
                  n = this.negStacks,
                  C = this.yAxis,
                  w = C.stacking.stacks,
                  v = C.stacking.oldStacks,
                  F,
                  D;
              C.stacking.stacksTouched += 1;

              for (D = 0; D < t; D++) {
                var G = g[D];
                var y = p[D];
                var A = this.getStackIndicator(A, G, this.index);
                var J = A.key;
                var z = (F = n && y < (e ? 0 : q)) ? c : a;
                w[z] || (w[z] = {});
                w[z][G] || (v[z] && v[z][G] ? (w[z][G] = v[z][G], w[z][G].total = null) : w[z][G] = new r(C, C.options.stackLabels, F, G, m));
                z = w[z][G];
                null !== y ? (z.points[J] = z.points[this.index] = [k(z.cumulative, e)], h(z.cumulative) || (z.base = J), z.touched = C.stacking.stacksTouched, 0 < A.index && !1 === this.singleStacks && (z.points[J][0] = z.points[this.index + "," + G + ",0"][0])) : z.points[J] = z.points[this.index] = null;
                "percent" === d ? (F = F ? a : c, n && w[F] && w[F][G] ? (F = w[F][G], z.total = F.total = Math.max(F.total, z.total) + Math.abs(y) || 0) : z.total = l(z.total + (Math.abs(y) || 0))) : "group" === d ? (b(y) && (y = y[0]), null !== y && (z.total = (z.total || 0) + 1)) : z.total = l(z.total + (y || 0));
                z.cumulative = "group" === d ? (z.total || 1) - 1 : k(z.cumulative, e) + (y || 0);
                null !== y && (z.points[J].push(z.cumulative), u[D] = z.cumulative, z.hasValidPoints = !0);
              }

              "percent" === d && (C.stacking.usePercentage = !0);
              "group" !== d && (this.stackedYData = u);
              C.stacking.oldStacks = {};
            }
          };

          z.prototype.modifyStacks = function () {
            var b = this,
                a = b.stackKey,
                d = b.yAxis.stacking.stacks,
                g = b.processedXData,
                k,
                h = b.options.stacking;
            b[h + "Stacker"] && [a, "-" + a].forEach(function (a) {
              for (var f = g.length, e, c; f--;) {
                if (e = g[f], k = b.getStackIndicator(k, e, b.index, a), c = (e = d[a] && d[a][e]) && e.points[k.key]) b[h + "Stacker"](c, e, f);
              }
            });
          };

          z.prototype.percentStacker = function (b, a, d) {
            a = a.total ? 100 / a.total : 0;
            b[0] = l(b[0] * a);
            b[1] = l(b[1] * a);
            this.stackedYData[d] = b[1];
          };

          z.prototype.getStackIndicator = function (b, a, d, g) {
            !h(b) || b.x !== a || g && b.key !== g ? b = {
              x: a,
              index: 0,
              key: g
            } : b.index++;
            b.key = [d, a, b.index].join();
            return b;
          };

          y.StackItem = r;
          "";
          return y.StackItem;
        });
        I(a, "Series/Line/LineSeries.js", [a["Core/Color/Palette.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = this && this.__extends || function () {
            var _a28 = function a(l, h) {
              _a28 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var d in b) {
                  b.hasOwnProperty(d) && (a[d] = b[d]);
                }
              };

              return _a28(l, h);
            };

            return function (l, h) {
              function d() {
                this.constructor = l;
              }

              _a28(l, h);

              l.prototype = null === h ? Object.create(h) : (d.prototype = h.prototype, new d());
            };
          }(),
              w = y.defined,
              D = y.merge;

          y = function (t) {
            function l() {
              var a = null !== t && t.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(l, t);

            l.prototype.drawGraph = function () {
              var h = this,
                  d = this.options,
                  b = (this.gappedPath || this.getGraphPath).call(this),
                  g = this.chart.styledMode,
                  p = [["graph", "highcharts-graph"]];
              g || p[0].push(d.lineColor || this.color || a.neutralColor20, d.dashStyle);
              p = h.getZonesGraphs(p);
              p.forEach(function (a, p) {
                var k = a[0],
                    f = h[k],
                    l = f ? "animate" : "attr";
                f ? (f.endX = h.preventGraphAnimation ? null : b.xMap, f.animate({
                  d: b
                })) : b.length && (h[k] = f = h.chart.renderer.path(b).addClass(a[1]).attr({
                  zIndex: 1
                }).add(h.group));
                f && !g && (k = {
                  stroke: a[2],
                  "stroke-width": d.lineWidth,
                  fill: h.fillGraph && h.color || "none"
                }, a[3] ? k.dashstyle = a[3] : "square" !== d.linecap && (k["stroke-linecap"] = k["stroke-linejoin"] = "round"), f[l](k).shadow(2 > p && d.shadow));
                f && (f.startX = b.xMap, f.isArea = b.isArea);
              });
            };

            l.prototype.getGraphPath = function (a, d, b) {
              var g = this,
                  h = g.options,
                  k = [],
                  l = [],
                  t,
                  f = h.step;
              a = a || g.points;
              var r = a.reversed;
              r && a.reverse();
              (f = {
                right: 1,
                center: 2
              }[f] || f && 3) && r && (f = 4 - f);
              a = this.getValidPoints(a, !1, !(h.connectNulls && !d && !b));
              a.forEach(function (p, u) {
                var r = p.plotX,
                    m = p.plotY,
                    q = a[u - 1];
                (p.leftCliff || q && q.rightCliff) && !b && (t = !0);
                p.isNull && !w(d) && 0 < u ? t = !h.connectNulls : p.isNull && !d ? t = !0 : (0 === u || t ? u = [["M", p.plotX, p.plotY]] : g.getPointSpline ? u = [g.getPointSpline(a, p, u)] : f ? (u = 1 === f ? [["L", q.plotX, m]] : 2 === f ? [["L", (q.plotX + r) / 2, q.plotY], ["L", (q.plotX + r) / 2, m]] : [["L", r, q.plotY]], u.push(["L", r, m])) : u = [["L", r, m]], l.push(p.x), f && (l.push(p.x), 2 === f && l.push(p.x)), k.push.apply(k, u), t = !1);
              });
              k.xMap = l;
              return g.graphPath = k;
            };

            l.prototype.getZonesGraphs = function (a) {
              this.zones.forEach(function (d, b) {
                b = ["zone-graph-" + b, "highcharts-graph highcharts-zone-graph-" + b + " " + (d.className || "")];
                this.chart.styledMode || b.push(d.color || this.color, d.dashStyle || this.options.dashStyle);
                a.push(b);
              }, this);
              return a;
            };

            l.defaultOptions = D(v.defaultOptions, {});
            return l;
          }(v);

          A.registerSeriesType("line", y);
          "";
          return y;
        });
        I(a, "Series/Area/AreaSeries.js", [a["Core/Color/Color.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = this && this.__extends || function () {
            var _a29 = function a(b, d) {
              _a29 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _a29(b, d);
            };

            return function (b, d) {
              function g() {
                this.constructor = b;
              }

              _a29(b, d);

              b.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }(),
              w = a.parse,
              D = A.seriesTypes.line;

          a = y.extend;
          var t = y.merge,
              l = y.objectEach,
              h = y.pick;

          y = function (a) {
            function b() {
              var b = null !== a && a.apply(this, arguments) || this;
              b.data = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            r(b, a);

            b.prototype.drawGraph = function () {
              this.areaPath = [];
              a.prototype.drawGraph.apply(this);
              var b = this,
                  d = this.areaPath,
                  k = this.options,
                  l = [["area", "highcharts-area", this.color, k.fillColor]];
              this.zones.forEach(function (a, d) {
                l.push(["zone-area-" + d, "highcharts-area highcharts-zone-area-" + d + " " + a.className, a.color || b.color, a.fillColor || k.fillColor]);
              });
              l.forEach(function (a) {
                var f = a[0],
                    g = b[f],
                    p = g ? "animate" : "attr",
                    l = {};
                g ? (g.endX = b.preventGraphAnimation ? null : d.xMap, g.animate({
                  d: d
                })) : (l.zIndex = 0, g = b[f] = b.chart.renderer.path(d).addClass(a[1]).add(b.group), g.isArea = !0);
                b.chart.styledMode || (l.fill = h(a[3], w(a[2]).setOpacity(h(k.fillOpacity, .75)).get()));
                g[p](l);
                g.startX = d.xMap;
                g.shiftUnit = k.step ? 2 : 1;
              });
            };

            b.prototype.getGraphPath = function (b) {
              var a = D.prototype.getGraphPath,
                  d = this.options,
                  g = d.stacking,
                  l = this.yAxis,
                  f,
                  t = [],
                  r = [],
                  u = this.index,
                  E = l.stacking.stacks[this.stackKey],
                  m = d.threshold,
                  q = Math.round(l.getThreshold(d.threshold));
              d = h(d.connectNulls, "percent" === g);

              var e = function e(a, c, d) {
                var e = b[a];
                a = g && E[e.x].points[u];
                var f = e[d + "Null"] || 0;
                d = e[d + "Cliff"] || 0;
                e = !0;

                if (d || f) {
                  var k = (f ? a[0] : a[1]) + d;
                  var h = a[0] + d;
                  e = !!f;
                } else !g && b[c] && b[c].isNull && (k = h = m);

                "undefined" !== typeof k && (r.push({
                  plotX: n,
                  plotY: null === k ? q : l.getThreshold(k),
                  isNull: e,
                  isCliff: !0
                }), t.push({
                  plotX: n,
                  plotY: null === h ? q : l.getThreshold(h),
                  doCurve: !1
                }));
              };

              b = b || this.points;
              g && (b = this.getStackPoints(b));

              for (f = 0; f < b.length; f++) {
                g || (b[f].leftCliff = b[f].rightCliff = b[f].leftNull = b[f].rightNull = void 0);
                var c = b[f].isNull;
                var n = h(b[f].rectPlotX, b[f].plotX);
                var C = g ? h(b[f].yBottom, q) : q;
                if (!c || d) d || e(f, f - 1, "left"), c && !g && d || (r.push(b[f]), t.push({
                  x: f,
                  plotX: n,
                  plotY: C
                })), d || e(f, f + 1, "right");
              }

              f = a.call(this, r, !0, !0);
              t.reversed = !0;
              c = a.call(this, t, !0, !0);
              (C = c[0]) && "M" === C[0] && (c[0] = ["L", C[1], C[2]]);
              c = f.concat(c);
              c.length && c.push(["Z"]);
              a = a.call(this, r, !1, d);
              c.xMap = f.xMap;
              this.areaPath = c;
              return a;
            };

            b.prototype.getStackPoints = function (b) {
              var a = this,
                  d = [],
                  g = [],
                  t = this.xAxis,
                  f = this.yAxis,
                  r = f.stacking.stacks[this.stackKey],
                  x = {},
                  u = f.series,
                  E = u.length,
                  m = f.options.reversedStacks ? 1 : -1,
                  q = u.indexOf(a);
              b = b || this.points;

              if (this.options.stacking) {
                for (var e = 0; e < b.length; e++) {
                  b[e].leftNull = b[e].rightNull = void 0, x[b[e].x] = b[e];
                }

                l(r, function (b, a) {
                  null !== b.total && g.push(a);
                });
                g.sort(function (b, a) {
                  return b - a;
                });
                var c = u.map(function (b) {
                  return b.visible;
                });
                g.forEach(function (b, e) {
                  var k = 0,
                      n,
                      p;
                  if (x[b] && !x[b].isNull) d.push(x[b]), [-1, 1].forEach(function (d) {
                    var f = 1 === d ? "rightNull" : "leftNull",
                        k = 0,
                        h = r[g[e + d]];
                    if (h) for (var l = q; 0 <= l && l < E;) {
                      var t = u[l].index;
                      n = h.points[t];
                      n || (t === a.index ? x[b][f] = !0 : c[l] && (p = r[b].points[t]) && (k -= p[1] - p[0]));
                      l += m;
                    }
                    x[b][1 === d ? "rightCliff" : "leftCliff"] = k;
                  });else {
                    for (var l = q; 0 <= l && l < E;) {
                      if (n = r[b].points[u[l].index]) {
                        k = n[1];
                        break;
                      }

                      l += m;
                    }

                    k = h(k, 0);
                    k = f.translate(k, 0, 1, 0, 1);
                    d.push({
                      isNull: !0,
                      plotX: t.translate(b, 0, 0, 0, 1),
                      x: b,
                      plotY: k,
                      yBottom: k
                    });
                  }
                });
              }

              return d;
            };

            b.defaultOptions = t(D.defaultOptions, {
              threshold: 0
            });
            return b;
          }(D);

          a(y.prototype, {
            singleStacks: !1,
            drawLegendSymbol: v.drawRectangle
          });
          A.registerSeriesType("area", y);
          "";
          return y;
        });
        I(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = this && this.__extends || function () {
            var _a30 = function a(t, l) {
              _a30 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _a30(t, l);
            };

            return function (t, l) {
              function h() {
                this.constructor = t;
              }

              _a30(t, l);

              t.prototype = null === l ? Object.create(l) : (h.prototype = l.prototype, new h());
            };
          }(),
              y = a.seriesTypes.line,
              z = v.merge,
              w = v.pick;

          v = function (a) {
            function t() {
              var l = null !== a && a.apply(this, arguments) || this;
              l.data = void 0;
              l.options = void 0;
              l.points = void 0;
              return l;
            }

            r(t, a);

            t.prototype.getPointSpline = function (a, h, d) {
              var b = h.plotX || 0,
                  g = h.plotY || 0,
                  p = a[d - 1];
              d = a[d + 1];

              if (p && !p.isNull && !1 !== p.doCurve && !h.isCliff && d && !d.isNull && !1 !== d.doCurve && !h.isCliff) {
                a = p.plotY || 0;
                var k = d.plotX || 0;
                d = d.plotY || 0;
                var l = 0;
                var t = (1.5 * b + (p.plotX || 0)) / 2.5;
                var f = (1.5 * g + a) / 2.5;
                k = (1.5 * b + k) / 2.5;
                var r = (1.5 * g + d) / 2.5;
                k !== t && (l = (r - f) * (k - b) / (k - t) + g - r);
                f += l;
                r += l;
                f > a && f > g ? (f = Math.max(a, g), r = 2 * g - f) : f < a && f < g && (f = Math.min(a, g), r = 2 * g - f);
                r > d && r > g ? (r = Math.max(d, g), f = 2 * g - r) : r < d && r < g && (r = Math.min(d, g), f = 2 * g - r);
                h.rightContX = k;
                h.rightContY = r;
              }

              h = ["C", w(p.rightContX, p.plotX, 0), w(p.rightContY, p.plotY, 0), w(t, b, 0), w(f, g, 0), b, g];
              p.rightContX = p.rightContY = void 0;
              return h;
            };

            t.defaultOptions = z(y.defaultOptions);
            return t;
          }(y);

          a.registerSeriesType("spline", v);
          "";
          return v;
        });
        I(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Area/AreaSeries.js"], a["Series/Spline/SplineSeries.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z) {
          var r = this && this.__extends || function () {
            var _a31 = function a(d, b) {
              _a31 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _a31(d, b);
            };

            return function (d, b) {
              function g() {
                this.constructor = d;
              }

              _a31(d, b);

              d.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());
            };
          }(),
              D = a.prototype,
              t = z.extend,
              l = z.merge;

          z = function (h) {
            function d() {
              var b = null !== h && h.apply(this, arguments) || this;
              b.data = void 0;
              b.points = void 0;
              b.options = void 0;
              return b;
            }

            r(d, h);
            d.defaultOptions = l(v.defaultOptions, a.defaultOptions);
            return d;
          }(v);

          t(z.prototype, {
            getGraphPath: D.getGraphPath,
            getStackPoints: D.getStackPoints,
            drawGraph: D.drawGraph,
            drawLegendSymbol: A.drawRectangle
          });
          y.registerSeriesType("areaspline", z);
          "";
          return z;
        });
        I(a, "Series/Column/ColumnSeries.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Color/Palette.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t) {
          var l = this && this.__extends || function () {
            var _b3 = function b(a, d) {
              _b3 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var c in a) {
                  a.hasOwnProperty(c) && (b[c] = a[c]);
                }
              };

              return _b3(a, d);
            };

            return function (a, d) {
              function c() {
                this.constructor = a;
              }

              _b3(a, d);

              a.prototype = null === d ? Object.create(d) : (c.prototype = d.prototype, new c());
            };
          }(),
              h = a.animObject,
              d = v.parse,
              b = A.hasTouch;

          a = A.noop;
          var g = t.clamp,
              p = t.css,
              k = t.defined,
              r = t.extend,
              G = t.fireEvent,
              f = t.isArray,
              B = t.isNumber,
              x = t.merge,
              u = t.pick,
              E = t.objectEach;

          t = function (a) {
            function m() {
              var b = null !== a && a.apply(this, arguments) || this;
              b.borderWidth = void 0;
              b.data = void 0;
              b.group = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            l(m, a);

            m.prototype.animate = function (b) {
              var a = this,
                  d = this.yAxis,
                  e = a.options,
                  f = this.chart.inverted,
                  k = {},
                  m = f ? "translateX" : "translateY";
              if (b) k.scaleY = .001, b = g(d.toPixels(e.threshold), d.pos, d.pos + d.len), f ? k.translateX = b - d.len : k.translateY = b, a.clipBox && a.setClip(), a.group.attr(k);else {
                var q = Number(a.group.attr(m));
                a.group.animate({
                  scaleY: 1
                }, r(h(a.options.animation), {
                  step: function step(b, c) {
                    a.group && (k[m] = q + c.pos * (d.pos - q), a.group.attr(k));
                  }
                }));
              }
            };

            m.prototype.init = function (b, c) {
              a.prototype.init.apply(this, arguments);
              var d = this;
              b = d.chart;
              b.hasRendered && b.series.forEach(function (b) {
                b.type === d.type && (b.isDirty = !0);
              });
            };

            m.prototype.getColumnMetrics = function () {
              var b = this,
                  a = b.options,
                  d = b.xAxis,
                  f = b.yAxis,
                  g = d.options.reversedStacks;
              g = d.reversed && !g || !d.reversed && g;
              var k = {},
                  h,
                  m = 0;
              !1 === a.grouping ? m = 1 : b.chart.series.forEach(function (a) {
                var c = a.yAxis,
                    d = a.options;

                if (a.type === b.type && (a.visible || !b.chart.options.chart.ignoreHiddenSeries) && f.len === c.len && f.pos === c.pos) {
                  if (d.stacking && "group" !== d.stacking) {
                    h = a.stackKey;
                    "undefined" === typeof k[h] && (k[h] = m++);
                    var e = k[h];
                  } else !1 !== d.grouping && (e = m++);

                  a.columnIndex = e;
                }
              });
              var q = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || a.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),
                  p = q * a.groupPadding,
                  l = (q - 2 * p) / (m || 1);
              a = Math.min(a.maxPointWidth || d.len, u(a.pointWidth, l * (1 - 2 * a.pointPadding)));
              b.columnMetrics = {
                width: a,
                offset: (l - a) / 2 + (p + ((b.columnIndex || 0) + (g ? 1 : 0)) * l - q / 2) * (g ? -1 : 1),
                paddedWidth: l,
                columnCount: m
              };
              return b.columnMetrics;
            };

            m.prototype.crispCol = function (b, a, d, f) {
              var c = this.chart,
                  e = this.borderWidth,
                  g = -(e % 2 ? .5 : 0);
              e = e % 2 ? .5 : 1;
              c.inverted && c.renderer.isVML && (e += 1);
              this.options.crisp && (d = Math.round(b + d) + g, b = Math.round(b) + g, d -= b);
              f = Math.round(a + f) + e;
              g = .5 >= Math.abs(a) && .5 < f;
              a = Math.round(a) + e;
              f -= a;
              g && f && (--a, f += 1);
              return {
                x: b,
                y: a,
                width: d,
                height: f
              };
            };

            m.prototype.adjustForMissingColumns = function (b, a, d, g) {
              var c = this,
                  e = this.options.stacking;

              if (!d.isNull && 1 < g.columnCount) {
                var k = 0,
                    h = 0;
                E(this.yAxis.stacking && this.yAxis.stacking.stacks, function (b) {
                  if ("number" === typeof d.x && (b = b[d.x.toString()])) {
                    var a = b.points[c.index],
                        g = b.total;
                    e ? (a && (k = h), b.hasValidPoints && h++) : f(a) && (k = a[1], h = g || 0);
                  }
                });
                b = (d.plotX || 0) + ((h - 1) * g.paddedWidth + a) / 2 - a - k * g.paddedWidth;
              }

              return b;
            };

            m.prototype.translate = function () {
              var b = this,
                  a = b.chart,
                  d = b.options,
                  f = b.dense = 2 > b.closestPointRange * b.xAxis.transA;
              f = b.borderWidth = u(d.borderWidth, f ? 0 : 1);
              var h = b.xAxis,
                  m = b.yAxis,
                  q = d.threshold,
                  p = b.translatedThreshold = m.getThreshold(q),
                  l = u(d.minPointLength, 5),
                  r = b.getColumnMetrics(),
                  t = r.width,
                  E = b.pointXOffset = r.offset,
                  x = b.dataMin,
                  v = b.dataMax,
                  z = b.barW = Math.max(t, 1 + 2 * f);
              a.inverted && (p -= .5);
              d.pointPadding && (z = Math.ceil(z));
              w.prototype.translate.apply(b);
              b.points.forEach(function (c) {
                var e = u(c.yBottom, p),
                    f = 999 + Math.abs(e),
                    n = c.plotX || 0;
                f = g(c.plotY, -f, m.len + f);
                var C = Math.min(f, e),
                    w = Math.max(f, e) - C,
                    D = t,
                    y = n + E,
                    A = z;
                l && Math.abs(w) < l && (w = l, n = !m.reversed && !c.negative || m.reversed && c.negative, B(q) && B(v) && c.y === q && v <= q && (m.min || 0) < q && (x !== v || (m.max || 0) <= q) && (n = !n), C = Math.abs(C - p) > l ? e - l : p - (n ? l : 0));
                k(c.options.pointWidth) && (D = A = Math.ceil(c.options.pointWidth), y -= Math.round((D - t) / 2));
                d.centerInCategory && (y = b.adjustForMissingColumns(y, D, c, r));
                c.barX = y;
                c.pointWidth = D;
                c.tooltipPos = a.inverted ? [g(m.len + m.pos - a.plotLeft - f, m.pos - a.plotLeft, m.len + m.pos - a.plotLeft), h.len + h.pos - a.plotTop - y - A / 2, w] : [h.left - a.plotLeft + y + A / 2, g(f + m.pos - a.plotTop, m.pos - a.plotTop, m.len + m.pos - a.plotTop), w];
                c.shapeType = b.pointClass.prototype.shapeType || "rect";
                c.shapeArgs = b.crispCol.apply(b, c.isNull ? [y, p, A, 0] : [y, C, A, w]);
              });
            };

            m.prototype.drawGraph = function () {
              this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            };

            m.prototype.pointAttribs = function (b, a) {
              var c = this.options,
                  e = this.pointAttrToOptions || {},
                  f = e.stroke || "borderColor",
                  g = e["stroke-width"] || "borderWidth",
                  k = b && b.color || this.color,
                  h = b && b[f] || c[f] || k;
              e = b && b.options.dashStyle || c.dashStyle;
              var m = b && b[g] || c[g] || this[g] || 0,
                  q = u(b && b.opacity, c.opacity, 1);

              if (b && this.zones.length) {
                var p = b.getZone();
                k = b.options.color || p && (p.color || b.nonZonedColor) || this.color;
                p && (h = p.borderColor || h, e = p.dashStyle || e, m = p.borderWidth || m);
              }

              a && b && (b = x(c.states[a], b.options.states && b.options.states[a] || {}), a = b.brightness, k = b.color || "undefined" !== typeof a && d(k).brighten(b.brightness).get() || k, h = b[f] || h, m = b[g] || m, e = b.dashStyle || e, q = u(b.opacity, q));
              f = {
                fill: k,
                stroke: h,
                "stroke-width": m,
                opacity: q
              };
              e && (f.dashstyle = e);
              return f;
            };

            m.prototype.drawPoints = function () {
              var b = this,
                  a = this.chart,
                  d = b.options,
                  f = a.renderer,
                  g = d.animationLimit || 250,
                  k;
              b.points.forEach(function (c) {
                var e = c.graphic,
                    h = !!e,
                    m = e && a.pointCount < g ? "animate" : "attr";

                if (B(c.plotY) && null !== c.y) {
                  k = c.shapeArgs;
                  e && c.hasNewShapeType() && (e = e.destroy());
                  b.enabledDataSorting && (c.startXPos = b.xAxis.reversed ? -(k ? k.width || 0 : 0) : b.xAxis.width);
                  e || (c.graphic = e = f[c.shapeType](k).add(c.group || b.group)) && b.enabledDataSorting && a.hasRendered && a.pointCount < g && (e.attr({
                    x: c.startXPos
                  }), h = !0, m = "animate");
                  if (e && h) e[m](x(k));
                  if (d.borderRadius) e[m]({
                    r: d.borderRadius
                  });
                  a.styledMode || e[m](b.pointAttribs(c, c.selected && "select")).shadow(!1 !== c.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);
                  e && (e.addClass(c.getClassName(), !0), e.attr({
                    visibility: c.visible ? "inherit" : "hidden"
                  }));
                } else e && (c.graphic = e.destroy());
              });
            };

            m.prototype.drawTracker = function () {
              var a = this,
                  c = a.chart,
                  d = c.pointer,
                  g = function g(b) {
                var a = d.getPointFromEvent(b);
                "undefined" !== typeof a && (d.isDirectTouch = !0, a.onMouseOver(b));
              },
                  k;

              a.points.forEach(function (b) {
                k = f(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];
                b.graphic && (b.graphic.element.point = b);
                k.forEach(function (a) {
                  a.div ? a.div.point = b : a.element.point = b;
                });
              });
              a._hasTracking || (a.trackerGroups.forEach(function (e) {
                if (a[e]) {
                  a[e].addClass("highcharts-tracker").on("mouseover", g).on("mouseout", function (b) {
                    d.onTrackerMouseOut(b);
                  });
                  if (b) a[e].on("touchstart", g);
                  !c.styledMode && a.options.cursor && a[e].css(p).css({
                    cursor: a.options.cursor
                  });
                }
              }), a._hasTracking = !0);
              G(this, "afterDrawTracker");
            };

            m.prototype.remove = function () {
              var b = this,
                  a = b.chart;
              a.hasRendered && a.series.forEach(function (a) {
                a.type === b.type && (a.isDirty = !0);
              });
              w.prototype.remove.apply(b, arguments);
            };

            m.defaultOptions = x(w.defaultOptions, {
              borderRadius: 0,
              centerInCategory: !1,
              groupPadding: .2,
              marker: null,
              pointPadding: .1,
              minPointLength: 0,
              cropThreshold: 50,
              pointRange: null,
              states: {
                hover: {
                  halo: !1,
                  brightness: .1
                },
                select: {
                  color: z.neutralColor20,
                  borderColor: z.neutralColor100
                }
              },
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
              },
              startFromThreshold: !0,
              stickyTracking: !1,
              tooltip: {
                distance: 6
              },
              threshold: 0,
              borderColor: z.backgroundColor
            });
            return m;
          }(w);

          r(t.prototype, {
            cropShoulder: 0,
            directTouch: !0,
            drawLegendSymbol: y.drawRectangle,
            getSymbol: a,
            negStacks: !0,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          D.registerSeriesType("column", t);
          "";
          "";
          return t;
        });
        I(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Color/Palette.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = a.getDeferredAnimation,
              w = v.format,
              D = y.defined,
              t = y.extend,
              l = y.fireEvent,
              h = y.isArray,
              d = y.merge,
              b = y.objectEach,
              g = y.pick,
              p = y.splat,
              k;

          (function (a) {
            function k(b, a, c, d, f) {
              var e = this,
                  k = this.chart,
                  h = this.isCartesian && k.inverted,
                  m = this.enabledDataSorting,
                  n = g(b.dlBox && b.dlBox.centerX, b.plotX, -9999),
                  p = g(b.plotY, -9999),
                  q = a.getBBox(),
                  l = c.rotation,
                  u = c.align,
                  r = k.isInsidePlot(n, Math.round(p), {
                inverted: h,
                paneCoordinates: !0,
                series: e
              }),
                  E = function E(c) {
                m && e.xAxis && !x && e.setDataLabelStartPos(b, a, f, r, c);
              },
                  x = "justify" === g(c.overflow, m ? "none" : "justify"),
                  B = this.visible && !1 !== b.visible && (b.series.forceDL || m && !x || r || g(c.inside, !!this.options.stacking) && d && k.isInsidePlot(n, h ? d.x + 1 : d.y + d.height - 1, {
                inverted: h,
                paneCoordinates: !0,
                series: e
              }));

              if (B) {
                var C = k.renderer.fontMetrics(k.styledMode ? void 0 : c.style.fontSize, a).b;
                d = t({
                  x: h ? this.yAxis.len - p : n,
                  y: Math.round(h ? this.xAxis.len - n : p),
                  width: 0,
                  height: 0
                }, d);
                t(c, {
                  width: q.width,
                  height: q.height
                });
                l ? (x = !1, n = k.renderer.rotCorr(C, l), n = {
                  x: d.x + (c.x || 0) + d.width / 2 + n.x,
                  y: d.y + (c.y || 0) + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                  }[c.verticalAlign] * d.height
                }, E(n), a[f ? "attr" : "animate"](n).attr({
                  align: u
                }), E = (l + 720) % 360, E = 180 < E && 360 > E, "left" === u ? n.y -= E ? q.height : 0 : "center" === u ? (n.x -= q.width / 2, n.y -= q.height / 2) : "right" === u && (n.x -= q.width, n.y -= E ? 0 : q.height), a.placed = !0, a.alignAttr = n) : (E(d), a.align(c, void 0, d), n = a.alignAttr);
                x && 0 <= d.height ? this.justifyDataLabel(a, c, n, q, d, f) : g(c.crop, !0) && (B = k.isInsidePlot(n.x, n.y, {
                  paneCoordinates: !0,
                  series: e
                }) && k.isInsidePlot(n.x + q.width, n.y + q.height, {
                  paneCoordinates: !0,
                  series: e
                }));
                if (c.shape && !l) a[f ? "attr" : "animate"]({
                  anchorX: h ? k.plotWidth - b.plotY : b.plotX,
                  anchorY: h ? k.plotHeight - b.plotX : b.plotY
                });
              }

              f && m && (a.placed = !1);
              B || m && !x || (a.hide(!0), a.placed = !1);
            }

            function f(b, a) {
              var c = a.filter;
              return c ? (a = c.operator, b = b[c.property], c = c.value, ">" === a && b > c || "<" === a && b < c || ">=" === a && b >= c || "<=" === a && b <= c || "==" === a && b == c || "===" === a && b === c ? !0 : !1) : !0;
            }

            function B() {
              var a = this,
                  d = a.chart,
                  c = a.options,
                  k = a.points,
                  m = a.hasRendered || 0,
                  t = d.renderer,
                  E = c.dataLabels,
                  x,
                  B = E.animation;
              B = E.defer ? r(d, B, a) : {
                defer: 0,
                duration: 0
              };
              E = u(u(d.options.plotOptions && d.options.plotOptions.series && d.options.plotOptions.series.dataLabels, d.options.plotOptions && d.options.plotOptions[a.type] && d.options.plotOptions[a.type].dataLabels), E);
              l(this, "drawDataLabels");

              if (h(E) || E.enabled || a._hasPointLabels) {
                var v = a.plotGroup("dataLabelsGroup", "data-labels", m ? "inherit" : "hidden", E.zIndex || 6);
                v.attr({
                  opacity: +m
                });
                !m && (m = a.dataLabelsGroup) && (a.visible && v.show(!0), m[c.animation ? "animate" : "attr"]({
                  opacity: 1
                }, B));
                k.forEach(function (e) {
                  x = p(u(E, e.dlOptions || e.options && e.options.dataLabels));
                  x.forEach(function (k, h) {
                    var m = k.enabled && (!e.isNull || e.dataLabelOnNull) && f(e, k),
                        n = e.connectors ? e.connectors[h] : e.connector,
                        p = e.dataLabels ? e.dataLabels[h] : e.dataLabel,
                        q = g(k.distance, e.labelDistance),
                        l = !p;

                    if (m) {
                      var u = e.getLabelConfig();
                      var r = g(k[e.formatPrefix + "Format"], k.format);
                      u = D(r) ? w(r, u, d) : (k[e.formatPrefix + "Formatter"] || k.formatter).call(u, k);
                      r = k.style;
                      var E = k.rotation;
                      d.styledMode || (r.color = g(k.color, r.color, a.color, A.neutralColor100), "contrast" === r.color ? (e.contrastColor = t.getContrast(e.color || a.color), r.color = !D(q) && k.inside || 0 > q || c.stacking ? e.contrastColor : A.neutralColor100) : delete e.contrastColor, c.cursor && (r.cursor = c.cursor));
                      var x = {
                        r: k.borderRadius || 0,
                        rotation: E,
                        padding: k.padding,
                        zIndex: 1
                      };
                      d.styledMode || (x.fill = k.backgroundColor, x.stroke = k.borderColor, x["stroke-width"] = k.borderWidth);
                      b(x, function (b, a) {
                        "undefined" === typeof b && delete x[a];
                      });
                    }

                    !p || m && D(u) ? m && D(u) && (p ? x.text = u : (e.dataLabels = e.dataLabels || [], p = e.dataLabels[h] = E ? t.text(u, 0, -9999, k.useHTML).addClass("highcharts-data-label") : t.label(u, 0, -9999, k.shape, null, null, k.useHTML, null, "data-label"), h || (e.dataLabel = p), p.addClass(" highcharts-data-label-color-" + e.colorIndex + " " + (k.className || "") + (k.useHTML ? " highcharts-tracker" : ""))), p.options = k, p.attr(x), d.styledMode || p.css(r).shadow(k.shadow), p.added || p.add(v), k.textPath && !k.useHTML && (p.setTextPath(e.getDataLabelPath && e.getDataLabelPath(p) || e.graphic, k.textPath), e.dataLabelPath && !k.textPath.enabled && (e.dataLabelPath = e.dataLabelPath.destroy())), a.alignDataLabel(e, p, k, null, l)) : (e.dataLabel = e.dataLabel && e.dataLabel.destroy(), e.dataLabels && (1 === e.dataLabels.length ? delete e.dataLabels : delete e.dataLabels[h]), h || delete e.dataLabel, n && (e.connector = e.connector.destroy(), e.connectors && (1 === e.connectors.length ? delete e.connectors : delete e.connectors[h])));
                  });
                });
              }

              l(this, "afterDrawDataLabels");
            }

            function x(b, a, c, d, f, g) {
              var e = this.chart,
                  k = a.align,
                  h = a.verticalAlign,
                  m = b.box ? 0 : b.padding || 0,
                  n = a.x;
              n = void 0 === n ? 0 : n;
              var p = a.y;
              p = void 0 === p ? 0 : p;
              var q = (c.x || 0) + m;

              if (0 > q) {
                "right" === k && 0 <= n ? (a.align = "left", a.inside = !0) : n -= q;
                var l = !0;
              }

              q = (c.x || 0) + d.width - m;
              q > e.plotWidth && ("left" === k && 0 >= n ? (a.align = "right", a.inside = !0) : n += e.plotWidth - q, l = !0);
              q = c.y + m;
              0 > q && ("bottom" === h && 0 <= p ? (a.verticalAlign = "top", a.inside = !0) : p -= q, l = !0);
              q = (c.y || 0) + d.height - m;
              q > e.plotHeight && ("top" === h && 0 >= p ? (a.verticalAlign = "bottom", a.inside = !0) : p += e.plotHeight - q, l = !0);
              l && (a.x = n, a.y = p, b.placed = !g, b.align(a, void 0, f));
              return l;
            }

            function u(b, a) {
              var c = [],
                  e;
              if (h(b) && !h(a)) c = b.map(function (b) {
                return d(b, a);
              });else if (h(a) && !h(b)) c = a.map(function (a) {
                return d(b, a);
              });else if (h(b) || h(a)) for (e = Math.max(b.length, a.length); e--;) {
                c[e] = d(b[e], a[e]);
              } else c = d(b, a);
              return c;
            }

            function E(b, a, c, d, f) {
              var e = this.chart,
                  g = e.inverted,
                  k = this.xAxis,
                  h = k.reversed,
                  m = g ? a.height / 2 : a.width / 2;
              b = (b = b.pointWidth) ? b / 2 : 0;
              a.startXPos = g ? f.x : h ? -m - b : k.width - m + b;
              a.startYPos = g ? h ? this.yAxis.height - m + b : -m - b : f.y;
              d ? "hidden" === a.visibility && (a.show(), a.attr({
                opacity: 0
              }).animate({
                opacity: 1
              })) : a.attr({
                opacity: 1
              }).animate({
                opacity: 0
              }, void 0, a.hide);
              e.hasRendered && (c && a.attr({
                x: a.startXPos,
                y: a.startYPos
              }), a.placed = !0);
            }

            var m = [];

            a.compose = function (b) {
              if (-1 === m.indexOf(b)) {
                var a = b.prototype;
                m.push(b);
                a.alignDataLabel = k;
                a.drawDataLabels = B;
                a.justifyDataLabel = x;
                a.setDataLabelStartPos = E;
              }
            };
          })(k || (k = {}));

          "";
          return k;
        });
        I(a, "Series/Column/ColumnDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = v.series,
              z = A.merge,
              w = A.pick,
              D;

          (function (t) {
            function l(a, b, g, h, k) {
              var d = this.chart.inverted,
                  p = a.series,
                  f = a.dlBox || a.shapeArgs,
                  l = w(a.below, a.plotY > w(this.translatedThreshold, p.yAxis.len)),
                  t = w(g.inside, !!this.options.stacking);
              f && (h = z(f), 0 > h.y && (h.height += h.y, h.y = 0), f = h.y + h.height - p.yAxis.len, 0 < f && f < h.height && (h.height -= f), d && (h = {
                x: p.yAxis.len - h.y - h.height,
                y: p.xAxis.len - h.x - h.width,
                width: h.height,
                height: h.width
              }), t || (d ? (h.x += l ? 0 : h.width, h.width = 0) : (h.y += l ? h.height : 0, h.height = 0)));
              g.align = w(g.align, !d || t ? "center" : l ? "right" : "left");
              g.verticalAlign = w(g.verticalAlign, d || t ? "middle" : l ? "top" : "bottom");
              r.prototype.alignDataLabel.call(this, a, b, g, h, k);
              g.inside && a.contrastColor && b.css({
                color: a.contrastColor
              });
            }

            var h = [];

            t.compose = function (d) {
              a.compose(r);
              -1 === h.indexOf(d) && (h.push(d), d.prototype.alignDataLabel = l);
            };
          })(D || (D = {}));

          return D;
        });
        I(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = this && this.__extends || function () {
            var _a32 = function a(r, l) {
              _a32 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _a32(r, l);
            };

            return function (r, l) {
              function h() {
                this.constructor = r;
              }

              _a32(r, l);

              r.prototype = null === l ? Object.create(l) : (h.prototype = l.prototype, new h());
            };
          }(),
              z = A.extend,
              w = A.merge;

          A = function (v) {
            function t() {
              var a = null !== v && v.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(t, v);
            t.defaultOptions = w(a.defaultOptions, {});
            return t;
          }(a);

          z(A.prototype, {
            inverted: !0
          });
          v.registerSeriesType("bar", A);
          "";
          return A;
        });
        I(a, "Series/Scatter/ScatterSeries.js", [a["Series/Column/ColumnSeries.js"], a["Series/Line/LineSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = this && this.__extends || function () {
            var _a33 = function a(h, d) {
              _a33 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _a33(h, d);
            };

            return function (h, d) {
              function b() {
                this.constructor = h;
              }

              _a33(h, d);

              h.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              w = y.addEvent,
              D = y.extend,
              t = y.merge;

          y = function (a) {
            function h() {
              var d = null !== a && a.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            r(h, a);

            h.prototype.applyJitter = function () {
              var a = this,
                  b = this.options.jitter,
                  g = this.points.length;
              b && this.points.forEach(function (d, k) {
                ["x", "y"].forEach(function (h, p) {
                  var f = "plot" + h.toUpperCase();

                  if (b[h] && !d.isNull) {
                    var l = a[h + "Axis"];
                    var r = b[h] * l.transA;

                    if (l && !l.isLog) {
                      var u = Math.max(0, d[f] - r);
                      l = Math.min(l.len, d[f] + r);
                      p = 1E4 * Math.sin(k + p * g);
                      d[f] = u + (l - u) * (p - Math.floor(p));
                      "x" === h && (d.clientX = d.plotX);
                    }
                  }
                });
              });
            };

            h.prototype.drawGraph = function () {
              this.options.lineWidth ? a.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
            };

            h.defaultOptions = t(v.defaultOptions, {
              lineWidth: 0,
              findNearestPointBy: "xy",
              jitter: {
                x: 0,
                y: 0
              },
              marker: {
                enabled: !0
              },
              tooltip: {
                headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
              }
            });
            return h;
          }(v);

          D(y.prototype, {
            drawTracker: a.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1
          });
          w(y, "afterTranslate", function () {
            this.applyJitter();
          });
          A.registerSeriesType("scatter", y);
          "";
          return y;
        });
        I(a, "Mixins/CenteredSeries.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = A.isNumber,
              z = A.pick,
              w = A.relativeLength,
              D = a.deg2rad;
          return a.CenteredSeriesMixin = {
            getCenter: function getCenter() {
              var a = this.options,
                  l = this.chart,
                  h = 2 * (a.slicedOffset || 0),
                  d = l.plotWidth - 2 * h,
                  b = l.plotHeight - 2 * h,
                  g = a.center,
                  p = Math.min(d, b),
                  k = a.size,
                  r = a.innerSize || 0;
              "string" === typeof k && (k = parseFloat(k));
              "string" === typeof r && (r = parseFloat(r));
              a = [z(g[0], "50%"), z(g[1], "50%"), z(k && 0 > k ? void 0 : a.size, "100%"), z(r && 0 > r ? void 0 : a.innerSize || 0, "0%")];
              !l.angular || this instanceof v || (a[3] = 0);

              for (g = 0; 4 > g; ++g) {
                k = a[g], l = 2 > g || 2 === g && /%$/.test(k), a[g] = w(k, [d, b, p, a[2]][g]) + (l ? h : 0);
              }

              a[3] > a[2] && (a[3] = a[2]);
              return a;
            },
            getStartAndEndRadians: function getStartAndEndRadians(a, l) {
              a = r(a) ? a : 0;
              l = r(l) && l > a && 360 > l - a ? l : a + 360;
              return {
                start: D * (a + -90),
                end: D * (l + -90)
              };
            }
          };
        });
        I(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = this && this.__extends || function () {
            var _a34 = function a(b, d) {
              _a34 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _a34(b, d);
            };

            return function (b, d) {
              function g() {
                this.constructor = b;
              }

              _a34(b, d);

              b.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
            };
          }(),
              z = a.setAnimation,
              w = A.addEvent,
              D = A.defined;

          a = A.extend;
          var t = A.isNumber,
              l = A.pick,
              h = A.relativeLength;

          v = function (a) {
            function b() {
              var b = null !== a && a.apply(this, arguments) || this;
              b.labelDistance = void 0;
              b.options = void 0;
              b.series = void 0;
              return b;
            }

            r(b, a);

            b.prototype.getConnectorPath = function () {
              var b = this.labelPosition,
                  a = this.series.options.dataLabels,
                  d = this.connectorShapes,
                  h = a.connectorShape;
              d[h] && (h = d[h]);
              return h.call(this, {
                x: b["final"].x,
                y: b["final"].y,
                alignment: b.alignment
              }, b.connectorPosition, a);
            };

            b.prototype.getTranslate = function () {
              return this.sliced ? this.slicedTranslation : {
                translateX: 0,
                translateY: 0
              };
            };

            b.prototype.haloPath = function (b) {
              var a = this.shapeArgs;
              return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(a.x, a.y, a.r + b, a.r + b, {
                innerR: a.r - 1,
                start: a.start,
                end: a.end
              });
            };

            b.prototype.init = function () {
              var b = this;
              a.prototype.init.apply(this, arguments);
              this.name = l(this.name, "Slice");

              var d = function d(a) {
                b.slice("select" === a.type);
              };

              w(this, "select", d);
              w(this, "unselect", d);
              return this;
            };

            b.prototype.isValid = function () {
              return t(this.y) && 0 <= this.y;
            };

            b.prototype.setVisible = function (b, a) {
              var d = this,
                  g = this.series,
                  h = g.chart,
                  f = g.options.ignoreHiddenPoint;
              a = l(a, f);
              b !== this.visible && (this.visible = this.options.visible = b = "undefined" === typeof b ? !this.visible : b, g.options.data[g.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (a) {
                if (d[a]) d[a][b ? "show" : "hide"](b);
              }), this.legendItem && h.legend.colorizeItem(this, b), b || "hover" !== this.state || this.setState(""), f && (g.isDirty = !0), a && h.redraw());
            };

            b.prototype.slice = function (b, a, d) {
              var g = this.series;
              z(d, g.chart);
              l(a, !0);
              this.sliced = this.options.sliced = D(b) ? b : !this.sliced;
              g.options.data[g.data.indexOf(this)] = this.options;
              this.graphic && this.graphic.animate(this.getTranslate());
              this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            };

            return b;
          }(v);

          a(v.prototype, {
            connectorShapes: {
              fixedOffset: function fixedOffset(a, b, g) {
                var d = b.breakAt;
                b = b.touchingSliceAt;
                return [["M", a.x, a.y], g.softConnector ? ["C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * d.x - b.x, 2 * d.y - b.y, d.x, d.y] : ["L", d.x, d.y], ["L", b.x, b.y]];
              },
              straight: function straight(a, b) {
                b = b.touchingSliceAt;
                return [["M", a.x, a.y], ["L", b.x, b.y]];
              },
              crookedLine: function crookedLine(a, b, g) {
                b = b.touchingSliceAt;
                var d = this.series,
                    k = d.center[0],
                    l = d.chart.plotWidth,
                    r = d.chart.plotLeft;
                d = a.alignment;
                var f = this.shapeArgs.r;
                g = h(g.crookDistance, 1);
                l = "left" === d ? k + f + (l + r - k - f) * (1 - g) : r + (k - f) * g;
                g = ["L", l, a.y];
                k = !0;
                if ("left" === d ? l > a.x || l < b.x : l < a.x || l > b.x) k = !1;
                a = [["M", a.x, a.y]];
                k && a.push(g);
                a.push(["L", b.x, b.y]);
                return a;
              }
            }
          });
          return v;
        });
        I(a, "Series/Pie/PieSeries.js", [a["Mixins/CenteredSeries.js"], a["Series/Column/ColumnSeries.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Color/Palette.js"], a["Series/Pie/PiePoint.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t, l, h) {
          var d = this && this.__extends || function () {
            var _b4 = function b(a, d) {
              _b4 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (b, a) {
                b.__proto__ = a;
              } || function (b, a) {
                for (var d in a) {
                  a.hasOwnProperty(d) && (b[d] = a[d]);
                }
              };

              return _b4(a, d);
            };

            return function (a, d) {
              function f() {
                this.constructor = a;
              }

              _b4(a, d);

              a.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
            };
          }(),
              b = a.getStartAndEndRadians;

          A = A.noop;
          var g = h.clamp,
              p = h.extend,
              k = h.fireEvent,
              r = h.merge,
              G = h.pick,
              f = h.relativeLength;

          h = function (a) {
            function h() {
              var b = null !== a && a.apply(this, arguments) || this;
              b.center = void 0;
              b.data = void 0;
              b.maxLabelDistance = void 0;
              b.options = void 0;
              b.points = void 0;
              return b;
            }

            d(h, a);

            h.prototype.animate = function (b) {
              var a = this,
                  d = a.points,
                  f = a.startAngleRad;
              b || d.forEach(function (b) {
                var c = b.graphic,
                    d = b.shapeArgs;
                c && d && (c.attr({
                  r: G(b.startR, a.center && a.center[3] / 2),
                  start: f,
                  end: f
                }), c.animate({
                  r: d.r,
                  start: d.start,
                  end: d.end
                }, a.options.animation));
              });
            };

            h.prototype.drawEmpty = function () {
              var b = this.startAngleRad,
                  a = this.endAngleRad,
                  d = this.options;

              if (0 === this.total && this.center) {
                var f = this.center[0];
                var e = this.center[1];
                this.graph || (this.graph = this.chart.renderer.arc(f, e, this.center[1] / 2, 0, b, a).addClass("highcharts-empty-series").add(this.group));
                this.graph.attr({
                  d: l.arc(f, e, this.center[2] / 2, 0, {
                    start: b,
                    end: a,
                    innerR: this.center[3] / 2
                  })
                });
                this.chart.styledMode || this.graph.attr({
                  "stroke-width": d.borderWidth,
                  fill: d.fillColor || "none",
                  stroke: d.color || z.neutralColor20
                });
              } else this.graph && (this.graph = this.graph.destroy());
            };

            h.prototype.drawPoints = function () {
              var b = this.chart.renderer;
              this.points.forEach(function (a) {
                a.graphic && a.hasNewShapeType() && (a.graphic = a.graphic.destroy());
                a.graphic || (a.graphic = b[a.shapeType](a.shapeArgs).add(a.series.group), a.delayedRendering = !0);
              });
            };

            h.prototype.generatePoints = function () {
              a.prototype.generatePoints.call(this);
              this.updateTotals();
            };

            h.prototype.getX = function (b, a, d) {
              var f = this.center,
                  e = this.radii ? this.radii[d.index] || 0 : f[2] / 2;
              b = Math.asin(g((b - f[1]) / (e + d.labelDistance), -1, 1));
              return f[0] + (a ? -1 : 1) * Math.cos(b) * (e + d.labelDistance) + (0 < d.labelDistance ? (a ? -1 : 1) * this.options.dataLabels.padding : 0);
            };

            h.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            h.prototype.redrawPoints = function () {
              var b = this,
                  a = b.chart,
                  d = a.renderer,
                  f = b.options.shadow,
                  e,
                  c,
                  g,
                  k;
              this.drawEmpty();
              !f || b.shadowGroup || a.styledMode || (b.shadowGroup = d.g("shadow").attr({
                zIndex: -1
              }).add(b.group));
              b.points.forEach(function (h) {
                var m = {};
                c = h.graphic;

                if (!h.isNull && c) {
                  var n = void 0;
                  k = h.shapeArgs;
                  e = h.getTranslate();
                  a.styledMode || (n = h.shadowGroup, f && !n && (n = h.shadowGroup = d.g("shadow").add(b.shadowGroup)), n && n.attr(e), g = b.pointAttribs(h, h.selected && "select"));
                  h.delayedRendering ? (c.setRadialReference(b.center).attr(k).attr(e), a.styledMode || c.attr(g).attr({
                    "stroke-linejoin": "round"
                  }).shadow(f, n), h.delayedRendering = !1) : (c.setRadialReference(b.center), a.styledMode || r(!0, m, g), r(!0, m, k, e), c.animate(m));
                  c.attr({
                    visibility: h.visible ? "inherit" : "hidden"
                  });
                  c.addClass(h.getClassName(), !0);
                } else c && (h.graphic = c.destroy());
              });
            };

            h.prototype.sortByAngle = function (b, a) {
              b.sort(function (b, d) {
                return "undefined" !== typeof b.angle && (d.angle - b.angle) * a;
              });
            };

            h.prototype.translate = function (a) {
              this.generatePoints();
              var d = this.options,
                  g = d.slicedOffset,
                  h = g + (d.borderWidth || 0),
                  e = b(d.startAngle, d.endAngle),
                  c = this.startAngleRad = e.start;
              e = (this.endAngleRad = e.end) - c;
              var n = this.points,
                  l = d.dataLabels.distance;
              d = d.ignoreHiddenPoint;
              var p = n.length,
                  u,
                  r = 0;
              a || (this.center = a = this.getCenter());

              for (u = 0; u < p; u++) {
                var t = n[u];
                var x = c + r * e;
                !t.isValid() || d && !t.visible || (r += t.percentage / 100);
                var B = c + r * e;
                var w = {
                  x: a[0],
                  y: a[1],
                  r: a[2] / 2,
                  innerR: a[3] / 2,
                  start: Math.round(1E3 * x) / 1E3,
                  end: Math.round(1E3 * B) / 1E3
                };
                t.shapeType = "arc";
                t.shapeArgs = w;
                t.labelDistance = G(t.options.dataLabels && t.options.dataLabels.distance, l);
                t.labelDistance = f(t.labelDistance, w.r);
                this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, t.labelDistance);
                B = (B + x) / 2;
                B > 1.5 * Math.PI ? B -= 2 * Math.PI : B < -Math.PI / 2 && (B += 2 * Math.PI);
                t.slicedTranslation = {
                  translateX: Math.round(Math.cos(B) * g),
                  translateY: Math.round(Math.sin(B) * g)
                };
                w = Math.cos(B) * a[2] / 2;
                var v = Math.sin(B) * a[2] / 2;
                t.tooltipPos = [a[0] + .7 * w, a[1] + .7 * v];
                t.half = B < -Math.PI / 2 || B > Math.PI / 2 ? 1 : 0;
                t.angle = B;
                x = Math.min(h, t.labelDistance / 5);
                t.labelPosition = {
                  natural: {
                    x: a[0] + w + Math.cos(B) * t.labelDistance,
                    y: a[1] + v + Math.sin(B) * t.labelDistance
                  },
                  "final": {},
                  alignment: 0 > t.labelDistance ? "center" : t.half ? "right" : "left",
                  connectorPosition: {
                    breakAt: {
                      x: a[0] + w + Math.cos(B) * x,
                      y: a[1] + v + Math.sin(B) * x
                    },
                    touchingSliceAt: {
                      x: a[0] + w,
                      y: a[1] + v
                    }
                  }
                };
              }

              k(this, "afterTranslate");
            };

            h.prototype.updateTotals = function () {
              var b = this.points,
                  a = b.length,
                  d = this.options.ignoreHiddenPoint,
                  f,
                  e = 0;

              for (f = 0; f < a; f++) {
                var c = b[f];
                !c.isValid() || d && !c.visible || (e += c.y);
              }

              this.total = e;

              for (f = 0; f < a; f++) {
                c = b[f], c.percentage = 0 < e && (c.visible || !d) ? c.y / e * 100 : 0, c.total = e;
              }
            };

            h.defaultOptions = r(D.defaultOptions, {
              center: [null, null],
              clip: !1,
              colorByPoint: !0,
              dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0
              },
              fillColor: void 0,
              ignoreHiddenPoint: !0,
              inactiveOtherPoints: !0,
              legendType: "point",
              marker: null,
              size: null,
              showInLegend: !1,
              slicedOffset: 10,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0
              },
              borderColor: z.backgroundColor,
              borderWidth: 1,
              lineWidth: void 0,
              states: {
                hover: {
                  brightness: .1
                }
              }
            });
            return h;
          }(D);

          p(h.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawLegendSymbol: y.drawRectangle,
            drawTracker: v.prototype.drawTracker,
            getCenter: a.getCenter,
            getSymbol: A,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: v.prototype.pointAttribs,
            pointClass: w,
            requireSorting: !1,
            searchPoint: A,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          t.registerSeriesType("pie", h);
          "";
          return h;
        });
        I(a, "Series/Pie/PieDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Globals.js"], a["Core/Color/Palette.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w) {
          var r = v.noop,
              t = y.distribute,
              l = z.series,
              h = w.arrayMax,
              d = w.clamp,
              b = w.defined,
              g = w.merge,
              p = w.pick,
              k = w.relativeLength,
              J;

          (function (w) {
            function f() {
              var a = this,
                  d = a.data,
                  e = a.chart,
                  c = a.options.dataLabels || {},
                  f = c.connectorPadding,
                  k = e.plotWidth,
                  u = e.plotHeight,
                  r = e.plotLeft,
                  x = Math.round(e.chartWidth / 3),
                  E = a.center,
                  B = E[2] / 2,
                  w = E[1],
                  v = [[], []],
                  z = [0, 0, 0, 0],
                  D = a.dataLabelPositioners,
                  y,
                  G,
                  J,
                  I,
                  Z,
                  K,
                  U,
                  P,
                  X,
                  V,
                  Y,
                  Q;
              a.visible && (c.enabled || a._hasPointLabels) && (d.forEach(function (b) {
                b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({
                  width: "auto"
                }).css({
                  width: "auto",
                  textOverflow: "clip"
                }), b.dataLabel.shortened = !1);
              }), l.prototype.drawDataLabels.apply(a), d.forEach(function (a) {
                a.dataLabel && (a.visible ? (v[a.half].push(a), a.dataLabel._pos = null, !b(c.style.width) && !b(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > x && (a.dataLabel.css({
                  width: Math.round(.7 * x) + "px"
                }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
              }), v.forEach(function (d, g) {
                var h = d.length,
                    m = [],
                    n;

                if (h) {
                  a.sortByAngle(d, g - .5);

                  if (0 < a.maxLabelDistance) {
                    var l = Math.max(0, w - B - a.maxLabelDistance);
                    var q = Math.min(w + B + a.maxLabelDistance, e.plotHeight);
                    d.forEach(function (b) {
                      0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, w - B - b.labelDistance), b.bottom = Math.min(w + B + b.labelDistance, e.plotHeight), n = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                        target: b.labelPosition.natural.y - b.top + n / 2,
                        size: n,
                        rank: b.y
                      }, m.push(b.distributeBox));
                    });
                    l = q + n - l;
                    t(m, l, l / 5);
                  }

                  for (Y = 0; Y < h; Y++) {
                    y = d[Y];
                    K = y.labelPosition;
                    I = y.dataLabel;
                    V = !1 === y.visible ? "hidden" : "inherit";
                    X = l = K.natural.y;
                    m && b(y.distributeBox) && ("undefined" === typeof y.distributeBox.pos ? V = "hidden" : (U = y.distributeBox.size, X = D.radialDistributionY(y)));
                    delete y.positionIndex;
                    if (c.justify) P = D.justify(y, B, E);else switch (c.alignTo) {
                      case "connectors":
                        P = D.alignToConnectors(d, g, k, r);
                        break;

                      case "plotEdges":
                        P = D.alignToPlotEdges(I, g, k, r);
                        break;

                      default:
                        P = D.radialDistributionX(a, y, X, l);
                    }
                    I._attr = {
                      visibility: V,
                      align: K.alignment
                    };
                    Q = y.options.dataLabels || {};
                    I._pos = {
                      x: P + p(Q.x, c.x) + ({
                        left: f,
                        right: -f
                      }[K.alignment] || 0),
                      y: X + p(Q.y, c.y) - 10
                    };
                    K["final"].x = P;
                    K["final"].y = X;
                    p(c.crop, !0) && (Z = I.getBBox().width, l = null, P - Z < f && 1 === g ? (l = Math.round(Z - P + f), z[3] = Math.max(l, z[3])) : P + Z > k - f && 0 === g && (l = Math.round(P + Z - k + f), z[1] = Math.max(l, z[1])), 0 > X - U / 2 ? z[0] = Math.max(Math.round(-X + U / 2), z[0]) : X + U / 2 > u && (z[2] = Math.max(Math.round(X + U / 2 - u), z[2])), I.sideOverflow = l);
                  }
                }
              }), 0 === h(z) || this.verifyDataLabelOverflow(z)) && (this.placeDataLabels(), this.points.forEach(function (b) {
                Q = g(c, b.options.dataLabels);

                if (G = p(Q.connectorWidth, 1)) {
                  var d;
                  J = b.connector;

                  if ((I = b.dataLabel) && I._pos && b.visible && 0 < b.labelDistance) {
                    V = I._attr.visibility;
                    if (d = !J) b.connector = J = e.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b.colorIndex + (b.className ? " " + b.className : "")).add(a.dataLabelsGroup), e.styledMode || J.attr({
                      "stroke-width": G,
                      stroke: Q.connectorColor || b.color || A.neutralColor60
                    });
                    J[d ? "attr" : "animate"]({
                      d: b.getConnectorPath()
                    });
                    J.attr("visibility", V);
                  } else J && (b.connector = J.destroy());
                }
              }));
            }

            function B() {
              this.points.forEach(function (b) {
                var a = b.dataLabel,
                    d;
                a && b.visible && ((d = a._pos) ? (a.sideOverflow && (a._attr.width = Math.max(a.getBBox().width - a.sideOverflow, 0), a.css({
                  width: a._attr.width + "px",
                  textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), a.shortened = !0), a.attr(a._attr), a[a.moved ? "animate" : "attr"](d), a.moved = !0) : a && a.attr({
                  y: -9999
                }));
                delete b.distributeBox;
              }, this);
            }

            function x(b) {
              var a = this.center,
                  e = this.options,
                  c = e.center,
                  f = e.minSize || 80,
                  g = null !== e.size;

              if (!g) {
                if (null !== c[0]) var h = Math.max(a[2] - Math.max(b[1], b[3]), f);else h = Math.max(a[2] - b[1] - b[3], f), a[0] += (b[3] - b[1]) / 2;
                null !== c[1] ? h = d(h, f, a[2] - Math.max(b[0], b[2])) : (h = d(h, f, a[2] - b[0] - b[2]), a[1] += (b[0] - b[2]) / 2);
                h < a[2] ? (a[2] = h, a[3] = Math.min(k(e.innerSize || 0, h), h), this.translate(a), this.drawDataLabels && this.drawDataLabels()) : g = !0;
              }

              return g;
            }

            var u = [],
                E = {
              radialDistributionY: function radialDistributionY(b) {
                return b.top + b.distributeBox.pos;
              },
              radialDistributionX: function radialDistributionX(b, a, d, c) {
                return b.getX(d < a.top + 2 || d > a.bottom - 2 ? c : d, a.half, a);
              },
              justify: function justify(b, a, d) {
                return d[0] + (b.half ? -1 : 1) * (a + b.labelDistance);
              },
              alignToPlotEdges: function alignToPlotEdges(b, a, d, c) {
                b = b.getBBox().width;
                return a ? b + c : d - b - c;
              },
              alignToConnectors: function alignToConnectors(b, a, d, c) {
                var e = 0,
                    f;
                b.forEach(function (b) {
                  f = b.dataLabel.getBBox().width;
                  f > e && (e = f);
                });
                return a ? e + c : d - e - c;
              }
            };

            w.compose = function (b) {
              a.compose(l);
              -1 === u.indexOf(b) && (u.push(b), b = b.prototype, b.dataLabelPositioners = E, b.alignDataLabel = r, b.drawDataLabels = f, b.placeDataLabels = B, b.verifyDataLabelOverflow = x);
            };
          })(J || (J = {}));

          return J;
        });
        I(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function (a, v) {
          function r(a, d) {
            var b = !1;

            if (a) {
              var g = a.newOpacity;
              a.oldOpacity !== g && (a.alignAttr && a.placed ? (a[g ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), b = !0, a.alignAttr.opacity = g, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, function () {
                d.styledMode || a.css({
                  pointerEvents: g ? "auto" : "none"
                });
              }), z(d, "afterHideOverlappingLabel")) : a.attr({
                opacity: g
              }));
              a.isOld = !0;
            }

            return b;
          }

          var y = v.addEvent,
              z = v.fireEvent,
              w = v.isArray,
              D = v.isNumber,
              t = v.objectEach,
              l = v.pick;
          y(a, "render", function () {
            var a = this,
                d = [];
            (this.labelCollectors || []).forEach(function (b) {
              d = d.concat(b());
            });
            (this.yAxis || []).forEach(function (b) {
              b.stacking && b.options.stackLabels && !b.options.stackLabels.allowOverlap && t(b.stacking.stacks, function (b) {
                t(b, function (b) {
                  b.label && "hidden" !== b.label.visibility && d.push(b.label);
                });
              });
            });
            (this.series || []).forEach(function (b) {
              var g = b.options.dataLabels;
              b.visible && (!1 !== g.enabled || b._hasPointLabels) && (g = function g(b) {
                return b.forEach(function (b) {
                  b.visible && (w(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : []).forEach(function (g) {
                    var h = g.options;
                    g.labelrank = l(h.labelrank, b.labelrank, b.shapeArgs && b.shapeArgs.height);
                    h.allowOverlap ? (g.oldOpacity = g.opacity, g.newOpacity = 1, r(g, a)) : d.push(g);
                  });
                });
              }, g(b.nodes || []), g(b.points));
            });
            this.hideOverlappingLabels(d);
          });

          a.prototype.hideOverlappingLabels = function (a) {
            var d = this,
                b = a.length,
                g = d.renderer,
                h,
                k,
                l,
                t = !1;

            var f = function f(b) {
              var a,
                  d = b.box ? 0 : b.padding || 0,
                  f = a = 0,
                  e;

              if (b && (!b.alignAttr || b.placed)) {
                var c = b.alignAttr || {
                  x: b.attr("x"),
                  y: b.attr("y")
                };
                var h = b.parentGroup;
                b.width || (a = b.getBBox(), b.width = a.width, b.height = a.height, a = g.fontMetrics(null, b.element).h);
                var k = b.width - 2 * d;
                (e = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[b.alignValue]) ? f = +e * k : D(b.x) && Math.round(b.x) !== b.translateX && (f = b.x - b.translateX);
                return {
                  x: c.x + (h.translateX || 0) + d - (f || 0),
                  y: c.y + (h.translateY || 0) + d - a,
                  width: b.width - 2 * d,
                  height: b.height - 2 * d
                };
              }
            };

            for (k = 0; k < b; k++) {
              if (h = a[k]) h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = f(h);
            }

            a.sort(function (b, a) {
              return (a.labelrank || 0) - (b.labelrank || 0);
            });

            for (k = 0; k < b; k++) {
              var B = (f = a[k]) && f.absoluteBox;

              for (h = k + 1; h < b; ++h) {
                var x = (l = a[h]) && l.absoluteBox;
                !B || !x || f === l || 0 === f.newOpacity || 0 === l.newOpacity || x.x >= B.x + B.width || x.x + x.width <= B.x || x.y >= B.y + B.height || x.y + x.height <= B.y || ((f.labelrank < l.labelrank ? f : l).newOpacity = 0);
              }
            }

            a.forEach(function (b) {
              r(b, d) && (t = !0);
            });
            t && z(d, "afterHideAllOverlappingLabels");
          };
        });
        I(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function (a) {
          var r = a.extend,
              A = a.find,
              y = a.isArray,
              z = a.isObject,
              w = a.merge,
              D = a.objectEach,
              t = a.pick,
              l = a.splat,
              h = a.uniqueKey,
              d;

          (function (b) {
            var a = [];

            b.compose = function (b) {
              -1 === a.indexOf(b) && (a.push(b), r(b.prototype, d.prototype));
              return b;
            };

            var d = function () {
              function b() {}

              b.prototype.currentOptions = function (b) {
                function a(b, f, g, h) {
                  var k;
                  D(b, function (b, c) {
                    if (!h && -1 < d.collectionsWithUpdate.indexOf(c) && f[c]) for (b = l(b), g[c] = [], k = 0; k < Math.max(b.length, f[c].length); k++) {
                      f[c][k] && (void 0 === b[k] ? g[c][k] = f[c][k] : (g[c][k] = {}, a(b[k], f[c][k], g[c][k], h + 1)));
                    } else z(b) ? (g[c] = y(b) ? [] : {}, a(b, f[c] || {}, g[c], h + 1)) : g[c] = "undefined" === typeof f[c] ? null : f[c];
                  });
                }

                var d = this,
                    g = {};
                a(b, this.options, g, 0);
                return g;
              };

              b.prototype.matchResponsiveRule = function (b, a) {
                var d = b.condition;
                (d.callback || function () {
                  return this.chartWidth <= t(d.maxWidth, Number.MAX_VALUE) && this.chartHeight <= t(d.maxHeight, Number.MAX_VALUE) && this.chartWidth >= t(d.minWidth, 0) && this.chartHeight >= t(d.minHeight, 0);
                }).call(this) && a.push(b._id);
              };

              b.prototype.setResponsive = function (b, a) {
                var d = this,
                    g = this.options.responsive,
                    k = this.currentResponsive,
                    l = [];
                !a && g && g.rules && g.rules.forEach(function (b) {
                  "undefined" === typeof b._id && (b._id = h());
                  d.matchResponsiveRule(b, l);
                }, this);
                a = w.apply(void 0, l.map(function (b) {
                  return A((g || {}).rules || [], function (a) {
                    return a._id === b;
                  });
                }).map(function (b) {
                  return b && b.chartOptions;
                }));
                a.isResponsiveOptions = !0;
                l = l.toString() || void 0;
                l !== (k && k.ruleIds) && (k && this.update(k.undoOptions, b, !0), l ? (k = this.currentOptions(a), k.isResponsiveOptions = !0, this.currentResponsive = {
                  ruleIds: l,
                  mergedOptions: a,
                  undoOptions: k
                }, this.update(a, b, !0)) : this.currentResponsive = void 0);
              };

              return b;
            }();
          })(d || (d = {}));

          "";
          "";
          return d;
        });
        I(a, "masters/highcharts.src.js", [a["Core/Globals.js"], a["Core/Utilities.js"], a["Core/DefaultOptions.js"], a["Core/Animation/Fx.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/Renderer/HTML/AST.js"], a["Core/FormatUtilities.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Renderer/HTML/HTMLElement.js"], a["Core/Renderer/HTML/HTMLRenderer.js"], a["Core/Axis/Axis.js"], a["Core/Axis/DateTimeAxis.js"], a["Core/Axis/LogarithmicAxis.js"], a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], a["Core/Axis/Tick.js"], a["Core/Tooltip.js"], a["Core/Series/Point.js"], a["Core/Pointer.js"], a["Core/MSPointer.js"], a["Core/Legend/Legend.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Series/Column/ColumnSeries.js"], a["Series/Column/ColumnDataLabel.js"], a["Series/Pie/PieSeries.js"], a["Series/Pie/PieDataLabel.js"], a["Core/Series/DataLabel.js"], a["Core/Responsive.js"], a["Core/Color/Color.js"], a["Core/Time.js"]], function (a, v, A, y, z, w, D, t, l, h, d, b, g, p, k, J, G, f, B, x, u, E, m, q, e, c, n, C, H, L, F, I, S) {
          a.animate = z.animate;
          a.animObject = z.animObject;
          a.getDeferredAnimation = z.getDeferredAnimation;
          a.setAnimation = z.setAnimation;
          a.stop = z.stop;
          a.timers = y.timers;
          a.AST = w;
          a.Axis = g;
          a.Chart = m;
          a.chart = m.chart;
          a.Fx = y;
          a.Legend = E;
          a.PlotLineOrBand = J;
          a.Point = B;
          a.Pointer = u.isRequired() ? u : x;
          a.Series = q;
          a.SVGElement = l;
          a.SVGRenderer = h;
          a.Tick = G;
          a.Time = S;
          a.Tooltip = f;
          a.Color = I;
          a.color = I.parse;
          b.compose(h);
          d.compose(l);
          a.defaultOptions = A.defaultOptions;
          a.getOptions = A.getOptions;
          a.time = A.defaultTime;
          a.setOptions = A.setOptions;
          a.dateFormat = D.dateFormat;
          a.format = D.format;
          a.numberFormat = D.numberFormat;
          a.addEvent = v.addEvent;
          a.arrayMax = v.arrayMax;
          a.arrayMin = v.arrayMin;
          a.attr = v.attr;
          a.clearTimeout = v.clearTimeout;
          a.correctFloat = v.correctFloat;
          a.createElement = v.createElement;
          a.css = v.css;
          a.defined = v.defined;
          a.destroyObjectProperties = v.destroyObjectProperties;
          a.discardElement = v.discardElement;
          a.distribute = t.distribute;
          a.erase = v.erase;
          a.error = v.error;
          a.extend = v.extend;
          a.extendClass = v.extendClass;
          a.find = v.find;
          a.fireEvent = v.fireEvent;
          a.getMagnitude = v.getMagnitude;
          a.getStyle = v.getStyle;
          a.inArray = v.inArray;
          a.isArray = v.isArray;
          a.isClass = v.isClass;
          a.isDOMElement = v.isDOMElement;
          a.isFunction = v.isFunction;
          a.isNumber = v.isNumber;
          a.isObject = v.isObject;
          a.isString = v.isString;
          a.keys = v.keys;
          a.merge = v.merge;
          a.normalizeTickInterval = v.normalizeTickInterval;
          a.objectEach = v.objectEach;
          a.offset = v.offset;
          a.pad = v.pad;
          a.pick = v.pick;
          a.pInt = v.pInt;
          a.relativeLength = v.relativeLength;
          a.removeEvent = v.removeEvent;
          a.seriesType = e.seriesType;
          a.splat = v.splat;
          a.stableSort = v.stableSort;
          a.syncTimeout = v.syncTimeout;
          a.timeUnits = v.timeUnits;
          a.uniqueKey = v.uniqueKey;
          a.useSerialIds = v.useSerialIds;
          a.wrap = v.wrap;
          n.compose(c);
          L.compose(q);
          p.compose(g);
          k.compose(g);
          H.compose(C);
          J.compose(g);
          F.compose(m);
          return a;
        });
        I(a, "Core/Axis/MapAxis.js", [a["Core/Axis/Axis.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = v.addEvent,
              y = v.pick,
              z = function () {
            return function (a) {
              this.axis = a;
            };
          }();

          v = function () {
            function a() {}

            a.compose = function (a) {
              a.keepProps.push("mapAxis");
              r(a, "init", function () {
                this.mapAxis || (this.mapAxis = new z(this));
              });
              r(a, "getSeriesExtremes", function () {
                if (this.mapAxis) {
                  var a = [];
                  this.isXAxis && (this.series.forEach(function (l, h) {
                    l.useMapGeometry && (a[h] = l.xData, l.xData = []);
                  }), this.mapAxis.seriesXData = a);
                }
              });
              r(a, "afterGetSeriesExtremes", function () {
                if (this.mapAxis) {
                  var a = this.mapAxis.seriesXData || [],
                      l;

                  if (this.isXAxis) {
                    var h = y(this.dataMin, Number.MAX_VALUE);
                    var d = y(this.dataMax, -Number.MAX_VALUE);
                    this.series.forEach(function (b, g) {
                      b.useMapGeometry && (h = Math.min(h, y(b.minX, h)), d = Math.max(d, y(b.maxX, d)), b.xData = a[g], l = !0);
                    });
                    l && (this.dataMin = h, this.dataMax = d);
                    this.mapAxis.seriesXData = void 0;
                  }
                }
              });
              r(a, "afterSetAxisTranslation", function () {
                if (this.mapAxis) {
                  var a = this.chart,
                      l = a.plotWidth / a.plotHeight;
                  a = a.xAxis[0];
                  var h;
                  "yAxis" === this.coll && "undefined" !== typeof a.transA && this.series.forEach(function (a) {
                    a.preserveAspectRatio && (h = !0);
                  });

                  if (h && (this.transA = a.transA = Math.min(this.transA, a.transA), l /= (a.max - a.min) / (this.max - this.min), l = 1 > l ? this : a, a = (l.max - l.min) * l.transA, l.mapAxis.pixelPadding = l.len - a, l.minPixelPadding = l.mapAxis.pixelPadding / 2, a = l.mapAxis.fixTo)) {
                    a = a[1] - l.toValue(a[0], !0);
                    a *= l.transA;
                    if (Math.abs(a) > l.minPixelPadding || l.min === l.dataMin && l.max === l.dataMax) a = 0;
                    l.minPixelPadding -= a;
                  }
                }
              });
              r(a, "render", function () {
                this.mapAxis && (this.mapAxis.fixTo = void 0);
              });
            };

            return a;
          }();

          v.compose(a);
          return v;
        });
        I(a, "Mixins/ColorSeries.js", [], function () {
          return {
            colorPointMixin: {
              setVisible: function setVisible(a) {
                var r = this,
                    A = a ? "show" : "hide";
                r.visible = r.options.visible = !!a;
                ["graphic", "dataLabel"].forEach(function (a) {
                  if (r[a]) r[a][A]();
                });
                this.series.buildKDTree();
              }
            },
            colorSeriesMixin: {
              optionalAxis: "colorAxis",
              translateColors: function translateColors() {
                var a = this,
                    v = this.options.nullColor,
                    A = this.colorAxis,
                    y = this.colorKey;
                (this.data.length ? this.data : this.points).forEach(function (r) {
                  var w = r.getNestedProperty(y);
                  (w = r.options.color || (r.isNull || null === r.value ? v : A && "undefined" !== typeof w ? A.toColor(w, r) : r.color || a.color)) && r.color !== w && (r.color = w, "point" === a.options.legendType && r.legendItem && a.chart.legend.colorizeItem(r, r.visible));
                });
              }
            }
          };
        });
        I(a, "Core/Axis/Color/ColorAxisComposition.js", [a["Core/Color/Color.js"], a["Mixins/ColorSeries.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = a.parse,
              z = v.colorPointMixin,
              w = v.colorSeriesMixin,
              D = A.addEvent,
              t = A.extend,
              l = A.merge,
              h = A.pick,
              d = A.splat,
              b;

          (function (a) {
            function b() {
              var a = this,
                  b = this.options;
              this.colorAxis = [];
              b.colorAxis && (b.colorAxis = d(b.colorAxis), b.colorAxis.forEach(function (b, c) {
                b.index = c;
                new q(a, b);
              }));
            }

            function g(a) {
              var b = this,
                  d = function d(c) {
                c = a.allItems.indexOf(c);
                -1 !== c && (b.destroyItem(a.allItems[c]), a.allItems.splice(c, 1));
              },
                  e = [],
                  f,
                  g;

              (this.chart.colorAxis || []).forEach(function (a) {
                (f = a.options) && f.showInLegend && (f.dataClasses && f.visible ? e = e.concat(a.getDataClassLegendSymbols()) : f.visible && e.push(a), a.series.forEach(function (a) {
                  if (!a.options.showInLegend || f.dataClasses) "point" === a.options.legendType ? a.points.forEach(function (a) {
                    d(a);
                  }) : d(a);
                }));
              });

              for (g = e.length; g--;) {
                a.allItems.unshift(e[g]);
              }
            }

            function v(a) {
              a.visible && a.item.legendColor && a.item.legendSymbol.attr({
                fill: a.item.legendColor
              });
            }

            function y() {
              var a = this.chart.colorAxis;
              a && a.forEach(function (a, b, d) {
                a.update({}, d);
              });
            }

            function f() {
              (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
            }

            function B() {
              var a = this.axisTypes;
              a ? -1 === a.indexOf("colorAxis") && a.push("colorAxis") : this.axisTypes = ["colorAxis"];
            }

            function x(a) {
              var b = a.prototype.createAxis;

              a.prototype.createAxis = function (a, c) {
                if ("colorAxis" !== a) return b.apply(this, arguments);
                var d = new q(this, l(c.axis, {
                  index: this[a].length,
                  isX: !1
                }));
                this.isDirtyLegend = !0;
                this.axes.forEach(function (a) {
                  a.series = [];
                });
                this.series.forEach(function (a) {
                  a.bindAxes();
                  a.isDirtyData = !0;
                });
                h(c.redraw, !0) && this.redraw(c.animation);
                return d;
              };
            }

            function u() {
              this.elem.attr("fill", r(this.start).tweenTo(r(this.end), this.pos), void 0, !0);
            }

            function E() {
              this.elem.attr("stroke", r(this.start).tweenTo(r(this.end), this.pos), void 0, !0);
            }

            var m = [],
                q;

            a.compose = function (a, c, d, h, k) {
              q || (q = a);
              -1 === m.indexOf(c) && (m.push(c), a = c.prototype, a.collectionsWithUpdate.push("colorAxis"), a.collectionsWithInit.colorAxis = [a.addColorAxis], D(c, "afterGetAxes", b), x(c));
              -1 === m.indexOf(d) && (m.push(d), c = d.prototype, c.fillSetter = u, c.strokeSetter = E);
              -1 === m.indexOf(h) && (m.push(h), D(h, "afterGetAllItems", g), D(h, "afterColorizeItem", v), D(h, "afterUpdate", y));
              -1 === m.indexOf(k) && (m.push(k), t(k.prototype, w), t(k.prototype.pointClass.prototype, z), D(k, "afterTranslate", f), D(k, "bindAxes", B));
            };
          })(b || (b = {}));

          return b;
        });
        I(a, "Core/Axis/Color/ColorAxisDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          return {
            lineWidth: 0,
            minPadding: 0,
            maxPadding: 0,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            startOnTick: !0,
            endOnTick: !0,
            offset: 0,
            marker: {
              animation: {
                duration: 50
              },
              width: .01,
              color: a.neutralColor40
            },
            labels: {
              overflow: "justify",
              rotation: 0
            },
            minColor: a.highlightColor10,
            maxColor: a.highlightColor100,
            tickLength: 5,
            showInLegend: !0
          };
        });
        I(a, "Core/Axis/Color/ColorAxis.js", [a["Core/Axis/Axis.js"], a["Core/Color/Color.js"], a["Core/Axis/Color/ColorAxisComposition.js"], a["Core/Axis/Color/ColorAxisDefaults.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t) {
          var l = this && this.__extends || function () {
            var _a35 = function a(b, d) {
              _a35 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var d in b) {
                  b.hasOwnProperty(d) && (a[d] = b[d]);
                }
              };

              return _a35(b, d);
            };

            return function (b, d) {
              function f() {
                this.constructor = b;
              }

              _a35(b, d);

              b.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
            };
          }(),
              h = v.parse,
              d = z.noop,
              b = D.series,
              g = t.extend,
              p = t.isNumber,
              k = t.merge,
              r = t.pick;

          v = function (a) {
            function f(b, d) {
              var f = a.call(this, b, d) || this;
              f.beforePadding = !1;
              f.chart = void 0;
              f.coll = "colorAxis";
              f.dataClasses = void 0;
              f.legendItem = void 0;
              f.legendItems = void 0;
              f.name = "";
              f.options = void 0;
              f.stops = void 0;
              f.visible = !0;
              f.init(b, d);
              return f;
            }

            l(f, a);

            f.compose = function (a, b, d, g) {
              A.compose(f, a, b, d, g);
            };

            f.prototype.init = function (b, d) {
              var g = b.options.legend || {},
                  h = d.layout ? "vertical" !== d.layout : "vertical" !== g.layout,
                  m = d.visible;
              g = k(f.defaultColorAxisOptions, d, {
                showEmpty: !1,
                title: null,
                visible: g.enabled && !1 !== m
              });
              this.coll = "colorAxis";
              this.side = d.side || h ? 2 : 1;
              this.reversed = d.reversed || !h;
              this.opposite = !h;
              a.prototype.init.call(this, b, g);
              this.userOptions.visible = m;
              d.dataClasses && this.initDataClasses(d);
              this.initStops();
              this.horiz = h;
              this.zoomEnabled = !1;
            };

            f.prototype.initDataClasses = function (a) {
              var b = this.chart,
                  d = this.options,
                  f = a.dataClasses.length,
                  g,
                  l = 0,
                  e = b.options.chart.colorCount;
              this.dataClasses = g = [];
              this.legendItems = [];
              (a.dataClasses || []).forEach(function (a, n) {
                a = k(a);
                g.push(a);
                if (b.styledMode || !a.color) "category" === d.dataClassColor ? (b.styledMode || (n = b.options.colors, e = n.length, a.color = n[l]), a.colorIndex = l, l++, l === e && (l = 0)) : a.color = h(d.minColor).tweenTo(h(d.maxColor), 2 > f ? .5 : n / (f - 1));
              });
            };

            f.prototype.hasData = function () {
              return !!(this.tickPositions || []).length;
            };

            f.prototype.setTickPositions = function () {
              if (!this.dataClasses) return a.prototype.setTickPositions.call(this);
            };

            f.prototype.initStops = function () {
              this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
              this.stops.forEach(function (a) {
                a.color = h(a[1]);
              });
            };

            f.prototype.setOptions = function (b) {
              a.prototype.setOptions.call(this, b);
              this.options.crosshair = this.options.marker;
            };

            f.prototype.setAxisSize = function () {
              var a = this.legendSymbol,
                  b = this.chart,
                  d = b.options.legend || {},
                  g,
                  h;
              a ? (this.left = d = a.attr("x"), this.top = g = a.attr("y"), this.width = h = a.attr("width"), this.height = a = a.attr("height"), this.right = b.chartWidth - d - h, this.bottom = b.chartHeight - g - a, this.len = this.horiz ? h : a, this.pos = this.horiz ? d : g) : this.len = (this.horiz ? d.symbolWidth : d.symbolHeight) || f.defaultLegendLength;
            };

            f.prototype.normalizedValue = function (a) {
              this.logarithmic && (a = this.logarithmic.log2lin(a));
              return 1 - (this.max - a) / (this.max - this.min || 1);
            };

            f.prototype.toColor = function (a, b) {
              var d = this.dataClasses,
                  f = this.stops,
                  g;
              if (d) for (g = d.length; g--;) {
                var h = d[g];
                var e = h.from;
                f = h.to;

                if (("undefined" === typeof e || a >= e) && ("undefined" === typeof f || a <= f)) {
                  var c = h.color;
                  b && (b.dataClass = g, b.colorIndex = h.colorIndex);
                  break;
                }
              } else {
                a = this.normalizedValue(a);

                for (g = f.length; g-- && !(a > f[g][0]);) {
                  ;
                }

                e = f[g] || f[g + 1];
                f = f[g + 1] || e;
                a = 1 - (f[0] - a) / (f[0] - e[0] || 1);
                c = e.color.tweenTo(f.color, a);
              }
              return c;
            };

            f.prototype.getOffset = function () {
              var b = this.legendGroup,
                  d = this.chart.axisOffset[this.side];
              b && (this.axisParent = b, a.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = d);
            };

            f.prototype.setLegendColor = function () {
              var a = this.reversed,
                  b = a ? 1 : 0;
              a = a ? 0 : 1;
              b = this.horiz ? [b, 0, a, 0] : [0, a, 0, b];
              this.legendColor = {
                linearGradient: {
                  x1: b[0],
                  y1: b[1],
                  x2: b[2],
                  y2: b[3]
                },
                stops: this.stops
              };
            };

            f.prototype.drawLegendSymbol = function (a, b) {
              var d = a.padding,
                  g = a.options,
                  h = this.horiz,
                  k = r(g.symbolWidth, h ? f.defaultLegendLength : 12),
                  e = r(g.symbolHeight, h ? 12 : f.defaultLegendLength),
                  c = r(g.labelPadding, h ? 16 : 30);
              g = r(g.itemDistance, 10);
              this.setLegendColor();
              b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, k, e).attr({
                zIndex: 1
              }).add(b.legendGroup);
              this.legendItemWidth = k + d + (h ? g : c);
              this.legendItemHeight = e + d + (h ? c : 0);
            };

            f.prototype.setState = function (a) {
              this.series.forEach(function (b) {
                b.setState(a);
              });
            };

            f.prototype.setVisible = function () {};

            f.prototype.getSeriesExtremes = function () {
              var a = this.series,
                  d = a.length,
                  f;
              this.dataMin = Infinity;

              for (this.dataMax = -Infinity; d--;) {
                var g = a[d];
                var h = g.colorKey = r(g.options.colorKey, g.colorKey, g.pointValKey, g.zoneAxis, "y");
                var k = g.pointArrayMap;
                var e = g[h + "Min"] && g[h + "Max"];
                if (g[h + "Data"]) var c = g[h + "Data"];else if (k) {
                  c = [];
                  k = k.indexOf(h);
                  var n = g.yData;
                  if (0 <= k && n) for (f = 0; f < n.length; f++) {
                    c.push(r(n[f][k], n[f]));
                  }
                } else c = g.yData;
                e ? (g.minColorValue = g[h + "Min"], g.maxColorValue = g[h + "Max"]) : (c = b.prototype.getExtremes.call(g, c), g.minColorValue = c.dataMin, g.maxColorValue = c.dataMax);
                "undefined" !== typeof g.minColorValue && (this.dataMin = Math.min(this.dataMin, g.minColorValue), this.dataMax = Math.max(this.dataMax, g.maxColorValue));
                e || b.prototype.applyExtremes.call(g);
              }
            };

            f.prototype.drawCrosshair = function (b, d) {
              var f = d && d.plotX,
                  g = d && d.plotY,
                  h = this.pos,
                  k = this.len;

              if (d) {
                var e = this.toPixels(d.getNestedProperty(d.series.colorKey));
                e < h ? e = h - 2 : e > h + k && (e = h + k + 2);
                d.plotX = e;
                d.plotY = this.len - e;
                a.prototype.drawCrosshair.call(this, b, d);
                d.plotX = f;
                d.plotY = g;
                this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || "object" !== typeof this.crosshair || this.cross.attr({
                  fill: this.crosshair.color
                }));
              }
            };

            f.prototype.getPlotLinePath = function (b) {
              var d = this.left,
                  f = b.translatedValue,
                  g = this.top;
              return p(f) ? this.horiz ? [["M", f - 4, g - 6], ["L", f + 4, g - 6], ["L", f, g], ["Z"]] : [["M", d, f], ["L", d - 6, f + 6], ["L", d - 6, f - 6], ["Z"]] : a.prototype.getPlotLinePath.call(this, b);
            };

            f.prototype.update = function (b, d) {
              var f = this.chart.legend;
              this.series.forEach(function (a) {
                a.isDirtyData = !0;
              });
              (b.dataClasses && f.allItems || this.dataClasses) && this.destroyItems();
              a.prototype.update.call(this, b, d);
              this.legendItem && (this.setLegendColor(), f.colorizeItem(this, !0));
            };

            f.prototype.destroyItems = function () {
              var a = this.chart;
              this.legendItem ? a.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (b) {
                a.legend.destroyItem(b);
              });
              a.isDirtyLegend = !0;
            };

            f.prototype.destroy = function () {
              this.chart.isDirtyLegend = !0;
              this.destroyItems();
              a.prototype.destroy.apply(this, [].slice.call(arguments));
            };

            f.prototype.remove = function (b) {
              this.destroyItems();
              a.prototype.remove.call(this, b);
            };

            f.prototype.getDataClassLegendSymbols = function () {
              var a = this,
                  b = a.chart,
                  f = a.legendItems,
                  h = b.options.legend,
                  k = h.valueDecimals,
                  l = h.valueSuffix || "",
                  e;
              f.length || a.dataClasses.forEach(function (c, h) {
                var n = c.from,
                    m = c.to,
                    p = b.numberFormatter,
                    q = !0;
                e = "";
                "undefined" === typeof n ? e = "< " : "undefined" === typeof m && (e = "> ");
                "undefined" !== typeof n && (e += p(n, k) + l);
                "undefined" !== typeof n && "undefined" !== typeof m && (e += " - ");
                "undefined" !== typeof m && (e += p(m, k) + l);
                f.push(g({
                  chart: b,
                  name: e,
                  options: {},
                  drawLegendSymbol: w.drawRectangle,
                  visible: !0,
                  setState: d,
                  isDataClass: !0,
                  setVisible: function setVisible() {
                    q = a.visible = !q;
                    a.series.forEach(function (a) {
                      a.points.forEach(function (a) {
                        a.dataClass === h && a.setVisible(q);
                      });
                    });
                    b.legend.colorizeItem(this, q);
                  }
                }, c));
              });
              return f;
            };

            f.defaultColorAxisOptions = y;
            f.defaultLegendLength = 200;
            f.keepProps = ["legendGroup", "legendItemHeight", "legendItemWidth", "legendItem", "legendSymbol"];
            return f;
          }(a);

          Array.prototype.push.apply(a.keepProps, v.keepProps);
          "";
          return v;
        });
        I(a, "Mixins/ColorMapSeries.js", [a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = A.defined;
          A = A.addEvent;
          var z = a.noop;
          a = a.seriesTypes;
          A(v, "afterSetState", function (a) {
            this.moveToTopOnHover && this.graphic && this.graphic.attr({
              zIndex: a && "hover" === a.state ? 1 : 0
            });
          });
          return {
            colorMapPointMixin: {
              dataLabelOnNull: !0,
              moveToTopOnHover: !0,
              isValid: function isValid() {
                return null !== this.value && Infinity !== this.value && -Infinity !== this.value;
              }
            },
            colorMapSeriesMixin: {
              pointArrayMap: ["value"],
              axisTypes: ["xAxis", "yAxis", "colorAxis"],
              trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
              getSymbol: z,
              parallelArrays: ["x", "y", "value"],
              colorKey: "value",
              pointAttribs: a.column.prototype.pointAttribs,
              colorAttribs: function colorAttribs(a) {
                var w = {};
                !r(a.color) || a.state && "normal" !== a.state || (w[this.colorProp || "fill"] = a.color);
                return w;
              }
            }
          };
        });
        I(a, "Maps/MapNavigationOptionsDefault.js", [a["Core/DefaultOptions.js"], a["Core/Utilities.js"]], function (a, v) {
          v = v.extend;
          var r = {
            buttonOptions: {
              alignTo: "plotBox",
              align: "left",
              verticalAlign: "top",
              x: 0,
              width: 18,
              height: 18,
              padding: 5,
              style: {
                fontSize: "15px",
                fontWeight: "bold"
              },
              theme: {
                "stroke-width": 1,
                "text-align": "center"
              }
            },
            buttons: {
              zoomIn: {
                onclick: function onclick() {
                  this.mapZoom(.5);
                },
                text: "+",
                y: 0
              },
              zoomOut: {
                onclick: function onclick() {
                  this.mapZoom(2);
                },
                text: "-",
                y: 28
              }
            },
            mouseWheelSensitivity: 1.1
          };
          v(a.defaultOptions.lang, {
            zoomIn: "Zoom in",
            zoomOut: "Zoom out"
          });
          return a.defaultOptions.mapNavigation = r;
        });
        I(a, "Maps/MapNavigation.js", [a["Core/Chart/Chart.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v, A) {
          function r(a) {
            a && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);
          }

          function z(a) {
            this.init(a);
          }

          var w = v.doc,
              D = A.addEvent,
              t = A.extend,
              l = A.merge,
              h = A.objectEach,
              d = A.pick;

          z.prototype.init = function (a) {
            this.chart = a;
            a.mapNavButtons = [];
          };

          z.prototype.update = function (a) {
            var b = this.chart,
                p = b.options.mapNavigation,
                k,
                w,
                v,
                f,
                B = function B(a) {
              this.handler.call(b, a);
              r(a);
            },
                x = b.mapNavButtons;

            a && (p = b.options.mapNavigation = l(b.options.mapNavigation, a));

            for (; x.length;) {
              x.pop().destroy();
            }

            d(p.enableButtons, p.enabled) && !b.renderer.forExport && h(p.buttons, function (a, d) {
              a = l(p.buttonOptions, a);
              !b.styledMode && a.theme && (k = a.theme, k.style = l(a.theme.style, a.style), v = (w = k.states) && w.hover, f = w && w.select, delete k.states);
              var g = b.renderer.button(a.text || "", 0, 0, B, k, v, f, void 0, "zoomIn" === d ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + {
                zoomIn: "zoom-in",
                zoomOut: "zoom-out"
              }[d]).attr({
                width: a.width,
                height: a.height,
                title: b.options.lang[d],
                padding: a.padding,
                zIndex: 5
              }).add();
              g.handler = a.onclick;
              D(g.element, "dblclick", r);
              x.push(g);
              t(a, {
                width: g.width,
                height: 2 * g.height
              });
              if (b.hasLoaded) g.align(a, !1, a.alignTo);else var h = D(b, "load", function () {
                g.element && g.align(a, !1, a.alignTo);
                h();
              });
            });
            this.updateEvents(p);
          };

          z.prototype.updateEvents = function (a) {
            var b = this.chart;
            d(a.enableDoubleClickZoom, a.enabled) || a.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || D(b.container, "dblclick", function (a) {
              b.pointer.onContainerDblClick(a);
            }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());
            d(a.enableMouseWheelZoom, a.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || D(b.container, void 0 !== w.onwheel ? "wheel" : void 0 !== w.onmousewheel ? "mousewheel" : "DOMMouseScroll", function (a) {
              b.pointer.inClass(a.target, "highcharts-no-mousewheel") || (b.pointer.onContainerMouseWheel(a), r(a));
              return !1;
            }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
          };

          t(a.prototype, {
            fitToBox: function fitToBox(a, d) {
              [["x", "width"], ["y", "height"]].forEach(function (b) {
                var g = b[0];
                b = b[1];
                a[g] + a[b] > d[g] + d[b] && (a[b] > d[b] ? (a[b] = d[b], a[g] = d[g]) : a[g] = d[g] + d[b] - a[b]);
                a[b] > d[b] && (a[b] = d[b]);
                a[g] < d[g] && (a[g] = d[g]);
              });
              return a;
            },
            mapZoom: function mapZoom(a, g, h, k, l, t) {
              var b = this.xAxis[0],
                  p = b.max - b.min,
                  r = d(g, b.min + p / 2),
                  u = p * a;
              p = this.yAxis[0];
              var w = p.max - p.min,
                  m = d(h, p.min + w / 2);
              w *= a;
              r = this.fitToBox({
                x: r - u * (k ? (k - b.pos) / b.len : .5),
                y: m - w * (l ? (l - p.pos) / p.len : .5),
                width: u,
                height: w
              }, {
                x: b.dataMin,
                y: p.dataMin,
                width: b.dataMax - b.dataMin,
                height: p.dataMax - p.dataMin
              });
              u = r.x <= b.dataMin && r.width >= b.dataMax - b.dataMin && r.y <= p.dataMin && r.height >= p.dataMax - p.dataMin;
              k && b.mapAxis && (b.mapAxis.fixTo = [k - b.pos, g]);
              l && p.mapAxis && (p.mapAxis.fixTo = [l - p.pos, h]);
              "undefined" === typeof a || u ? (b.setExtremes(void 0, void 0, !1), p.setExtremes(void 0, void 0, !1)) : (b.setExtremes(r.x, r.x + r.width, !1), p.setExtremes(r.y, r.y + r.height, !1));
              this.redraw(t);
            }
          });
          D(a, "beforeRender", function () {
            this.mapNavigation = new z(this);
            this.mapNavigation.update();
          });
          v.MapNavigation = z;
        });
        I(a, "Maps/MapPointer.js", [a["Core/Pointer.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = v.extend,
              y = v.pick;
          v = v.wrap;
          var z = 0,
              w;
          r(a.prototype, {
            onContainerDblClick: function onContainerDblClick(a) {
              var t = this.chart;
              a = this.normalize(a);
              t.options.mapNavigation.enableDoubleClickZoomTo ? t.pointer.inClass(a.target, "highcharts-tracker") && t.hoverPoint && t.hoverPoint.zoomTo() : t.isInsidePlot(a.chartX - t.plotLeft, a.chartY - t.plotTop) && t.mapZoom(.5, t.xAxis[0].toValue(a.chartX), t.yAxis[0].toValue(a.chartY), a.chartX, a.chartY);
            },
            onContainerMouseWheel: function onContainerMouseWheel(a) {
              var t = this.chart;
              a = this.normalize(a);
              var l = a.deltaY || a.detail || -(a.wheelDelta / 120);
              1 <= Math.abs(l) && (z += Math.abs(l), w && clearTimeout(w), w = setTimeout(function () {
                z = 0;
              }, 50));
              10 > z && t.isInsidePlot(a.chartX - t.plotLeft, a.chartY - t.plotTop) && t.mapZoom(Math.pow(t.options.mapNavigation.mouseWheelSensitivity, l), t.xAxis[0].toValue(a.chartX), t.yAxis[0].toValue(a.chartY), a.chartX, a.chartY, 1 > Math.abs(l) ? !1 : void 0);
            }
          });
          v(a.prototype, "zoomOption", function (a) {
            var t = this.chart.options.mapNavigation;
            y(t.enableTouchZoom, t.enabled) && (this.chart.options.chart.pinchType = "xy");
            a.apply(this, [].slice.call(arguments, 1));
          });
          v(a.prototype, "pinchTranslate", function (a, t, l, h, d, b, g) {
            a.call(this, t, l, h, d, b, g);
            "map" === this.chart.options.chart.type && this.hasZoom && (a = h.scaleX > h.scaleY, this.pinchTranslateDirection(!a, t, l, h, d, b, g, a ? h.scaleX : h.scaleY));
          });
        });
        I(a, "Maps/MapSymbols.js", [a["Core/Renderer/SVG/SVGRenderer.js"]], function (a) {
          function r(a, r, v, w, D, t, l, h) {
            return [["M", a + D, r], ["L", a + v - t, r], ["C", a + v - t / 2, r, a + v, r + t / 2, a + v, r + t], ["L", a + v, r + w - l], ["C", a + v, r + w - l / 2, a + v - l / 2, r + w, a + v - l, r + w], ["L", a + h, r + w], ["C", a + h / 2, r + w, a, r + w - h / 2, a, r + w - h], ["L", a, r + D], ["C", a, r + D / 2, a + D / 2, r, a + D, r], ["Z"]];
          }

          a = a.prototype.symbols;

          a.bottombutton = function (a, v, z, w, D) {
            D = D && D.r || 0;
            return r(a - 1, v - 1, z, w, 0, 0, D, D);
          };

          a.topbutton = function (a, v, z, w, D) {
            D = D && D.r || 0;
            return r(a - 1, v - 1, z, w, D, D, 0, 0);
          };

          return a;
        });
        I(a, "Core/Chart/MapChart.js", [a["Core/Chart/Chart.js"], a["Core/DefaultOptions.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = this && this.__extends || function () {
            var _a36 = function a(h, d) {
              _a36 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _a36(h, d);
            };

            return function (h, d) {
              function b() {
                this.constructor = h;
              }

              _a36(h, d);

              h.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              w = v.getOptions,
              D = y.merge,
              t = y.pick;

          a = function (a) {
            function h() {
              return null !== a && a.apply(this, arguments) || this;
            }

            r(h, a);

            h.prototype.init = function (d, b) {
              var g = {
                endOnTick: !1,
                visible: !1,
                minPadding: 0,
                maxPadding: 0,
                startOnTick: !1
              },
                  h = w().credits;
              d = D({
                chart: {
                  panning: {
                    enabled: !0,
                    type: "xy"
                  },
                  type: "map"
                },
                credits: {
                  mapText: t(h.mapText, " \xA9 <a href=\"{geojson.copyrightUrl}\">{geojson.copyrightShort}</a>"),
                  mapTextFull: t(h.mapTextFull, "{geojson.copyright}")
                },
                tooltip: {
                  followTouchMove: !1
                },
                xAxis: g,
                yAxis: D(g, {
                  reversed: !0
                })
              }, d, {
                chart: {
                  inverted: !1,
                  alignTicks: !1
                }
              });
              a.prototype.init.call(this, d, b);
            };

            return h;
          }(a);

          (function (a) {
            a.maps = {};

            a.mapChart = function (h, d, b) {
              return new a(h, d, b);
            };

            a.splitPath = function (a) {
              "string" === typeof a && (a = a.replace(/([A-Za-z])/g, " $1 ").replace(/^\s*/, "").replace(/\s*$/, ""), a = a.split(/[ ,;]+/).map(function (a) {
                return /[A-za-z]/.test(a) ? a : parseFloat(a);
              }));
              return A.prototype.pathToSegments(a);
            };
          })(a || (a = {}));

          return a;
        });
        I(a, "Series/Map/MapPoint.js", [a["Mixins/ColorMapSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = this && this.__extends || function () {
            var _a37 = function a(r, t) {
              _a37 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, h) {
                a.__proto__ = h;
              } || function (a, h) {
                for (var d in h) {
                  h.hasOwnProperty(d) && (a[d] = h[d]);
                }
              };

              return _a37(r, t);
            };

            return function (r, t) {
              function l() {
                this.constructor = r;
              }

              _a37(r, t);

              r.prototype = null === t ? Object.create(t) : (l.prototype = t.prototype, new l());
            };
          }();

          a = a.colorMapPointMixin;
          var z = A.extend;

          v = function (a) {
            function w() {
              var r = null !== a && a.apply(this, arguments) || this;
              r.options = void 0;
              r.path = void 0;
              r.series = void 0;
              return r;
            }

            r(w, a);

            w.prototype.applyOptions = function (r, l) {
              var h = this.series;
              r = a.prototype.applyOptions.call(this, r, l);
              l = h.joinBy;
              h.mapData && h.mapMap && (l = a.prototype.getNestedProperty.call(r, l[1]), (l = "undefined" !== typeof l && h.mapMap[l]) ? (h.xyFromShape && (r.x = l._midX, r.y = l._midY), z(r, l)) : r.value = r.value || null);
              return r;
            };

            w.prototype.onMouseOver = function (r) {
              A.clearTimeout(this.colorInterval);
              if (null !== this.value || this.series.options.nullInteraction) a.prototype.onMouseOver.call(this, r);else this.series.onMouseOut(r);
            };

            w.prototype.zoomTo = function () {
              var a = this.series;
              a.xAxis.setExtremes(this._minX, this._maxX, !1);
              a.yAxis.setExtremes(this._minY, this._maxY, !1);
              a.chart.redraw();
            };

            return w;
          }(v.seriesTypes.scatter.prototype.pointClass);

          z(v.prototype, {
            dataLabelOnNull: a.dataLabelOnNull,
            isValid: a.isValid,
            moveToTopOnHover: a.moveToTopOnHover
          });
          return v;
        });
        I(a, "Series/Map/MapSeries.js", [a["Mixins/ColorMapSeries.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Chart/MapChart.js"], a["Series/Map/MapPoint.js"], a["Core/Color/Palette.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t, l, h) {
          var d = this && this.__extends || function () {
            var _a38 = function a(b, d) {
              _a38 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var c in b) {
                  b.hasOwnProperty(c) && (a[c] = b[c]);
                }
              };

              return _a38(b, d);
            };

            return function (b, d) {
              function c() {
                this.constructor = b;
              }

              _a38(b, d);

              b.prototype = null === d ? Object.create(d) : (c.prototype = d.prototype, new c());
            };
          }();

          a = a.colorMapSeriesMixin;
          var b = v.noop,
              g = y.maps,
              p = y.splitPath;
          y = t.seriesTypes;
          var k = y.column,
              r = y.scatter;
          y = h.extend;
          var G = h.fireEvent,
              f = h.getNestedProperty,
              B = h.isArray,
              x = h.isNumber,
              u = h.merge,
              E = h.objectEach,
              m = h.pick,
              q = h.splat;

          h = function (a) {
            function b() {
              var b = null !== a && a.apply(this, arguments) || this;
              b.baseTrans = void 0;
              b.chart = void 0;
              b.data = void 0;
              b.group = void 0;
              b.joinBy = void 0;
              b.options = void 0;
              b.points = void 0;
              b.transformGroup = void 0;
              return b;
            }

            d(b, a);

            b.prototype.animate = function (a) {
              var b = this.options.animation,
                  c = this.group,
                  d = this.xAxis,
                  e = this.yAxis,
                  f = d.pos,
                  g = e.pos;
              this.chart.renderer.isSVG && (!0 === b && (b = {
                duration: 1E3
              }), a ? c.attr({
                translateX: f + d.len / 2,
                translateY: g + e.len / 2,
                scaleX: .001,
                scaleY: .001
              }) : c.animate({
                translateX: f,
                translateY: g,
                scaleX: 1,
                scaleY: 1
              }, b));
            };

            b.prototype.animateDrilldown = function (a) {
              var b = this.chart.plotBox,
                  c = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],
                  d = c.bBox,
                  e = this.chart.options.drilldown.animation;
              a || (a = Math.min(d.width / b.width, d.height / b.height), c.shapeArgs = {
                scaleX: a,
                scaleY: a,
                translateX: d.x,
                translateY: d.y
              }, this.points.forEach(function (a) {
                a.graphic && a.graphic.attr(c.shapeArgs).animate({
                  scaleX: 1,
                  scaleY: 1,
                  translateX: 0,
                  translateY: 0
                }, e);
              }));
            };

            b.prototype.animateDrillupFrom = function (a) {
              k.prototype.animateDrillupFrom.call(this, a);
            };

            b.prototype.animateDrillupTo = function (a) {
              k.prototype.animateDrillupTo.call(this, a);
            };

            b.prototype.doFullTranslate = function () {
              return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;
            };

            b.prototype.drawMapDataLabels = function () {
              D.prototype.drawDataLabels.call(this);
              this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            };

            b.prototype.drawPoints = function () {
              var a = this,
                  b = a.xAxis,
                  c = a.yAxis,
                  d = a.group,
                  e = a.chart,
                  f = e.renderer,
                  g = this.baseTrans;
              a.transformGroup || (a.transformGroup = f.g().attr({
                scaleX: 1,
                scaleY: 1
              }).add(d), a.transformGroup.survive = !0);
              if (a.doFullTranslate()) e.hasRendered && !e.styledMode && a.points.forEach(function (b) {
                b.shapeArgs && (b.shapeArgs.fill = a.pointAttribs(b, b.state).fill);
              }), a.group = a.transformGroup, k.prototype.drawPoints.apply(a), a.group = d, a.points.forEach(function (b) {
                if (b.graphic) {
                  var c = "";
                  b.name && (c += "highcharts-name-" + b.name.replace(/ /g, "-").toLowerCase());
                  b.properties && b.properties["hc-key"] && (c += " highcharts-key-" + b.properties["hc-key"].toLowerCase());
                  c && b.graphic.addClass(c);
                  e.styledMode && b.graphic.css(a.pointAttribs(b, b.selected && "select" || void 0));
                }
              }), this.baseTrans = {
                originX: b.min - b.minPixelPadding / b.transA,
                originY: c.min - c.minPixelPadding / c.transA + (c.reversed ? 0 : c.len / c.transA),
                transAX: b.transA,
                transAY: c.transA
              }, this.transformGroup.animate({
                translateX: 0,
                translateY: 0,
                scaleX: 1,
                scaleY: 1
              });else {
                var h = b.transA / g.transAX;
                var l = c.transA / g.transAY;
                var p = b.toPixels(g.originX, !0);
                var q = c.toPixels(g.originY, !0);
                .99 < h && 1.01 > h && .99 < l && 1.01 > l && (l = h = 1, p = Math.round(p), q = Math.round(q));
                var u = this.transformGroup;

                if (e.renderer.globalAnimation) {
                  var r = u.attr("translateX");
                  var t = u.attr("translateY");
                  var w = u.attr("scaleX");
                  var v = u.attr("scaleY");
                  u.attr({
                    animator: 0
                  }).animate({
                    animator: 1
                  }, {
                    step: function step(a, b) {
                      u.attr({
                        translateX: r + (p - r) * b.pos,
                        translateY: t + (q - t) * b.pos,
                        scaleX: w + (h - w) * b.pos,
                        scaleY: v + (l - v) * b.pos
                      });
                    }
                  });
                } else u.attr({
                  translateX: p,
                  translateY: q,
                  scaleX: h,
                  scaleY: l
                });
              }
              e.styledMode || d.element.setAttribute("stroke-width", m(a.options[a.pointAttrToOptions && a.pointAttrToOptions["stroke-width"] || "borderWidth"], 1) / (h || 1));
              this.drawMapDataLabels();
            };

            b.prototype.getBox = function (a) {
              var b = Number.MAX_VALUE,
                  c = -b,
                  d = b,
                  e = -b,
                  f = b,
                  g = b,
                  h = this.xAxis,
                  k = this.yAxis,
                  n;
              (a || []).forEach(function (a) {
                if (a.path) {
                  "string" === typeof a.path ? a.path = p(a.path) : "M" === a.path[0] && (a.path = l.prototype.pathToSegments(a.path));
                  var h = a.path || [],
                      k = -b,
                      q = b,
                      u = -b,
                      r = b,
                      t = a.properties;
                  a._foundBox || (h.forEach(function (a) {
                    var b = a[a.length - 2];
                    a = a[a.length - 1];
                    "number" === typeof b && "number" === typeof a && (q = Math.min(q, b), k = Math.max(k, b), r = Math.min(r, a), u = Math.max(u, a));
                  }), a._midX = q + (k - q) * m(a.middleX, t && t["hc-middle-x"], .5), a._midY = r + (u - r) * m(a.middleY, t && t["hc-middle-y"], .5), a._maxX = k, a._minX = q, a._maxY = u, a._minY = r, a.labelrank = m(a.labelrank, (k - q) * (u - r)), a._foundBox = !0);
                  c = Math.max(c, a._maxX);
                  d = Math.min(d, a._minX);
                  e = Math.max(e, a._maxY);
                  f = Math.min(f, a._minY);
                  g = Math.min(a._maxX - a._minX, a._maxY - a._minY, g);
                  n = !0;
                }
              });
              n && (this.minY = Math.min(f, m(this.minY, b)), this.maxY = Math.max(e, m(this.maxY, -b)), this.minX = Math.min(d, m(this.minX, b)), this.maxX = Math.max(c, m(this.maxX, -b)), h && "undefined" === typeof h.options.minRange && (h.minRange = Math.min(5 * g, (this.maxX - this.minX) / 5, h.minRange || b)), k && "undefined" === typeof k.options.minRange && (k.minRange = Math.min(5 * g, (this.maxY - this.minY) / 5, k.minRange || b)));
            };

            b.prototype.getExtremes = function () {
              var a = D.prototype.getExtremes.call(this, this.valueData),
                  b = a.dataMin;
              a = a.dataMax;
              this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data);
              x(b) && (this.valueMin = b);
              x(a) && (this.valueMax = a);
              return {
                dataMin: this.minY,
                dataMax: this.maxY
              };
            };

            b.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            b.prototype.pointAttribs = function (a, b) {
              b = a.series.chart.styledMode ? this.colorAttribs(a) : k.prototype.pointAttribs.call(this, a, b);
              b["stroke-width"] = m(a.options[this.pointAttrToOptions && this.pointAttrToOptions["stroke-width"] || "borderWidth"], "inherit");
              return b;
            };

            b.prototype.render = function () {
              var a = this,
                  b = D.prototype.render;
              a.chart.renderer.isVML && 3E3 < a.data.length ? setTimeout(function () {
                b.call(a);
              }) : b.call(a);
            };

            b.prototype.setData = function (a, b, c, d) {
              var e = this.options,
                  h = this.chart.options.chart,
                  k = h && h.map,
                  l = e.mapData,
                  m = this.joinBy,
                  n = e.keys || this.pointArrayMap,
                  p = [],
                  q = {},
                  r = this.chart.mapTransforms;
              !l && k && (l = "string" === typeof k ? g[k] : k);
              a && a.forEach(function (b, c) {
                var d = 0;
                if (x(b)) a[c] = {
                  value: b
                };else if (B(b)) {
                  a[c] = {};
                  !e.keys && b.length > n.length && "string" === typeof b[0] && (a[c]["hc-key"] = b[0], ++d);

                  for (var f = 0; f < n.length; ++f, ++d) {
                    n[f] && "undefined" !== typeof b[d] && (0 < n[f].indexOf(".") ? z.prototype.setNestedProperty(a[c], b[d], n[f]) : a[c][n[f]] = b[d]);
                  }
                }
                m && "_i" === m[0] && (a[c]._i = c);
              });
              this.getBox(a);
              (this.chart.mapTransforms = r = h.mapTransforms || l && l["hc-transform"] || r) && E(r, function (a) {
                a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation));
              });

              if (l) {
                "FeatureCollection" === l.type && (this.mapTitle = l.title, l = v.geojson(l, this.type, this));
                this.mapData = l;
                this.mapMap = {};

                for (r = 0; r < l.length; r++) {
                  h = l[r], k = h.properties, h._i = r, m[0] && k && k[m[0]] && (h[m[0]] = k[m[0]]), q[h[m[0]]] = h;
                }

                this.mapMap = q;

                if (a && m[1]) {
                  var t = m[1];
                  a.forEach(function (a) {
                    a = f(t, a);
                    q[a] && p.push(q[a]);
                  });
                }

                if (e.allAreas) {
                  this.getBox(l);
                  a = a || [];

                  if (m[1]) {
                    var w = m[1];
                    a.forEach(function (a) {
                      p.push(f(w, a));
                    });
                  }

                  p = "|" + p.map(function (a) {
                    return a && a[m[0]];
                  }).join("|") + "|";
                  l.forEach(function (b) {
                    m[0] && -1 !== p.indexOf("|" + b[m[0]] + "|") || (a.push(u(b, {
                      value: null
                    })), d = !1);
                  });
                } else this.getBox(p);
              }

              D.prototype.setData.call(this, a, b, c, d);
            };

            b.prototype.setOptions = function (a) {
              a = D.prototype.setOptions.call(this, a);
              var b = a.joinBy;
              null === b && (b = "_i");
              b = this.joinBy = q(b);
              b[1] || (b[1] = b[0]);
              return a;
            };

            b.prototype.translate = function () {
              var a = this,
                  b = a.xAxis,
                  c = a.yAxis,
                  d = a.doFullTranslate();
              a.generatePoints();
              a.data.forEach(function (e) {
                x(e._midX) && x(e._midY) && (e.plotX = b.toPixels(e._midX, !0), e.plotY = c.toPixels(e._midY, !0));
                d && (e.shapeType = "path", e.shapeArgs = {
                  d: a.translatePath(e.path)
                });
              });
              G(a, "afterTranslate");
            };

            b.prototype.translatePath = function (a) {
              var b = this.xAxis,
                  c = this.yAxis,
                  d = b.min,
                  e = b.transA,
                  f = b.minPixelPadding,
                  g = c.min,
                  h = c.transA,
                  k = c.minPixelPadding,
                  l = [];
              a && a.forEach(function (a) {
                "M" === a[0] ? l.push(["M", (a[1] - (d || 0)) * e + f, (a[2] - (g || 0)) * h + k]) : "L" === a[0] ? l.push(["L", (a[1] - (d || 0)) * e + f, (a[2] - (g || 0)) * h + k]) : "C" === a[0] ? l.push(["C", (a[1] - (d || 0)) * e + f, (a[2] - (g || 0)) * h + k, (a[3] - (d || 0)) * e + f, (a[4] - (g || 0)) * h + k, (a[5] - (d || 0)) * e + f, (a[6] - (g || 0)) * h + k]) : "Q" === a[0] ? l.push(["Q", (a[1] - (d || 0)) * e + f, (a[2] - (g || 0)) * h + k, (a[3] - (d || 0)) * e + f, (a[4] - (g || 0)) * h + k]) : "Z" === a[0] && l.push(["Z"]);
              });
              return l;
            };

            b.defaultOptions = u(r.defaultOptions, {
              animation: !1,
              dataLabels: {
                crop: !1,
                formatter: function formatter() {
                  var a = this.series.chart.numberFormatter,
                      b = this.point.value;
                  return x(b) ? a(b, -1) : "";
                },
                inside: !0,
                overflow: !1,
                padding: 0,
                verticalAlign: "middle"
              },
              marker: null,
              nullColor: w.neutralColor3,
              stickyTracking: !1,
              tooltip: {
                followPointer: !0,
                pointFormat: "{point.name}: {point.value}<br/>"
              },
              turboThreshold: 0,
              allAreas: !0,
              borderColor: w.neutralColor20,
              borderWidth: 1,
              joinBy: "hc-key",
              states: {
                hover: {
                  halo: null,
                  brightness: .2
                },
                normal: {
                  animation: !0
                },
                select: {
                  color: w.neutralColor20
                },
                inactive: {
                  opacity: 1
                }
              }
            });
            return b;
          }(r);

          y(h.prototype, {
            type: "map",
            axisTypes: a.axisTypes,
            colorAttribs: a.colorAttribs,
            colorKey: a.colorKey,
            directTouch: !0,
            drawDataLabels: b,
            drawGraph: b,
            drawLegendSymbol: A.drawRectangle,
            forceDL: !0,
            getExtremesFromAll: !0,
            getSymbol: a.getSymbol,
            parallelArrays: a.parallelArrays,
            pointArrayMap: a.pointArrayMap,
            pointClass: z,
            preserveAspectRatio: !0,
            searchPoint: b,
            trackerGroups: a.trackerGroups,
            useMapGeometry: !0
          });
          t.registerSeriesType("map", h);
          "";
          return h;
        });
        I(a, "Series/MapLine/MapLineSeries.js", [a["Series/Map/MapSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = this && this.__extends || function () {
            var _a39 = function a(l, h) {
              _a39 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var d in b) {
                  b.hasOwnProperty(d) && (a[d] = b[d]);
                }
              };

              return _a39(l, h);
            };

            return function (l, h) {
              function d() {
                this.constructor = l;
              }

              _a39(l, h);

              l.prototype = null === h ? Object.create(h) : (d.prototype = h.prototype, new d());
            };
          }(),
              z = v.series,
              w = A.extend,
              D = A.merge;

          A = function (t) {
            function l() {
              var a = null !== t && t.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(l, t);

            l.prototype.pointAttribs = function (h, d) {
              h = a.prototype.pointAttribs.call(this, h, d);
              h.fill = this.options.fillColor;
              return h;
            };

            l.defaultOptions = D(a.defaultOptions, {
              lineWidth: 1,
              fillColor: "none"
            });
            return l;
          }(a);

          w(A.prototype, {
            type: "mapline",
            colorProp: "stroke",
            drawLegendSymbol: z.prototype.drawLegendSymbol,
            pointAttrToOptions: {
              stroke: "color",
              "stroke-width": "lineWidth"
            }
          });
          v.registerSeriesType("mapline", A);
          "";
          return A;
        });
        I(a, "Series/MapPoint/MapPointPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = this && this.__extends || function () {
            var _a40 = function a(r, v) {
              _a40 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, l) {
                a.__proto__ = l;
              } || function (a, l) {
                for (var h in l) {
                  l.hasOwnProperty(h) && (a[h] = l[h]);
                }
              };

              return _a40(r, v);
            };

            return function (r, v) {
              function t() {
                this.constructor = r;
              }

              _a40(r, v);

              r.prototype = null === v ? Object.create(v) : (t.prototype = v.prototype, new t());
            };
          }(),
              y = v.merge;

          return function (a) {
            function w() {
              var r = null !== a && a.apply(this, arguments) || this;
              r.options = void 0;
              r.series = void 0;
              return r;
            }

            r(w, a);

            w.prototype.applyOptions = function (r, t) {
              r = "undefined" !== typeof r.lat && "undefined" !== typeof r.lon ? y(r, this.series.chart.fromLatLonToPoint(r)) : r;
              return a.prototype.applyOptions.call(this, r, t);
            };

            return w;
          }(a.seriesTypes.scatter.prototype.pointClass);
        });
        I(a, "Series/MapPoint/MapPointSeries.js", [a["Series/MapPoint/MapPointPoint.js"], a["Core/Color/Palette.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = this && this.__extends || function () {
            var _a41 = function a(h, d) {
              _a41 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _a41(h, d);
            };

            return function (h, d) {
              function b() {
                this.constructor = h;
              }

              _a41(h, d);

              h.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              w = A.seriesTypes.scatter,
              D = y.extend,
              t = y.merge;

          y = function (a) {
            function h() {
              var d = null !== a && a.apply(this, arguments) || this;
              d.data = void 0;
              d.options = void 0;
              d.points = void 0;
              return d;
            }

            r(h, a);

            h.prototype.drawDataLabels = function () {
              a.prototype.drawDataLabels.call(this);
              this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
            };

            h.defaultOptions = t(w.defaultOptions, {
              dataLabels: {
                crop: !1,
                defer: !1,
                enabled: !0,
                formatter: function formatter() {
                  return this.point.name;
                },
                overflow: !1,
                style: {
                  color: v.neutralColor100
                }
              }
            });
            return h;
          }(w);

          D(y.prototype, {
            type: "mappoint",
            forceDL: !0,
            pointClass: a
          });
          A.registerSeriesType("mappoint", y);
          "";
          return y;
        });
        I(a, "Series/Bubble/BubbleLegendDefaults.js", [a["Core/Color/Palette.js"]], function (a) {
          return {
            borderColor: void 0,
            borderWidth: 2,
            className: void 0,
            color: void 0,
            connectorClassName: void 0,
            connectorColor: void 0,
            connectorDistance: 60,
            connectorWidth: 1,
            enabled: !1,
            labels: {
              className: void 0,
              allowOverlap: !1,
              format: "",
              formatter: void 0,
              align: "right",
              style: {
                fontSize: "10px",
                color: a.neutralColor100
              },
              x: 0,
              y: 0
            },
            maxSize: 60,
            minSize: 10,
            legendIndex: 0,
            ranges: {
              value: void 0,
              borderColor: void 0,
              color: void 0,
              connectorColor: void 0
            },
            sizeBy: "area",
            sizeByAbsoluteValue: !1,
            zIndex: 1,
            zThreshold: 0
          };
        });
        I(a, "Series/Bubble/BubbleLegendItem.js", [a["Core/Color/Color.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = a.parse,
              w = A.noop,
              D = y.arrayMax,
              t = y.arrayMin,
              l = y.isNumber,
              h = y.merge,
              d = y.pick,
              b = y.stableSort;
          "";
          return function () {
            function a(a, b) {
              this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;
              this.setState = w;
              this.init(a, b);
            }

            a.prototype.init = function (a, b) {
              this.options = a;
              this.visible = !0;
              this.chart = b.chart;
              this.legend = b;
            };

            a.prototype.addToLegend = function (a) {
              a.splice(this.options.legendIndex, 0, this);
            };

            a.prototype.drawLegendSymbol = function (a) {
              var g = this.chart,
                  h = this.options,
                  p = d(a.options.itemDistance, 20),
                  f = h.ranges,
                  r = h.connectorDistance;
              this.fontMetrics = g.renderer.fontMetrics(h.labels.style.fontSize);
              f && f.length && l(f[0].value) ? (b(f, function (a, b) {
                return b.value - a.value;
              }), this.ranges = f, this.setOptions(), this.render(), a = this.getMaxLabelSize(), f = this.ranges[0].radius, g = 2 * f, r = r - f + a.width, r = 0 < r ? r : 0, this.maxLabel = a, this.movementX = "left" === h.labels.align ? r : 0, this.legendItemWidth = g + r + p, this.legendItemHeight = g + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;
            };

            a.prototype.setOptions = function () {
              var a = this.ranges,
                  b = this.options,
                  g = this.chart.series[b.seriesIndex],
                  l = this.legend.baseline,
                  f = {
                zIndex: b.zIndex,
                "stroke-width": b.borderWidth
              },
                  t = {
                zIndex: b.zIndex,
                "stroke-width": b.connectorWidth
              },
                  w = {
                align: this.legend.options.rtl || "left" === b.labels.align ? "right" : "left",
                zIndex: b.zIndex
              },
                  u = g.options.marker.fillOpacity,
                  v = this.chart.styledMode;
              a.forEach(function (k, p) {
                v || (f.stroke = d(k.borderColor, b.borderColor, g.color), f.fill = d(k.color, b.color, 1 !== u ? r(g.color).setOpacity(u).get("rgba") : g.color), t.stroke = d(k.connectorColor, b.connectorColor, g.color));
                a[p].radius = this.getRangeRadius(k.value);
                a[p] = h(a[p], {
                  center: a[0].radius - a[p].radius + l
                });
                v || h(!0, a[p], {
                  bubbleAttribs: h(f),
                  connectorAttribs: h(t),
                  labelAttribs: w
                });
              }, this);
            };

            a.prototype.getRangeRadius = function (a) {
              var b = this.options;
              return this.chart.series[this.options.seriesIndex].getRadius.call(this, b.ranges[b.ranges.length - 1].value, b.ranges[0].value, b.minSize, b.maxSize, a);
            };

            a.prototype.render = function () {
              var a = this.chart.renderer,
                  b = this.options.zThreshold;
              this.symbols || (this.symbols = {
                connectors: [],
                bubbleItems: [],
                labels: []
              });
              this.legendSymbol = a.g("bubble-legend");
              this.legendItem = a.g("bubble-legend-item");
              this.legendSymbol.translateX = 0;
              this.legendSymbol.translateY = 0;
              this.ranges.forEach(function (a) {
                a.value >= b && this.renderRange(a);
              }, this);
              this.legendSymbol.add(this.legendItem);
              this.legendItem.add(this.legendGroup);
              this.hideOverlappingLabels();
            };

            a.prototype.renderRange = function (a) {
              var b = this.options,
                  d = b.labels,
                  g = this.chart,
                  f = g.series[b.seriesIndex],
                  h = g.renderer,
                  l = this.symbols;
              g = l.labels;
              var p = a.center,
                  r = Math.abs(a.radius),
                  m = b.connectorDistance || 0,
                  q = d.align,
                  e = b.connectorWidth,
                  c = this.ranges[0].radius || 0,
                  n = p - r - b.borderWidth / 2 + e / 2,
                  t = this.fontMetrics;
              t = t.f / 2 - (t.h - t.f) / 2;
              var w = h.styledMode;
              m = this.legend.options.rtl || "left" === q ? -m : m;
              "center" === q && (m = 0, b.connectorDistance = 0, a.labelAttribs.align = "center");
              q = n + b.labels.y;
              var v = c + m + b.labels.x;
              l.bubbleItems.push(h.circle(c, p + ((n % 1 ? 1 : .5) - (e % 2 ? 0 : .5)), r).attr(w ? {} : a.bubbleAttribs).addClass((w ? "highcharts-color-" + f.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (b.className || "")).add(this.legendSymbol));
              l.connectors.push(h.path(h.crispLine([["M", c, n], ["L", c + m, n]], b.connectorWidth)).attr(w ? {} : a.connectorAttribs).addClass((w ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (b.connectorClassName || "")).add(this.legendSymbol));
              a = h.text(this.formatLabel(a), v, q + t).attr(w ? {} : a.labelAttribs).css(w ? {} : d.style).addClass("highcharts-bubble-legend-labels " + (b.labels.className || "")).add(this.legendSymbol);
              g.push(a);
              a.placed = !0;
              a.alignAttr = {
                x: v,
                y: q + t
              };
            };

            a.prototype.getMaxLabelSize = function () {
              var a, b;
              this.symbols.labels.forEach(function (d) {
                b = d.getBBox(!0);
                a = a ? b.width > a.width ? b : a : b;
              });
              return a || {};
            };

            a.prototype.formatLabel = function (a) {
              var b = this.options,
                  d = b.labels.formatter;
              b = b.labels.format;
              var g = this.chart.numberFormatter;
              return b ? v.format(b, a) : d ? d.call(a) : g(a.value, 1);
            };

            a.prototype.hideOverlappingLabels = function () {
              var a = this.chart,
                  b = this.symbols;
              !this.options.labels.allowOverlap && b && (a.hideOverlappingLabels(b.labels), b.labels.forEach(function (a, d) {
                a.newOpacity ? a.newOpacity !== a.oldOpacity && b.connectors[d].show() : b.connectors[d].hide();
              }));
            };

            a.prototype.getRanges = function () {
              var a = this.legend.bubbleLegend,
                  b = a.options.ranges,
                  g,
                  r = Number.MAX_VALUE,
                  f = -Number.MAX_VALUE;
              a.chart.series.forEach(function (a) {
                a.isBubble && !a.ignoreSeries && (g = a.zData.filter(l), g.length && (r = d(a.options.zMin, Math.min(r, Math.max(t(g), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), f = d(a.options.zMax, Math.max(f, D(g)))));
              });
              var w = r === f ? [{
                value: f
              }] : [{
                value: r
              }, {
                value: (r + f) / 2
              }, {
                value: f,
                autoRanges: !0
              }];
              b.length && b[0].radius && w.reverse();
              w.forEach(function (a, d) {
                b && b[d] && (w[d] = h(b[d], a));
              });
              return w;
            };

            a.prototype.predictBubbleSizes = function () {
              var a = this.chart,
                  b = this.fontMetrics,
                  d = a.legend.options,
                  g = "horizontal" === d.layout,
                  f = g ? a.legend.lastLineHeight : 0,
                  h = a.plotSizeX,
                  l = a.plotSizeY,
                  r = a.series[this.options.seriesIndex];
              a = Math.ceil(r.minPxSize);
              var t = Math.ceil(r.maxPxSize),
                  m = Math.min(l, h);
              r = r.options.maxSize;
              if (d.floating || !/%$/.test(r)) b = t;else if (r = parseFloat(r), b = (m + f - b.h / 2) * r / 100 / (r / 100 + 1), g && l - b >= h || !g && h - b >= l) b = t;
              return [a, Math.ceil(b)];
            };

            a.prototype.updateRanges = function (a, b) {
              var d = this.legend.options.bubbleLegend;
              d.minSize = a;
              d.maxSize = b;
              d.ranges = this.getRanges();
            };

            a.prototype.correctSizes = function () {
              var a = this.legend,
                  b = this.chart.series[this.options.seriesIndex];
              1 < Math.abs(Math.ceil(b.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, b.maxPxSize), a.render());
            };

            return a;
          }();
        });
        I(a, "Series/Bubble/BubbleLegendComposition.js", [a["Series/Bubble/BubbleLegendDefaults.js"], a["Series/Bubble/BubbleLegendItem.js"], a["Core/DefaultOptions.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          var r = A.setOptions,
              w = y.addEvent,
              D = y.objectEach,
              t = y.wrap,
              l;

          (function (h) {
            function d(a, d, h) {
              var f = this.legend,
                  k = 0 <= b(this);

              if (f && f.options.enabled && f.bubbleLegend && f.options.bubbleLegend.autoRanges && k) {
                var l = f.bubbleLegend.options;
                k = f.bubbleLegend.predictBubbleSizes();
                f.bubbleLegend.updateRanges(k[0], k[1]);
                l.placed || (f.group.placed = !1, f.allItems.forEach(function (a) {
                  a.legendGroup.translateY = null;
                }));
                f.render();
                this.getMargins();
                this.axes.forEach(function (a) {
                  a.visible && a.render();
                  l.placed || (a.setScale(), a.updateNames(), D(a.ticks, function (a) {
                    a.isNew = !0;
                    a.isNewLabel = !0;
                  }));
                });
                l.placed = !0;
                this.getMargins();
                a.call(this, d, h);
                f.bubbleLegend.correctSizes();
                z(f, g(f));
              } else a.call(this, d, h), f && f.options.enabled && f.bubbleLegend && (f.render(), z(f, g(f)));
            }

            function b(a) {
              a = a.series;

              for (var b = 0; b < a.length;) {
                if (a[b] && a[b].isBubble && a[b].visible && a[b].zData.length) return b;
                b++;
              }

              return -1;
            }

            function g(a) {
              a = a.allItems;
              var b = [],
                  d = a.length,
                  f,
                  g = 0;

              for (f = 0; f < d; f++) {
                if (a[f].legendItemHeight && (a[f].itemHeight = a[f].legendItemHeight), a[f] === a[d - 1] || a[f + 1] && a[f]._legendItemPos[1] !== a[f + 1]._legendItemPos[1]) {
                  b.push({
                    height: 0
                  });
                  var h = b[b.length - 1];

                  for (g; g <= f; g++) {
                    a[g].itemHeight > h.height && (h.height = a[g].itemHeight);
                  }

                  h.step = f;
                }
              }

              return b;
            }

            function l(a) {
              var d = this.bubbleLegend,
                  f = this.options,
                  g = f.bubbleLegend,
                  h = b(this.chart);
              d && d.ranges && d.ranges.length && (g.ranges.length && (g.autoRanges = !!g.ranges[0].autoRanges), this.destroyItem(d));
              0 <= h && f.enabled && g.enabled && (g.seriesIndex = h, this.bubbleLegend = new v(g, this), this.bubbleLegend.addToLegend(a.allItems));
            }

            function k() {
              var a = this.chart,
                  d = this.visible,
                  g = this.chart.legend;
              g && g.bubbleLegend && (this.visible = !d, this.ignoreSeries = d, a = 0 <= b(a), g.bubbleLegend.visible !== a && (g.update({
                bubbleLegend: {
                  enabled: a
                }
              }), g.bubbleLegend.visible = a), this.visible = d);
            }

            function z(a, b) {
              var d = a.options.rtl,
                  f,
                  g,
                  h,
                  k = 0;
              a.allItems.forEach(function (a, c) {
                f = a.legendGroup.translateX;
                g = a._legendItemPos[1];
                if ((h = a.movementX) || d && a.ranges) h = d ? f - a.options.maxSize / 2 : f + h, a.legendGroup.attr({
                  translateX: h
                });
                c > b[k].step && k++;
                a.legendGroup.attr({
                  translateY: Math.round(g + b[k].height / 2)
                });
                a._legendItemPos[1] = g + b[k].height / 2;
              });
            }

            var y = [];

            h.compose = function (b, g, h) {
              -1 === y.indexOf(b) && (y.push(b), r({
                legend: {
                  bubbleLegend: a
                }
              }), t(b.prototype, "drawChartBox", d));
              -1 === y.indexOf(g) && (y.push(g), w(g, "afterGetAllItems", l));
              -1 === y.indexOf(h) && (y.push(h), w(h, "legendItemClick", k));
            };
          })(l || (l = {}));

          return l;
        });
        I(a, "Series/Bubble/BubblePoint.js", [a["Core/Series/Point.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = this && this.__extends || function () {
            var _a42 = function a(r, v) {
              _a42 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, l) {
                a.__proto__ = l;
              } || function (a, l) {
                for (var h in l) {
                  l.hasOwnProperty(h) && (a[h] = l[h]);
                }
              };

              return _a42(r, v);
            };

            return function (r, v) {
              function t() {
                this.constructor = r;
              }

              _a42(r, v);

              r.prototype = null === v ? Object.create(v) : (t.prototype = v.prototype, new t());
            };
          }();

          A = A.extend;

          v = function (v) {
            function w() {
              var a = null !== v && v.apply(this, arguments) || this;
              a.options = void 0;
              a.series = void 0;
              return a;
            }

            r(w, v);

            w.prototype.haloPath = function (r) {
              return a.prototype.haloPath.call(this, 0 === r ? 0 : (this.marker ? this.marker.radius || 0 : 0) + r);
            };

            return w;
          }(v.seriesTypes.scatter.prototype.pointClass);

          A(v.prototype, {
            ttBelow: !1
          });
          return v;
        });
        I(a, "Series/Bubble/BubbleSeries.js", [a["Core/Axis/Axis.js"], a["Series/Bubble/BubbleLegendComposition.js"], a["Series/Bubble/BubblePoint.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t) {
          var l = this && this.__extends || function () {
            var _a43 = function a(b, d) {
              _a43 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var c in b) {
                  b.hasOwnProperty(c) && (a[c] = b[c]);
                }
              };

              return _a43(b, d);
            };

            return function (b, d) {
              function f() {
                this.constructor = b;
              }

              _a43(b, d);

              b.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
            };
          }(),
              h = y.parse;

          y = z.noop;
          var d = D.seriesTypes;
          z = d.column;
          var b = d.scatter,
              g = t.arrayMax,
              p = t.arrayMin,
              k = t.clamp,
              r = t.extend,
              G = t.isNumber,
              f = t.merge,
              B = t.pick,
              x = t.pInt;

          t = function (a) {
            function d() {
              var b = null !== a && a.apply(this, arguments) || this;
              b.data = void 0;
              b.maxPxSize = void 0;
              b.minPxSize = void 0;
              b.options = void 0;
              b.points = void 0;
              b.radii = void 0;
              b.yData = void 0;
              b.zData = void 0;
              return b;
            }

            l(d, a);

            d.prototype.animate = function (a) {
              !a && this.points.length < this.options.animationLimit && this.points.forEach(function (a) {
                var b = a.graphic;
                b && b.width && (this.hasRendered || b.attr({
                  x: a.plotX,
                  y: a.plotY,
                  width: 1,
                  height: 1
                }), b.animate(this.markerAttribs(a), this.options.animation));
              }, this);
            };

            d.prototype.getRadii = function (a, b, d) {
              var c = this.zData,
                  e = this.yData,
                  f = d.minPxSize,
                  g = d.maxPxSize,
                  h = [];
              var k = 0;

              for (d = c.length; k < d; k++) {
                var l = c[k];
                h.push(this.getRadius(a, b, f, g, l, e[k]));
              }

              this.radii = h;
            };

            d.prototype.getRadius = function (a, b, d, c, f, g) {
              var e = this.options,
                  h = "width" !== e.sizeBy,
                  k = e.zThreshold,
                  l = b - a,
                  m = .5;
              if (null === g || null === f) return null;

              if (G(f)) {
                e.sizeByAbsoluteValue && (f = Math.abs(f - k), l = Math.max(b - k, Math.abs(a - k)), a = 0);
                if (f < a) return d / 2 - 1;
                0 < l && (m = (f - a) / l);
              }

              h && 0 <= m && (m = Math.sqrt(m));
              return Math.ceil(d + m * (c - d)) / 2;
            };

            d.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            d.prototype.pointAttribs = function (a, b) {
              var d = this.options.marker.fillOpacity;
              a = w.prototype.pointAttribs.call(this, a, b);
              1 !== d && (a.fill = h(a.fill).setOpacity(d).get("rgba"));
              return a;
            };

            d.prototype.translate = function () {
              var b,
                  d = this.data,
                  e = this.radii;
              a.prototype.translate.call(this);

              for (b = d.length; b--;) {
                var c = d[b];
                var f = e ? e[b] : 0;
                G(f) && f >= this.minPxSize / 2 ? (c.marker = r(c.marker, {
                  radius: f,
                  width: 2 * f,
                  height: 2 * f
                }), c.dlBox = {
                  x: c.plotX - f,
                  y: c.plotY - f,
                  width: 2 * f,
                  height: 2 * f
                }) : c.shapeArgs = c.plotY = c.dlBox = void 0;
              }
            };

            d.compose = v.compose;
            d.defaultOptions = f(b.defaultOptions, {
              dataLabels: {
                formatter: function formatter() {
                  var a = this.series.chart.numberFormatter,
                      b = this.point.z;
                  return G(b) ? a(b, -1) : "";
                },
                inside: !0,
                verticalAlign: "middle"
              },
              animationLimit: 250,
              marker: {
                lineColor: null,
                lineWidth: 1,
                fillOpacity: .5,
                radius: null,
                states: {
                  hover: {
                    radiusPlus: 0
                  }
                },
                symbol: "circle"
              },
              minSize: 8,
              maxSize: "20%",
              softThreshold: !1,
              states: {
                hover: {
                  halo: {
                    size: 5
                  }
                }
              },
              tooltip: {
                pointFormat: "({point.x}, {point.y}), Size: {point.z}"
              },
              turboThreshold: 0,
              zThreshold: 0,
              zoneAxis: "z"
            });
            return d;
          }(b);

          r(t.prototype, {
            alignDataLabel: z.prototype.alignDataLabel,
            applyZones: y,
            bubblePadding: !0,
            buildKDTree: y,
            directTouch: !0,
            isBubble: !0,
            pointArrayMap: ["y", "z"],
            pointClass: A,
            parallelArrays: ["x", "y", "z"],
            trackerGroups: ["group", "dataLabelsGroup"],
            specialGroup: "group",
            zoneAxis: "z"
          });

          a.prototype.beforePadding = function () {
            var a = this,
                b = this.len,
                d = this.chart,
                f = 0,
                e = b,
                c = this.isXAxis,
                h = c ? "xData" : "yData",
                l = this.min,
                r = {},
                t = Math.min(d.plotWidth, d.plotHeight),
                v = Number.MAX_VALUE,
                w = -Number.MAX_VALUE,
                y = this.max - l,
                z = b / y,
                A = [];
            this.series.forEach(function (b) {
              var e = b.options;
              !b.bubblePadding || !b.visible && d.options.chart.ignoreHiddenSeries || (a.allowZoomOutside = !0, A.push(b), c && (["minSize", "maxSize"].forEach(function (a) {
                var b = e[a],
                    c = /%$/.test(b);
                b = x(b);
                r[a] = c ? t * b / 100 : b;
              }), b.minPxSize = r.minSize, b.maxPxSize = Math.max(r.maxSize, r.minSize), b = b.zData.filter(G), b.length && (v = B(e.zMin, k(p(b), !1 === e.displayNegative ? e.zThreshold : -Number.MAX_VALUE, v)), w = B(e.zMax, Math.max(w, g(b))))));
            });
            A.forEach(function (b) {
              var d = b[h],
                  g = d.length;
              c && b.getRadii(v, w, b);
              if (0 < y) for (; g--;) {
                if (G(d[g]) && a.dataMin <= d[g] && d[g] <= a.max) {
                  var k = b.radii ? b.radii[g] : 0;
                  f = Math.min((d[g] - l) * z - k, f);
                  e = Math.max((d[g] - l) * z + k, e);
                }
              }
            });
            A.length && 0 < y && !this.logarithmic && (e -= b, z *= (b + Math.max(0, f) - Math.min(e, b)) / b, [["min", "userMin", f], ["max", "userMax", e]].forEach(function (b) {
              "undefined" === typeof B(a.options[b[0]], a[b[1]]) && (a[b[0]] += b[2] / z);
            }));
          };

          D.registerSeriesType("bubble", t);
          "";
          "";
          return t;
        });
        I(a, "Series/MapBubble/MapBubblePoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v) {
          var r = this && this.__extends || function () {
            var _a44 = function a(r, l) {
              _a44 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _a44(r, l);
            };

            return function (r, l) {
              function h() {
                this.constructor = r;
              }

              _a44(r, l);

              r.prototype = null === l ? Object.create(l) : (h.prototype = l.prototype, new h());
            };
          }(),
              y = a.seriesTypes,
              z = y.map;

          a = v.extend;
          var w = v.merge;

          v = function (a) {
            function t() {
              return null !== a && a.apply(this, arguments) || this;
            }

            r(t, a);

            t.prototype.applyOptions = function (l, h) {
              return l && "undefined" !== typeof l.lat && "undefined" !== typeof l.lon ? a.prototype.applyOptions.call(this, w(l, this.series.chart.fromLatLonToPoint(l)), h) : z.prototype.pointClass.prototype.applyOptions.call(this, l, h);
            };

            t.prototype.isValid = function () {
              return "number" === typeof this.z;
            };

            return t;
          }(y.bubble.prototype.pointClass);

          a(v.prototype, {
            ttBelow: !1
          });
          return v;
        });
        I(a, "Series/MapBubble/MapBubbleSeries.js", [a["Series/Bubble/BubbleSeries.js"], a["Series/MapBubble/MapBubblePoint.js"], a["Series/Map/MapSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A, y, z) {
          var r = this && this.__extends || function () {
            var _a45 = function a(h, d) {
              _a45 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, d) {
                a.__proto__ = d;
              } || function (a, d) {
                for (var b in d) {
                  d.hasOwnProperty(b) && (a[b] = d[b]);
                }
              };

              return _a45(h, d);
            };

            return function (h, d) {
              function b() {
                this.constructor = h;
              }

              _a45(h, d);

              h.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
            };
          }(),
              D = z.extend,
              t = z.merge;

          z = function (l) {
            function h() {
              var a = null !== l && l.apply(this, arguments) || this;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              return a;
            }

            r(h, l);
            h.compose = a.compose;
            h.defaultOptions = t(a.defaultOptions, {
              animationLimit: 500,
              tooltip: {
                pointFormat: "{point.name}: {point.z}"
              }
            });
            return h;
          }(a);

          D(z.prototype, {
            type: "mapbubble",
            getBox: A.prototype.getBox,
            pointArrayMap: ["z"],
            pointClass: v,
            setData: A.prototype.setData,
            setOptions: A.prototype.setOptions,
            xyFromShape: !0
          });
          y.registerSeriesType("mapbubble", z);
          "";
          return z;
        });
        I(a, "Series/Heatmap/HeatmapPoint.js", [a["Mixins/ColorMapSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function (a, v, A) {
          var r = this && this.__extends || function () {
            var _a46 = function a(l, h) {
              _a46 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var d in b) {
                  b.hasOwnProperty(d) && (a[d] = b[d]);
                }
              };

              return _a46(l, h);
            };

            return function (l, h) {
              function d() {
                this.constructor = l;
              }

              _a46(l, h);

              l.prototype = null === h ? Object.create(h) : (d.prototype = h.prototype, new d());
            };
          }();

          a = a.colorMapPointMixin;
          var z = A.clamp,
              w = A.extend,
              D = A.pick;

          v = function (a) {
            function l() {
              var h = null !== a && a.apply(this, arguments) || this;
              h.options = void 0;
              h.series = void 0;
              h.value = void 0;
              h.x = void 0;
              h.y = void 0;
              return h;
            }

            r(l, a);

            l.prototype.applyOptions = function (h, d) {
              h = a.prototype.applyOptions.call(this, h, d);
              h.formatPrefix = h.isNull || null === h.value ? "null" : "point";
              return h;
            };

            l.prototype.getCellAttributes = function () {
              var a = this.series,
                  d = a.options,
                  b = (d.colsize || 1) / 2,
                  g = (d.rowsize || 1) / 2,
                  l = a.xAxis,
                  k = a.yAxis,
                  r = this.options.marker || a.options.marker;
              a = a.pointPlacementToXValue();
              var t = D(this.pointPadding, d.pointPadding, 0),
                  f = {
                x1: z(Math.round(l.len - (l.translate(this.x - b, !1, !0, !1, !0, -a) || 0)), -l.len, 2 * l.len),
                x2: z(Math.round(l.len - (l.translate(this.x + b, !1, !0, !1, !0, -a) || 0)), -l.len, 2 * l.len),
                y1: z(Math.round(k.translate(this.y - g, !1, !0, !1, !0) || 0), -k.len, 2 * k.len),
                y2: z(Math.round(k.translate(this.y + g, !1, !0, !1, !0) || 0), -k.len, 2 * k.len)
              };
              [["width", "x"], ["height", "y"]].forEach(function (a) {
                var b = a[0];
                a = a[1];
                var d = a + "1",
                    g = a + "2",
                    h = Math.abs(f[d] - f[g]),
                    k = r && r.lineWidth || 0,
                    e = Math.abs(f[d] + f[g]) / 2;
                r[b] && r[b] < h && (f[d] = e - r[b] / 2 - k / 2, f[g] = e + r[b] / 2 + k / 2);
                t && ("y" === a && (d = g, g = a + "1"), f[d] += t, f[g] -= t);
              });
              return f;
            };

            l.prototype.haloPath = function (a) {
              if (!a) return [];
              var d = this.shapeArgs;
              return ["M", d.x - a, d.y - a, "L", d.x - a, d.y + d.height + a, d.x + d.width + a, d.y + d.height + a, d.x + d.width + a, d.y - a, "Z"];
            };

            l.prototype.isValid = function () {
              return Infinity !== this.value && -Infinity !== this.value;
            };

            return l;
          }(v.seriesTypes.scatter.prototype.pointClass);

          w(v.prototype, {
            dataLabelOnNull: a.dataLabelOnNull,
            moveToTopOnHover: a.moveToTopOnHover
          });
          return v;
        });
        I(a, "Series/Heatmap/HeatmapSeries.js", [a["Core/Color/Color.js"], a["Mixins/ColorMapSeries.js"], a["Series/Heatmap/HeatmapPoint.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Color/Palette.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function (a, v, A, y, z, w, D, t) {
          var l = this && this.__extends || function () {
            var _a47 = function a(b, d) {
              _a47 = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (a, b) {
                a.__proto__ = b;
              } || function (a, b) {
                for (var d in b) {
                  b.hasOwnProperty(d) && (a[d] = b[d]);
                }
              };

              return _a47(b, d);
            };

            return function (b, d) {
              function f() {
                this.constructor = b;
              }

              _a47(b, d);

              b.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());
            };
          }();

          v = v.colorMapSeriesMixin;
          var h = w.series,
              d = w.seriesTypes,
              b = d.column,
              g = d.scatter,
              p = D.prototype.symbols,
              k = t.extend,
              r = t.fireEvent,
              G = t.isNumber,
              f = t.merge,
              B = t.pick;

          D = function (b) {
            function d() {
              var a = null !== b && b.apply(this, arguments) || this;
              a.colorAxis = void 0;
              a.data = void 0;
              a.options = void 0;
              a.points = void 0;
              a.valueMax = NaN;
              a.valueMin = NaN;
              return a;
            }

            l(d, b);

            d.prototype.drawPoints = function () {
              var a = this;
              if ((this.options.marker || {}).enabled || this._hasPointMarkers) h.prototype.drawPoints.call(this), this.points.forEach(function (b) {
                b.graphic && (b.graphic[a.chart.styledMode ? "css" : "animate"](a.colorAttribs(b)), a.options.borderRadius && b.graphic.attr({
                  r: a.options.borderRadius
                }), null === b.value && b.graphic.addClass("highcharts-null-point"));
              });
            };

            d.prototype.getExtremes = function () {
              var a = h.prototype.getExtremes.call(this, this.valueData),
                  b = a.dataMin;
              a = a.dataMax;
              G(b) && (this.valueMin = b);
              G(a) && (this.valueMax = a);
              return h.prototype.getExtremes.call(this);
            };

            d.prototype.getValidPoints = function (a, b) {
              return h.prototype.getValidPoints.call(this, a, b, !0);
            };

            d.prototype.hasData = function () {
              return !!this.processedXData.length;
            };

            d.prototype.init = function () {
              h.prototype.init.apply(this, arguments);
              var a = this.options;
              a.pointRange = B(a.pointRange, a.colsize || 1);
              this.yAxis.axisPointRange = a.rowsize || 1;
              p.ellipse = p.circle;
            };

            d.prototype.markerAttribs = function (a, b) {
              var d = a.marker || {},
                  e = this.options.marker || {},
                  c = a.shapeArgs || {},
                  f = {};
              if (a.hasImage) return {
                x: a.plotX,
                y: a.plotY
              };

              if (b) {
                var g = e.states[b] || {};
                var h = d.states && d.states[b] || {};
                [["width", "x"], ["height", "y"]].forEach(function (a) {
                  f[a[0]] = (h[a[0]] || g[a[0]] || c[a[0]]) + (h[a[0] + "Plus"] || g[a[0] + "Plus"] || 0);
                  f[a[1]] = c[a[1]] + (c[a[0]] - f[a[0]]) / 2;
                });
              }

              return b ? f : c;
            };

            d.prototype.pointAttribs = function (b, d) {
              var g = h.prototype.pointAttribs.call(this, b, d),
                  e = this.options || {},
                  c = this.chart.options.plotOptions || {},
                  k = c.series || {},
                  l = c.heatmap || {};
              c = b && b.options.borderColor || e.borderColor || l.borderColor || k.borderColor;
              k = b && b.options.borderWidth || e.borderWidth || l.borderWidth || k.borderWidth || g["stroke-width"];
              g.stroke = b && b.marker && b.marker.lineColor || e.marker && e.marker.lineColor || c || this.color;
              g["stroke-width"] = k;
              d && (b = f(e.states[d], e.marker && e.marker.states[d], b && b.options.states && b.options.states[d] || {}), d = b.brightness, g.fill = b.color || a.parse(g.fill).brighten(d || 0).get(), g.stroke = b.lineColor);
              return g;
            };

            d.prototype.setClip = function (a) {
              var b = this.chart;
              h.prototype.setClip.apply(this, arguments);
              (!1 !== this.options.clip || a) && this.markerGroup.clip((a || this.clipBox) && this.sharedClipKey ? b.sharedClips[this.sharedClipKey] : b.clipRect);
            };

            d.prototype.translate = function () {
              var a = this.options,
                  b = a.marker && a.marker.symbol || "rect",
                  d = p[b] ? b : "rect",
                  e = -1 !== ["circle", "square"].indexOf(d);
              this.generatePoints();
              this.points.forEach(function (a) {
                var c = a.getCellAttributes(),
                    g = {};
                g.x = Math.min(c.x1, c.x2);
                g.y = Math.min(c.y1, c.y2);
                g.width = Math.max(Math.abs(c.x2 - c.x1), 0);
                g.height = Math.max(Math.abs(c.y2 - c.y1), 0);
                var h = a.hasImage = 0 === (a.marker && a.marker.symbol || b || "").indexOf("url");

                if (e) {
                  var l = Math.abs(g.width - g.height);
                  g.x = Math.min(c.x1, c.x2) + (g.width < g.height ? 0 : l / 2);
                  g.y = Math.min(c.y1, c.y2) + (g.width < g.height ? l / 2 : 0);
                  g.width = g.height = Math.min(g.width, g.height);
                }

                l = {
                  plotX: (c.x1 + c.x2) / 2,
                  plotY: (c.y1 + c.y2) / 2,
                  clientX: (c.x1 + c.x2) / 2,
                  shapeType: "path",
                  shapeArgs: f(!0, g, {
                    d: p[d](g.x, g.y, g.width, g.height)
                  })
                };
                h && (a.marker = {
                  width: g.width,
                  height: g.height
                });
                k(a, l);
              });
              r(this, "afterTranslate");
            };

            d.defaultOptions = f(g.defaultOptions, {
              animation: !1,
              borderRadius: 0,
              borderWidth: 0,
              nullColor: z.neutralColor3,
              dataLabels: {
                formatter: function formatter() {
                  var a = this.series.chart.numberFormatter,
                      b = this.point.value;
                  return G(b) ? a(b, -1) : "";
                },
                inside: !0,
                verticalAlign: "middle",
                crop: !1,
                overflow: !1,
                padding: 0
              },
              marker: {
                symbol: "rect",
                radius: 0,
                lineColor: void 0,
                states: {
                  hover: {
                    lineWidthPlus: 0
                  },
                  select: {}
                }
              },
              clip: !0,
              pointRange: null,
              tooltip: {
                pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
              },
              states: {
                hover: {
                  halo: !1,
                  brightness: .2
                }
              }
            });
            return d;
          }(g);

          k(D.prototype, {
            alignDataLabel: b.prototype.alignDataLabel,
            axisTypes: v.axisTypes,
            colorAttribs: v.colorAttribs,
            colorKey: v.colorKey,
            directTouch: !0,
            drawLegendSymbol: y.drawRectangle,
            getExtremesFromAll: !0,
            getSymbol: h.prototype.getSymbol,
            parallelArrays: v.parallelArrays,
            pointArrayMap: ["y", "value"],
            pointClass: A,
            trackerGroups: v.trackerGroups
          });
          w.registerSeriesType("heatmap", D);
          "";
          "";
          return D;
        });
        I(a, "Extensions/GeoJSON.js", [a["Core/Chart/Chart.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, v, A, y) {
          function r(a, b) {
            var d,
                h = !1,
                k = a.x,
                l = a.y;
            a = 0;

            for (d = b.length - 1; a < b.length; d = a++) {
              var r = b[a][1] > l;
              var f = b[d][1] > l;
              r !== f && k < (b[d][0] - b[a][0]) * (l - b[a][1]) / (b[d][1] - b[a][1]) + b[a][0] && (h = !h);
            }

            return h;
          }

          var w = v.format,
              D = A.win,
              t = y.error,
              l = y.extend,
              h = y.merge;
          v = y.wrap;
          "";

          a.prototype.transformFromLatLon = function (a, b) {
            var d = this.userOptions.chart && this.userOptions.chart.proj4 || D.proj4;
            if (!d) return t(21, !1, this), {
              x: 0,
              y: null
            };
            a = d(b.crs, [a.lon, a.lat]);
            d = b.cosAngle || b.rotation && Math.cos(b.rotation);
            var h = b.sinAngle || b.rotation && Math.sin(b.rotation);
            a = b.rotation ? [a[0] * d + a[1] * h, -a[0] * h + a[1] * d] : a;
            return {
              x: ((a[0] - (b.xoffset || 0)) * (b.scale || 1) + (b.xpan || 0)) * (b.jsonres || 1) + (b.jsonmarginX || 0),
              y: (((b.yoffset || 0) - a[1]) * (b.scale || 1) + (b.ypan || 0)) * (b.jsonres || 1) - (b.jsonmarginY || 0)
            };
          };

          a.prototype.transformToLatLon = function (a, b) {
            if ("undefined" === typeof D.proj4) t(21, !1, this);else {
              a = {
                x: ((a.x - (b.jsonmarginX || 0)) / (b.jsonres || 1) - (b.xpan || 0)) / (b.scale || 1) + (b.xoffset || 0),
                y: ((-a.y - (b.jsonmarginY || 0)) / (b.jsonres || 1) + (b.ypan || 0)) / (b.scale || 1) + (b.yoffset || 0)
              };
              var d = b.cosAngle || b.rotation && Math.cos(b.rotation),
                  h = b.sinAngle || b.rotation && Math.sin(b.rotation);
              b = D.proj4(b.crs, "WGS84", b.rotation ? {
                x: a.x * d + a.y * -h,
                y: a.x * h + a.y * d
              } : a);
              return {
                lat: b.y,
                lon: b.x
              };
            }
          };

          a.prototype.fromPointToLatLon = function (a) {
            var b = this.mapTransforms,
                d;

            if (b) {
              for (d in b) {
                if (Object.hasOwnProperty.call(b, d) && b[d].hitZone && r({
                  x: a.x,
                  y: -a.y
                }, b[d].hitZone.coordinates[0])) return this.transformToLatLon(a, b[d]);
              }

              return this.transformToLatLon(a, b["default"]);
            }

            t(22, !1, this);
          };

          a.prototype.fromLatLonToPoint = function (a) {
            var b = this.mapTransforms,
                d;
            if (!b) return t(22, !1, this), {
              x: 0,
              y: null
            };

            for (d in b) {
              if (Object.hasOwnProperty.call(b, d) && b[d].hitZone) {
                var h = this.transformFromLatLon(a, b[d]);
                if (r({
                  x: h.x,
                  y: -h.y
                }, b[d].hitZone.coordinates[0])) return h;
              }
            }

            return this.transformFromLatLon(a, b["default"]);
          };

          A.geojson = function (a, b, g) {
            var d = [],
                h = [],
                r = function r(a) {
              a.forEach(function (a, b) {
                0 === b ? h.push(["M", a[0], -a[1]]) : h.push(["L", a[0], -a[1]]);
              });
            };

            b = b || "map";
            a.features.forEach(function (a) {
              var f = a.geometry,
                  g = f.type;
              f = f.coordinates;
              a = a.properties;
              var k;
              h = [];
              "map" === b || "mapbubble" === b ? ("Polygon" === g ? (f.forEach(r), h.push(["Z"])) : "MultiPolygon" === g && (f.forEach(function (a) {
                a.forEach(r);
              }), h.push(["Z"])), h.length && (k = {
                path: h
              })) : "mapline" === b ? ("LineString" === g ? r(f) : "MultiLineString" === g && f.forEach(r), h.length && (k = {
                path: h
              })) : "mappoint" === b && "Point" === g && (k = {
                x: f[0],
                y: -f[1]
              });
              k && d.push(l(k, {
                name: a.name || a.NAME,
                properties: a
              }));
            });
            g && a.copyrightShort && (g.chart.mapCredits = w(g.chart.options.credits.mapText, {
              geojson: a
            }), g.chart.mapCreditsFull = w(g.chart.options.credits.mapTextFull, {
              geojson: a
            }));
            return d;
          };

          v(a.prototype, "addCredits", function (a, b) {
            b = h(!0, this.options.credits, b);
            this.mapCredits && (b.href = null);
            a.call(this, b);
            this.credits && this.mapCreditsFull && this.credits.attr({
              title: this.mapCreditsFull
            });
          });
        });
        I(a, "masters/modules/map.src.js", [a["Core/Globals.js"], a["Core/Axis/Color/ColorAxis.js"], a["Series/MapBubble/MapBubbleSeries.js"], a["Core/Chart/MapChart.js"]], function (a, v, A, y) {
          a.ColorAxis = v;
          a.MapChart = y;
          a.mapChart = a.Map = y.mapChart;
          a.maps = y.maps;
          v.compose(a.Chart, a.Fx, a.Legend, a.Series);
          A.compose(a.Chart, a.Legend, a.Series);
        });
        I(a, "masters/highmaps.src.js", [a["masters/highcharts.src.js"]], function (a) {
          a.product = "Highmaps";
          return a;
        });
        a["masters/highmaps.src.js"]._modules = a;
        return a["masters/highmaps.src.js"];
      }); //# sourceMappingURL=highmaps.js.map

      /***/

    },

    /***/
    "mE01":
    /*!************************************************************************!*\
      !*** ./node_modules/angular-highcharts/fesm2015/angular-highcharts.js ***!
      \************************************************************************/

    /*! exports provided: Chart, ChartDirective, ChartModule, HIGHCHARTS_MODULES, HighchartsGantt, MapChart, StockChart, a */

    /***/
    function mE01(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "Chart", function () {
        return Chart;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "ChartDirective", function () {
        return ChartDirective;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "ChartModule", function () {
        return ChartModule;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "HIGHCHARTS_MODULES", function () {
        return HIGHCHARTS_MODULES;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "HighchartsGantt", function () {
        return HighchartsGantt;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "MapChart", function () {
        return MapChart;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "StockChart", function () {
        return StockChart;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return ChartService;
      });
      /* harmony import */


      var highcharts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! highcharts */
      "6n/F");
      /* harmony import */


      var highcharts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(highcharts__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! rxjs */
      "qCKp");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! highcharts/highmaps */
      "bIOw");
      /* harmony import */


      var highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__);
      /* harmony import */


      var highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! highcharts/highstock */
      "5ZEx");
      /* harmony import */


      var highcharts_highstock__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__);
      /* harmony import */


      var highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! highcharts/highcharts-gantt */
      "ZivX");
      /* harmony import */


      var highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__);

      var Chart = /*#__PURE__*/function () {
        function Chart() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, Chart);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }
        /**
         * Add Point
         * @param point         Highcharts.DataPoint, number touple or number
         * @param serieIndex    Index position of series. This defaults to 0.
         * @param redraw        Flag whether or not to redraw point. This defaults to true.
         * @param shift         Shift point to the start of series. This defaults to false.
         */


        _createClass(Chart, [{
          key: "addPoint",
          value: function addPoint(point) {
            var serieIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var redraw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var shift = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            this.ref$.subscribe(function (chart) {
              if (chart.series.length > serieIndex) {
                chart.series[serieIndex].addPoint(point, redraw, shift);
              }
            });
          }
          /**
           * Add Series
           * @param series        Series Configuration
           * @param redraw        Flag whether or not to redraw series. This defaults to true.
           * @param animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
           */

        }, {
          key: "addSeries",
          value: function addSeries(series) {
            var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var animation = arguments.length > 2 ? arguments[2] : undefined;
            this.ref$.subscribe(function (chart) {
              chart.addSeries(series, redraw, animation);
            });
          }
          /**
           * Remove Point
           * @param pointIndex    Index of Point
           * @param serieIndex    Specified Index of Series. Defaults to 0.
           */

        }, {
          key: "removePoint",
          value: function removePoint(pointIndex) {
            var serieIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            this.ref$.subscribe(function (chart) {
              if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
                chart.series[serieIndex].removePoint(pointIndex, true);
              }
            });
          }
          /**
           * Remove Series
           * @param seriesIndex    Index position of series to remove.
           */

        }, {
          key: "removeSeries",
          value: function removeSeries(seriesIndex) {
            this.ref$.subscribe(function (chart) {
              if (chart.series.length > seriesIndex) {
                chart.series[seriesIndex].remove(true);
              }
            });
          }
        }, {
          key: "init",
          value: function init(el) {
            var _this = this;

            if (!this.ref) {
              highcharts__WEBPACK_IMPORTED_MODULE_0__["chart"](el.nativeElement, this.options, function (chart) {
                if (!_this.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this.refSubject.next(chart);

                  _this.ref = chart;

                  _this.refSubject.complete();
                }
              });
            }
          }
        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return Chart;
      }(); // import * as Highcharts from 'highcharts';

      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       */


      var MapChart = /*#__PURE__*/function () {
        function MapChart() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, MapChart);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }

        _createClass(MapChart, [{
          key: "init",
          value: function init(el) {
            var _this2 = this;

            if (!this.ref) {
              highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__["mapChart"](el.nativeElement, this.options, function (chart) {
                if (!_this2.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this2.refSubject.next(chart);

                  _this2.ref = chart;

                  _this2.refSubject.complete();
                }
              });
            }
          }
        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return MapChart;
      }(); //import * as Highcharts from 'highcharts';

      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       *
       * @author Felix Itzenplitz
       * @author Timothy A. Perez (contributor)
       */


      var StockChart = /*#__PURE__*/function () {
        function StockChart() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, StockChart);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }

        _createClass(StockChart, [{
          key: "init",
          value: function init(el) {
            var _this3 = this;

            if (!this.ref) {
              highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__["stockChart"](el.nativeElement, this.options, function (chart) {
                if (!_this3.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this3.refSubject.next(chart);

                  _this3.ref = chart;

                  _this3.refSubject.complete();
                }
              });
            }
          }
        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return StockChart;
      }();
      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       */


      var HighchartsGantt = /*#__PURE__*/function () {
        function HighchartsGantt() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            series: []
          };

          _classCallCheck(this, HighchartsGantt);

          this.options = options;
          this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
          this.ref$ = this.refSubject.asObservable();
        }

        _createClass(HighchartsGantt, [{
          key: "init",
          value: function init(el) {
            var _this4 = this;

            if (!this.ref) {
              highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__["ganttChart"](el.nativeElement, this.options, function (chart) {
                if (!_this4.ref) {
                  // TODO: workaround for doubled callbacks on exporting charts: issue #238
                  _this4.refSubject.next(chart);

                  _this4.ref = chart;

                  _this4.refSubject.complete();
                }
              });
            }
          }
        }, {
          key: "destroy",
          value: function destroy() {
            if (this.ref) {
              this.options = this.ref.options;
              this.ref.destroy();
              this.ref = undefined; // new init subject

              this.refSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();
              this.ref$ = this.refSubject.asObservable();
            }
          }
        }]);

        return HighchartsGantt;
      }();
      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       */


      var ChartDirective = /*#__PURE__*/function () {
        function ChartDirective(el) {
          _classCallCheck(this, ChartDirective);

          this.el = el;
        }

        _createClass(ChartDirective, [{
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            if (!changes.chart.isFirstChange()) {
              this.destroy();
              this.init();
            }
          }
        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            this.init();
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.destroy();
          }
        }, {
          key: "init",
          value: function init() {
            if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
              this.chart.init(this.el);
            }
          }
        }, {
          key: "destroy",
          value: function destroy() {
            if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart || this.chart instanceof HighchartsGantt) {
              this.chart.destroy();
            }
          }
        }]);

        return ChartDirective;
      }();

      ChartDirective.fac = function ChartDirective_Factory(t) {
        return new (t || ChartDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]));
      };

      ChartDirective.dir = _angular_core__WEBPACK_IMPORTED_MODULE_2__["defineDirective"]({
        type: ChartDirective,
        selectors: [["", "chart", ""]],
        inputs: {
          chart: "chart"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["NgOnChangesFeature"]]
      });
      /** @nocollapse */

      ChartDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]
        }];
      };

      ChartDirective.propDecorators = {
        chart: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }]
      };
      /*@__PURE__*/

      (function () {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["setClassMetadata"](ChartDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"],
          args: [{
            selector: '[chart]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]
          }];
        }, {
          chart: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
          }]
        });
      })();
      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       */


      var HIGHCHARTS_MODULES = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('HighchartsModules');

      var ChartService = /*#__PURE__*/function () {
        function ChartService(chartModules) {
          _classCallCheck(this, ChartService);

          this.chartModules = chartModules;
        }

        _createClass(ChartService, [{
          key: "initModules",
          value: function initModules() {
            this.chartModules.forEach(function (chartModule) {
              [highcharts__WEBPACK_IMPORTED_MODULE_0__, highcharts_highstock__WEBPACK_IMPORTED_MODULE_4__, highcharts_highmaps__WEBPACK_IMPORTED_MODULE_3__, highcharts_highcharts_gantt__WEBPACK_IMPORTED_MODULE_5__].forEach(chartModule);
            });
          }
        }]);

        return ChartService;
      }();

      ChartService.fac = function ChartService_Factory(t) {
        return new (t || ChartService)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["inject"](HIGHCHARTS_MODULES));
      };

      ChartService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_2__["defineInjectable"]({
        token: ChartService,
        factory: ChartService.fac
      });
      /** @nocollapse */

      ChartService.ctorParameters = function () {
        return [{
          type: Array,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"],
            args: [HIGHCHARTS_MODULES]
          }]
        }];
      };
      /*@__PURE__*/


      (function () {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["setClassMetadata"](ChartService, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Injectable"]
        }], function () {
          return [{
            type: Array,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"],
              args: [HIGHCHARTS_MODULES]
            }]
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Felix Itzenplitz. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at
       * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
       */


      var 0 = [];

      var ChartModule = function ChartModule(cs) {
        _classCallCheck(this, ChartModule);

        this.cs = cs;
        this.cs.initModules();
      };

      ChartModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_2__["defineNgModule"]({
        type: ChartModule
      });
      ChartModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_2__["defineInjector"]({
        factory: function ChartModule_Factory(t) {
          return new (t || ChartModule)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["inject"](ChartService));
        },
        providers: [{
          provide: HIGHCHARTS_MODULES,
          useValue: 0
        }, ChartService]
      });
      /** @nocollapse */

      ChartModule.ctorParameters = function () {
        return [{
          type: ChartService
        }];
      };

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["setNgModuleScope"](ChartModule, {
          declarations: [ChartDirective],
          exports: [ChartDirective]
        });
      })();
      /*@__PURE__*/


      (function () {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["setClassMetadata"](ChartModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"],
          args: [{
            exports: [ChartDirective],
            declarations: [ChartDirective],
            providers: [{
              provide: HIGHCHARTS_MODULES,
              useValue: 0
            }, ChartService]
          }]
        }], function () {
          return [{
            type: ChartService
          }];
        }, null);
      })();
      /*
       * Public API Surface of angular-highcharts
       */

      /**
       * Generated bundle index. Do not edit.
       */
      //# sourceMappingURL=angular-highcharts.js.map

      /***/

    }
  }]);
})();
//# sourceMappingURL=default~views-card-account-card-account-module~views-others-onboarding-corporate-onboarding-corporat~af09a1a5-es5.js.map